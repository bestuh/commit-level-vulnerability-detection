static int addit_dammit(void *v, const char *key, const char *val)
{
    apr_table_addn(v, key, val);
    return 1;
}

    apr_table_t *save_table;
            /* First, tuck away all already existing cookies */
            save_table = apr_table_make(r->pool, 2);
            apr_table_do(addit_dammit, save_table, r->err_headers_out,
                         "Set-Cookie", NULL);
            apr_table_do(addit_dammit, save_table, r->headers_out,
                         "Set-Cookie", NULL);



                /* Now, add in the just read cookies */
                apr_table_do(addit_dammit, save_table, r->headers_out,
        	             "Set-Cookie", NULL);

                /* and now load 'em all in */
                if (!apr_is_empty_table(save_table)) {
                    apr_table_unset(r->headers_out, "Set-Cookie");
                    r->headers_out = apr_table_overlay(r->pool,
                                                       r->headers_out,
                                                       save_table);
                }
                
                /* strip connection listed hop-by-hop headers from response */
typedef apr_status_t (*accept_function)(void **csd, ap_listen_rec *lr, apr_pool_t *ptrans);
    /**
     * The accept function for this socket
     */
    accept_function accept_func;
#include "apr_thread_proc.h"

AP_DECLARE(apr_status_t) unixd_accept(void **accepted, ap_listen_rec *lr,
                                        apr_pool_t *ptrans)
{
    apr_socket_t *csd;
    apr_status_t status;
    int sockdes;

    status = apr_accept(&csd, lr->sd, ptrans);
    if (status == APR_SUCCESS) { 
        *accepted = csd;
        apr_os_sock_get(&sockdes, csd);
        if (sockdes >= FD_SETSIZE) {
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
                         "new file descriptor %d is too large; you probably need "
                         "to rebuild Apache with a larger FD_SETSIZE "
                         "(currently %d)",
                         sockdes, FD_SETSIZE);
            apr_socket_close(csd);
            return APR_EINTR;
        } 
#ifdef TPF
        if (sockdes == 0) {                  /* 0 is invalid socket for TPF */
            return APR_EINTR;
        }
#endif
        return status;
    }

    if (APR_STATUS_IS_EINTR(status)) {
        return status;
    }
    /* Our old behaviour here was to continue after accept()
     * errors.  But this leads us into lots of troubles
     * because most of the errors are quite fatal.  For
     * example, EMFILE can be caused by slow descriptor
     * leaks (say in a 3rd party module, or libc).  It's
     * foolish for us to continue after an EMFILE.  We also
     * seem to tickle kernel bugs on some platforms which
     * lead to never-ending loops here.  So it seems best
     * to just exit in most cases.
     */
    switch (status) {
#ifdef EPROTO
        /* EPROTO on certain older kernels really means
         * ECONNABORTED, so we need to ignore it for them.
         * See discussion in new-httpd archives nh.9701
         * search for EPROTO.
         *
         * Also see nh.9603, search for EPROTO:
         * There is potentially a bug in Solaris 2.x x<6,
         * and other boxes that implement tcp sockets in
         * userland (i.e. on top of STREAMS).  On these
         * systems, EPROTO can actually result in a fatal
         * loop.  See PR#981 for example.  It's hard to
         * handle both uses of EPROTO.
         */
        case EPROTO:
#endif
#ifdef ECONNABORTED
        case ECONNABORTED:
#endif
        /* Linux generates the rest of these, other tcp
         * stacks (i.e. bsd) tend to hide them behind
         * getsockopt() interfaces.  They occur when
         * the net goes sour or the client disconnects
         * after the three-way handshake has been done
         * in the kernel but before userland has picked
         * up the socket.
         */
#ifdef ECONNRESET
        case ECONNRESET:
#endif
#ifdef ETIMEDOUT
        case ETIMEDOUT:
#endif
#ifdef EHOSTUNREACH
        case EHOSTUNREACH:
#endif
#ifdef ENETUNREACH
        case ENETUNREACH:
#endif
            break;
#ifdef ENETDOWN
        case ENETDOWN:
            /*
             * When the network layer has been shut down, there
             * is not much use in simply exiting: the parent
             * would simply re-create us (and we'd fail again).
             * Use the CHILDFATAL code to tear the server down.
             * @@@ Martin's idea for possible improvement:
             * A different approach would be to define
             * a new APEXIT_NETDOWN exit code, the reception
             * of which would make the parent shutdown all
             * children, then idle-loop until it detected that
             * the network is up again, and restart the children.
             * Ben Hyde noted that temporary ENETDOWN situations
             * occur in mobile IP.
             */
            ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
                         "apr_accept: giving up.");
            return APR_EGENERAL;
#endif /*ENETDOWN*/

#ifdef TPF
        case EINACT:
            ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
                         "offload device inactive");
            return APR_EGENERAL;
            break;
        default:
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, ap_server_conf,
                         "select/accept error (%d)", status);
            return APR_EGENERAL;
#else
        default:
            ap_log_error(APLOG_MARK, APLOG_ERR, status, ap_server_conf,
                         "apr_accept: (client socket)");
            return APR_EGENERAL;
#endif
    }
    return status;
}

#include "ap_listen.h"
AP_DECLARE(apr_status_t) unixd_accept(void **accepted, ap_listen_rec *lr, apr_pool_t *ptrans);
#ifdef MPM_ACCEPT_FUNC
    server->accept_func = MPM_ACCEPT_FUNC;
#else
    server->accept_func = NULL;
#endif
#define MPM_ACCEPT_FUNC unixd_accept
static ap_listen_rec *listensocks;
    int i;
    int offset;
    void *csd;
    for (lr = ap_listeners, i = 0; i < num_listensocks; lr = lr->next, i++) {
        listensocks[i].accept_func = lr->accept_func;
        listensocks[i].sd = lr->sd;
    }
        apr_poll_socket_add(pollset, listensocks[i].sd, APR_POLLIN);
                offset = 0;
                    apr_poll_revents_get(&event, listensocks[curr_pollfd].sd, pollset);
                        offset = curr_pollfd;
        }
            status = listensocks[offset].accept_func(&csd, 
                                       &listensocks[offset], ptrans);
            if (status == APR_SUCCESS) {
                break;
            }
            if (status == APR_EGENERAL) {
                clean_child_exit(APEXIT_CHILDFATAL);
            }
        }
        /* basedir is either "", or "/%2f" for the "squid %2f hack" */
        const char *basedir = "";  /* By default, path is relative to the $HOME dir */
        char *wildcard = NULL;

        /* If path began with /%2f, change the basedir */
        if (strncasecmp(path, "/%2f", 4) == 0) {
            basedir = "/%2f";
        }

        while (path[1] == '/') /* collapse multiple leading slashes to one */
            ++path;

        reldir = strrchr(path, '/');
        if (reldir != NULL) {
            for (n=0; reldir[n] != '\0'; ++n) {
                if (reldir[n] == '\\' && reldir[n+1] != '\0')
                    ++n; /* escaped character */
                else if (reldir[n] == '*' || reldir[n] == '?') {
                    wildcard = &reldir[1];
                    reldir[0] = '\0'; /* strip off the wildcard suffix */
                    break;
                }
            }
        }

        /* (the trailing slash is needed for the dir component loop below) */
        path = dir = ap_pstrcat(p, path, "/", NULL);
        for (n = strlen(path); n > 1 && path[n - 1] == '/' && path[n - 2] == '/'; --n)
        /* Add a link to the root directory (if %2f hack was used) */
        str = (basedir[0] != '\0') ? "<a href=\"/%2f/\">%2f</a>/" : "";

                "<html>\n <head>\n  <title>%s%s%s</title>\n"
                "  <base href=\"%s%s%s\">\n </head>\n"
                " <body>\n  <h2>Directory of "
                "<a href=\"/\">%s</a>/%s",
                site, basedir, ap_escape_html(p, path),
                site, basedir, ap_escape_uri(p, path),
                site, str);
        for (dir = path+1; (dir = strchr(dir, '/')) != NULL; )
        {
            if ((reldir = strrchr(path+1, '/'))==NULL) {
                reldir = path+1;
            }
            str = apr_psprintf(p, "<a href=\"%s%s/\">%s</a>/", basedir,
                        ap_escape_uri(p, path),
                        ap_escape_html(p, reldir));
            while (*dir == '/')
              ++dir;
            APR_BRIGADE_INSERT_TAIL(out, apr_bucket_pool_create(str, strlen(str), p));
        if (wildcard != NULL) {
            APR_BRIGADE_INSERT_TAIL(out, apr_bucket_pool_create(wildcard, strlen(wildcard), p));
        }

            str = apr_psprintf(p, "</h2>\n\n  <hr />\n\n<pre>");
            str = apr_psprintf(p, "</h2>\n\n(%s)\n\n  <hr />\n\n<pre>",
                               ap_escape_html(p, pwd));

            /* len+1 to leave spave for the trailing nil char */

            if (ctx->buffer[n-1] == CRLF[1])  /* strip trailing '\n' */
            if (ctx->buffer[n-1] == CRLF[0])  /* strip trailing '\r' if present */
        str = apr_psprintf(p, "</pre>\n\n  <hr />\n\n  %s\n\n </body>\n</html>\n", ap_psignature("", r));
             * should be created with the correct family in the first place.
             */
         * So we need to escape the URI metacharacters.
                ;
    char *path, *querystring;
    /*
     * Check if we need to ignore session identifiers in the URL and do so
     * if needed.
     */
    path = r->parsed_uri.path;
    querystring = r->parsed_uri.query;
    if (conf->ignore_session_id_set == CACHE_IGNORE_SESSION_ID_SET) {
        int i;
        char **identifier;

        identifier = (char **)conf->ignore_session_id->elts;
        for (i = 0; i < conf->ignore_session_id->nelts; i++, identifier++) {
            int len;
            char *param;

            len = strlen(*identifier);
            /*
             * Check that we have a parameter separator in the last segment
             * of the path and that the parameter matches our identifier
             */
            if ((param = strrchr(path, ';'))
                && !strncmp(param + 1, *identifier, len)
                && (*(param + len + 1) == '=')
                && !strchr(param + len + 2, '/')) {
                path = apr_pstrndup(p, path, param - path);
                break;
            }
            /*
             * Check if the identifier is in the querystring and cut it out.
             */
            if (querystring
                && (param = strstr(querystring, *identifier))
                && (*(param + len) == '=')
                ) {
                char *amp;

                if (querystring != param) {
                    querystring = apr_pstrndup(p, querystring,
                                               param - querystring);
                }
                else {
                    querystring = "";
                }
                if ((amp = strchr(param + len + 1, '&'))) {
                    querystring = apr_pstrcat(p, querystring, amp + 1, NULL);
                }
                break;
            }
        }
    }

                           path, "?", NULL);
                           path, "?", querystring, NULL);
    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                 "cache: Key for entity %s?%s is %s", r->parsed_uri.path,
                 r->parsed_uri.query, *key);
    /* array of identifiers that should not be used for key calculation */
    ps->ignore_session_id = apr_array_make(p, 10, sizeof(char *));
    ps->ignore_session_id_set = CACHE_IGNORE_SESSION_ID_UNSET;
    ps->ignore_session_id =
        (overrides->ignore_session_id_set == CACHE_IGNORE_HEADERS_UNSET)
        ? base->ignore_session_id
        : overrides->ignore_session_id;
static const char *add_ignore_session_id(cmd_parms *parms, void *dummy,
                                         const char *identifier)
{
    cache_server_conf *conf;
    char **new;

    conf =
        (cache_server_conf *)ap_get_module_config(parms->server->module_config,
                                                  &cache_module);
    if (!strncasecmp(identifier, "None", 4)) {
        /* if identifier None is listed clear array */
        conf->ignore_session_id->nelts = 0;
    }
    else {
        if ((conf->ignore_session_id_set == CACHE_IGNORE_SESSION_ID_UNSET) ||
            (conf->ignore_session_id->nelts)) {
            /*
             * Only add identifier if no "None" has been found in identifier
             * list so far.
             */
            new = (char **)apr_array_push(conf->ignore_session_id);
            (*new) = (char *)identifier;
        }
    }
    conf->ignore_session_id_set = CACHE_IGNORE_SESSION_ID_SET;
    return NULL;
}

    AP_INIT_ITERATE("CacheIgnoreURLSessionIdentifiers", add_ignore_session_id,
                    NULL, RSRC_CONF, "A space separated list of session "
                    "identifiers that should be ignored for creating the key "
                    "of the cached entity."),
    /** store the identifiers that should not be used for key calculation */
    apr_array_header_t *ignore_session_id;
    /* flag if CacheIgnoreURLSessionIdentifiers has been set */
    #define CACHE_IGNORE_SESSION_ID_SET   1
    #define CACHE_IGNORE_SESSION_ID_UNSET 0
    int ignore_session_id_set;
static int read_request_line(request_rec *r, apr_bucket_brigade *bb)

#if 0
    conn_rec *conn = r->connection;
#endif
    int num_blank_lines = 0;
    int max_blank_lines = r->server->limit_req_fields;

    if (max_blank_lines <= 0) {
        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
    }

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    do {
        apr_status_t rv;

        /* insure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */
        r->the_request = NULL;
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                         &len, r, 0, bb);

        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }
            return 0;
        }
    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));

    /* we've probably got something to do, ignore graceful restart requests */
    ll = r->the_request;
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method",
                                r->method);
#endif

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

             && (minor < HTTP_VERSION(1, 0)) ) /* don't allow HTTP/0.1000 */
    else
    return 1;
    char *last_field = NULL;
    apr_size_t last_len = 0;
    apr_size_t alloc_len = 0;
    char *value;
    int fields_read = 0;
    char *tmp_field;
        int folded = 0;

        if (last_field != NULL) {
            if ((len > 0) && ((*field == '\t') || *field == ' ')) {
                /* This line is a continuation of the preceding line(s),
                 * so append it to the line that we've set aside.
                 * Note: this uses a power-of-two allocator to avoid
                 * doing O(n) allocs and using O(n^2) space for
                 * continuations that span many many lines.
                 */
                apr_size_t fold_len = last_len + len + 1; /* trailing null */

                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field "
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                if (fold_len > alloc_len) {
                    char *fold_buf;
                    alloc_len += alloc_len;
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
                    }
                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);
                    memcpy(fold_buf, last_field, last_len);
                    last_field = fold_buf;
                }
                memcpy(last_field + last_len, field, len +1); /* +1 for nul */
                last_len += len;
                folded = 1;
            }
            else /* not a continuation line */ {

                if (r->server->limit_req_fields
                    && (++fields_read > r->server->limit_req_fields)) {
                    r->status = HTTP_BAD_REQUEST;
                    apr_table_setn(r->notes, "error-notes",
                                   "The number of request header fields "
                                   "exceeds this server's limit.");
                    return;
                }

                if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                    r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Request header field is "
                                               "missing ':' separator.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool,
                                                              last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                tmp_field = value - 1; /* last character of field-name */

                *value++ = '\0'; /* NUL-terminate at colon */

                while (*value == ' ' || *value == '\t') {
                    ++value;            /* Skip to start of value   */
                }

                /* Strip LWS after field-name: */
                while (tmp_field > last_field
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                /* Strip LWS after field-value: */
                tmp_field = last_field + last_len - 1;
                while (tmp_field > value
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                apr_table_addn(r->headers_in, last_field, value);

                /* reset the alloc_len so that we'll allocate a new
                 * buffer if we have to do any more folding: we can't
                 * use the previous buffer because its contents are
                 * now part of r->headers_in
                 */
                alloc_len = 0;

            } /* end if current line is not a continuation starting with tab */

        /* Found a blank line, stop. */
        if (len == 0) {
            break;
        }

        /* Keep track of this line so that we can parse it on
         * the next loop iteration.  (In the folded case, last_field
         * has been updated already.)
         */
        if (!folded) {
            last_field = field;
            last_len = len;

    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
request_rec *ap_read_request(conn_rec *conn)
    const char *expect;
    int access_status;
    apr_bucket_brigade *tmp_bb;
    apr_socket_t *csd;
    apr_interval_time_t cur_timeout;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    /* Get the request... */
    if (!read_request_line(r, tmp_bb)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        apr_brigade_destroy(tmp_bb);
        return NULL;
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_get(csd, &cur_timeout);
    if (cur_timeout != conn->base_server->timeout) {
        apr_socket_timeout_set(csd, conn->base_server->timeout);
        cur_timeout = conn->base_server->timeout;
    }

    if (!r->assbackwards) {
        ap_get_mime_headers_core(r, tmp_bb);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        if (apr_table_get(r->headers_in, "Transfer-Encoding")
            && apr_table_get(r->headers_in, "Content-Length")) {
            /* 2616 section 4.4, point 3: "if both Transfer-Encoding
             * and Content-Length are received, the latter MUST be
             * ignored"; so unset it here to prevent any confusion
             * later. */
            apr_table_unset(r->headers_in, "Content-Length");
        }
    }
    else {
        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }
    }

    apr_brigade_destroy(tmp_bb);
    if (cur_timeout != r->server->timeout) {
        apr_socket_timeout_set(csd, r->server->timeout);
        cur_timeout = r->server->timeout;
static int read_request_line(request_rec *r, apr_bucket_brigade *bb)

#if 0
    conn_rec *conn = r->connection;
#endif
    int num_blank_lines = 0;
    int max_blank_lines = r->server->limit_req_fields;

    if (max_blank_lines <= 0) {
        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
    }

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    do {
        apr_status_t rv;

        /* insure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */
        r->the_request = NULL;
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                         &len, r, 0, bb);

        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }
            return 0;
        }
    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));

    /* we've probably got something to do, ignore graceful restart requests */
    ll = r->the_request;
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method",
                                r->method);
#endif

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

             && (minor < HTTP_VERSION(1, 0)) ) /* don't allow HTTP/0.1000 */
    else
    return 1;
    char *last_field = NULL;
    apr_size_t last_len = 0;
    apr_size_t alloc_len = 0;
    char *value;
    int fields_read = 0;
    char *tmp_field;
        int folded = 0;

        if (last_field != NULL) {
            if ((len > 0) && ((*field == '\t') || *field == ' ')) {
                /* This line is a continuation of the preceding line(s),
                 * so append it to the line that we've set aside.
                 * Note: this uses a power-of-two allocator to avoid
                 * doing O(n) allocs and using O(n^2) space for
                 * continuations that span many many lines.
                 */
                apr_size_t fold_len = last_len + len + 1; /* trailing null */

                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field "
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                if (fold_len > alloc_len) {
                    char *fold_buf;
                    alloc_len += alloc_len;
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
                    }
                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);
                    memcpy(fold_buf, last_field, last_len);
                    last_field = fold_buf;
                }
                memcpy(last_field + last_len, field, len +1); /* +1 for nul */
                last_len += len;
                folded = 1;
            }
            else /* not a continuation line */ {

                if (r->server->limit_req_fields
                    && (++fields_read > r->server->limit_req_fields)) {
                    r->status = HTTP_BAD_REQUEST;
                    apr_table_setn(r->notes, "error-notes",
                                   "The number of request header fields "
                                   "exceeds this server's limit.");
                    return;
                }

                if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                    r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Request header field is "
                                               "missing ':' separator.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool,
                                                              last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                tmp_field = value - 1; /* last character of field-name */

                *value++ = '\0'; /* NUL-terminate at colon */

                while (*value == ' ' || *value == '\t') {
                    ++value;            /* Skip to start of value   */
                }

                /* Strip LWS after field-name: */
                while (tmp_field > last_field
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                /* Strip LWS after field-value: */
                tmp_field = last_field + last_len - 1;
                while (tmp_field > value
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                apr_table_addn(r->headers_in, last_field, value);

                /* reset the alloc_len so that we'll allocate a new
                 * buffer if we have to do any more folding: we can't
                 * use the previous buffer because its contents are
                 * now part of r->headers_in
                 */
                alloc_len = 0;

            } /* end if current line is not a continuation starting with tab */

        /* Found a blank line, stop. */
        if (len == 0) {
            break;
        }

        /* Keep track of this line so that we can parse it on
         * the next loop iteration.  (In the folded case, last_field
         * has been updated already.)
         */
        if (!folded) {
            last_field = field;
            last_len = len;

    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
request_rec *ap_read_request(conn_rec *conn)
    const char *expect;
    int access_status;
    apr_bucket_brigade *tmp_bb;
    apr_socket_t *csd;
    apr_interval_time_t cur_timeout;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    /* Get the request... */
    if (!read_request_line(r, tmp_bb)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        apr_brigade_destroy(tmp_bb);
        return NULL;
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_get(csd, &cur_timeout);
    if (cur_timeout != conn->base_server->timeout) {
        apr_socket_timeout_set(csd, conn->base_server->timeout);
        cur_timeout = conn->base_server->timeout;
    }

    if (!r->assbackwards) {
        ap_get_mime_headers_core(r, tmp_bb);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        if (apr_table_get(r->headers_in, "Transfer-Encoding")
            && apr_table_get(r->headers_in, "Content-Length")) {
            /* 2616 section 4.4, point 3: "if both Transfer-Encoding
             * and Content-Length are received, the latter MUST be
             * ignored"; so unset it here to prevent any confusion
             * later. */
            apr_table_unset(r->headers_in, "Content-Length");
        }
    }
    else {
        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }
    }

    apr_brigade_destroy(tmp_bb);
    if (cur_timeout != r->server->timeout) {
        apr_socket_timeout_set(csd, r->server->timeout);
        cur_timeout = r->server->timeout;
        if(APR_STATUS_IS_EINVAL(rv)) {
            /* looked nothing like an IP address */
        }
        else if (rv != APR_SUCCESS) {
    else if (!APR_STATUS_IS_EINVAL(rv = apr_ipsubnet_create(&a->x.ip, where, NULL, cmd->pool))) {
		if (stat == APR_SUCCESS || !APR_STATUS_IS_EINTR(stat))
/* Is the scoreboard shared between processes or not? 
 * Set by the MPM when the scoreboard is created.
 */
typedef enum {
    SB_SHARED = 1,
    SB_NOT_SHARED = 2
} ap_scoreboard_e;

    ap_scoreboard_e sb_type;
AP_DECLARE(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e t);
void ap_sync_scoreboard_image(void);
/*    ap_sync_scoreboard_image(); */
/* mpm.h is the place to make declarations that are MPM specific but that must be 
 * shared with non-mpm specific code in the server.  Hummm, perhaps we can
 * move most of this stuff to mpm_common.h?
 */
extern int ap_threads_per_child;
/* AP_CHILD_THREAD_FROM_ID is used by the scoreboard.  */
#define AP_CHILD_THREAD_FROM_ID(i)       i, 0


#include "scoreboard.h"

int ap_threads_per_child = 0;
/* ap_get_max_daemons and ap_my_generation are used by the scoreboard
 * code
 */
ap_generation_t volatile ap_my_generation=0; /* Used by the scoreboard */
AP_DECLARE(int) ap_get_max_daemons(void)
{
    return 1;
}

    /* Set up the scoreboard. The scoreboard in this MPM only applies to the
     * child process and is not shared across processes
     */
    ap_create_scoreboard(pconf, SB_NOT_SHARED);
/* ToDo: Fix this right */
#ifndef WIN32
#endif

#endif
/*
 * ToDo:
 * This function should be renamed to cleanup_shared
 * and it should handle cleaning up a scoreboard shared
 * between processes using any form of IPC (file, shared memory
 * segment, etc.). Leave it as is now because it is being used
 * by various MPMs. 
 */
#if APR_HAD_SHARED_MEMORY
#endif
/* ToDo: This function should be made to handle setting up 
 * a scoreboard shared between processes using any IPC technique, 
 * not just a shared memory segment
 */
static void setup_shared(apr_pool_t *p)
#if APR_HAD_SHARED_MEMORY
#endif
AP_DECLARE(void) reopen_scoreboard(apr_pool_t *p)
/* ap_cleanup_scoreboard
 * 
 */
static void ap_cleanup_scoreboard(void *d) {
    if (ap_scoreboard_image == NULL)
        return;
    if (ap_scoreboard_image->global.sb_type == SB_SHARED) {
        ap_cleanup_shared_mem(NULL);
    }
    else {
        free(ap_scoreboard_image);
        ap_scoreboard_image = NULL;
    }
}

/* ap_create_scoreboard(apr_pool_t*, ap_scoreboard_e t)
 *
 * Create or reinit an existing scoreboard. The MPM can control whether
 * the scoreboard is shared across multiple processes or not
 */
AP_DECLARE(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
        if (sb_type == SB_SHARED) {
            setup_shared(p);
            ap_scoreboard_image->global.sb_type = SB_SHARED;
        }
        else {
            /* A simple malloc will suffice */
            char buf[512];
            ap_scoreboard_image = (scoreboard *) malloc(SCOREBOARD_SIZE);
            if (ap_scoreboard_image == NULL) {
                apr_snprintf(buf, sizeof(buf), "%s: cannot allocate scoreboard",
                             ap_server_argv0);
                perror(buf); /* o.k. since MM sets errno */
                exit(APEXIT_INIT);            
            }
            ap_scoreboard_image->global.sb_type = SB_NOT_SHARED;
        }
    apr_register_cleanup(p, NULL, ap_cleanup_scoreboard, apr_null_cleanup);
}

/* ToDo:
 * reinit_scoreboard should be eliminated when all MPMs migrate to
 * ap_create_scoreboard()
 */
void reinit_scoreboard(apr_pool_t *p)
{
    ap_create_scoreboard(p, SB_SHARED);
void ap_sync_scoreboard_image(void)
/* NOTE: these check the shared status */
#define PROXY_WORKER_IS_INITIALIZED(f)   ( (f)->s && \
  ( (f)->s->status &  PROXY_WORKER_INITIALIZED ) )
#define PROXY_WORKER_IS_STANDBY(f)   ( (f)->s && \
  ( (f)->s->status &  PROXY_WORKER_HOT_STANDBY ) )
#define PROXY_WORKER_IS_USABLE(f)   ( (f)->s && \
  ( !( (f)->s->status & PROXY_WORKER_NOT_USABLE_BITMAP) ) && \
  PROXY_WORKER_IS_INITIALIZED(f) )
/* XXXX - fix me / EBCDIC
 *        there was a cludge here which would use its
 *	  own version ap_isascii(). Indicating that
 *	  on some platforms that might be needed. 
 *
 *	  #define OS_ASC(c) (c)		    -- for mere mortals 
 *     or
 *        #define OS_ASC(c) (ebcdic2ascii[c]) -- for dino's
 *
 *        #define ap_isascii(c) ((OS_ASC(c) & 0x80) == 0)
 */

/* XXXXX - fix me - See note with NOT_PROXY */

    ap_table_t *charset_types;       /* Added with AddCharset... */       
	                        /* Due to the FUD about JS and charsets 
                                 * default_charset is actually in src/main */
typedef struct param_s {
    char *attr;
    char *val;
    struct param_s *next;
} param;

typedef struct {
    char *type;
    char *subtype;
    param *param;
} content_type;

static char tspecial[] = {
    '(', ')', '<', '>', '@', ',', ';', ':',
    '\\', '"', '/', '[', ']', '?', '=',
    '\0'
};

    new->charset_types = ap_make_table(p, 4);
					 base->forced_types);
    new->charset_types = ap_overlay_tables(p, add->charset_types,
					   base->charset_types);
static const char *add_type(cmd_parms *cmd, mime_dir_config *m, char *ct,
	++ext;
	
static const char *add_encoding(cmd_parms *cmd, mime_dir_config *m, char *enc,
static const char *add_charset(cmd_parms *cmd, mime_dir_config *m,
			       char *charset, char *ext)
{
    if (*ext == '.') {
	++ext;
    }
    ap_str_tolower(charset);
    ap_table_setn(m->charset_types, ext, charset);
    return NULL;
}

static const char *add_language(cmd_parms *cmd, mime_dir_config *m, char *lang,
    if (*ext == '.') {
	++ext;
    }
static const char *add_handler(cmd_parms *cmd, mime_dir_config *m, char *hdlr,
    {"AddCharset", add_charset, NULL, OR_FILEINFO, ITERATE2,
     "a charset (e.g., iso-2022-jp), followed by one or more file extensions"},
static char *zap_sp(char *s)
{
    char *tp;

    if (s == NULL) {
	return (NULL);
    }
    if (*s == '\0') {
	return (s);
    }

    /* delete prefixed white space */
    for (; *s == ' ' || *s == '\t' || *s == '\n'; s++);

    /* delete postfixed white space */
    for (tp = s; *tp != '\0'; tp++);
    for (tp--; tp != s && (*tp == ' ' || *tp == '\t' || *tp == '\n'); tp--) {
	*tp = '\0';
    }
    return (s);
}

static int is_token(char c)
{
    int res;

    res = (ap_isascii(c) && ap_isgraph(c)
	   && (strchr(tspecial, c) == NULL)) ? 1 : -1;
    return res;
}

static int is_qtext(char c)
{
    int res;

    res = (ap_isascii(c) && (c != '"') && (c != '\\') && (c != '\n'))
	? 1 : -1;
    return res;
}

static int is_quoted_pair(char *s)
{
    int res = -1;
    int c;

    if (((s + 1) != NULL) && (*s == '\\')) {
	c = (int) *(s + 1);
	if (ap_isascii(c)) {
	    res = 1;
	}
    }
    return (res);
}

static content_type *analyze_ct(request_rec *r, char *s)
{
    char *tp, *mp, *cp;
    char *attribute, *value;
    int quoted = 0;
    server_rec * ss = r->server;
    ap_context_t  * p = r->pool;

    content_type *ctp;
    param *pp, *npp;

    /* initialize ctp */
    ctp = (content_type *) ap_palloc(p, sizeof(content_type));
    ctp->type = NULL;
    ctp->subtype = NULL;
    ctp->param = NULL;

    tp = ap_pstrdup(p, s);

    mp = tp;
    cp = mp;

    /* getting a type */
    if (!(cp = strchr(mp, '/'))) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
		     "mod_mime: analyze_ct: cannot get media type from '%s'",
		     (const char *) mp);
	return (NULL);
    }
    ctp->type = ap_pstrndup(p, mp, cp - mp);
    ctp->type = zap_sp(ctp->type);
    if (ctp->type == NULL || *(ctp->type) == '\0' ||
	strchr(ctp->type, ';') || strchr(ctp->type, ' ') ||
	strchr(ctp->type, '\t')) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
		     "Cannot get media subtype.");
	return (NULL);
    }

    /* getting a subtype */
    cp++;
    mp = cp;

    for (; *cp != ';' && *cp != '\0'; cp++);
    ctp->subtype = ap_pstrndup(p, mp, cp - mp);
    ctp->subtype = zap_sp(ctp->subtype);
    if ((ctp->subtype == NULL) || (*(ctp->subtype) == '\0') ||
	strchr(ctp->subtype, ' ') || strchr(ctp->subtype, '\t')) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
		     "Cannot get media subtype.");
	return (NULL);
    }
    cp = zap_sp(cp);
    if (cp == NULL || *cp == '\0') {
	return (ctp);
    }

    /* getting parameters */
    cp++;
    cp = zap_sp(cp);
    if (cp == NULL || *cp == '\0') {
	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
		     "Cannot get media parameter.");
	return (NULL);
    }
    mp = cp;
    attribute = NULL;
    value = NULL;

    while (cp != NULL && *cp != '\0') {
	if (attribute == NULL) {
	    if (is_token((int) *cp) > 0) {
		cp++;
		continue;
	    }
	    else if (*cp == ' ' || *cp == '\t' || *cp == '\n') {
		cp++;
		continue;
	    }
	    else if (*cp == '=') {
		attribute = ap_pstrndup(p, mp, cp - mp);
		attribute = zap_sp(attribute);
		if (attribute == NULL || *attribute == '\0') {
		    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
				 "Cannot get media parameter.");
		    return (NULL);
		}
		cp++;
		cp = zap_sp(cp);
		if (cp == NULL || *cp == '\0') {
		    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
				 "Cannot get media parameter.");
		    return (NULL);
		}
		mp = cp;
		continue;
	    }
	    else {
		ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
			     "Cannot get media parameter.");
		return (NULL);
	    }
	}
	else {
	    if (mp == cp) {
		if (*cp == '"') {
		    quoted = 1;
		    cp++;
		}
		else {
		    quoted = 0;
		}
	    }
	    if (quoted > 0) {
		while (quoted && *cp != '\0') {
		    if (is_qtext((int) *cp) > 0) {
			cp++;
		    }
		    else if (is_quoted_pair(cp) > 0) {
			cp += 2;
		    }
		    else if (*cp == '"') {
			cp++;
			while (*cp == ' ' || *cp == '\t' || *cp == '\n') {
			    cp++;
			}
			if (*cp != ';' && *cp != '\0') {
			    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
					 "Cannot get media parameter.");
			    return(NULL);
			}
			quoted = 0;
		    }
		    else {
			ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
				     "Cannot get media parameter.");
			return (NULL);
		    }
		}
	    }
	    else {
		while (1) {
		    if (is_token((int) *cp) > 0) {
			cp++;
		    }
		    else if (*cp == '\0' || *cp == ';') {
			break;
		    }
		    else {
			ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
				     "Cannot get media parameter.");
			return (NULL);
		    }
		}
	    }
	    value = ap_pstrndup(p, mp, cp - mp);
	    value = zap_sp(value);
	    if (value == NULL || *value == '\0') {
		ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
			     "Cannot get media parameter.");
		return (NULL);
	    }

	    pp = ap_palloc(p, sizeof(param));
	    pp->attr = attribute;
	    pp->val = value;
	    pp->next = NULL;

	    if (ctp->param == NULL) {
		ctp->param = pp;
	    }
	    else {
		npp = ctp->param;
		while (npp->next) {
		    npp = npp->next;
		}
		npp->next = pp;
	    }
	    quoted = 0;
	    attribute = NULL;
	    value = NULL;
	    if (*cp == '\0') {
		break;
	    }
	    cp++;
	    mp = cp;
	}
    }
    return (ctp);
}

    const char *charset = NULL;
    if (fn == NULL) {
	fn = r->filename;
    }
	/* Add charset to Content-Type */
	if ((type = ap_table_get(conf->charset_types, ext))) {
	    charset = type;
	    found = 1;
	}

        if ((type = ap_table_get(conf->handlers, ext))
#if 0	
	/* XXX fix me when the proxy code is updated */
	    && r->proxyreq == NOT_PROXY) 
#endif
        ) {
	    charset = NULL;
	}
    }
    if (r->content_type) {
	content_type *ctp;
	char *ct;
	int override = 0;

	ct = (char *) ap_palloc(r->pool,
				sizeof(char) * (strlen(r->content_type) + 1));
	strcpy(ct, r->content_type);

	if ((ctp = analyze_ct(r, ct))) {
	    param *pp = ctp->param;
	    r->content_type = ap_pstrcat(r->pool, ctp->type, "/",
					 ctp->subtype, NULL);
	    while (pp != NULL) {
		if (charset && !strcmp(pp->attr, "charset")) {
		    if (!override) {
			r->content_type = ap_pstrcat(r->pool, r->content_type,
						     "; charset=", charset,
						     NULL);
			override = 1;
		    }
		}
		else {
		    r->content_type = ap_pstrcat(r->pool, r->content_type,
						 "; ", pp->attr,
						 "=", pp->val,
						 NULL);
		}
		pp = pp->next;
	    }
	    if (charset && !override) {
		r->content_type = ap_pstrcat(r->pool, r->content_type,
					     "; charset=", charset,
					     NULL);
	    }
	}
    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, "text/xml");
    ap_set_content_type(r, apr_pstrdup(r->pool, info->content_type));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html;charset=utf-8");
    ap_set_content_type(r, "text/html");
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html");
                    ap_set_content_type(r, "text/plain");
    ap_set_content_type(r, "message/http");
AP_DECLARE(void) ap_set_content_type(request_rec *r, const char *ct)
        ap_set_content_type(r, "text/html; charset=iso-8859-1");
            ap_set_content_type(r, apr_pstrcat(r->pool, "multipart",
                                               use_range_x(r) ? "/x-" : "/",
                                               "byteranges; boundary=",
                                               r->boundary, NULL));
    ap_set_content_type(r, rr->content_type);
        ap_set_content_type(new, r->content_type);
        ap_set_content_type(r, DIR_MAGIC_TYPE);
                ap_set_content_type(r, (char*) type);
                ap_set_content_type(r, exinfo->forced_type);
	    ap_set_content_type(r, apr_pstrcat(r->pool, ctp->type, "/",
                                               ctp->subtype, NULL));
			ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                           "; charset=", charset,
                                                           NULL));
		    ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                       "; ", pp->attr,
                                                       "=", pp->val,
                                                       NULL));
		ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                   "; charset=", charset,
                                                   NULL));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(sub_req, CGI_MAGIC_TYPE);
        ap_set_content_type(r, t);
                ap_set_content_type(r, p->forced_mimetype);
	    ap_set_content_type(r, tmp);
	ap_set_content_type(r, tmp);
	ap_set_content_type(r, apr_pstrdup(r->pool, sub->content_type));
        ap_set_content_type(r, "text/html");
            ap_set_content_type(r, ap_default_type(r));
                    ap_set_content_type(r, apr_pstrdup(p, buf));
#if APR_HAVE_UNISTD_H
#include <unistd.h>
#endif
static const char     *client_lock_name;
static const char     *opaque_lock_name;
static const char     *client_shm_filename;
    if (client_rmm) {
        apr_rmm_destroy(client_rmm);
        client_rmm = NULL;
    }

static int initialize_tables(server_rec *s, apr_pool_t *ctx)
    const char *tempdir; 
    sts = apr_temp_dir_get(&tempdir, ctx);
    if (APR_SUCCESS != sts) {
        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s, 
                     "Failed to find temporary directory");
        log_error_and_cleanup("failed to find temp dir", sts, s);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    /* Create the shared memory segment */

    /* 
     * Create a unique filename using our pid. This information is 
     * stashed in the global variable so the children inherit it.
     */
    client_shm_filename = apr_psprintf(ctx, "%s/authdigest_shm.%"APR_PID_T_FMT, tempdir, 
                                       getpid());

    /* Now create that segment */
    sts = apr_shm_create(&client_shm, shmem_size,
                        client_shm_filename, ctx);
    if (APR_SUCCESS != sts) {
        ap_log_error(APLOG_MARK, APLOG_ERR, sts, s, 
                     "Failed to create shared memory segment on file %s", 
                     client_shm_filename);
        log_error_and_cleanup("failed to initialize shm", sts, s);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    sts = apr_rmm_init(&client_rmm,
                       NULL, /* no lock, we'll do the locking ourselves */
                       apr_shm_baseaddr_get(client_shm),
                       shmem_size, ctx);
        log_error_and_cleanup("failed to initialize rmm", sts, s);
        return !OK;
    client_list = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(*client_list) +
                                                          sizeof(client_entry*)*num_buckets));
        return !OK;
    client_lock_name = apr_psprintf(ctx, "%s/authdigest_lock.%"APR_PID_T_FMT, tempdir, 
                                    getpid());
        return !OK;
    opaque_cntr = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(*opaque_cntr)));
        return !OK;
    opaque_lock_name = apr_psprintf(ctx, "%s/authdigest_opaque_lock.%"APR_PID_T_FMT,
                                    tempdir, 
                                    getpid());
        return !OK;
    otn_counter = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(*otn_counter)));
        return !OK;
    return OK;
    if (initialize_tables(s, p) != OK) {
        return !OK;
    }
    /* Call cleanup_tables on exit or restart */
    /* Get access to rmm in child */
    sts = apr_rmm_attach(&client_rmm,
                         NULL,
                         apr_shm_baseaddr_get(client_shm),
                         p);
    if (sts != APR_SUCCESS) {
        log_error_and_cleanup("failed to attach to rmm", sts, s);
        return;
    }

            apr_rmm_free(client_rmm, apr_rmm_offset_get(client_rmm, entry));
    entry = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(client_entry)));
        entry = apr_rmm_addr_get(client_rmm, apr_rmm_malloc(client_rmm, sizeof(client_entry)));
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                         "unable to allocate new auth_digest client");
            apr_global_mutex_unlock(client_lock);
    apr_global_mutex_unlock(opaque_lock);
    apr_os_pipe_put(&tempsock, &sd, r->pool);
    apr_os_pipe_put(&tempsock, &sd, r->pool);
const char *ap_set_listenbacklog(cmd_parms *cmd, void *dummy, const char *arg);
const char *ap_set_listener(cmd_parms *cmd, void *dummy, const char *ips);
const char *ap_set_send_buffer_size(cmd_parms *cmd, void *dummy,
				    const char *arg);
AP_INIT_TAKE1("ListenBacklog", ap_set_listenbacklog, NULL, RSRC_CONF, \
  "Maximum length of the queue of pending connections, as used by listen(2)"), \
AP_INIT_TAKE1("Listen", ap_set_listener, NULL, RSRC_CONF, \
  "A port number or a numeric IP address and a port number"), \
AP_INIT_TAKE1("SendBufferSize", ap_set_send_buffer_size, NULL, RSRC_CONF, \
  "Send buffer size in bytes"),
API_EXPORT(const char *) ap_resolve_env(ap_pool_t *p, const char * word); 
# define strchr(s, c)	ap_strchr(s,c)
char *ap_strchr(char *s, int c);
const char *ap_strchr_c(const char *s, int c);
# define ap_strchr(s, c)	strchr(s, c)
# define ap_strchr_c(s, c)	strchr(s, c)
		    in = ap_strchr_c(in, '}');
    if (!args || !args[0] || ap_strchr_c(args, '=')) {
    if ((filename_only = ap_strrchr_c(filename_full, '/')) == NULL) {
    if (ap_strchr_c(msg,' ')) 
    if (!ap_strchr_c(range, ',')) {
    if (ap_strchr_c(new_file, '/') == NULL) {
const char *unixd_set_user(cmd_parms *cmd, void *dummy, const char *arg)
const char *unixd_set_group(cmd_parms *cmd, void *dummy, const char *arg)
const char *unixd_set_user(cmd_parms *cmd, void *dummy, const char *arg);
const char *unixd_set_group(cmd_parms *cmd, void *dummy, const char *arg);
AP_INIT_TAKE1("User", unixd_set_user, NULL, RSRC_CONF, \
  "Effective user id for this server"), \
AP_INIT_TAKE1("Group", unixd_set_group, NULL, RSRC_CONF, \
  "Effective group id for this server"),
    const char *starp;
	    if (ap_strchr_c(handp->content_type, '*')) {
	    if ((starp = ap_strchr_c(handp->content_type, '*'))) {
    const char *p;
        if ((p = ap_strchr_c(handler, ';')) != NULL) {
	    /* MIME type arguments */
const char *ap_set_listener(cmd_parms *cmd, void *dummy, const char *ips_)
    char *ips=ap_pstrdup(cmd->pool, ips_);
const char *ap_set_listenbacklog(cmd_parms *cmd, void *dummy, const char *arg) 
const char *ap_set_send_buffer_size(cmd_parms *cmd, void *dummy, const char *arg)
static const char *ap_pid_fname=NULL;
API_VAR_EXPORT const char *ap_scoreboard_fname=NULL;
static const char *lock_fname;
static const char *set_pidfile(cmd_parms *cmd, void *dummy, const char *arg) 
static const char *set_scoreboard(cmd_parms *cmd, void *dummy,
				  const char *arg) 
static const char *set_lockfile(cmd_parms *cmd, void *dummy, const char *arg) 
static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy,
					const char *arg) 
static const char *set_min_spare_threads(cmd_parms *cmd, void *dummy,
					 const char *arg)
static const char *set_max_spare_threads(cmd_parms *cmd, void *dummy,
					 const char *arg)
static const char *set_server_limit (cmd_parms *cmd, void *dummy,
				     const char *arg) 
static const char *set_threads_per_child (cmd_parms *cmd, void *dummy,
					  const char *arg) 
static const char *set_max_requests(cmd_parms *cmd, void *dummy,
				    const char *arg) 
static const char *set_coredumpdir (cmd_parms *cmd, void *dummy,
				    const char *arg) 
AP_INIT_TAKE1("PidFile", set_pidfile, NULL, RSRC_CONF,
    "A file for logging the server process ID"),
AP_INIT_TAKE1("ScoreBoardFile", set_scoreboard, NULL, RSRC_CONF,
    "A file for Apache to maintain runtime process management information"),
AP_INIT_TAKE1("LockFile", set_lockfile, NULL, RSRC_CONF,
    "The lockfile used when Apache needs to lock the accept() call"),
AP_INIT_TAKE1("StartServers", set_daemons_to_start, NULL, RSRC_CONF,
  "Number of child processes launched at server startup"),
AP_INIT_TAKE1("MinSpareThreads", set_min_spare_threads, NULL, RSRC_CONF,
  "Minimum number of idle children, to handle request spikes"),
AP_INIT_TAKE1("MaxSpareThreads", set_max_spare_threads, NULL, RSRC_CONF,
  "Maximum number of idle children"),
AP_INIT_TAKE1("MaxClients", set_server_limit, NULL, RSRC_CONF,
  "Maximum number of children alive at the same time"),
AP_INIT_TAKE1("ThreadsPerChild", set_threads_per_child, NULL, RSRC_CONF,
  "Number of threads each child creates"),
AP_INIT_TAKE1("MaxRequestsPerChild", set_max_requests, NULL, RSRC_CONF,
  "Maximum number of requests a particular child serves before dying."),
AP_INIT_TAKE1("CoreDumpDirectory", set_coredumpdir, NULL, RSRC_CONF,
  "The location of the directory Apache changes to before dumping core"),
    semi = ap_strchr_c(intype, ';');
    const char *pos = ap_strchr_c(*line, stop);
    const char *pos = ap_strchr_c(*line, stop);
API_EXPORT(const char *) ap_resolve_env(ap_pool_t *p, const char * word)
       const char *s, *e;
       if (!(s=ap_strchr_c(word,'$')))
               return word;
               if ((s[1] == '{') && (e=ap_strchr_c(s,'}'))) {
                       const char *e2 = e;
                           strncat(tmp, s, e2-s);
       } while ((s=ap_strchr_c(word,'$')));
	const char *colon = ap_strchr_c(path, ':');
	const char *slash = ap_strchr_c(path, '/');
/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

#include "httpd.h"

#ifdef AP_DEBUG
# undef strchr

char *ap_strchr(char *s, int c)
{ return strchr(s,c); }

const char *ap_strchr_c(const char *s, int c)
{ return strchr(s,c); }

# undef strrchr

char *ap_strrchr(char *s, int c)
{ return strrchr(s,c); }

const char *ap_strrchr_c(const char *s, int c)
{ return strrchr(s,c); }

#endif
	    s1 = ap_strchr_c(s, '#');
    s = ap_strchr_c(hostinfo, ':');
static const char *get_addresses(ap_pool_t *p, const char *w_,
    char *w;
    if (*w_ == 0)
    w=ap_pstrdup(p, w_);

                if ((fold_len - 1) > r->server->limit_req_fieldsize) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field " 
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

    const char *p;
    const char *allowed = "~$-_.+!*'(),;:@&=/"; /* allowed+reserved from
                                                   ap_proxy_canonenc */
    /* In a reverse proxy, our URL has been processed, so canonicalise
     * In a forward proxy, we have and MUST NOT MANGLE the original,
     * so just check it for disallowed chars.
     */
    switch (r->proxyreq) {
    default: /* wtf are we doing here? */
    case PROXYREQ_REVERSE:
        path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path, 0, r->proxyreq);
        break;
    case PROXYREQ_PROXY:
        for (p = url; *p; ++p) {
            if (!apr_isalnum(*p) && !strchr(allowed, *p)) {
                if (*p == '%' && apr_isxdigit(p[1]) && apr_isxdigit(p[2])) {
                    p += 2; /* an encoded char */
                }
                else {
                    return HTTP_BAD_REQUEST; /* reject bad char in URL */
                }
            }
        }
        path = url;
        break;
    }

 * 20091119.1 (2.3.4-dev)  ap_mutex_register(), ap_{proc,global}_mutex_create()
#define MODULE_MAGIC_NUMBER_MINOR 1                     /* 0...n */
/* mutex type string for accept mutex, if any; MPMs should use the
 * same mutex type for ease of configuration
 */
#define ap_accept_mutex_type "mpm-accept"

/* private function to process the Mutex directive */
AP_DECLARE(const char *) ap_set_mutex(cmd_parms *cmd, void *dummy,
                                      const char *typelist,
                                      const char *mechfile);

/**
 * option flags for ap_mutex_register(), ap_global_mutex_create(), and
 * ap_proc_mutex_create()
 */
#define AP_MUTEX_ALLOW_NONE    1 /* allow "none" as mutex implementation;
                                  * respected only on ap_mutex_register()
                                  */
#define AP_MUTEX_DEFAULT_NONE  2 /* default to "none" for this mutex;
                                  * respected only on ap_mutex_register()
                                  */

/**
 * Register a module's mutex type with core to allow configuration
 * with the Mutex directive.  This must be called in the pre_config
 * hook; otherwise, configuration directives referencing this mutex
 * type will be rejected.
 *
 * The default_dir and default_mech parameters allow a module to set
 * defaults for the lock file directory and mechanism.  These could
 * be based on compile-time settings.  These aren't required except
 * in special circumstances.
 *
 * The order of precedence for the choice of mechanism and lock file
 * directory is:
 *
 *   1. Mutex directive specifically for this mutex
 *      e.g., Mutex mpm-default flock:/tmp/mpmlocks
 *   2. Mutex directive for global default
 *      e.g., Mutex default flock:/tmp/httpdlocks
 *   3. Defaults for this mutex provided on the ap_mutex_register()
 *   4. Built-in defaults for all mutexes, which are
 *      APR_LOCK_DEFAULT and DEFAULT_REL_RUNTIMEDIR.
 *
 * @param pconf The pconf pool
 * @param type The type name of the mutex, used as the basename of the
 * file associated with the mutex, if any.  This must be unique among
 * all mutex types (mutex creation accommodates multi-instance mutex
 * types); mod_foo might have mutex  types "foo-pipe" and "foo-shm"
 * @param default_dir Default dir for any lock file required for this
 * lock, to override built-in defaults; should be NULL for most
 * modules, to respect built-in defaults
 * @param default_mech Default mechanism for this lock, to override
 * built-in defaults; should be APR_LOCK_DEFAULT for most modules, to
 * respect built-in defaults
 * or NULL if there are no defaults for this mutex.
 * @param options combination of AP_MUTEX_* constants, or 0 for defaults
 */
AP_DECLARE(apr_status_t) ap_mutex_register(apr_pool_t *pconf,
                                           const char *type,
                                           const char *default_dir,
                                           apr_lockmech_e default_mech,
                                           apr_int32_t options);

/**
 * Create an APR global mutex that has been registered previously with
 * ap_mutex_register().  Mutex files, permissions, and error logging will
 * be handled internally.
 * @param mutex The memory address where the newly created mutex will be
 * stored.  If this mutex is disabled, mutex will be set to NULL on
 * output.  (That is allowed only if the AP_MUTEX_ALLOW_NONE flag is
 * passed to ap_mutex_register().)
 * @param type The type name of the mutex, matching the type name passed
 * to ap_mutex_register().
 * @param instance_id A unique string to be used in the lock filename IFF
 * this mutex type is multi-instance, NULL otherwise.
 * @param s server_rec of main server
 * @param pconf pool
 * @param options combination of AP_MUTEX_* constants, or 0 for defaults
 * (currently none are defined for this function)
 */
AP_DECLARE(apr_status_t) ap_global_mutex_create(apr_global_mutex_t **mutex,
                                                const char *type,
                                                const char *instance_id,
                                                server_rec *s,
                                                apr_pool_t *pconf,
                                                apr_int32_t options);

/**
 * Create an APR proc mutex that has been registered previously with
 * ap_mutex_register().  Mutex files, permissions, and error logging will
 * be handled internally.
 * @param mutex The memory address where the newly created mutex will be
 * stored.  If this mutex is disabled, mutex will be set to NULL on
 * output.  (That is allowed only if the AP_MUTEX_ALLOW_NONE flag is
 * passed to ap_mutex_register().)
 * @param type The type name of the mutex, matching the type name passed
 * to ap_mutex_register().
 * @param instance_id A unique string to be used in the lock filename IFF
 * this mutex type is multi-instance, NULL otherwise.
 * @param s server_rec of main server
 * @param pconf pool
 * @param options combination of AP_MUTEX_* constants, or 0 for defaults
 * (currently none are defined for this function)
 */
AP_DECLARE(apr_status_t) ap_proc_mutex_create(apr_proc_mutex_t **mutex,
                                              const char *type,
                                              const char *instance_id,
                                              server_rec *s, apr_pool_t *p,
                                              apr_int32_t options);
#include "util_mutex.h"
static const char     *client_lock_type = "authdigest-client";
static const char     *opaque_lock_type = "authdigest-opaque";
    sts = ap_global_mutex_create(&client_lock, client_lock_type, NULL, s, ctx, 0);
    sts = ap_global_mutex_create(&opaque_lock, opaque_lock_type, NULL, s, ctx, 0);
static int pre_init(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    apr_status_t rv;

    rv = ap_mutex_register(pconf, client_lock_type, NULL, APR_LOCK_DEFAULT, 0);
    if (rv == APR_SUCCESS) {
        rv = ap_mutex_register(pconf, opaque_lock_type, NULL, APR_LOCK_DEFAULT,
                               0);
    }
    if (rv != APR_SUCCESS) {
        return rv;
    }

    return OK;
}
    sts = apr_global_mutex_child_init(&client_lock,
                                      apr_global_mutex_lockfile(client_lock),
                                      p);
    sts = apr_global_mutex_child_init(&opaque_lock,
                                      apr_global_mutex_lockfile(opaque_lock),
                                      p);
    ap_hook_pre_config(pre_init, NULL, NULL, APR_HOOK_MIDDLE);
#include "util_mutex.h"
static const char *wd_proc_mutex_type = "wd-proc";
        rc = apr_proc_mutex_child_init(&w->mutex,
                                       apr_proc_mutex_lockfile(w->mutex), p);

    if ((rv = ap_mutex_register(pconf, wd_proc_mutex_type, NULL,
                                APR_LOCK_DEFAULT, 0)) != APR_SUCCESS) {
        return rv;
    }

                        rv = ap_proc_mutex_create(&w->mutex, wd_proc_mutex_type,
                                                  w->name, s,
                                                  wd_server_conf->pool, 0);
#include "util_mutex.h"
static const char *exipc_mutex_type = "example-ipc-shm";
/*
 * This routine is called in the parent; we must register our
 * mutex type before the config is processed so that users can
 * adjust the mutex settings using the Mutex directive.
 */

static int exipc_pre_config(apr_pool_t *pconf, apr_pool_t *plog, 
                            apr_pool_t *ptemp)
{
    ap_mutex_register(pconf, exipc_mutex_type, NULL, APR_LOCK_DEFAULT, 0);
    return OK;
}
     * The shared memory allocation routines take a file name.
     * Depending on system-specific implementation of these
    rs = ap_global_mutex_create(&exipc_mutex, exipc_mutex_type, NULL, s, pconf,
                                0);
                                     apr_global_mutex_lockfile(exipc_mutex),
                     "Failed to reopen mutex %s in child", 
                     exipc_mutex_type);
    ap_hook_pre_config(exipc_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
#include "util_mutex.h"
static const char *ldap_cache_lock_type = "ldap-cache";
static int util_ldap_pre_config(apr_pool_t *pconf, apr_pool_t *plog,
                                apr_pool_t *ptemp)
{
    apr_status_t result;

    result = ap_mutex_register(pconf, ldap_cache_lock_type, NULL,
                               APR_LOCK_DEFAULT, 0);
    if (result != APR_SUCCESS) {
        return result;
    }

    return OK;
}

        result = ap_global_mutex_create(&st->util_ldap_cache_lock,
                                        ldap_cache_lock_type, NULL, s, p, 0);
              apr_global_mutex_lockfile(st->util_ldap_cache_lock), p);
                     ldap_cache_lock_type, getpid());
    ap_hook_pre_config(util_ldap_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
#include "util_mutex.h"
const char *rewritemap_mutex_type = "rewrite-map";
    /* XXX See if there are any rewrite map programs before creating
     * the mutex.
     */
    rc = ap_global_mutex_create(&rewrite_mapr_lock_acquire,
                                rewritemap_mutex_type, NULL, s, p, 0);
    if (rewrite_mapr_lock_acquire) {
        apr_global_mutex_destroy(rewrite_mapr_lock_acquire);
        rewrite_mapr_lock_acquire = NULL;
    }
    ap_mutex_register(pconf, rewritemap_mutex_type, NULL, APR_LOCK_DEFAULT, 0);

    if (rewrite_mapr_lock_acquire) {
                 apr_global_mutex_lockfile(rewrite_mapr_lock_acquire), p);
    /* Register mutex type names so they can be configured with Mutex */
    ap_mutex_register(pconf, ssl_cache_mutex_type, NULL, APR_LOCK_DEFAULT, 0);
#ifdef HAVE_OCSP_STAPLING
    ap_mutex_register(pconf, ssl_stapling_mutex_type, NULL, APR_LOCK_DEFAULT, 0);
#endif

    mc->stapling_cache         = NULL;
    mc->stapling_mutex         = NULL;
    if ((rv = ap_global_mutex_create(&mc->pMutex, ssl_cache_mutex_type, NULL,
                                     s, s->process->pool, 0))
    const char *lockfile;
    if (mc->pMutex == NULL || !mc->sesscache
    lockfile = apr_global_mutex_lockfile(mc->pMutex);
                                          lockfile,
                                          p)) != APR_SUCCESS) {
        if (lockfile)
                         "Cannot reinit %s mutex with file `%s'",
                         ssl_cache_mutex_type, lockfile);
                         "Cannot reinit %s mutex", ssl_cache_mutex_type);
#include "util_mutex.h"
/* mutex type names for Mutex directive */
#define ssl_cache_mutex_type    "ssl-cache"
#define ssl_stapling_mutex_type "ssl-stapling"

    if ((rv = ap_global_mutex_create(&mc->stapling_mutex,
                                     ssl_stapling_mutex_type, NULL, s,
                                     s->process->pool, 0)) != APR_SUCCESS) {
    const char *lockfile;
    lockfile = apr_global_mutex_lockfile(mc->stapling_mutex);
                                          lockfile, p)) != APR_SUCCESS) {
        if (lockfile) {
                         "Cannot reinit %s mutex with file `%s'",
                         ssl_stapling_mutex_type, lockfile);
                         "Cannot reinit %s mutex", ssl_stapling_mutex_type);
AP_INIT_TAKE2("Mutex", ap_set_mutex, NULL, RSRC_CONF,
              "mutex (or \"default\") and mechanism"),
#include "util_mutex.h"
    const char *lockfile;
    lockfile = apr_proc_mutex_lockfile(accept_mutex);
    status = apr_proc_mutex_child_init(&accept_mutex,
                                       lockfile,
                                       pchild);
                     "(%s) (%s)",
                     lockfile ? lockfile : "none",
                     apr_proc_mutex_name(accept_mutex));
    rv = ap_proc_mutex_create(&accept_mutex, ap_accept_mutex_type, NULL, s,
                              _pconf, 0);
                "Accept mutex: %s (default: %s)",
    ap_mutex_register(p, ap_accept_mutex_type, NULL, APR_LOCK_DEFAULT, 0);

#include "util_mutex.h"
    rv = SAFE_ACCEPT(apr_proc_mutex_child_init(&accept_mutex,
                                               apr_proc_mutex_lockfile(accept_mutex),
    rv = ap_proc_mutex_create(&accept_mutex, ap_accept_mutex_type, NULL, s,
                              _pconf, 0);
                "Accept mutex: %s (default: %s)",
    ap_mutex_register(pconf, ap_accept_mutex_type, NULL, APR_LOCK_DEFAULT, 0);

#include "apr_hash.h"
#include "http_log.h"
#include "unixd.h"
#ifdef HAVE_UNISTD_H
#include <unistd.h> /* getpid() */
#endif
    if (!strcasecmp(meth, "none") || !strcasecmp(meth, "no")) {
        return APR_ENOLOCK;
    }


typedef struct {
    apr_int32_t options;
    int set;
    int none;
    apr_lockmech_e mech;
    const char *dir;
} mutex_cfg_t;

/* hash is created the first time a module calls ap_mutex_register(),
 * rather than attempting to be the REALLY_REALLY_FIRST pre-config
 * hook; it is cleaned up when the associated pool goes away; assume
 * pconf is the pool passed to ap_mutex_register()
 */
static apr_hash_t *mxcfg_by_type;

static apr_status_t cleanup_mx_hash(void *dummy)
{
    mxcfg_by_type = NULL;
    return APR_SUCCESS;
}

static void mx_hash_init(apr_pool_t *p)
{
    mutex_cfg_t *def;

    if (mxcfg_by_type) {
        return;
    }

    mxcfg_by_type = apr_hash_make(p);
    apr_pool_cleanup_register(p, NULL, cleanup_mx_hash, apr_pool_cleanup_null);

    /* initialize default mutex configuration */
    def = apr_pcalloc(p, sizeof *def);
    def->mech = APR_LOCK_DEFAULT;
    def->dir = DEFAULT_REL_RUNTIMEDIR;
    apr_hash_set(mxcfg_by_type, "default", APR_HASH_KEY_STRING, def);
}

AP_DECLARE(const char *) ap_set_mutex(cmd_parms *cmd, void *dummy,
                                      const char *type, const char *mechdir)
{
    apr_pool_t *p = cmd->pool;
    apr_lockmech_e mech;
    apr_status_t rv;
    const char *mutexdir;
    mutex_cfg_t *mxcfg = apr_hash_get(mxcfg_by_type, type,
                                      APR_HASH_KEY_STRING);
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);

    if (err != NULL) {
        return err;
    }

    if (!mxcfg) {
        return apr_psprintf(p, "Mutex type %s is not valid", type);
    }

    mxcfg->none = 0; /* in case that was the default */

    rv = ap_parse_mutex(mechdir, p, &mech, &mutexdir);
    if (rv == APR_ENOTIMPL) {
        return apr_pstrcat(p, "Invalid Mutex argument ", mechdir,
                           " (" AP_ALL_AVAILABLE_MUTEXES_STRING ")", NULL);
    }
    else if (rv == APR_BADARG
             || (mutexdir && !ap_is_directory(p, mutexdir))) {
        return apr_pstrcat(p, "Invalid Mutex directory in argument ",
                           mechdir, NULL);
    }

    mxcfg->set = 1;
    if (rv == APR_ENOLOCK) { /* "none" */
        if (!(mxcfg->options & AP_MUTEX_ALLOW_NONE)) {
            return apr_psprintf(p,
                                "None is not allowed for mutex type %s",
                                type);
        }
        mxcfg->none = 1;
    }
    else {
        mxcfg->mech = mech;
        if (mutexdir) { /* retain mutex default if not configured */
            mxcfg->dir = mutexdir;
        }
    }

    return NULL;
}

AP_DECLARE(apr_status_t) ap_mutex_register(apr_pool_t *pconf,
                                           const char *type,
                                           const char *default_dir,
                                           apr_lockmech_e default_mech,
                                           apr_int32_t options)
{
    mutex_cfg_t *mxcfg = apr_pcalloc(pconf, sizeof *mxcfg);

    if ((options & ~(AP_MUTEX_ALLOW_NONE | AP_MUTEX_DEFAULT_NONE))) {
        return APR_EINVAL;
    }

    mx_hash_init(pconf);

    mxcfg->options = options;
    if (options & AP_MUTEX_DEFAULT_NONE) {
        mxcfg->none = 1;
    }
    mxcfg->dir = default_dir; /* usually NULL */
    mxcfg->mech = default_mech; /* usually APR_LOCK_DEFAULT */
    apr_hash_set(mxcfg_by_type, type, APR_HASH_KEY_STRING, mxcfg);

    return APR_SUCCESS;
}

static int mutex_needs_file(apr_lockmech_e mech)
{
    if (mech != APR_LOCK_FLOCK
        && mech != APR_LOCK_FCNTL
#if APR_USE_FLOCK_SERIALIZE || APR_USE_FCNTL_SERIALIZE
        && mech != APR_LOCK_DEFAULT
#endif
        ) {
        return 0;
    }
    return 1;
}

static const char *get_mutex_filename(apr_pool_t *p, mutex_cfg_t *mxcfg,
                                      const char *type,
                                      const char *instance_id)
{
    const char *pid_suffix = "";

    if (!mutex_needs_file(mxcfg->mech)) {
        return NULL;
    }

#if HAVE_UNISTD_H
    pid_suffix = apr_psprintf(p, ".%" APR_PID_T_FMT, getpid());
#endif

    return ap_server_root_relative(p,
                                   apr_pstrcat(p,
                                               mxcfg->dir,
                                               "/",
                                               type,
                                               instance_id ? "-" : "",
                                               instance_id ? instance_id : "",
                                               pid_suffix,
                                               NULL));
}

static mutex_cfg_t *mxcfg_lookup(apr_pool_t *p, const char *type)
{
    mutex_cfg_t *defcfg, *mxcfg, *newcfg;

    defcfg = apr_hash_get(mxcfg_by_type, "default", APR_HASH_KEY_STRING);

    /* MUST exist in table, or wasn't registered */
    mxcfg = apr_hash_get(mxcfg_by_type, type, APR_HASH_KEY_STRING);
    if (!mxcfg) {
        return NULL;
    }

    /* order of precedence:
     * 1. Mutex directive for this mutex
     * 2. Mutex directive for "default"
     * 3. Defaults for this mutex from ap_mutex_register()
     * 4. Global defaults
     */

    if (mxcfg->set) {
        newcfg = mxcfg;
    }
    else if (defcfg->set) {
        newcfg = defcfg;
    }
    else if (mxcfg->none || mxcfg->mech != APR_LOCK_DEFAULT) {
        newcfg = mxcfg;
    }
    else {
        newcfg = defcfg;
    }

    if (!newcfg->none && mutex_needs_file(newcfg->mech) && !newcfg->dir) {
        /* a file-based mutex mechanism was configured, but
         * without a mutex file directory; go back through
         * the chain to find the directory, store in new
         * mutex cfg structure
         */
        newcfg = apr_pmemdup(p, newcfg, sizeof *newcfg);

        /* !true if dir not already set: mxcfg->set && defcfg->dir */
        if (defcfg->set && defcfg->dir) {
            newcfg->dir = defcfg->dir;
        }
        else if (mxcfg->dir) {
            newcfg->dir = mxcfg->dir;
        }
        else {
            newcfg->dir = defcfg->dir;
        }
    }

    return newcfg;
}

static void log_bad_create_options(server_rec *s, const char *type)
{
    ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
                 "Invalid options were specified when creating the %s mutex",
                 type);
}

static void log_unknown_type(server_rec *s, const char *type)
{
    ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s,
                 "Can't create mutex of unknown type %s", type);
}

static void log_create_failure(apr_status_t rv, server_rec *s, const char *type,
                               const char *fname)
{
    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
                 "Couldn't create the %s mutex %s%s%s", type,
                 fname ? "(file " : "",
                 fname ? fname : "",
                 fname ? ")" : "");
}

static void log_perms_failure(apr_status_t rv, server_rec *s, const char *type)
{
    ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
                 "Couldn't set permissions on the %s mutex; "
                 "check User and Group directives",
                 type);
}

AP_DECLARE(apr_status_t) ap_global_mutex_create(apr_global_mutex_t **mutex,
                                                const char *type,
                                                const char *instance_id,
                                                server_rec *s, apr_pool_t *p,
                                                apr_int32_t options)
{
    apr_status_t rv;
    const char *fname;
    mutex_cfg_t *mxcfg = mxcfg_lookup(p, type);

    if (options) {
        log_bad_create_options(s, type);
        return APR_EINVAL;
    }

    if (!mxcfg) {
        log_unknown_type(s, type);
        return APR_EINVAL;
    }

    if (mxcfg->none) {
        *mutex = NULL;
        return APR_SUCCESS;
    }

    fname = get_mutex_filename(p, mxcfg, type, instance_id);

    rv = apr_global_mutex_create(mutex, fname, mxcfg->mech, p);
    if (rv != APR_SUCCESS) {
        log_create_failure(rv, s, type, fname);
        return rv;
    }

#ifdef AP_NEED_SET_MUTEX_PERMS
    rv = ap_unixd_set_global_mutex_perms(*mutex);
    if (rv != APR_SUCCESS) {
        log_perms_failure(rv, s, type);
        return rv;
    }
#endif

    return APR_SUCCESS;
}

AP_DECLARE(apr_status_t) ap_proc_mutex_create(apr_proc_mutex_t **mutex,
                                              const char *type,
                                              const char *instance_id,
                                              server_rec *s, apr_pool_t *p,
                                              apr_int32_t options)
{
    apr_status_t rv;
    const char *fname;
    mutex_cfg_t *mxcfg = mxcfg_lookup(p, type);

    if (options) {
        log_bad_create_options(s, type);
        return APR_EINVAL;
    }

    if (!mxcfg) {
        log_unknown_type(s, type);
        return APR_EINVAL;
    }

    if (mxcfg->none) {
        *mutex = NULL;
        return APR_SUCCESS;
    }

    fname = get_mutex_filename(p, mxcfg, type, instance_id);

    rv = apr_proc_mutex_create(mutex, fname, mxcfg->mech, p);
    if (rv != APR_SUCCESS) {
        log_create_failure(rv, s, type, fname);
        return rv;
    }

#ifdef AP_NEED_SET_MUTEX_PERMS
    rv = ap_unixd_set_proc_mutex_perms(*mutex);
    if (rv != APR_SUCCESS) {
        log_perms_failure(rv, s, type);
        return rv;
    }
#endif

    return APR_SUCCESS;
}
 * 20120109.0 (2.5.0-dev)  Changes sizeof(overrides_t) in core config.
#define MODULE_MAGIC_NUMBER_MAJOR 20120109
#define MODULE_MAGIC_NUMBER_MINOR 0                   /* 0...n */
/* Flags to determine whether syntax errors in .htaccess should be
 * treated as nonfatal (log and ignore errors)
 */
#define NONFATAL_OVERRIDE 512    /* Violation of AllowOverride rule */
#define NONFATAL_UNKNOWN 1024    /* Unrecognised directive */
#define NONFATAL_ALL (NONFATAL_OVERRIDE|NONFATAL_UNKNOWN)

typedef unsigned int overrides_t;
    if ((parms->override & cmd->req_override) == 0 && !override_list_ok) {
        if (parms->override & NONFATAL_OVERRIDE) {
            ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, parms->temp_pool,
                          APLOGNO(02295)
                          "%s in .htaccess forbidden by AllowOverride",
                          cmd->name);
            return NULL;
        }
        else {
            return apr_pstrcat(parms->pool, cmd->name,
                               " not allowed here", NULL);
        }
    }
        if (parms->override & NONFATAL_UNKNOWN) {
            ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, parms->temp_pool,
                          APLOGNO(02296) "Unknown directive %s "
                          "perhaps misspelled or defined by a module "
                          "not included in the server configuration", dir);
            return NULL;
        }
        else {
            return apr_pstrcat(parms->pool, "Invalid command '",
                               current->directive,
                               "', perhaps misspelled or defined by a module "
                               "not included in the server configuration",
                               NULL);
        }
        else if (!strcasecmp(w, "Nonfatal")) {
            if (!strcasecmp(v, "Override")) {
                d->override |= NONFATAL_OVERRIDE;
            }
            else if (!strcasecmp(v, "Unknown")) {
                d->override |= NONFATAL_UNKNOWN;
            }
            else if (!strcasecmp(v, "All")) {
                d->override |= NONFATAL_ALL;
            }
        }
 * 20051231.0 (2.3.0-dev) Added num_blank_lines, pending_header_line, and
 *                        pending_header_size to request_rec
#define MODULE_MAGIC_NUMBER_MAJOR 20051231
    /** Number of leading blank lines encountered before request header */
    int num_blank_lines;

    /** A buffered header line, used to support header folding while
     *  reading the request */
    char *pending_header_line;

    /** If nonzero, the number of bytes allocated to hold pending_header_line */
    apr_size_t pending_header_size;

static void set_the_request(request_rec *r, char *line)
    apr_socket_t *csd;
    ll = r->the_request = line;
             && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */
    }
    else {
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(r->connection->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->connection->base_server->timeout);

    return;
}

static apr_status_t set_mime_header(request_rec *r, char *line)
{
    char *value, *tmp_field;

    if (r->server->limit_req_fields) {
        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);
        if (mime_headers->nelts >= r->server->limit_req_fields) {
            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields "
                           "exceeds this server's limit.");
            r->status = HTTP_BAD_REQUEST;
            return APR_ENOSPC;
        }
    }
    
    if (!(value = strchr(line, ':'))) { /* Find ':' or    */
        r->status = HTTP_BAD_REQUEST;      /* abort bad request */
        apr_table_setn(r->notes, "error-notes",
                       apr_pstrcat(r->pool,
                                   "Request header field is "
                                   "missing ':' separator.<br />\n"
                                   "<pre>\n",
                                   ap_escape_html(r->pool, line),
                                   "</pre>\n", NULL));
        return APR_EGENERAL;
    }

    tmp_field = value - 1; /* last character of field-name */

    *value++ = '\0'; /* NUL-terminate at colon */

    while (*value == ' ' || *value == '\t') {
        ++value;            /* Skip to start of value   */
    }

    /* Strip LWS after field-name: */
    while (tmp_field > line
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }

    /* Strip LWS after field-value: */
    tmp_field = strchr(value, '\0') - 1;
    while (tmp_field > value
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }
    apr_table_addn(r->headers_in, line, value);
    return APR_SUCCESS;
}

static apr_status_t process_request_line(request_rec *r, char *line,
                                         int skip_first)
{
    if (!skip_first && (r->the_request == NULL)) {
        /* This is the first line of the request */
        if ((line == NULL) || (*line == '\0')) {
            /* We skip empty lines because browsers have to tack a CRLF on to the end
             * of POSTs to support old CERN webservers.
             */
            int max_blank_lines = r->server->limit_req_fields;
            if (max_blank_lines <= 0) {
                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
            }
            r->num_blank_lines++;
            if (r->num_blank_lines < max_blank_lines) {
                return APR_SUCCESS;
            }
        }
        set_the_request(r, line);
    }
    else {
        /* We've already read the first line of the request.  This is either
         * a header field or the blank line terminating the header
         */
        if ((line == NULL) || (*line == '\0')) {
            if (r->pending_header_line != NULL) {
                apr_status_t rv = set_mime_header(r, r->pending_header_line);
                if (rv != APR_SUCCESS) {
                    return rv;
                }
                r->pending_header_line = NULL;
            }
            if (r->status == HTTP_REQUEST_TIME_OUT) {
                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
                r->status = HTTP_OK;
            }
        }
        else {
            if ((*line == ' ') || (*line == '\t')) {
                /* This line is a continuation of the previous one */
                if (r->pending_header_line == NULL) {
                    r->pending_header_line = line;
                    r->pending_header_size = 0;
                }
                else {
                    apr_size_t pending_len = strlen(r->pending_header_line);
                    apr_size_t fold_len = strlen(line);
                    if (pending_len + fold_len >
                        r->server->limit_req_fieldsize) {
                        /* CVE-2004-0942 */
                        r->status = HTTP_BAD_REQUEST;
                        return APR_ENOSPC;
                    }
                    if (pending_len + fold_len + 1 > r->pending_header_size) {
                        /* Allocate a new buffer big enough to hold the
                         * concatenated lines
                         */
                        apr_size_t new_size = r->pending_header_size;
                        char *new_buf;
                        if (new_size == 0) {
                            new_size = pending_len + fold_len + 1;
                        }
                        else {
                            do {
                                new_size *= 2;
                            } while (new_size < pending_len + fold_len + 1);
                        }
                        new_buf = (char *)apr_palloc(r->pool, new_size);
                        memcpy(new_buf, r->pending_header_line, pending_len);
                        r->pending_header_line = new_buf;
                        r->pending_header_size = new_size;
                    }
                    memcpy(r->pending_header_line + pending_len, line,
                           fold_len + 1);
                }
            }
            else {
                /* Set aside this line in case the next line is a continuation
                 */
                if (r->pending_header_line != NULL) {
                    apr_status_t rv = set_mime_header(r, r->pending_header_line);
                    if (rv != APR_SUCCESS) {
                        return rv;
                    }
                }
                r->pending_header_line = line;
                r->pending_header_size = 0;
            }
        }
    }
    return APR_SUCCESS;
        rv = process_request_line(r, field, 1);
        if (rv != APR_SUCCESS) {
            return;
        if ((field == NULL) || (*field == '\0')) {
            return;
static request_rec *init_request(conn_rec *conn)
    
    return r;
}
static request_rec *request_post_read(request_rec *r, conn_rec *conn)
{
    apr_socket_t *csd;
    const char *expect;
    int access_status;
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->server->timeout);

    if (apr_table_get(r->headers_in, "Transfer-Encoding") &&
        apr_table_get(r->headers_in, "Content-Length")) {
        /* 2616 section 4.4, point 3: "if both Transfer-Encoding
         * and Content-Length are received, the latter MUST be
         * ignored"; so unset it here to prevent any confusion
         * later.
         */
        apr_table_unset(r->headers_in, "Content-Length");
static apr_status_t read_partial_request(request_rec *r) {
    apr_bucket_brigade *tmp_bb;
    apr_status_t rv = APR_SUCCESS;

    /* Read and process lines of the request until we
     * encounter a complete request header, an error, or EAGAIN
     */
    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    while (r->status == HTTP_REQUEST_TIME_OUT) {
        char *line = NULL;
        apr_size_t line_length;
        apr_size_t length_limit;
        int first_line = (r->the_request == NULL);
        if (first_line) {
            length_limit = r->server->limit_req_line;
        }
        else {
            if (r->assbackwards) {
                r->status = HTTP_OK;
                break;
            }
            length_limit = r->server->limit_req_fieldsize;
        }
        /* TODO: use a nonblocking call in place of ap_rgetline */
        rv = ap_rgetline(&line, length_limit + 2,
                         &line_length, r, 0, tmp_bb);
        if (rv == APR_SUCCESS) {
            rv = process_request_line(r, line, 0);
        }
        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();
            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                if (first_line) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: URI too long (longer than %d)",
                                  r->server->limit_req_line);
                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                    r->proto_num = HTTP_VERSION(1,0);
                    r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
                }
                else {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: header line too long "
                                  "(longer than %d)",
                                  r->server->limit_req_fieldsize);
                    r->status = HTTP_BAD_REQUEST;
                }
            }
            break;
        }
    }
    apr_brigade_destroy(tmp_bb);
    return rv;
}

request_rec *ap_read_request(conn_rec *conn)
{
    request_rec *r;
    apr_status_t rv;

    r = init_request(conn);

    rv = read_partial_request(r);
    /* TODO poll if EAGAIN */
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return NULL;
    }

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers! Have to dink things just to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "client sent invalid HTTP/0.9 request: HEAD %s",
                      r->uri);
        r->header_only = 0;
        r->status = HTTP_BAD_REQUEST;
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return r;
    }

    return request_post_read(r, conn);
}

    ps->io_buffer_size = AP_IOBUFSIZE;
    ps->io_buffer_size_set = 0;
    ps->io_buffer_size = (overrides->io_buffer_size_set == 0) ? base->io_buffer_size : overrides->io_buffer_size;
static const char *
    set_io_buffer_size(cmd_parms *parms, void *dummy, const char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    long s = atol(arg);

    psf->io_buffer_size = MAX(s, AP_IOBUFSIZE);
    psf->io_buffer_size_set = 1;
    return NULL;
}

    AP_INIT_TAKE1("ProxyIOBufferSize", set_io_buffer_size, NULL, RSRC_CONF,
     "IO buffer size for outgoing HTTP and FTP connections in bytes"),
    apr_size_t recv_buffer_size;
    apr_size_t io_buffer_size;
    char io_buffer_size_set;
        apr_bucket *e;
        int finish = FALSE;
        while (ap_get_brigade(data->input_filters, 
                              bb, 
                              AP_MODE_READBYTES, 
                              APR_BLOCK_READ, 
                              conf->io_buffer_size) == APR_SUCCESS) {
#if DEBUGGING
            {
                apr_off_t readbytes;
                apr_brigade_length(bb, 0, &readbytes);
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0,
                             r->server, "proxy (PID %d): readbytes: %#x",
                             getpid(), readbytes);
            }
#endif
            /* sanity check */
            if (APR_BRIGADE_EMPTY(bb)) {
                apr_brigade_cleanup(bb);

            /* found the last brigade? */
            if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
                /* if this is the last brigade, cleanup the
                 * backend connection first to prevent the
                 * backend server from hanging around waiting
                 * for a slow client to eat these bytes
                 */
                ap_flush_conn(data);
                apr_socket_close(data_sock);
                data_sock = NULL;
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                             "proxy: FTP: data connection closed");
                /* signal that we must leave */
                finish = TRUE;
            }

            /* if no EOS yet, then we must flush */
            if (FALSE == finish) {
                e = apr_bucket_flush_create();
                APR_BRIGADE_INSERT_TAIL(bb, e);
            }

            /* try send what we read */
                finish = TRUE;

            /* make sure we always clean up after ourselves */

            /* if we are done, leave */
            if (TRUE == finish) {
                break;
            }
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                     "proxy: FTP: end body send");

    }
    if (data_sock) {
        ap_flush_conn(data);
        apr_socket_close(data_sock);
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                     "proxy: FTP: data connection closed");
static apr_status_t ap_proxy_http_cleanup(request_rec *r,
                                          proxy_http_conn_t *p_conn,
                                          proxy_conn_rec *backend);

             * if we are overriding the errors, we can't put the content
             * of the page into the brigade

                /* read the body, pass it to the output filters */
                int finish = FALSE;
                                      conf->io_buffer_size) == APR_SUCCESS) {
                    /* sanity check */
                        apr_brigade_cleanup(bb);

                    /* found the last brigade? */
                        /* if this is the last brigade, cleanup the
                         * backend connection first to prevent the
                         * backend server from hanging around waiting
                         * for a slow client to eat these bytes
                         */
                        ap_proxy_http_cleanup(r, p_conn, backend);
                        /* signal that we must leave */
                        finish = TRUE;

                    /* if no EOS yet, then we must flush */
                    if (FALSE == finish) {
                        e = apr_bucket_flush_create();
                        APR_BRIGADE_INSERT_TAIL(bb, e);
                    }

                    /* try send what we read */
                        finish = TRUE;

                    /* make sure we always clean up after ourselves */

                    /* if we are done, leave */
                    if (TRUE == finish) {
                        break;
                    }
        if (p_conn->sock) {
            apr_socket_close(p_conn->sock);
            p_conn->sock = NULL;
            backend->connection = NULL;
        }
static char* process_tags(header_entry *hdr, request_rec *r, request_rec *rr)
            str = apr_pstrdup(rr->pool, s);
            str = apr_pstrcat(rr->pool, str, s, NULL);
    request_rec *rr;

    rr = r;
    while (rr->main != NULL) {
        rr = rr->main;
    }
            apr_table_addn(headers, hdr->header, process_tags(hdr, r, rr));
            apr_table_mergen(headers, hdr->header, process_tags(hdr, r, rr));
                apr_table_addn(headers, hdr->header, process_tags(hdr, r, rr));
                char *new_val = process_tags(hdr, r, rr);
                 ap_set_content_type(r, process_tags(hdr, r, rr));
            apr_table_setn(headers, hdr->header, process_tags(hdr, r, rr));
                ed.p = rr->pool;
/* NOTE: these check the shared status */
#define PROXY_WORKER_IS_INITIALIZED(f)   ( (f)->s && \
  ( (f)->s->status &  PROXY_WORKER_INITIALIZED ) )
#define PROXY_WORKER_IS_STANDBY(f)   ( (f)->s && \
  ( (f)->s->status &  PROXY_WORKER_HOT_STANDBY ) )
#define PROXY_WORKER_IS_USABLE(f)   ( (f)->s && \
  ( !( (f)->s->status & PROXY_WORKER_NOT_USABLE_BITMAP) ) && \
  PROXY_WORKER_IS_INITIALIZED(f) )
                recycled_pool = NULL;
                    recycled_pool = ptrans;
            else {
                recycled_pool = ptrans;
            }
#include "http_main.h"
#include "http_protocol.h"
    char *date_str = ap_palloc(p, 48 * sizeof(char));
    char *date_str_ptr = date_str;
    int real_year;

    tms = gmtime(&sec);    /* ZZZ replace with AP time routine */

    /* Assumption: this is always 3 */
    /* i = strlen(ap_day_snames[tms->tm_wday]); */
    memcpy(date_str_ptr, ap_day_snames[tms->tm_wday], 3);
    date_str_ptr += 3;
    *date_str_ptr++ = ',';
    *date_str_ptr++ = ' ';
    *date_str_ptr++ = tms->tm_mday / 10 + '0';
    *date_str_ptr++ = tms->tm_mday % 10 + '0';
    *date_str_ptr++ = ' ';
    /* Assumption: this is also always 3 */
    /* i = strlen(ap_month_snames[tms->tm_mon]); */
    memcpy(date_str_ptr, ap_month_snames[tms->tm_mon], 3);
    date_str_ptr += 3;
    *date_str_ptr++ = ' ';
    real_year = 1900 + tms->tm_year;
    /* This routine isn't y10k ready. */
    *date_str_ptr++ = real_year / 1000 + '0';
    *date_str_ptr++ = real_year % 1000 / 100 + '0';
    *date_str_ptr++ = real_year % 100 / 10 + '0';
    *date_str_ptr++ = real_year % 10 + '0';
    *date_str_ptr++ = ' ';
    *date_str_ptr++ = tms->tm_hour / 10 + '0';
    *date_str_ptr++ = tms->tm_hour % 10 + '0';
    *date_str_ptr++ = ':';
    *date_str_ptr++ = tms->tm_min / 10 + '0';
    *date_str_ptr++ = tms->tm_min % 10 + '0';
    *date_str_ptr++ = ':';
    *date_str_ptr++ = tms->tm_sec / 10 + '0';
    *date_str_ptr++ = tms->tm_sec % 10 + '0';
    *date_str_ptr++ = ' ';
    *date_str_ptr++ = 'G';
    *date_str_ptr++ = 'M';
    *date_str_ptr++ = 'T';
    *date_str_ptr = '\0';

    return date_str;

    /* The equivalent using sprintf. Use this for more legible but slower code
    */
    register int badesc, badpath;
    char *x, *y;
    /* Initial scan for first '%'. Don't bother writing values before
     * seeing a '%' */
    y = strchr(url, '%');
    if (y == NULL) {
        return OK;
    }
    for (x = y; *y; ++x, ++y) {
	if (*y != '%')
	    *x = *y;
	    if (!ap_isxdigit(*(y + 1)) || !ap_isxdigit(*(y + 2))) {
		*x = '%';
		*x = x2c(y + 1);
		if (*x == '/' || *x == '\0')
    *x = '\0';
typedef struct
{
    const char *name;           /* matching module name */
    const char *info;           /* additional info */
typedef struct
{
static void *create_info_config(apr_pool_t * p, server_rec *s)
    info_svr_conf *conf =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t * p, void *basev, void *overridesv)
    info_svr_conf *new =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info =
        apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec *r, int nest, const char *thisfn,
                            int linenum)
    const char *prevfn =
        ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL)
        thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n",
                   thisfn);
    if (linenum > 0)
        sprintf(buf, "%d", linenum);
    else
        buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i)
        ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i)
        ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec *r, const ap_directive_t * dir,
                              int nest)
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec *r, const ap_directive_t * dir,
                               int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n",
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec *r, const ap_directive_t * dir,
    }
    else {
        ap_rprintf(r, "/%s</tt></dd>", ap_escape_html(r->pool, dirname));
    }

static int mod_info_has_cmd(const command_rec *cmds, ap_directive_t * dir)
    const command_rec *cmd;
    if (cmds == NULL)
        return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0)
            return 1;
    }
static void mod_info_show_parents(request_rec *r, ap_directive_t * node,
                                  int from, int to)
{
    if (from < to)
        mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec *r, const command_rec *cmds,
    ap_directive_t *dir;
    if (level == 0)
        ap_set_module_config(r->request_config, &info_module, NULL);
                                             shown, level + 1)) {
        }
        else if (mod_info_has_cmd(cmds, dir)) {
        }
typedef struct
{                               /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc) (void);       /* just to get the right size */
    const char *const *aszPredecessors;
    const char *const *aszSuccessors;
typedef apr_array_header_t *(
                                __stdcall
                                * hook_get_t)      (void);
typedef struct
{
static int module_find_hook(module *modp, hook_get_t hook_get)
    elts = (hook_struct_t *) hooks->elts;
    for (i = 0; i < hooks->nelts; i++) {
                               hook_lookup_t * lookup, int *comma)
    int i, comma = 0;
    for (i = 0; request_hooks[i].name; i++) {
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
        return DECLINED;
             "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n",
             r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ",
                     r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name,
                           modp->name);
            ap_rprintf(r,
                       "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                       ap_get_server_version());
            ap_rprintf(r,
                       "<dt><strong>Server Built:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                       ap_get_server_built());
            ap_rprintf(r,
                       "<dt><strong>API Version:</strong> "
                       "<tt>%d:%d</tt></dt>\n", MODULE_MAGIC_NUMBER_MAJOR,
                       MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r,
                       "<dt><strong>Hostname/port:</strong> "
                       "<tt>%s:%u</tt></dt>\n", ap_get_server_name(r),
                       ap_get_server_port(r));
            ap_rprintf(r,
                       "<dt><strong>Timeouts:</strong> "
                       "<tt>connection: %d &nbsp;&nbsp; "
                       "keep-alive: %d</tt></dt>",
                       (int) (apr_time_sec(serv->timeout)),
                       (int) (apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n",
                       ap_show_mpm());
            ap_rprintf(r,
                       "<dt><strong>MPM Information:</strong> "
                       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r,
                       "<dt><strong>Server Root:</strong> "
                       "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r,
                       "<dt><strong>Config File:</strong> "
                       "<tt>%s</tt></dt>\n", ap_conftree->filename);
            for (modp = ap_top_module; modp; modp = modp->next) {
                if (!r->args || !strcasecmp(modp->name, r->args)) {
                    ap_rprintf(r,
                               "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                               "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                               modp->name, modp->name);
                    ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                    hand = modp->handlers;
                    if (hand) {
                        while (hand) {
                            if (hand->content_type) {
                                ap_rprintf(r, " <tt>%s</tt>\n",
                                           hand->content_type);
                            }
                            else {
                                break;
                            }
                            hand++;
                            if (hand && hand->content_type) {
                                ap_rputs(",", r);
                            }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    if (module_find_hook(modp, ap_hook_get_handler)) {
                        ap_rputs("<tt> <em>yes</em></tt>", r);
                    }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    ap_rputs("</dt>", r);
                    ap_rputs
                        ("<dt><strong>Configuration Phase Participation:</strong>\n",
                         r);
                    if (modp->create_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Directory Config</tt>", r);
                        comma = 1;
                    if (modp->merge_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Directory Configs</tt>", r);
                        comma = 1;
                    if (modp->create_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Server Config</tt>", r);
                        comma = 1;
                    if (modp->merge_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Server Configs</tt>", r);
                        comma = 1;
                    if (!comma)
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    comma = 0;
                    ap_rputs("</dt>", r);

                    module_request_hook_participate(r, modp);

                    cmd = modp->cmds;
                    if (cmd) {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong></dt>",
                             r);
                        while (cmd) {
                            if (cmd->name) {
                                ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                           ap_escape_html(r->pool, cmd->name),
                                           cmd->name[0] == '<' ? "&gt;" : "");
                                if (cmd->errmsg) {
                                    ap_rputs(cmd->errmsg, r);
                                }
                                ap_rputs("</i></tt></dd>\n", r);
                            else {
                                break;
                            }
                            cmd++;
                        ap_rputs
                            ("<dt><strong>Current Configuration:</strong></dt>\n",
                             r);
                        mod_info_module_cmds(r, modp->cmds, ap_conftree, 0,
                                             0);
                    }
                    else {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>",
                             r);
                    }
                    more_info = find_more_info(serv, modp->name);
                    if (more_info) {
                        ap_rputs
                            ("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                             r);
                        ap_rputs(more_info, r);
                        ap_rputs("</dd>", r);
                    }
                    ap_rputs("</dl><hr />\n", r);
                    if (r->args) {
                        break;
            if (!modp && r->args && strcasecmp(r->args, "server")) {
                ap_rputs("<p><b>No such module</b></p>\n", r);
            }
    ap_rputs(ap_psignature("", r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy,
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
static const command_rec info_cmds[] = {
static void register_hooks(apr_pool_t * p)
module AP_MODULE_DECLARE_DATA info_module = {
        if (APR_SUCCESS != (status = apr_strtoff(&cl_val, old_cl_val, NULL,
                                                 0))) {
            return status;
        }
module AP_MODULE_DECLARE_DATA imagemap_module;
    icr = ap_get_module_config(r->per_dir_config, &imagemap_module);
module AP_MODULE_DECLARE_DATA imagemap_module =
#include "apr_network_io.h"

    ap_socket_t *sd;
    ap_file_t fds[2];
    ap_file_t *write_f;
#define ap_piped_log_write_fd(pl)	((pl)->write_f)
#include "apr_portable.h"
API_EXPORT(long) ap_send_fd(int fd, request_rec *r);
API_EXPORT(long) ap_send_fd_length(int fd, request_rec *r, long length);
    ap_file_t *error_log;
API_EXPORT(char *) ap_md5digest(ap_context_t *p, int infile, int convert);
API_EXPORT(char *) ap_md5digest(ap_context_t *p, int infile);
    ap_file_t *f;
    FILE *thefile;         /* XXX leave these alone until we convert */
    int thefd;             /* everything to use apr_file_t's. */ 
    if (ap_open(r->pool, r->filename, APR_READ | APR_BUFFERED, 
                APR_OS_DEFAULT, &f) != APR_SUCCESS) {
    ap_get_os_file(f, &thefd); 
    thefile = fdopen(thefd, "r");
    
    ap_scan_script_header_err(r, thefile, NULL);
	ap_close(f);
        ap_off_t zero = 0;
	ap_seek(f, APR_CUR, &zero);
	ap_send_fd(thefd, r);
    ap_close(f);
static void do_emit_plain(request_rec *r, ap_file_t *f)
    ap_status_t stat;
    while (!ap_eof(f)) {
            n = sizeof(char) * IOBUFSIZE;
	    stat = ap_read(f, buf, &n);
	while (stat != APR_SUCCESS && stat == EINTR);
    ap_file_t *f;
		if (ap_open(r->pool, rr->filename, APR_READ | APR_BUFFERED,
                            APR_OS_DEFAULT, &f) == APR_SUCCESS) {
		    ap_close(f);
    ap_file_t *f;
		if (ap_open(r->pool, rr->filename, APR_READ | APR_BUFFERED,
                            APR_OS_DEFAULT, &f) == APR_SUCCESS) {
		    ap_close(f);
    ap_file_t *thefile = NULL;
        if (ap_open(r->pool, r->filename, APR_READ | APR_BUFFERED,
                    APR_OS_DEFAULT, &thefile) != APR_SUCCESS) {
        n = sizeof(char) * (MAX_STRING_LEN - 1);
	ap_read(thefile, titlebuf, &n);
	    ap_close(thefile);
		    ap_close(thefile);
	ap_close(thefile);
    ap_dir_t *d;
    if (ap_opendir(r->pool, name, &d) != APR_SUCCESS) {
	ap_closedir(d);
    while (ap_readdir(d)) {
        char *d_name;
        ap_get_dir_filename(d, &d_name);
	p = make_autoindex_entry(d_name, autoindex_opts,
    ap_closedir(d);
	    (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
    ap_file_t *fd = NULL;
    int fd_os;
    if (ap_open (r->pool, r->filename, APR_READ | APR_BINARY, 0, &fd) != APR_SUCCESS) {
    else
       ap_get_os_file (fd, &fd_os);
        ap_close(fd);
		  fd_os, 0);
			  ap_md5digest(r->pool, fd_os, convert_flag));
			  ap_md5digest(r->pool, fd_os));
		ap_send_fd(fd_os, r);
		long     length;
                ap_off_t offset;

                    if (ap_seek(fd, APR_SET, &offset) != APR_SUCCESS) {
			ap_close(fd);
		    ap_send_fd_length(fd_os, r, length);
    ap_close(fd);
API_EXPORT(long) ap_send_fd(int fd, request_rec *r)
API_EXPORT(long) ap_send_fd_length(int fd, request_rec *r, long length)
static int xfer_flags = (APR_WRITE | APR_APPEND | APR_CREATE);
static mode_t xfer_mode = (APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD);
 * well, use the CLF. log_fd is NULL before the log file is opened and
    ap_file_t *log_fd;
    if (cls->outcnt && cls->log_fd != NULL) {
        ap_write(cls->log_fd, cls->outbuf, cls->outcnt);
        ap_write(cls->log_fd, str, len);
    ap_write(cls->log_fd, str, &len);
    cls->log_fd = NULL;
    if (cls->log_fd != NULL) {
        if (ap_open(p, fname, xfer_flags, xfer_mode, &cls->log_fd) != APR_SUCCESS) {
static enum header_state get_header_line(char *buffer, int len, ap_file_t *map)
    char c;
        if (ap_gets(map, buffer, MAX_STRING_LEN) != APR_SUCCESS) {
    while (ap_getc(map, &c) != APR_EOF) {
            while (ap_getc(map, &c) != EOF && c != '\n') {
                ap_getc(map, &c);
            ap_ungetc(map, c);
            while (cp < buf_end - 2 && (ap_getc(map, &c)) != EOF && c != '\n') {
            ap_ungetc(map, c);
    ap_file_t *map;
    if (ap_open(neg->pool, rr->filename, APR_READ | APR_BUFFERED,
                APR_OS_DEFAULT, &map) != APR_SUCCESS) {
    ap_close(map);
    ap_dir_t *dirp;
    if (ap_opendir(neg->pool, neg->dir_name, &dirp) != APR_SUCCESS) {
    while (ap_readdir(dirp) == APR_SUCCESS) {
        char *d_name;
        ap_get_dir_filename(dirp, &d_name);
        if (strncmp(d_name, filp, prefix_len)) {
        if (d_name[prefix_len] != '.') {
        sub_req = ap_sub_req_lookup_file(d_name, r);
            ap_closedir(dirp);
        mime_info.file_name = ap_pstrdup(neg->pool, d_name);
    ap_closedir(dirp);
#include "apr_portable.h"
    int errfile = STDERR_FILENO;
    ap_put_os_file(p, &s->error_log, &errfile);
#include "apr_network_io.h"
static ap_status_t make_sock(ap_context_t *p, ap_listen_rec *server)
    ap_socket_t *s = server->sd;
    ap_status_t stat;
    stat = ap_setsocketopt(s, APR_SO_REUSEADDR, one);
    if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
	ap_close_socket(s);
	return stat;
    
    stat = ap_setsocketopt(s, APR_SO_KEEPALIVE, one);
    if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
	ap_close_socket(s);
	return stat;
	stat = ap_setsocketopt(s, SO_SNDBUF,  send_buffer_size);
        if (stat != APR_SUCCESS && stat != APR_ENOTIMPL) {
            ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
    if ((stat = ap_bind(s)) != APR_SUCCESS) {
	ap_close_socket(s);
	return stat;
    if ((stat = ap_listen(s, ap_listenbacklog)) != APR_SUCCESS) {
	ap_close_socket(s);
	return stat;
    server->sd = s;
    return APR_SUCCESS;
	ap_close_socket(lr->sd);
static void alloc_listener(char *addr, unsigned int port)
    char *oldaddr;
    unsigned int oldport;
        ap_getport((*walk)->sd, &oldport);
        ap_getipaddr((*walk)->sd, &oldaddr);
	if (!strcmp(oldaddr, addr) && port == oldport) {
    if (ap_create_tcp_socket(NULL, &new->sd) != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
                 "make_sock: failed to get a socket for %s", addr);
        return;
    }
    ap_setport(new->sd, port);
    ap_setipaddr(new->sd, addr);
    ap_status_t stat;
	alloc_listener(APR_ANYADDR, port ? port : DEFAULT_HTTP_PORT);
	stat = make_sock(pconf, lr);
	if (stat == APR_SUCCESS) {
	ap_close_socket(lr->sd);
/*	free(lr);*/
    if (ports == ips) { /* no address */
        alloc_listener(APR_ANYADDR, port);
    }
    else {
        ips[(ports - ips) - 1] = '\0';
	alloc_listener(ips, port);
    }
#include "apr_portable.h"
        int dummyno;
        dummyno = fileno(dummy);
	ap_put_os_file(p, &s->error_log, &dummyno);
        if (ap_open(p, fname, APR_BUFFERED | APR_APPEND | APR_READ | APR_WRITE, 
                      APR_OS_DEFAULT, &s->error_log) != APR_SUCCESS) {
    int errfile;
        ap_get_os_file(s_main->error_log, &errfile);
	if (dup2(errfile, STDERR_FILENO) == -1) {
    int errfile;

    ap_get_os_file(s->error_log, &errfile);
        && errfile != STDERR_FILENO)
        dup2(errfile, STDERR_FILENO);
    ap_file_t *logf = NULL;
    int errfileno = STDERR_FILENO;
	ap_put_os_file(NULL, &logf, &errfileno);
	ap_puts(logf, errstr);
	ap_putc(logf, '\n');
	ap_flush(logf);
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
		     ap_psprintf(p,
                                 "pid file %s overwritten -- Unclean shutdown of previous Apache run?",
                     fname)
			       );
    ap_close(pl->fds[0]);
    ap_close(pl->fds[1]);
    ap_close(pl->fds[0]);
    ap_close(pl->fds[1]);
    if (ap_create_pipe(p, &pl->fds[0], &pl->fds[1]) != APR_SUCCESS) {
	ap_close(pl->fds[0]);
	ap_close(pl->fds[1]);
    int dummyno;
    dummyno = fileno(dummy);
    ap_put_os_file(p, &pl->write_f, &dummyno);
    ap_close(pl->write_f);
#include "apr_portable.h"
    ap_socket_t *csd = NULL;
    ap_socket_t *sd = NULL;
    int thesock;
                sd = ap_listeners->sd;
                        ap_put_os_sock(tpool, &sd, &listenfds[curr_pollfd].fd); 
            ap_accept(sd, &csd);
        ap_get_os_sock(csd, &thesock);
        process_socket(ptrans, &sa_client, thesock, process_slot, thread_slot);
        ap_get_os_sock(lr->sd, &listenfds[i].fd);
/*  XXXXXX  Removed because these functions don't exist anymore.  When
    These pipes are changed to apr_types, these functions won't be needed
    anyway.
*/

#include "apr_portable.h"
static ap_socket_t *sd;
    ap_file_t *tempfile;
    ap_open(p, ap_lock_fname, APR_CREATE | APR_WRITE | APR_EXCL,
            APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD, &tempfile);
    ap_get_os_file(tempfile, &lock_fd);
static ap_socket_t *csd;
    ap_status_t stat;
    int sockdes;
    csd = NULL;
                    ap_get_os_sock(lr->sd, &sockdes);
		    if (FD_ISSET(sockdes, &main_fds))
		sd = lr->sd;
		sd = ap_listeners->sd;
		stat = ap_accept(sd, &csd);
		if (stat == APR_SUCCESS || stat != APR_EINTR)
	    if (stat == APR_SUCCESS)
        ap_get_os_sock(csd, &sockdes);

	if (getsockname(sockdes, &sa_server, &clen) < 0) {
	    ap_close_socket(csd);
	sock_disable_nagle(sockdes);
	iol = unix_attach_socket(sockdes);
		    "larger FD_SETSIZE", sockdes, FD_SETSIZE);
	    ap_close_socket(csd);
    int sockdes;
        ap_get_os_sock(lr->sd, &sockdes);
	FD_SET(sockdes, &listenfds);
	if (sockdes > listenmaxfd) {
	    listenmaxfd = sockdes;
 
#include "apr_network_io.h"
static int get_rfc1413(ap_socket_t *sock, const char *local_ip,
		       const char *rmt_ip, 
    unsigned int sav_rmt_port, sav_our_port;
    ap_setport(sock, ANY_PORT);
    ap_setipaddr(sock, local_ip); 
    if (ap_bind(sock) != APR_SUCCESS) {
    ap_getport(sock, &sav_our_port);
    ap_setport(sock, RFC1413_PORT);
    ap_setipaddr(sock, rmt_ip); 
                    
    if (ap_connect(sock, NULL) != APR_SUCCESS)
        return -1;
    ap_getport(sock, &sav_rmt_port);
    buflen = ap_snprintf(buffer, sizeof(buffer), "%u,%u\r\n", sav_rmt_port,
		sav_our_port);
        int j = strlen(buffer + i);
        ap_status_t stat;
	stat  = ap_send(sock, buffer+i, &j);
	if (stat != APR_SUCCESS && stat != APR_EINTR) {
        int j = sizeof(buffer) - 1 - i;
        ap_status_t stat;
	stat = ap_recv(sock, buffer+i, &j);
	if (stat != APR_SUCCESS && stat != APR_EINTR) {
	       user) != 3 || sav_rmt_port != rmt_port
	|| sav_our_port != our_port)
    static ap_socket_t *sock;
    if (ap_create_tcp_socket(conn->pool, &sock) != APR_SUCCESS) {
	if (get_rfc1413(sock, conn->local_ip, conn->remote_ip, user, srv) >= 0)
    ap_close_socket(sock);
static ap_status_t cfg_close(void *param)
    ap_file_t *cfp = (ap_file_t *) param;
    return (ap_close(cfp));
    char ch;
    ap_file_t *cfp = (ap_file_t *) param;
    if (ap_getc(cfp, &ch) == APR_SUCCESS)
        return ch;
    return (int)EOF;
    ap_file_t *cfp = (ap_file_t *) param;
    if (ap_gets(cfp, buf, bufsiz) == APR_SUCCESS)
        return buf;
    return NULL;
    ap_file_t *file;
    ap_status_t stat;
    ap_filetype_e type;
    stat = ap_open(p, name, APR_READ | APR_BUFFERED, APR_OS_DEFAULT, &file);
                name, (stat != APR_SUCCESS) ? strerror(errno) : "successful");
    if (stat != APR_SUCCESS)
    if (ap_get_filetype(file, &type) == APR_SUCCESS &&
        type == APR_REG &&
        strcmp(name, "/dev/null") == 0) {
        ap_close(file);
    new_cfg->param = file;
#include "apr_portable.h"
API_EXPORT(char *) ap_md5digest(ap_context_t *p, int infile, int convert)
API_EXPORT(char *) ap_md5digest(ap_context_t *p, int infile)
    int errfileno = STDERR_FILENO;
    ap_put_os_file(r->pool, &r->server->error_log, &errfileno);
typedef struct
{
    const char *name;           /* matching module name */
    const char *info;           /* additional info */
typedef struct
{
static void *create_info_config(apr_pool_t * p, server_rec *s)
    info_svr_conf *conf =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t * p, void *basev, void *overridesv)
    info_svr_conf *new =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info =
        apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec *r, int nest, const char *thisfn,
                            int linenum)
    const char *prevfn =
        ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL)
        thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n",
                   thisfn);
    if (linenum > 0)
        sprintf(buf, "%d", linenum);
    else
        buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i)
        ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i)
        ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec *r, const ap_directive_t * dir,
                              int nest)
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec *r, const ap_directive_t * dir,
                               int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n",
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec *r, const ap_directive_t * dir,
    }
    else {
        ap_rprintf(r, "/%s</tt></dd>", ap_escape_html(r->pool, dirname));
    }

static int mod_info_has_cmd(const command_rec *cmds, ap_directive_t * dir)
    const command_rec *cmd;
    if (cmds == NULL)
        return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0)
            return 1;
    }
static void mod_info_show_parents(request_rec *r, ap_directive_t * node,
                                  int from, int to)
{
    if (from < to)
        mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec *r, const command_rec *cmds,
    ap_directive_t *dir;
    if (level == 0)
        ap_set_module_config(r->request_config, &info_module, NULL);
                                             shown, level + 1)) {
        }
        else if (mod_info_has_cmd(cmds, dir)) {
        }
typedef struct
{                               /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc) (void);       /* just to get the right size */
    const char *const *aszPredecessors;
    const char *const *aszSuccessors;
typedef apr_array_header_t *(
                                __stdcall
                                * hook_get_t)      (void);
typedef struct
{
static int module_find_hook(module *modp, hook_get_t hook_get)
    elts = (hook_struct_t *) hooks->elts;
    for (i = 0; i < hooks->nelts; i++) {
                               hook_lookup_t * lookup, int *comma)
    int i, comma = 0;
    for (i = 0; request_hooks[i].name; i++) {
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
        return DECLINED;
             "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n",
             r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ",
                     r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name,
                           modp->name);
            ap_rprintf(r,
                       "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                       ap_get_server_version());
            ap_rprintf(r,
                       "<dt><strong>Server Built:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                       ap_get_server_built());
            ap_rprintf(r,
                       "<dt><strong>API Version:</strong> "
                       "<tt>%d:%d</tt></dt>\n", MODULE_MAGIC_NUMBER_MAJOR,
                       MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r,
                       "<dt><strong>Hostname/port:</strong> "
                       "<tt>%s:%u</tt></dt>\n", ap_get_server_name(r),
                       ap_get_server_port(r));
            ap_rprintf(r,
                       "<dt><strong>Timeouts:</strong> "
                       "<tt>connection: %d &nbsp;&nbsp; "
                       "keep-alive: %d</tt></dt>",
                       (int) (apr_time_sec(serv->timeout)),
                       (int) (apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n",
                       ap_show_mpm());
            ap_rprintf(r,
                       "<dt><strong>MPM Information:</strong> "
                       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r,
                       "<dt><strong>Server Root:</strong> "
                       "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r,
                       "<dt><strong>Config File:</strong> "
                       "<tt>%s</tt></dt>\n", ap_conftree->filename);
            for (modp = ap_top_module; modp; modp = modp->next) {
                if (!r->args || !strcasecmp(modp->name, r->args)) {
                    ap_rprintf(r,
                               "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                               "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                               modp->name, modp->name);
                    ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                    hand = modp->handlers;
                    if (hand) {
                        while (hand) {
                            if (hand->content_type) {
                                ap_rprintf(r, " <tt>%s</tt>\n",
                                           hand->content_type);
                            }
                            else {
                                break;
                            }
                            hand++;
                            if (hand && hand->content_type) {
                                ap_rputs(",", r);
                            }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    if (module_find_hook(modp, ap_hook_get_handler)) {
                        ap_rputs("<tt> <em>yes</em></tt>", r);
                    }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    ap_rputs("</dt>", r);
                    ap_rputs
                        ("<dt><strong>Configuration Phase Participation:</strong>\n",
                         r);
                    if (modp->create_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Directory Config</tt>", r);
                        comma = 1;
                    if (modp->merge_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Directory Configs</tt>", r);
                        comma = 1;
                    if (modp->create_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Server Config</tt>", r);
                        comma = 1;
                    if (modp->merge_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Server Configs</tt>", r);
                        comma = 1;
                    if (!comma)
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    comma = 0;
                    ap_rputs("</dt>", r);

                    module_request_hook_participate(r, modp);

                    cmd = modp->cmds;
                    if (cmd) {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong></dt>",
                             r);
                        while (cmd) {
                            if (cmd->name) {
                                ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                           ap_escape_html(r->pool, cmd->name),
                                           cmd->name[0] == '<' ? "&gt;" : "");
                                if (cmd->errmsg) {
                                    ap_rputs(cmd->errmsg, r);
                                }
                                ap_rputs("</i></tt></dd>\n", r);
                            else {
                                break;
                            }
                            cmd++;
                        ap_rputs
                            ("<dt><strong>Current Configuration:</strong></dt>\n",
                             r);
                        mod_info_module_cmds(r, modp->cmds, ap_conftree, 0,
                                             0);
                    }
                    else {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>",
                             r);
                    }
                    more_info = find_more_info(serv, modp->name);
                    if (more_info) {
                        ap_rputs
                            ("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                             r);
                        ap_rputs(more_info, r);
                        ap_rputs("</dd>", r);
                    }
                    ap_rputs("</dl><hr />\n", r);
                    if (r->args) {
                        break;
            if (!modp && r->args && strcasecmp(r->args, "server")) {
                ap_rputs("<p><b>No such module</b></p>\n", r);
            }
    ap_rputs(ap_psignature("", r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy,
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
static const command_rec info_cmds[] = {
static void register_hooks(apr_pool_t * p)
module AP_MODULE_DECLARE_DATA info_module = {
 * by Alexei Kosut <akosut@apache.org>, significant overhauls and
 * redesign by William Rowe <wrowe@covalent.net>, and hints from many
 * other developer/users who have hit on specific flaws.
 * This module implements the ISAPI Handler architecture, allowing 
 * Apache to load Internet Server Applications (ISAPI extensions),
 * similar to the support in IIS, Zope, O'Reilly's WebSite and others.
 * It is a complete implementation of the ISAPI 2.0 specification, 
 * except for "Microsoft extensions" to the API which provide 
 * asynchronous I/O.  It is further extended to include additional
 * "Microsoft extentions" through IIS 5.0, with some deficiencies
 * where one-to-one mappings don't exist.
 *
 * Refer to /manual/mod/mod_isapi.html for additional details on
 * configuration and use, but check this source for specific support
 * of the API, 
#include "apr_strings.h"
#include "apr_portable.h"
#include "apr_buckets.h"
#include "apr_thread_mutex.h"
#include "apr_thread_rwlock.h"
#include "apr_hash.h"
#include "mod_isapi.h"
/* Retry frequency for a failed-to-load isapi .dll */
#define ISAPI_RETRY ( 30 * APR_USEC_PER_SEC )
apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r, 
                          const char *fpath, isapi_loaded** isa);
    isapi_loaded *isa;

    /* ### Just an observation ... it would be terribly cool to be
     * able to use this per-dir, relative to the directory block being
     * defined.  The hash result remains global, but shorthand of
     * <Directory "c:/webapps/isapi">
     *     ISAPICacheFile myapp.dll anotherapp.dll thirdapp.dll
     * </Directory>
     * would be very convienent.
     */
	             "ISAPI: invalid module path, skipping %s", filename);
	    "ISAPI: unable to stat, skipping %s", fspec);
	    "ISAPI: not a regular file, skipping %s", fspec);
    /* Load the extention as cached (with null request_rec) */
    rv = isapi_lookup(cmd->pool, cmd->server, NULL, fspec, &isa); 
                     "ISAPI: unable to cache, skipping %s", fspec);
/* Our isapi global config values */
static struct isapi_global_conf {
    apr_pool_t         *pool;
    apr_thread_mutex_t *lock;
    apr_hash_t         *hash;
} loaded;

    const char          *filename;
    apr_thread_rwlock_t *in_progress;
    apr_status_t         last_load_rv;
    apr_time_t           last_load_time;
    apr_dso_handle_t    *handle;
    HSE_VERSION_INFO    *isapi_version;
    apr_uint32_t         report_version;
#ifdef FAKE_ASYNC
    int                  fakeasync;
    apr_uint32_t         timeout;
#endif
static apr_status_t isapi_unload(isapi_loaded *isa, int force)
     * If optionally cached, and we weren't asked to force the unload,
     * pass HSE_TERM_ADVISORY_UNLOAD, and if it returns 1, unload, 
     * otherwise, leave it alone (it didn't choose to cooperate.)
    if (!isa->handle) {
    }
        if (force) {
        }
        else if (!(*isa->TerminateExtension)(HSE_TERM_ADVISORY_UNLOAD)) {
        }
static apr_status_t cleanup_isapi(void *isa_)
    isapi_loaded* isa = (isapi_loaded*) isa_;

    /* We must force the module to unload, we are about 
     * to lose the isapi structure's allocation entirely.
     */
    return isapi_unload(isa, 1);
static apr_status_t isapi_load(apr_pool_t *p, server_rec *s, request_rec *r, isapi_loaded *isa)
    isa->isapi_version = apr_pcalloc(p, sizeof(HSE_VERSION_INFO));

    /* TODO: These aught to become overrideable, so that we
     * assure a given isapi can be fooled into behaving well.
     *
     * The tricky bit, they aren't really a per-dir sort of
     * config, they will always be constant across every 
     * reference to the .dll no matter what context (vhost,
     * location, etc) they apply to.
     */
    isa->report_version = MAKELONG(0, 5); /* Revision 5.0 */
#ifdef FAKE_ASYNC
    isa->timeout = INFINITE; /* microsecs */
    isa->fakeasync = 1;
#endif
    rv = apr_dso_load(&isa->handle, isa->filename, p);
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                     "ISAPI: failed to load %s", isa->filename);
        isa->handle = NULL;
    rv = apr_dso_sym((void**)&isa->GetExtensionVersion, isa->handle,
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                     "ISAPI: missing GetExtensionVersion() in %s",
                     isa->filename);
        apr_dso_unload(isa->handle);
        isa->handle = NULL;
    rv = apr_dso_sym((void**)&isa->HttpExtensionProc, isa->handle,
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                     "ISAPI: missing HttpExtensionProc() in %s",
                     isa->filename);
        apr_dso_unload(isa->handle);
        isa->handle = NULL;
    rv = apr_dso_sym((void**)&isa->TerminateExtension, isa->handle,
    if (!(isa->GetExtensionVersion)(isa->isapi_version)) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                     "ISAPI: failed call to GetExtensionVersion() in %s", 
                     isa->filename);
        apr_dso_unload(isa->handle);
        isa->handle = NULL;
    apr_pool_cleanup_register(p, isa, cleanup_isapi, 
                              apr_pool_cleanup_null);
apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r, 
                          const char *fpath, isapi_loaded** isa)
{
    apr_status_t rv;
    const char *key;

    if ((rv = apr_thread_mutex_lock(loaded.lock)) != APR_SUCCESS) {
        return rv;
    }

    *isa = apr_hash_get(loaded.hash, fpath, APR_HASH_KEY_STRING);

    if (*isa) {

        /* If we find this lock exists, use a set-aside copy of gainlock
         * to avoid race conditions on NULLing the in_progress variable 
         * when the load has completed.  Release the global isapi hash
         * lock so other requests can proceed, then rdlock for completion
         * of loading our desired dll or wrlock if we would like to retry
         * loading the dll (because last_load_rv failed and retry is up.)
         */
        apr_thread_rwlock_t *gainlock = (*isa)->in_progress;

        /* gainlock is NULLed after the module loads successfully.
         * This free-threaded module can be used without any locking.
         */
        if (!gainlock) {
            rv = (*isa)->last_load_rv;
            apr_thread_mutex_unlock(loaded.lock);
            return rv;
        }

            
        if ((*isa)->last_load_rv == APR_SUCCESS) {
            apr_thread_mutex_unlock(loaded.lock);
            if ((rv = apr_thread_rwlock_rdlock(gainlock)) 
                    != APR_SUCCESS) {
                return rv;
            }
            rv = (*isa)->last_load_rv;
            apr_thread_rwlock_unlock(gainlock);
            return rv;
        }

        if (apr_time_now() > (*isa)->last_load_time + ISAPI_RETRY) {
        
            /* Remember last_load_time before releasing the global
             * hash lock to avoid colliding with another thread
             * that hit this exception at the same time as our
             * retry attempt, since we unlock the global mutex
             * before attempting a write lock for this module.
             */
            apr_time_t check_time = (*isa)->last_load_time;
            apr_thread_mutex_unlock(loaded.lock);

            if ((rv = apr_thread_rwlock_wrlock(gainlock)) 
                    != APR_SUCCESS) {
                return rv;
            }

            /* If last_load_time is unchanged, we still own this
             * retry, otherwise presume another thread provided 
             * our retry (for good or ill).  Relock the global
             * hash for updating last_load_ vars, so their update
             * is always atomic to the global lock.
             */
            if (check_time == (*isa)->last_load_time) {

                rv = isapi_load(loaded.pool, r->server, r, *isa);

                apr_thread_mutex_lock(loaded.lock);
                (*isa)->last_load_rv = rv;
                (*isa)->last_load_time = apr_time_now();
                apr_thread_mutex_unlock(loaded.lock);
            }
            else {
                rv = (*isa)->last_load_rv;
            }
            apr_thread_rwlock_unlock(gainlock);

            return rv;
        }

        /* We haven't hit timeup on retry, let's grab the last_rv
         * within the hash mutex before unlocking.
         */
        rv = (*isa)->last_load_rv;
        apr_thread_mutex_unlock(loaded.lock);

        return rv;
    }

    /* If the module was not found, it's time to create a hash key entry
     * before releasing the hash lock to avoid multiple threads from 
     * loading the same module.
     */
    key = apr_pstrdup(loaded.pool, fpath);
    *isa = apr_pcalloc(loaded.pool, sizeof(isapi_loaded));
    (*isa)->filename = key;
    if (r) {
        /* A mutex that exists only long enough to attempt to
         * load this isapi dll, the release this module to all
         * other takers that came along during the one-time
         * load process.  Short lifetime for this lock would
         * be great, however, using r->pool is nasty if those
         * blocked on the lock haven't all unlocked before we
         * attempt to destroy.  A nastier race condition than
         * I want to deal with at this moment...
         */
        apr_thread_rwlock_create(&(*isa)->in_progress, loaded.pool);
        apr_thread_rwlock_wrlock((*isa)->in_progress);
    }

    apr_hash_set(loaded.hash, key, APR_HASH_KEY_STRING, *isa);
    
    /* Now attempt to load the isapi on our own time, 
     * allow other isapi processing to resume.
     */
    apr_thread_mutex_unlock(loaded.lock);

    rv = isapi_load(loaded.pool, r->server, r, *isa);
    (*isa)->last_load_time = apr_time_now();
    (*isa)->last_load_rv = rv;

    if (r && (rv == APR_SUCCESS)) {
        /* Let others who are blocked on this particular
         * module resume their requests, for better or worse.
         */
        apr_thread_rwlock_t *unlock = (*isa)->in_progress;
        (*isa)->in_progress = NULL;
        apr_thread_rwlock_unlock(unlock);
    }
    else if (!r && (rv != APR_SUCCESS)) {
        /* We must leave a rwlock around for requests to retry
         * loading this dll after timeup... since we were in 
         * the setup code we had avoided creating this lock.
         */
        apr_thread_rwlock_create(&(*isa)->in_progress, loaded.pool);
    }

    return (*isa)->last_load_rv;
}

    EXTENSION_CONTROL_BLOCK *ecb;
#ifdef FAKE_ASYNC
#endif
int APR_THREAD_FUNC GetServerVariable (isapi_cid *cid, 
                                       char *lpszVariableName,
                                       void *lpvBuffer, 
                                       apr_uint32_t *lpdwSizeofBuffer)
    request_rec *r = cid->r;
    apr_uint32_t len;
            return 0;
        return 1;
            return 0;
        return 1;
            return 0;
        return 1;
    return 0;
int APR_THREAD_FUNC WriteClient(isapi_cid *ConnID, 
                                void *Buffer, 
                                apr_uint32_t *lpdwBytes, 
                                apr_uint32_t dwReserved)
    return 1;
int APR_THREAD_FUNC ReadClient(isapi_cid *ConnID, 
                               void *lpvBuffer, 
                               apr_uint32_t *lpdwSize)
    apr_uint32_t read = 0;
    return 1;
/* Common code invoked for both HSE_REQ_SEND_RESPONSE_HEADER and 
 * the newer HSE_REQ_SEND_RESPONSE_HEADER_EX ServerSupportFunction(s)
 */
static apr_ssize_t send_response_header(isapi_cid *cid, 
                                        const char *stat,
                                        const char *head, 
                                        apr_size_t statlen,
    /* Seems IIS does not enforce the requirement for \r\n termination 
     * on HSE_REQ_SEND_RESPONSE_HEADER, but we won't panic... 
     * ap_scan_script_header_err_strs handles this aspect for us.
     *
     * Parse them out, or die trying 
     */
int APR_THREAD_FUNC ServerSupportFunction(isapi_cid   *cid, 
                                          apr_uint32_t dwHSERequest,
                                          void        *lpvBuffer, 
                                          apr_uint32_t *lpdwSize,
                                          apr_uint32_t *lpdwDataType)
        return 1;
    case HSE_REQ_SEND_URL:
        return 1;
    case HSE_REQ_SEND_RESPONSE_HEADER:
            return 0;
        return 1;
    case HSE_REQ_DONE_WITH_SESSION:
#ifdef FAKE_ASYNC
            SetEvent(cid->complete);
#endif
        return 1;
    case HSE_REQ_MAP_URL_TO_PATH:
        apr_uint32_t len;
        return 1;
    case HSE_REQ_GET_SSPI_INFO:
        return 0;
    case HSE_APPEND_LOG_PARAMETER:
        return 1;
    case HSE_REQ_IO_COMPLETION:
#ifdef FAKE_ASYNC
        if (cid->isa->fakeasync) {
            cid->completion = (PFN_HSE_IO_COMPLETION) lpvBuffer;
            cid->completion_arg = (PVOID) lpdwDataType;
            return 1;
#endif
        if (cid->dconf.log_unsupported)
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
                      "ISAPI: ServerSupportFunction HSE_REQ_IO_COMPLETION "
                      "is not supported: %s", r->filename);
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    case HSE_REQ_TRANSMIT_FILE:
#ifdef FAKE_ASYNC
        if ((tf->dwFlags & HSE_IO_ASYNC) && cid->isa->fakeasync) {
            /* TBD */
        }
        else /* if (!cid->isa->fakeasync && ... */
#endif
        if (tf->dwFlags & HSE_IO_ASYNC)
        {
            return 0;
            return 0;
                return 0;
#ifdef FAKE_ASYNC
#endif
        return 1;
    case HSE_REQ_REFRESH_ISAPI_ACL:
        return 0;
    case HSE_REQ_IS_KEEP_CONN:
        *((int *)lpvBuffer) = (r->connection->keepalive == 1);
        return 1;
    case HSE_REQ_ASYNC_READ_CLIENT:
#ifdef FAKE_ASYNC
        /* TBD: Fake it */
#else
        return 0;
#endif
    case HSE_REQ_GET_IMPERSONATION_TOKEN:  /* Added in ISAPI 4.0 */
        return 0;
    case HSE_REQ_MAP_URL_TO_PATH_EX:
        HSE_URL_MAPEX_INFO *info = (HSE_URL_MAPEX_INFO*)lpdwDataType;
                                      sizeof(info->lpszPath)) - info->lpszPath;
        return 1;
    case HSE_REQ_ABORTIVE_CLOSE:
        return 0;
    case HSE_REQ_GET_CERT_INFO_EX:  /* Added in ISAPI 4.0 */
        return 0;
    case HSE_REQ_SEND_RESPONSE_HEADER_EX:  /* Added in ISAPI 4.0 */
        HSE_SEND_HEADER_EX_INFO *shi = (HSE_SEND_HEADER_EX_INFO*)lpvBuffer;

    /*  XXX: ignore shi->fKeepConn?  We shouldn't need the advise
     *  r->connection->keepalive = shi->fKeepConn; 
     */
            return 0;
        return 1;
    case HSE_REQ_CLOSE_CONNECTION:  /* Added after ISAPI 4.0 */
        return 0;
    case HSE_REQ_IS_CONNECTED:  /* Added after ISAPI 4.0 */
        *((int *)lpvBuffer) = (r->connection->aborted == 0);
        return 1;
    case HSE_REQ_EXTENSION_TRIGGER:  /* Added after ISAPI 4.0 */
        return 0;
        return 0;
    apr_uint32_t read;
    if(strcmp(r->handler, "isapi-isa") 
        && strcmp(r->handler, "isapi-handler")) {
        /* Hang on to the isapi-isa for compatibility with older docs
         * (wtf did '-isa' mean in the first place?) but introduce
         * a newer and clearer "isapi-handler" name.
         */
    }
    if (!(ap_allow_options(r) & OPT_EXECCGI)) {
    }
    if (r->finfo.filetype == APR_NOFILE) {
    }
    if (r->finfo.filetype != APR_REG) {
    }
        r->path_info && *r->path_info) {
    if (isapi_lookup(r->pool, r->server, r, r->filename, &isa) 
           != APR_SUCCESS) {
    }
    
    cid->ecb = apr_pcalloc(r->pool, sizeof(EXTENSION_CONTROL_BLOCK));
    cid->ecb->ConnID = cid;
#ifdef FAKE_ASYNC
#endif
        isapi_unload(isa, 0);
            if (cid->ecb->cbTotalBytes > (apr_uint32_t)cid->dconf.read_ahead_buflen)
            isapi_unload(isa, 0);
             * the ISAPI Handler's "advice".
        case HSE_STATUS_PENDING:
#ifdef FAKE_ASYNC
             *
             * This request completes upon a notification through
             * ServerSupportFunction(HSE_REQ_DONE_WITH_SESSION)
            if (isa->fakeasync) 
            {
                cid->complete = CreateEvent(NULL, 0, 0, NULL);
                break;
            }
#endif
            if (cid->dconf.log_unsupported)
            {
                 ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
                               "ISAPI: asynch I/O result HSE_STATUS_PENDING "
                               "from HttpExtensionProc() is not supported: %s",
                               r->filename);
                 cid->r->status = HTTP_INTERNAL_SERVER_ERROR;
    apr_status_t rv;

    loaded.hash = apr_hash_make(loaded.pool);
    if (!loaded.hash) {
        ap_log_error(APLOG_MARK, APLOG_NOERRNO, 0, NULL,
                     "ISAPI: Failed to create module cache");
    rv = apr_thread_mutex_create(&loaded.lock, APR_THREAD_MUTEX_DEFAULT, 
                                 loaded.pool);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, rv, 0, NULL,
                     "ISAPI: Failed to create module cache lock");
        return rv;
    }
    client_list = NULL;

/**
 * Unescape a string
 * @param url The string to unescape
 * @return 0 on success, non-zero otherwise
 */
AP_DECLARE(int) ap_unescape_all(char *url);

/**
 * Escape a path segment, as defined in RFC 1808, to a preallocated buffer.
 * @param c The preallocated buffer to write to
 * @param s The path to convert
 * @return The converted URL (c)
 */
AP_DECLARE(char *) ap_escape_path_segment_b(char *c, const char *s);

/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define CORE_PRIVATE

#include "mod_session.h"
#include "apr_lib.h"
#include "apr_strings.h"
#include "util_filter.h"
#include "http_log.h"
#include "http_request.h"
#include "http_protocol.h"

#define SESSION_PREFIX "mod_session: "
#define SESSION_EXPIRY "expiry"
#define HTTP_SESSION "HTTP_SESSION"

APR_HOOK_STRUCT(
                APR_HOOK_LINK(session_load)
                APR_HOOK_LINK(session_save)
                APR_HOOK_LINK(session_encode)
                APR_HOOK_LINK(session_decode)
)
AP_IMPLEMENT_HOOK_RUN_FIRST(int, session_load,
                      (request_rec * r, session_rec ** z), (r, z), DECLINED)
AP_IMPLEMENT_HOOK_RUN_FIRST(int, session_save,
                       (request_rec * r, session_rec * z), (r, z), DECLINED)
AP_IMPLEMENT_HOOK_RUN_ALL(int, session_encode,
                   (request_rec * r, session_rec * z), (r, z), OK, DECLINED)
AP_IMPLEMENT_HOOK_RUN_ALL(int, session_decode,
                   (request_rec * r, session_rec * z), (r, z), OK, DECLINED)
/**
 * Should the session be included within this URL.
 *
 * This function tests whether a session is valid for this URL. It uses the
 * include and exclude arrays to determine whether they should be included.
 */
    static int session_included(request_rec * r, session_dir_conf * conf)
{

    const char **includes = (const char **) conf->includes->elts;
    const char **excludes = (const char **) conf->excludes->elts;
    int included = 1;                /* defaults to included */
    int i;

    if (conf->includes->nelts) {
        included = 0;
        for (i = 0; !included && i < conf->includes->nelts; i++) {
            const char *include = includes[i];
            if (strncmp(r->parsed_uri.path, include, strlen(include))) {
                included = 1;
            }
        }
    }

    if (conf->excludes->nelts) {
        for (i = 0; included && i < conf->includes->nelts; i++) {
            const char *exclude = excludes[i];
            if (strncmp(r->parsed_uri.path, exclude, strlen(exclude))) {
                included = 0;
            }
        }
    }

    return included;
}

/**
 * Get a particular value from the session.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to get.
 * @param value The buffer to write the value to.
 */
AP_DECLARE(void) ap_session_get(request_rec * r, session_rec * z, const char *key, const char **value)
{
    if (!z) {
        ap_session_load(r, &z);
    }
    *value = apr_table_get(z->entries, key);
}

/**
 * Set a particular value to the session.
 *
 * Using this method ensures that the dirty flag is set correctly, so that
 * the session can be saved efficiently.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to set. The existing key value will be replaced.
 * @param value The value to set.
 */
AP_DECLARE(void) ap_session_set(request_rec * r, session_rec * z,
                                const char *key, const char *value)
{
    if (!z) {
        ap_session_load(r, &z);
    }
    if (value) {
        apr_table_set(z->entries, key, value);
    }
    else {
        apr_table_unset(z->entries, key);
    }
    z->dirty = 1;
}

/**
 * Load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_load(request_rec * r, session_rec ** z)
{

    session_dir_conf *dconf = ap_get_module_config(r->per_dir_config,
                                                   &session_module);
    apr_time_t now;
    session_rec *zz = NULL;

    /* is the session enabled? */
    if (!dconf->enabled) {
        return APR_SUCCESS;
    }

    /* should the session be loaded at all? */
    if (!session_included(r, dconf)) {
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, SESSION_PREFIX
                      "excluded by configuration for: %s", r->uri);
        return APR_SUCCESS;
    }

    /* load the session from the session hook */
    int rv = ap_run_session_load(r, &zz);
    if (DECLINED == rv) {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                      "session is enabled but no session modules have been configured, "
                      "session not loaded: %s", r->uri);
        return APR_EGENERAL;
    }
    else if (OK != rv) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                      "error while loading the session, "
                      "session not loaded: %s", r->uri);
        return rv;
    }

    /* found a session that hasn't expired? */
    now = apr_time_now();
    if (!zz || (zz->expiry && zz->expiry < now)) {

        /* no luck, create a blank session */
        zz = (session_rec *) apr_pcalloc(r->pool, sizeof(session_rec));
        zz->pool = r->pool;
        zz->entries = apr_table_make(zz->pool, 10);
        zz->uuid = (apr_uuid_t *) apr_pcalloc(zz->pool, sizeof(apr_uuid_t));
        apr_uuid_get(zz->uuid);

    }
    else {
        rv = ap_run_session_decode(r, zz);
        if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while decoding the session, "
                          "session not loaded: %s", r->uri);
            return rv;
        }
    }

    /* make sure the expiry is set, if present */
    if (!zz->expiry && dconf->maxage) {
        zz->expiry = now + dconf->maxage * APR_USEC_PER_SEC;
        zz->maxage = dconf->maxage;
    }

    *z = zz;

    return APR_SUCCESS;

}

/**
 * Save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_save(request_rec * r, session_rec * z)
{
    if (z) {
        apr_time_t now = apr_time_now();
        int rv = 0;

        /* sanity checks, should we try save at all? */
        if (z->written) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, SESSION_PREFIX
                          "attempt made to save the session twice, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }
        if (z->expiry && z->expiry < now) {
            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                          "attempt made to save a session when the session had already expired, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }

        /* encode the session */
        rv = ap_run_session_encode(r, z);
        if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while encoding the session, "
                          "session not saved: %s", r->uri);
            return rv;
        }

        /* try the save */
        rv = ap_run_session_save(r, z);
        if (DECLINED == rv) {
            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                          "session is enabled but no session modules have been configured, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }
        else if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while saving the session, "
                          "session not saved: %s", r->uri);
            return rv;
        }
        else {
            z->written = 1;
        }
    }

    return APR_SUCCESS;

}

static int identity_count(int *count, const char *key, const char *val)
{
    *count += strlen(key) * 3 + strlen(val) * 3 + 1;
    return 1;
}

static int identity_concat(char *buffer, const char *key, const char *val)
{
    char *slider = buffer;
    int length = strlen(slider);
    slider += length;
    if (length) {
        *slider = '&';
        slider++;
    }
    ap_escape_path_segment_b(slider, key);
    slider += strlen(slider);
    *slider = '=';
    slider++;
    ap_escape_path_segment_b(slider, val);
    return 1;
}

/**
 * Default identity encoding for the session.
 *
 * By default, the name value pairs in the session are URLEncoded, separated
 * by equals, and then in turn separated by ampersand, in the format of an
 * html form.
 *
 * This was chosen to make it easy for external code to unpack a session,
 * should there be a need to do so.
 *
 * @param r The request pointer.
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_identity_encode(request_rec * r, session_rec * z)
{

    char *buffer = NULL;
    int length = 0;
    if (z->expiry) {
        char *expiry = apr_psprintf(r->pool, "%" APR_INT64_T_FMT, z->expiry);
        apr_table_set(z->entries, SESSION_EXPIRY, expiry);
    }
    apr_table_do((int (*) (void *, const char *, const char *))
                 identity_count, &length, z->entries, NULL);;
    buffer = apr_pcalloc(r->pool, length + 1);
    apr_table_do((int (*) (void *, const char *, const char *))
                 identity_concat, buffer, z->entries, NULL);
    z->encoded = buffer;
    return OK;

}

/**
 * Default identity decoding for the session.
 *
 * By default, the name value pairs in the session are URLEncoded, separated
 * by equals, and then in turn separated by ampersand, in the format of an
 * html form.
 *
 * This was chosen to make it easy for external code to unpack a session,
 * should there be a need to do so.
 *
 * This function reverses that process, and populates the session table.
 *
 * Name / value pairs that are not encoded properly are ignored.
 *
 * @param r The request pointer.
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_identity_decode(request_rec * r, session_rec * z)
{

    char *last = NULL;
    char *encoded, *pair;
    const char *sep = "&";

    /* sanity check - anything to decode? */
    if (!z->encoded) {
        return OK;
    }

    /* decode what we have */
    encoded = apr_pstrcat(r->pool, z->encoded, NULL);
    pair = apr_strtok(encoded, sep, &last);
    while (pair && pair[0]) {
        char *plast = NULL;
        const char *psep = "=";
        char *key = apr_strtok(pair, psep, &plast);
        char *val = apr_strtok(NULL, psep, &plast);
        if (key && *key) {
            if (!val || !*val) {
                apr_table_unset(z->entries, key);
            }
            if (!ap_unescape_all(key) && !ap_unescape_all(val)) {
                if (!strcmp(SESSION_EXPIRY, key)) {
                    z->expiry = (apr_time_t) apr_atoi64(val);
                }
                else {
                    apr_table_set(z->entries, key, val);
                }
            }
        }
        pair = apr_strtok(NULL, sep, &last);
    }
    z->encoded = NULL;
    return OK;

}

/**
 * Ensure any changes to the session are committed.
 *
 * This is done in an output filter so that our options for where to
 * store the session can include storing the session within a cookie:
 * As an HTTP header, the cookie must be set before the output is
 * written, but after the handler is run.
 *
 * NOTE: It is possible for internal redirects to cause more than one
 * request to be present, and each request might have a session
 * defined. We need to go through each session in turn, and save each
 * one.
 * 
 * The same session might appear in more than one request. The first
 * attempt to save the session will be called
 */
static apr_status_t ap_session_output_filter(ap_filter_t * f,
                                                    apr_bucket_brigade * in)
{

    /* save all the sessions in all the requests */
    request_rec *r = f->r->main;
    if (!r) {
        r = f->r;
    }
    while (r) {
        session_rec *z = NULL;
        session_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_module);

        /* load the session, or create one if necessary */
        ap_session_load(r, &z);
        if (!z || z->written) {
            r = r->next;
            continue;
        }

        /* if a header was specified, insert the new values from the header */
        if (conf->header_set) {
            const char *override = apr_table_get(r->err_headers_out, conf->header);
            if (!override) {
                override = apr_table_get(r->headers_out, conf->header);
            }
            if (override) {
                z->encoded = override;
                ap_session_identity_decode(r, z);
            }
        }

        /* save away the session, and we're done */
        ap_session_save(r, z);

        r = r->next;
    }

    /* remove ourselves from the filter chain */
    ap_remove_output_filter(f);

    /* send the data up the stack */
    return ap_pass_brigade(f->next, in);

}

/**
 * Insert the output filter.
 */
static void ap_session_insert_output_filter(request_rec * r)
{
    ap_add_output_filter("MOD_SESSION_OUT", NULL, r, r->connection);
}

/**
 * Fixups hook.
 *
 * Load the session within a fixup - this ensures that the session is
 * properly loaded prior to the handler being called.
 * 
 * The fixup is also responsible for injecting the session into the CGI
 * environment, should the admin have configured it so.
 * 
 * @param r The request
 */
AP_DECLARE(int) ap_session_fixups(request_rec * r)
{
    session_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                  &session_module);

    session_rec *z = NULL;
    ap_session_load(r, &z);

    if (conf->env) {
        ap_session_identity_encode(r, z);
        if (z->encoded) {
            apr_table_set(r->subprocess_env, HTTP_SESSION, z->encoded);
            z->encoded = NULL;
        }
    }

    return OK;

}


static void *create_session_dir_config(apr_pool_t * p, char *dummy)
{
    session_dir_conf *new =
    (session_dir_conf *) apr_pcalloc(p, sizeof(session_dir_conf));

    new->includes = apr_array_make(p, 10, sizeof(const char **));
    new->excludes = apr_array_make(p, 10, sizeof(const char **));

    return (void *) new;
}

static void *merge_session_dir_config(apr_pool_t * p, void *basev, void *addv)
{
    session_dir_conf *new = (session_dir_conf *) apr_pcalloc(p, sizeof(session_dir_conf));
    session_dir_conf *add = (session_dir_conf *) addv;
    session_dir_conf *base = (session_dir_conf *) basev;

    new->enabled = (add->enabled_set == 0) ? base->enabled : add->enabled;
    new->enabled_set = add->enabled_set || base->enabled_set;
    new->maxage = (add->maxage_set == 0) ? base->maxage : add->maxage;
    new->maxage_set = add->maxage_set || base->maxage_set;
    new->header = (add->header_set == 0) ? base->header : add->header;
    new->header_set = add->header_set || base->header_set;
    new->env = (add->env_set == 0) ? base->env : add->env;
    new->env_set = add->env_set || base->env_set;
    new->includes = apr_array_append(p, base->includes, add->includes);
    new->excludes = apr_array_append(p, base->excludes, add->excludes);

    return new;
}


static const char *
     set_session_enable(cmd_parms * parms, void *dconf, int flag)
{
    session_dir_conf *conf = dconf;

    conf->enabled = flag;
    conf->enabled_set = 1;

    return NULL;
}

static const char *
     set_session_maxage(cmd_parms * parms, void *dconf, const char *arg)
{
    session_dir_conf *conf = dconf;

    conf->maxage = atol(arg);
    conf->maxage_set = 1;

    return NULL;
}

static const char *
     set_session_header(cmd_parms * parms, void *dconf, const char *arg)
{
    session_dir_conf *conf = dconf;

    conf->header = arg;
    conf->header_set = 1;

    return NULL;
}

static const char *
     set_session_env(cmd_parms * parms, void *dconf, int flag)
{
    session_dir_conf *conf = dconf;

    conf->env = flag;
    conf->env_set = 1;

    return NULL;
}

static const char *add_session_include(cmd_parms * cmd, void *dconf, const char *f)
{
    session_dir_conf *conf = dconf;

    const char **new = apr_array_push(conf->includes);
    *new = f;

    return NULL;
}

static const char *add_session_exclude(cmd_parms * cmd, void *dconf, const char *f)
{
    session_dir_conf *conf = dconf;

    const char **new = apr_array_push(conf->excludes);
    *new = f;

    return NULL;
}


static const command_rec session_cmds[] =
{
    AP_INIT_FLAG("Session", set_session_enable, NULL, OR_AUTHCFG,
                 "on if a session should be maintained for these URLs"),
    AP_INIT_TAKE1("SessionMaxAge", set_session_maxage, NULL, OR_AUTHCFG,
                  "length of time for which a session should be valid. Zero to disable"),
    AP_INIT_TAKE1("SessionHeader", set_session_header, NULL, OR_AUTHCFG,
                  "output header, if present, whose contents will be injected into the session."),
    AP_INIT_FLAG("SessionEnv", set_session_env, NULL, OR_AUTHCFG,
                 "on if a session should be written to the CGI environment. Defaults to off"),
    AP_INIT_TAKE1("SessionInclude", add_session_include, NULL, OR_AUTHCFG,
                  "URL prefixes to include in the session. Defaults to all URLs"),
    AP_INIT_TAKE1("SessionExclude", add_session_exclude, NULL, OR_AUTHCFG,
                  "URL prefixes to exclude from the session. Defaults to no URLs"),
    {NULL}
};

static void register_hooks(apr_pool_t * p)
{
    ap_register_output_filter("MOD_SESSION_OUT", ap_session_output_filter,
                              NULL, AP_FTYPE_CONTENT_SET);
    ap_hook_insert_filter(ap_session_insert_output_filter, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_insert_error_filter(ap_session_insert_output_filter,
                                NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_fixups(ap_session_fixups, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_session_encode(ap_session_identity_encode, NULL, NULL, APR_HOOK_REALLY_FIRST);
    ap_hook_session_decode(ap_session_identity_decode, NULL, NULL, APR_HOOK_REALLY_LAST);
    APR_REGISTER_OPTIONAL_FN(ap_session_get);
    APR_REGISTER_OPTIONAL_FN(ap_session_set);
    APR_REGISTER_OPTIONAL_FN(ap_session_load);
    APR_REGISTER_OPTIONAL_FN(ap_session_save);
}

module AP_MODULE_DECLARE_DATA session_module =
{
    STANDARD20_MODULE_STUFF,
    create_session_dir_config,   /* dir config creater */
    merge_session_dir_config,    /* dir merger --- default is to override */
    NULL,                        /* server config */
    NULL,                        /* merge server config */
    session_cmds,                /* command apr_table_t */
    register_hooks               /* register hooks */
};
/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef MOD_SESSION_H
#define MOD_SESSION_H

/**
 * @file  mod_session.h
 * @brief Session Module for Apache
 *
 * @defgroup MOD_SESSION mod_session
 * @ingroup  APACHE_MODS
 * @{
 */

#define CORE_PRIVATE

#include "apr_hooks.h"
#include "apr_optional.h"
#include "apr_tables.h"
#include "apr_uuid.h"
#include "apr_pools.h"
#include "apr_time.h"

#include "httpd.h"
#include "http_config.h"
#include "ap_config.h"

#define MOD_SESSION_NOTES_KEY "mod_session_key"

/**
 * Define the name of a username stored in the session, so that modules interested
 * in the username can find it in a standard place.
 */
#define MOD_SESSION_USER "user"

/**
 * Define the name of a password stored in the session, so that modules interested
 * in the password can find it in a standard place.
 */
#define MOD_SESSION_PW "pw"

/**
 * A session structure.
 *
 * At the core of the session is a set of name value pairs making up the
 * session.
 *
 * The session might be uniquely identified by an anonymous uuid, or
 * a remote_user value, or both.
 */
typedef struct {
    apr_pool_t *pool;             /* pool to be used for this session */
    apr_uuid_t *uuid;             /* anonymous uuid of this particular session */
    const char *remote_user;      /* user who owns this particular session */
    apr_table_t *entries;         /* key value pairs */
    const char *encoded;          /* the encoded version of the key value pairs */
    apr_time_t expiry;            /* if > 0, the time of expiry of this session */
    long maxage;                  /* if > 0, the maxage of the session, from
                                   * which expiry is calculated */
    int dirty;                    /* dirty flag */
    int cached;                   /* true if this session was loaded from a
                                   * cache of some kind */
    int written;                  /* true if this session has already been
                                   * written */
} session_rec;

/**
 * Structure to carry the per-dir session config.
 */
typedef struct {
    int enabled;                  /* whether the session has been enabled for
                                   * this directory */
    int enabled_set;
    long maxage;                  /* seconds until session expiry */
    int maxage_set;
    const char *header;           /* header to inject session */
    int header_set;
    int env;                      /* whether the session has been enabled for
                                   * this directory */
    int env_set;
    apr_array_header_t *includes; /* URL prefixes to be included. All
                                   * URLs included if empty */
    apr_array_header_t *excludes; /* URL prefixes to be excluded. No
                                   * URLs excluded if empty */
} session_dir_conf;

/**
 * Get a particular value from the session.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to get.
 * @param value The buffer to write the value to.
 */
AP_DECLARE(void) ap_session_get(request_rec * r, session_rec * z, const char *key, const char **value);

/**
 * Set a particular value to the session.
 *
 * Using this method ensures that the dirty flag is set correctly, so that
 * the session can be saved efficiently.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to set. The existing key value will be replaced.
 * @param value The value to set.
 */
AP_DECLARE(void) ap_session_set(request_rec * r, session_rec * z,
                                const char *key, const char *value);

/**
 * Load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_load(request_rec * r, session_rec ** z);

/**
 * Hook to load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_load, (request_rec * r, session_rec ** z))

/**
 * Save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_save(request_rec * r, session_rec * z);

/**
 * Hook to save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_save, (request_rec * r, session_rec * z))

/**
 * Hook to encode the session.
 *
 * In the default implementation, the key value pairs are encoded using
 * key value pairs separated by equals, in turn separated by ampersand,
 * like a web form.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_encode, (request_rec * r, session_rec * z))

/**
 * Hook to decode the session.
 *
 * In the default implementation, the key value pairs are encoded using
 * key value pairs separated by equals, in turn separated by ampersand,
 * like a web form.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_decode, (request_rec * r, session_rec * z))

APR_DECLARE_OPTIONAL_FN(void, ap_session_get, (request_rec * r, session_rec * z,
                                               const char *key, const char **value));
APR_DECLARE_OPTIONAL_FN(void, ap_session_set, (request_rec * r, session_rec * z,
                                               const char *key, const char *value));
APR_DECLARE_OPTIONAL_FN(int, ap_session_load, (request_rec *, session_rec **));
APR_DECLARE_OPTIONAL_FN(int, ap_session_save, (request_rec *, session_rec *));

/**
 * The name of the module.
 */
extern module AP_MODULE_DECLARE_DATA session_module;

#endif /* MOD_SESSION_H */
/** @} */
AP_DECLARE(int) ap_unescape_all(char *url)
{
    return unescape_url(url, NULL, NULL);
}

AP_DECLARE(char *) ap_escape_path_segment_b(char *copy, const char *segment)
AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char *segment)
{
    return ap_escape_path_segment_b(apr_palloc(p, 3 * strlen(segment) + 1), segment);
}

module AP_MODULE_DECLARE_DATA imagemap_module;
    icr = ap_get_module_config(r->per_dir_config, &imagemap_module);
module AP_MODULE_DECLARE_DATA imagemap_module =
                mime_info.file_name = rr->filename;
    if (strcmp(r->unparsed_uri, "*") == 0) {
        /* Don't apply rewrite rules to "*". */
        return DECLINED;
    }

    /* Check that the URI is valid. */
    if (!r->uri || r->uri[0] != '/') {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "Invalid URI in request %s", r->the_request);
        return HTTP_BAD_REQUEST;
    }
    
    if (strcmp(r->unparsed_uri, "*") == 0) {
        /* "*" cannot be proxied. */
        return DECLINED;
    }

    /* Check that the URI is valid. */
    if (!r->uri || r->uri[0] != '/') {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "Invalid URI in request %s", r->the_request);
        return HTTP_BAD_REQUEST;
    }

    /* XXX: Should replace SSL_set_state with SSL_renegotiate(ssl);
     * However, this causes failures in perl-framework currently, 
     * perhaps pre-test if we have already negotiated?
     */
    SSL_set_state(ssl, SSL_ST_ACCEPT);
            /* XXX: Should replace SSL_set_state with SSL_renegotiate(ssl);
             * However, this causes failures in perl-framework currently, 
             * perhaps pre-test if we have already negotiated?
             */
            SSL_set_state(ssl, SSL_ST_ACCEPT);
#define SSL_set_state(ssl,val) (ssl)->state = val

#ifndef HAVE_SSL_SET_STATE
#define SSL_set_state(ssl, state) /* XXX: should throw an error */
#endif

        unsigned skip;
        else if ((skip = is_absolute_uri(r->filename)) > 0) {
            if (rulestatus != ACTION_NOESCAPE) {
                rewritelog(r, 1, "escaping %s for redirect", r->filename);
                r->filename = escape_absolute_uri(r->pool, r->filename, skip);
            if (r->args) {
                                          (rulestatus == ACTION_NOESCAPE)
                                            ? r->args
                                            : ap_escape_uri(r->pool, r->args),
                                          NULL);
        unsigned skip;
        else if ((skip = is_absolute_uri(r->filename)) > 0) {
                /* skip 'scheme://' */
                cp = r->filename + skip;

            if (rulestatus != ACTION_NOESCAPE) {
                rewritelog(r, 1, "[per-dir %s] escaping %s for redirect",
                           dconf->directory, r->filename);
                r->filename = escape_absolute_uri(r->pool, r->filename, skip);
            if (r->args) {
                                          (rulestatus == ACTION_NOESCAPE)
                                            ? r->args
                                            : ap_escape_uri(r->pool, r->args),
                                          NULL);
    /* don't touch, unless it's an http or mailto URL.
     * See RFC 1738 and RFC 2368.
     */
    if (   is_absolute_uri(r->filename)
        && strncasecmp(r->filename, "http", 4)
        && strncasecmp(r->filename, "mailto", 6)) {
        r->args = NULL; /* forget the query that's still flying around */
        return;
    }


/* return number of chars of the scheme (incl. '://')
 * if the URI is absolute (includes a scheme etc.)
 * otherwise 0.
 *
 * NOTE: If you add new schemes here, please have a
 *       look at escape_absolute_uri and splitout_queryargs.
 *       Not every scheme takes query strings and some schemes
 *       may be handled in a special way.
 *
 * XXX: we should consider a scheme registry, perhaps with
 *      appropriate escape callbacks to allow other modules
 *      to extend mod_rewrite at runtime.
 */
static unsigned is_absolute_uri(char *uri)
{
    /* fast exit */
    if (*uri == '/' || strlen(uri) <= 5) {
        return 0;
    }

    switch (*uri++) {
    case 'f':
    case 'F':
        if (!strncasecmp(uri, "tp://", 5)) {        /* ftp://    */
            return 6;
        }
        break;
    case 'g':
    case 'G':
        if (!strncasecmp(uri, "opher://", 8)) {     /* gopher:// */
            return 9;
        }
        break;

    case 'h':
    case 'H':
        if (!strncasecmp(uri, "ttp://", 6)) {       /* http://   */
            return 7;
        }
        else if (!strncasecmp(uri, "ttps://", 7)) { /* https://  */
            return 8;
        }
        break;

    case 'l':
    case 'L':
        if (!strncasecmp(uri, "dap://", 6)) {       /* ldap://   */
            return 7;
        }
        break;

    case 'm':
    case 'M':
        if (!strncasecmp(uri, "ailto:", 6)) {       /* mailto:   */
            return 7;
        }
        break;

    case 'n':
    case 'N':
        if (!strncasecmp(uri, "ews:", 4)) {         /* news:     */
            return 5;
        }
        else if (!strncasecmp(uri, "ntp://", 6)) {  /* nntp://   */
            return 7;
        }
        break;
    }

    return 0;
}


/* escape absolute uri, which may or may not be path oriented.
 * So let's handle them differently.
 */
static char *escape_absolute_uri(apr_pool_t *p, char *uri, unsigned scheme)
    char *cp;

    /* be safe.
     * NULL should indicate elsewhere, that something's wrong
     */
    if (!scheme || strlen(uri) < scheme) {
        return NULL;

    cp = uri + scheme;

    /* scheme with authority part? */
    if (cp[-1] == '/') {
        /* skip host part */
        while (*cp && *cp != '/') {
            ++cp;
        }

        /* nothing after the hostpart. ready! */
        if (!*cp || !*++cp) {
            return apr_pstrdup(p, uri);
        }

        /* remember the hostname stuff */
        scheme = cp - uri;

        /* special thing for ldap.
         * The parts are separated by question marks. From RFC 2255:
         *     ldapurl = scheme "://" [hostport] ["/"
         *               [dn ["?" [attributes] ["?" [scope]
         *               ["?" [filter] ["?" extensions]]]]]]
         */
        if (!strncasecmp(uri, "ldap", 4)) {
            char *token[5];
            int c = 0;

            token[0] = cp = apr_pstrdup(p, cp);
            while (*cp && c < 5) {
                if (*cp == '?') {
                    token[++c] = cp + 1;
                    *cp = '\0';
                }
                ++cp;
            }

            return apr_pstrcat(p, apr_pstrndup(p, uri, scheme),
                                          ap_escape_uri(p, token[0]),
                               (c >= 1) ? "?" : NULL,
                               (c >= 1) ? ap_escape_uri(p, token[1]) : NULL,
                               (c >= 2) ? "?" : NULL,
                               (c >= 2) ? ap_escape_uri(p, token[2]) : NULL,
                               (c >= 3) ? "?" : NULL,
                               (c >= 3) ? ap_escape_uri(p, token[3]) : NULL,
                               (c >= 4) ? "?" : NULL,
                               (c >= 4) ? ap_escape_uri(p, token[4]) : NULL,
                               NULL);
        }

    /* Nothing special here. Apply normal escaping. */
    return apr_pstrcat(p, apr_pstrndup(p, uri, scheme),
                       ap_escape_uri(p, cp), NULL);
static unsigned is_absolute_uri(char *uri);
static char *escape_absolute_uri(apr_pool_t *p, char *uri, unsigned scheme);
/* NOTE: these check the shared status */
#define PROXY_WORKER_IS_INITIALIZED(f)   ( (f)->s && \
  ( (f)->s->status &  PROXY_WORKER_INITIALIZED ) )
#define PROXY_WORKER_IS_STANDBY(f)   ( (f)->s && \
  ( (f)->s->status &  PROXY_WORKER_HOT_STANDBY ) )
#define PROXY_WORKER_IS_USABLE(f)   ( (f)->s && \
  ( !( (f)->s->status & PROXY_WORKER_NOT_USABLE_BITMAP) ) && \
  PROXY_WORKER_IS_INITIALIZED(f) )
    char *tmp_field;
                tmp_field = value;  /*Used to trim the whitespace between key */
                ++value;            /*     token and seperator*/
                /* This check is to avoid any invalid memory reference while
                 *   traversing backwards in the key. To avoid a case where
                 *   the header starts with ':' (or with just some white
                 *   space and the ':') followed by the value
		         */
                if(tmp_field > last_field) {
                    --tmp_field;
                    while ((tmp_field > last_field) &&
                           (*tmp_field == ' ' || *tmp_field == '\t')) {
                        --tmp_field;   /* Removing LWS between key and ':' */
                    }
                    ++tmp_field;
                    *tmp_field = '\0';
                }

/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define CORE_PRIVATE

#include "mod_session.h"
#include "apr_lib.h"
#include "apr_strings.h"
#include "http_log.h"
#include "util_cookies.h"
#include "apr_dbd.h"
#include "mod_dbd.h"
#include "mpm_common.h"

#define LOG_PREFIX "mod_session_dbd: "
#define MOD_SESSION_DBD "mod_session_dbd"

module AP_MODULE_DECLARE_DATA session_dbd_module;

/**
 * Structure to carry the per-dir session config.
 */
typedef struct {
    const char *name;
    int name_set;
    const char *name_attrs;
    const char *name2;
    int name2_set;
    const char *name2_attrs;
    int peruser;
    int peruser_set;
    int remove;
    int remove_set;
    const char *selectlabel;
    const char *insertlabel;
    const char *updatelabel;
    const char *deletelabel;
} session_dbd_dir_conf;

/* optional function - look it up once in post_config */
static ap_dbd_t *(*session_dbd_acquire_fn) (request_rec *) = NULL;
static void (*session_dbd_prepare_fn) (server_rec *, const char *, const char *) = NULL;

/**
 * Initialise the database.
 * 
 * If the mod_dbd module is missing, this method will return APR_EGENERAL.
 */
static apr_status_t dbd_init(request_rec *r, const char *query, ap_dbd_t **dbdp,
                             apr_dbd_prepared_t **statementp)
{
    ap_dbd_t *dbd;
    apr_dbd_prepared_t *statement;

    if (!session_dbd_prepare_fn || !session_dbd_acquire_fn) {
        session_dbd_prepare_fn = APR_RETRIEVE_OPTIONAL_FN(ap_dbd_prepare);
        session_dbd_acquire_fn = APR_RETRIEVE_OPTIONAL_FN(ap_dbd_acquire);
        if (!session_dbd_prepare_fn || !session_dbd_acquire_fn) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                          "You must load mod_dbd to enable AuthDBD functions");
            return APR_EGENERAL;
        }
    }

    dbd = session_dbd_acquire_fn(r);
    if (!dbd) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "failed to acquire database connection");
        return APR_EGENERAL;
    }

    statement = apr_hash_get(dbd->prepared, query, APR_HASH_KEY_STRING);
    if (!statement) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "failed to find the prepared statement called '%s'", query);
        return APR_EGENERAL;
    }
    
    *dbdp = dbd;
    *statementp = statement;

    return APR_SUCCESS;
}

/**
 * Load the session by the key specified.
 */
static apr_status_t dbd_load(request_rec * r, const char *key, const char **val)
{

    apr_status_t rv;
    ap_dbd_t *dbd = NULL;
    apr_dbd_prepared_t *statement = NULL;
    apr_dbd_results_t *res = NULL;
    apr_dbd_row_t *row = NULL;
    apr_int64_t expiry = (apr_int64_t) apr_time_now();

    session_dbd_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_dbd_module);

    if (conf->selectlabel == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "no SessionDBDselectlabel has been specified");
        return APR_EGENERAL;
    }

    rv = dbd_init(r, conf->selectlabel, &dbd, &statement);
    if (rv) {
        return rv;
    }
    rv = apr_dbd_pvbselect(dbd->driver, r->pool, dbd->handle, &res, statement,
                          0, key, &expiry, NULL);
    if (rv) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "query execution error saving session '%s' "
                      "in database using query '%s': %s", key, conf->selectlabel,
                      apr_dbd_error(dbd->driver, dbd->handle, rv));
        return APR_EGENERAL;
    }
    for (rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1);
         rv != -1;
         rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1)) {
        if (rv != 0) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, LOG_PREFIX
                          "error retrieving results while saving '%s' "
                          "in database using query '%s': %s", key, conf->selectlabel,
                           apr_dbd_error(dbd->driver, dbd->handle, rv));
            return APR_EGENERAL;
        }
        if (*val == NULL) {
            *val = apr_dbd_get_entry(dbd->driver, row, 0);
        }
        /* we can't break out here or row won't get cleaned up */
    }

    return APR_SUCCESS;

}

/**
 * Load the session by firing off a dbd query.
 *
 * If the session is anonymous, the session key will be extracted from
 * the cookie specified. Failing that, the session key will be extracted
 * from the GET parameters.
 *
 * If the session is keyed by the username, the session will be extracted
 * by that.
 *
 * If no session is found, an empty session will be created.
 *
 * On success, this returns OK.
 */
AP_DECLARE(int) ap_session_dbd_load(request_rec * r, session_rec ** z)
{

    session_dbd_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_dbd_module);

    apr_status_t ret = APR_SUCCESS;
    session_rec *zz = NULL;
    const char *name = NULL;
    const char *note = NULL;
    const char *val = NULL;
    const char *key = NULL;
    request_rec *m = r->main ? r->main : r;

    /* is our session in a cookie? */
    if (conf->name2_set) {
        name = conf->name2;
    }
    else if (conf->name_set) {
        name = conf->name;
    }
    else if (conf->peruser_set && r->user) {
        name = r->user;
    }
    else {
        return DECLINED;
    }

    /* first look in the notes */
    note = apr_pstrcat(r->pool, MOD_SESSION_DBD, name, NULL);
    zz = (session_rec *)apr_table_get(m->notes, note);
    if (zz) {
        *z = zz;
        return OK;
    }

    /* load anonymous sessions */
    if (conf->name_set || conf->name2_set) {

        /* load RFC2109 compliant cookie */
        if (conf->name_set) {
            ap_cookie_read(r, conf->name, &key, conf->remove);
        }

        /* load RFC2965 compliant cookie */
        if (!key && conf->name2_set) {
            ap_cookie_read(r, conf->name2, &key, conf->remove);
        }

        if (key) {
            ret = dbd_load(r, key, &val);
            if (ret != APR_SUCCESS) {
                return ret;
            }
        }

    }

    /* load named session */
    else if (conf->peruser) {
        if (r->user) {
            ret = dbd_load(r, r->user, &val);
            if (ret != APR_SUCCESS) {
                return ret;
            }
        }
    }

    /* otherwise not for us */
    else {
        return DECLINED;
    }

    /* create a new session and return it */
    zz = (session_rec *) apr_pcalloc(r->pool, sizeof(session_rec));
    zz->pool = r->pool;
    zz->entries = apr_table_make(zz->pool, 10);
    zz->uuid = (apr_uuid_t *) apr_pcalloc(zz->pool, sizeof(apr_uuid_t));
    if (key) {
        apr_uuid_parse(zz->uuid, key);
    }
    else {
        apr_uuid_get(zz->uuid);
    }
    zz->encoded = val;
    *z = zz;

    /* put the session in the notes so we don't have to parse it again */
    apr_table_setn(m->notes, note, (char *)zz);

    return OK;

}

/**
 * Save the session by the key specified.
 */
static apr_status_t dbd_save(request_rec * r, const char *key, const char *val, apr_int64_t expiry)
{

    apr_status_t rv;
    ap_dbd_t *dbd = NULL;
    apr_dbd_prepared_t *statement;
    int rows = 0;

    session_dbd_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_dbd_module);

    if (conf->updatelabel == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "no SessionDBDupdatelabel has been specified");
        return APR_EGENERAL;
    }

    rv = dbd_init(r, conf->updatelabel, &dbd, &statement);
    if (rv) {
        return rv;
    }
    rv = apr_dbd_pvbquery(dbd->driver, r->pool, dbd->handle, &rows, statement,
                          val, &expiry, key, NULL);
    if (rv) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "query execution error updating session '%s' "
                      "using database query '%s': %s", key, conf->updatelabel,
                      apr_dbd_error(dbd->driver, dbd->handle, rv));
        return APR_EGENERAL;
    }

    /*
     * if some rows were updated it means a session existed and was updated,
     * so we are done.
     */
    if (rows != 0) {
        return APR_SUCCESS;
    }

    if (conf->insertlabel == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "no SessionDBDinsertlabel has been specified");
        return APR_EGENERAL;
    }

    rv = dbd_init(r, conf->insertlabel, &dbd, &statement);
    if (rv) {
        return rv;
    }
    rv = apr_dbd_pvbquery(dbd->driver, r->pool, dbd->handle, &rows, statement,
                          val, &expiry, key, NULL);
    if (rv) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, LOG_PREFIX
                      "query execution error inserting session '%s' "
                      "in database with '%s': %s", key, conf->insertlabel,
                      apr_dbd_error(dbd->driver, dbd->handle, rv));
        return APR_EGENERAL;
    }

    /*
     * if some rows were inserted it means a session was inserted, so we are
     * done.
     */
    if (rows != 0) {
        return APR_SUCCESS;
    }

    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                  "the session insert query did not cause any rows to be added "
                  "to the database for session '%s', session not inserted", key);

    return APR_EGENERAL;

}

/**
 * Remove the session by the key specified.
 */
static apr_status_t dbd_remove(request_rec * r, const char *key)
{

    apr_status_t rv;
    apr_dbd_prepared_t *statement;
    int rows = 0;

    session_dbd_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_dbd_module);
    ap_dbd_t *dbd = session_dbd_acquire_fn(r);
    if (dbd == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "failed to acquire database connection to remove "
                      "session with key '%s'", key);
        return APR_EGENERAL;
    }

    if (conf->deletelabel == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "no SessionDBDdeletelabel has been specified");
        return APR_EGENERAL;
    }

    statement = apr_hash_get(dbd->prepared, conf->deletelabel, APR_HASH_KEY_STRING);
    if (statement == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "prepared statement could not be found for "
                      "SessionDBDdeletelabel with the label '%s'", conf->deletelabel);
        return APR_EGENERAL;
    }
    rv = apr_dbd_pvbquery(dbd->driver, r->pool, dbd->handle, &rows, statement,
                          key, NULL);
    if (rv != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, LOG_PREFIX
                      "query execution error removing session '%s' "
                      "from database", key);
        return rv;
    }

    return APR_SUCCESS;

}

/**
 * Clean out expired sessions.
 * 
 * TODO: We need to figure out a way to clean out expired sessions from the database.
 * The monitor hook doesn't help us that much, as we have no handle into the
 * server, and so we need to come up with a way to do this safely.
 */
static apr_status_t dbd_clean(apr_pool_t *p)
{

    return APR_ENOTIMPL;

}

/**
 * Save the session by firing off a dbd query.
 *
 * If the session is anonymous, save the session and write a cookie
 * containing the uuid.
 *
 * If the session is keyed to the username, save the session using
 * the username as a key.
 *
 * On success, this method will return APR_SUCCESS.
 *
 * @param r The request pointer.
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_dbd_save(request_rec * r, session_rec * z)
{

    apr_status_t ret = APR_SUCCESS;
    session_dbd_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_dbd_module);

    /* support anonymous sessions */
    if (conf->name_set || conf->name2_set) {

        /* don't cache pages with a session */
        apr_table_addn(r->headers_out, "Cache-Control", "no-cache");

        /* must we create a uuid? */
        char *buffer = apr_pcalloc(r->pool, APR_UUID_FORMATTED_LENGTH + 1);
        apr_uuid_format(buffer, z->uuid);

        /* save the session with the uuid as key */
        if (z->encoded && z->encoded[0]) {
            ret = dbd_save(r, buffer, z->encoded, z->expiry);
        }
        else {
            ret = dbd_remove(r, buffer);
        }
        if (ret != APR_SUCCESS) {
            return ret;
        }

        /* create RFC2109 compliant cookie */
        if (conf->name_set) {
            ap_cookie_write(r, conf->name, buffer, conf->name_attrs, z->maxage);
        }

        /* create RFC2965 compliant cookie */
        if (conf->name2_set) {
            ap_cookie_write2(r, conf->name2, buffer, conf->name2_attrs, z->maxage);
        }

        return OK;

    }

    /* save named session */
    else if (conf->peruser) {

        /* don't cache pages with a session */
        apr_table_addn(r->headers_out, "Cache-Control", "no-cache");

        if (r->user) {
            ret = dbd_save(r, r->user, z->encoded, z->expiry);
            if (ret != APR_SUCCESS) {
                return ret;
            }
            return OK;
        }
        else {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
               "peruser sessions can only be saved if a user is logged in, "
                          "session not saved: %s", r->uri);
        }
    }

    return DECLINED;

}

/**
 * This function performs housekeeping on the database, deleting expired
 * sessions.
 */
AP_DECLARE(int) ap_session_dbd_monitor(apr_pool_t *p)
{
    /* TODO handle housekeeping */
    dbd_clean(p);
    return OK;
}


static void *create_session_dbd_dir_config(apr_pool_t * p, char *dummy)
{
    session_dbd_dir_conf *new =
    (session_dbd_dir_conf *) apr_pcalloc(p, sizeof(session_dbd_dir_conf));

    new->remove = 1;
    new->remove_set = 1;
    
    new->selectlabel = "selectsession";
    new->insertlabel = "insertsession";
    new->updatelabel = "updatesession";
    new->deletelabel = "deletesession";

    return (void *) new;
}

static void *merge_session_dbd_dir_config(apr_pool_t * p, void *basev, void *addv)
{
    session_dbd_dir_conf *new = (session_dbd_dir_conf *) apr_pcalloc(p, sizeof(session_dbd_dir_conf));
    session_dbd_dir_conf *add = (session_dbd_dir_conf *) addv;
    session_dbd_dir_conf *base = (session_dbd_dir_conf *) basev;

    new->name = (add->name_set == 0) ? base->name : add->name;
    new->name_attrs = (add->name_set == 0) ? base->name_attrs : add->name_attrs;
    new->name_set = add->name_set || base->name_set;
    new->name2 = (add->name2_set == 0) ? base->name2 : add->name2;
    new->name2_attrs = (add->name2_set == 0) ? base->name2_attrs : add->name2_attrs;
    new->name2_set = add->name2_set || base->name2_set;
    new->peruser = (add->peruser_set == 0) ? base->peruser : add->peruser;
    new->peruser_set = add->peruser_set || base->peruser_set;
    new->remove = (add->remove_set == 0) ? base->remove : add->remove;
    new->remove_set = add->remove_set || base->remove_set;
    new->selectlabel = (!add->selectlabel) ? base->selectlabel : add->selectlabel;
    new->updatelabel = (!add->updatelabel) ? base->updatelabel : add->updatelabel;
    new->insertlabel = (!add->insertlabel) ? base->insertlabel : add->insertlabel;
    new->deletelabel = (!add->deletelabel) ? base->deletelabel : add->deletelabel;

    return new;
}

/**
 * Sanity check a given string that it exists, is not empty,
 * and does not contain special characters.
 */
static const char *check_string(cmd_parms * cmd, const char *string)
{
    if (APR_SUCCESS != ap_cookie_check_string(string)) {
        return apr_pstrcat(cmd->pool, cmd->directive->directive,
                           " cannot be empty, or contain '=', ';' or '&'.",
                           NULL);
    }
    return NULL;
}

static const char *
     set_dbd_peruser(cmd_parms * parms, void *dconf, int flag)
{
    session_dbd_dir_conf *conf = dconf;

    conf->peruser = flag;
    conf->peruser_set = 1;

    return NULL;
}

static const char *
     set_dbd_cookie_remove(cmd_parms * parms, void *dconf, int flag)
{
    session_dbd_dir_conf *conf = dconf;

    conf->remove = flag;
    conf->remove_set = 1;

    return NULL;
}

static const char *set_cookie_name(cmd_parms * cmd, void *config, const char *args)
{
    char *last;
    char *line = apr_pstrdup(cmd->pool, args);
    session_dbd_dir_conf *conf = (session_dbd_dir_conf *) config;
    char *cookie = apr_strtok(line, " \t", &last);
    conf->name = cookie;
    conf->name_set = 1;
    while (apr_isspace(*last)) {
        last++;
    }
    conf->name_attrs = last;
    return check_string(cmd, cookie);
}

static const char *set_cookie_name2(cmd_parms * cmd, void *config, const char *args)
{
    char *last;
    char *line = apr_pstrdup(cmd->pool, args);
    session_dbd_dir_conf *conf = (session_dbd_dir_conf *) config;
    char *cookie = apr_strtok(line, " \t", &last);
    conf->name2 = cookie;
    conf->name2_set = 1;
    while (apr_isspace(*last)) {
        last++;
    }
    conf->name2_attrs = last;
    return check_string(cmd, cookie);
}

static const command_rec session_dbd_cmds[] =
{
    AP_INIT_TAKE1("SessionDBDSelectLabel", ap_set_string_slot,
      (void *) APR_OFFSETOF(session_dbd_dir_conf, selectlabel), OR_AUTHCFG,
                  "Query label used to select a new session"),
    AP_INIT_TAKE1("SessionDBDInsertLabel", ap_set_string_slot,
      (void *) APR_OFFSETOF(session_dbd_dir_conf, insertlabel), OR_AUTHCFG,
                  "Query label used to insert a new session"),
    AP_INIT_TAKE1("SessionDBDUpdateLabel", ap_set_string_slot,
      (void *) APR_OFFSETOF(session_dbd_dir_conf, updatelabel), OR_AUTHCFG,
                  "Query label used to update an existing session"),
    AP_INIT_TAKE1("SessionDBDDeleteLabel", ap_set_string_slot,
      (void *) APR_OFFSETOF(session_dbd_dir_conf, deletelabel), OR_AUTHCFG,
                  "Query label used to delete an existing session"),
    AP_INIT_FLAG("SessionDBDPerUser", set_dbd_peruser, NULL, OR_AUTHCFG,
                 "Save the session per user"),
    AP_INIT_FLAG("SessionDBDCookieRemove", set_dbd_cookie_remove, NULL, RSRC_CONF|OR_AUTHCFG,
                 "Remove the session cookie after session load. On by default."),
    AP_INIT_RAW_ARGS("SessionDBDCookieName", set_cookie_name, NULL, OR_AUTHCFG,
                 "The name of the RFC2109 cookie carrying the session key"),
    AP_INIT_RAW_ARGS("SessionDBDCookieName2", set_cookie_name2, NULL, OR_AUTHCFG,
                 "The name of the RFC2965 cookie carrying the session key"),
    {NULL}
};

static void register_hooks(apr_pool_t * p)
{
    ap_hook_session_load(ap_session_dbd_load, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_session_save(ap_session_dbd_save, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_monitor(ap_session_dbd_monitor, NULL, NULL, APR_HOOK_MIDDLE);
}

module AP_MODULE_DECLARE_DATA session_dbd_module =
{
    STANDARD20_MODULE_STUFF,
    create_session_dbd_dir_config, /* dir config creater */
    merge_session_dbd_dir_config,  /* dir merger --- default is to
                                    * override */
    NULL,                          /* server config */
    NULL,                          /* merge server config */
    session_dbd_cmds,              /* command apr_table_t */
    register_hooks                 /* register hooks */
};
    char *path, *querystring;
    /*
     * Check if we need to ignore session identifiers in the URL and do so
     * if needed.
     */
    path = r->parsed_uri.path;
    querystring = r->parsed_uri.query;
    if (conf->ignore_session_id_set == CACHE_IGNORE_SESSION_ID_SET) {
        int i;
        char **identifier;

        identifier = (char **)conf->ignore_session_id->elts;
        for (i = 0; i < conf->ignore_session_id->nelts; i++, identifier++) {
            int len;
            char *param;

            len = strlen(*identifier);
            /*
             * Check that we have a parameter separator in the last segment
             * of the path and that the parameter matches our identifier
             */
            if ((param = strrchr(path, ';'))
                && !strncmp(param + 1, *identifier, len)
                && (*(param + len + 1) == '=')
                && !strchr(param + len + 2, '/')) {
                path = apr_pstrndup(p, path, param - path);
                break;
            }
            /*
             * Check if the identifier is in the querystring and cut it out.
             */
            if (querystring
                && (param = strstr(querystring, *identifier))
                && (*(param + len) == '=')
                ) {
                char *amp;

                if (querystring != param) {
                    querystring = apr_pstrndup(p, querystring,
                                               param - querystring);
                }
                else {
                    querystring = "";
                }
                if ((amp = strchr(param + len + 1, '&'))) {
                    querystring = apr_pstrcat(p, querystring, amp + 1, NULL);
                }
                break;
            }
        }
    }

                           path, "?", NULL);
                           path, "?", querystring, NULL);
    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                 "cache: Key for entity %s?%s is %s", r->parsed_uri.path,
                 r->parsed_uri.query, *key);
    /* array of identifiers that should not be used for key calculation */
    ps->ignore_session_id = apr_array_make(p, 10, sizeof(char *));
    ps->ignore_session_id_set = CACHE_IGNORE_SESSION_ID_UNSET;
    ps->ignore_session_id =
        (overrides->ignore_session_id_set == CACHE_IGNORE_HEADERS_UNSET)
        ? base->ignore_session_id
        : overrides->ignore_session_id;
static const char *add_ignore_session_id(cmd_parms *parms, void *dummy,
                                         const char *identifier)
{
    cache_server_conf *conf;
    char **new;

    conf =
        (cache_server_conf *)ap_get_module_config(parms->server->module_config,
                                                  &cache_module);
    if (!strncasecmp(identifier, "None", 4)) {
        /* if identifier None is listed clear array */
        conf->ignore_session_id->nelts = 0;
    }
    else {
        if ((conf->ignore_session_id_set == CACHE_IGNORE_SESSION_ID_UNSET) ||
            (conf->ignore_session_id->nelts)) {
            /*
             * Only add identifier if no "None" has been found in identifier
             * list so far.
             */
            new = (char **)apr_array_push(conf->ignore_session_id);
            (*new) = (char *)identifier;
        }
    }
    conf->ignore_session_id_set = CACHE_IGNORE_SESSION_ID_SET;
    return NULL;
}

    AP_INIT_ITERATE("CacheIgnoreURLSessionIdentifiers", add_ignore_session_id,
                    NULL, RSRC_CONF, "A space separated list of session "
                    "identifiers that should be ignored for creating the key "
                    "of the cached entity."),
    /** store the identifiers that should not be used for key calculation */
    apr_array_header_t *ignore_session_id;
    /* flag if CacheIgnoreURLSessionIdentifiers has been set */
    #define CACHE_IGNORE_SESSION_ID_SET   1
    #define CACHE_IGNORE_SESSION_ID_UNSET 0
    int ignore_session_id_set;
    apr_pool_t *pool;
    apr_table_t *header_out;
    apr_table_t *req_hdrs; /* for Vary negotiation */

    apr_pool_destroy(mobj->pool);
    apr_status_t rv;
    apr_pool_t *pool;
    rv = apr_pool_create(&pool, NULL);

    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, r->server,
                     "mem_cache: Failed to create memory pool.");

    /* Allocate and initialize cache_object_t */
    obj = apr_pcalloc(pool, sizeof(*obj));
    obj->key = apr_pstrdup(pool, key);
    mobj = apr_pcalloc(pool, sizeof(*mobj));
    mobj->pool = pool;
    h->req_hdrs = apr_table_copy(r->pool, mobj->req_hdrs);
    h->resp_hdrs = apr_table_copy(r->pool, mobj->header_out);
    return OK;
    mobj->req_hdrs = apr_table_copy(mobj->pool, r->headers_in);
    mobj->header_out = apr_table_copy(mobj->pool, headers_out);
                mobj->m = realloc(mobj->m, obj->count);
                if (!mobj->m) {
 * 20120109.0 (2.5.0-dev)  Changes sizeof(overrides_t) in core config.
#define MODULE_MAGIC_NUMBER_MAJOR 20120109
#define MODULE_MAGIC_NUMBER_MINOR 0                   /* 0...n */
/* Flags to determine whether syntax errors in .htaccess should be
 * treated as nonfatal (log and ignore errors)
 */
#define NONFATAL_OVERRIDE 512    /* Violation of AllowOverride rule */
#define NONFATAL_UNKNOWN 1024    /* Unrecognised directive */
#define NONFATAL_ALL (NONFATAL_OVERRIDE|NONFATAL_UNKNOWN)

typedef unsigned int overrides_t;
    if ((parms->override & cmd->req_override) == 0 && !override_list_ok) {
        if (parms->override & NONFATAL_OVERRIDE) {
            ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, parms->temp_pool,
                          APLOGNO(02295)
                          "%s in .htaccess forbidden by AllowOverride",
                          cmd->name);
            return NULL;
        }
        else {
            return apr_pstrcat(parms->pool, cmd->name,
                               " not allowed here", NULL);
        }
    }
        if (parms->override & NONFATAL_UNKNOWN) {
            ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, parms->temp_pool,
                          APLOGNO(02296) "Unknown directive %s "
                          "perhaps misspelled or defined by a module "
                          "not included in the server configuration", dir);
            return NULL;
        }
        else {
            return apr_pstrcat(parms->pool, "Invalid command '",
                               current->directive,
                               "', perhaps misspelled or defined by a module "
                               "not included in the server configuration",
                               NULL);
        }
        else if (!strcasecmp(w, "Nonfatal")) {
            if (!strcasecmp(v, "Override")) {
                d->override |= NONFATAL_OVERRIDE;
            }
            else if (!strcasecmp(v, "Unknown")) {
                d->override |= NONFATAL_UNKNOWN;
            }
            else if (!strcasecmp(v, "All")) {
                d->override |= NONFATAL_ALL;
            }
        }
 * 20051231.0 (2.3.0-dev) Added num_blank_lines, pending_header_line, and
 *                        pending_header_size to request_rec
#define MODULE_MAGIC_NUMBER_MAJOR 20051231
    /** Number of leading blank lines encountered before request header */
    int num_blank_lines;

    /** A buffered header line, used to support header folding while
     *  reading the request */
    char *pending_header_line;

    /** If nonzero, the number of bytes allocated to hold pending_header_line */
    apr_size_t pending_header_size;

static void set_the_request(request_rec *r, char *line)
    apr_socket_t *csd;
    ll = r->the_request = line;
             && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */
    }
    else {
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(r->connection->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->connection->base_server->timeout);

    return;
}

static apr_status_t set_mime_header(request_rec *r, char *line)
{
    char *value, *tmp_field;

    if (r->server->limit_req_fields) {
        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);
        if (mime_headers->nelts >= r->server->limit_req_fields) {
            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields "
                           "exceeds this server's limit.");
            r->status = HTTP_BAD_REQUEST;
            return APR_ENOSPC;
        }
    }
    
    if (!(value = strchr(line, ':'))) { /* Find ':' or    */
        r->status = HTTP_BAD_REQUEST;      /* abort bad request */
        apr_table_setn(r->notes, "error-notes",
                       apr_pstrcat(r->pool,
                                   "Request header field is "
                                   "missing ':' separator.<br />\n"
                                   "<pre>\n",
                                   ap_escape_html(r->pool, line),
                                   "</pre>\n", NULL));
        return APR_EGENERAL;
    }

    tmp_field = value - 1; /* last character of field-name */

    *value++ = '\0'; /* NUL-terminate at colon */

    while (*value == ' ' || *value == '\t') {
        ++value;            /* Skip to start of value   */
    }

    /* Strip LWS after field-name: */
    while (tmp_field > line
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }

    /* Strip LWS after field-value: */
    tmp_field = strchr(value, '\0') - 1;
    while (tmp_field > value
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }
    apr_table_addn(r->headers_in, line, value);
    return APR_SUCCESS;
}

static apr_status_t process_request_line(request_rec *r, char *line,
                                         int skip_first)
{
    if (!skip_first && (r->the_request == NULL)) {
        /* This is the first line of the request */
        if ((line == NULL) || (*line == '\0')) {
            /* We skip empty lines because browsers have to tack a CRLF on to the end
             * of POSTs to support old CERN webservers.
             */
            int max_blank_lines = r->server->limit_req_fields;
            if (max_blank_lines <= 0) {
                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
            }
            r->num_blank_lines++;
            if (r->num_blank_lines < max_blank_lines) {
                return APR_SUCCESS;
            }
        }
        set_the_request(r, line);
    }
    else {
        /* We've already read the first line of the request.  This is either
         * a header field or the blank line terminating the header
         */
        if ((line == NULL) || (*line == '\0')) {
            if (r->pending_header_line != NULL) {
                apr_status_t rv = set_mime_header(r, r->pending_header_line);
                if (rv != APR_SUCCESS) {
                    return rv;
                }
                r->pending_header_line = NULL;
            }
            if (r->status == HTTP_REQUEST_TIME_OUT) {
                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
                r->status = HTTP_OK;
            }
        }
        else {
            if ((*line == ' ') || (*line == '\t')) {
                /* This line is a continuation of the previous one */
                if (r->pending_header_line == NULL) {
                    r->pending_header_line = line;
                    r->pending_header_size = 0;
                }
                else {
                    apr_size_t pending_len = strlen(r->pending_header_line);
                    apr_size_t fold_len = strlen(line);
                    if (pending_len + fold_len >
                        r->server->limit_req_fieldsize) {
                        /* CVE-2004-0942 */
                        r->status = HTTP_BAD_REQUEST;
                        return APR_ENOSPC;
                    }
                    if (pending_len + fold_len + 1 > r->pending_header_size) {
                        /* Allocate a new buffer big enough to hold the
                         * concatenated lines
                         */
                        apr_size_t new_size = r->pending_header_size;
                        char *new_buf;
                        if (new_size == 0) {
                            new_size = pending_len + fold_len + 1;
                        }
                        else {
                            do {
                                new_size *= 2;
                            } while (new_size < pending_len + fold_len + 1);
                        }
                        new_buf = (char *)apr_palloc(r->pool, new_size);
                        memcpy(new_buf, r->pending_header_line, pending_len);
                        r->pending_header_line = new_buf;
                        r->pending_header_size = new_size;
                    }
                    memcpy(r->pending_header_line + pending_len, line,
                           fold_len + 1);
                }
            }
            else {
                /* Set aside this line in case the next line is a continuation
                 */
                if (r->pending_header_line != NULL) {
                    apr_status_t rv = set_mime_header(r, r->pending_header_line);
                    if (rv != APR_SUCCESS) {
                        return rv;
                    }
                }
                r->pending_header_line = line;
                r->pending_header_size = 0;
            }
        }
    }
    return APR_SUCCESS;
        rv = process_request_line(r, field, 1);
        if (rv != APR_SUCCESS) {
            return;
        if ((field == NULL) || (*field == '\0')) {
            return;
static request_rec *init_request(conn_rec *conn)
    
    return r;
}
static request_rec *request_post_read(request_rec *r, conn_rec *conn)
{
    apr_socket_t *csd;
    const char *expect;
    int access_status;
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->server->timeout);

    if (apr_table_get(r->headers_in, "Transfer-Encoding") &&
        apr_table_get(r->headers_in, "Content-Length")) {
        /* 2616 section 4.4, point 3: "if both Transfer-Encoding
         * and Content-Length are received, the latter MUST be
         * ignored"; so unset it here to prevent any confusion
         * later.
         */
        apr_table_unset(r->headers_in, "Content-Length");
static apr_status_t read_partial_request(request_rec *r) {
    apr_bucket_brigade *tmp_bb;
    apr_status_t rv = APR_SUCCESS;

    /* Read and process lines of the request until we
     * encounter a complete request header, an error, or EAGAIN
     */
    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    while (r->status == HTTP_REQUEST_TIME_OUT) {
        char *line = NULL;
        apr_size_t line_length;
        apr_size_t length_limit;
        int first_line = (r->the_request == NULL);
        if (first_line) {
            length_limit = r->server->limit_req_line;
        }
        else {
            if (r->assbackwards) {
                r->status = HTTP_OK;
                break;
            }
            length_limit = r->server->limit_req_fieldsize;
        }
        /* TODO: use a nonblocking call in place of ap_rgetline */
        rv = ap_rgetline(&line, length_limit + 2,
                         &line_length, r, 0, tmp_bb);
        if (rv == APR_SUCCESS) {
            rv = process_request_line(r, line, 0);
        }
        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();
            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                if (first_line) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: URI too long (longer than %d)",
                                  r->server->limit_req_line);
                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                    r->proto_num = HTTP_VERSION(1,0);
                    r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
                }
                else {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: header line too long "
                                  "(longer than %d)",
                                  r->server->limit_req_fieldsize);
                    r->status = HTTP_BAD_REQUEST;
                }
            }
            break;
        }
    }
    apr_brigade_destroy(tmp_bb);
    return rv;
}

request_rec *ap_read_request(conn_rec *conn)
{
    request_rec *r;
    apr_status_t rv;

    r = init_request(conn);

    rv = read_partial_request(r);
    /* TODO poll if EAGAIN */
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return NULL;
    }

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers! Have to dink things just to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "client sent invalid HTTP/0.9 request: HEAD %s",
                      r->uri);
        r->header_only = 0;
        r->status = HTTP_BAD_REQUEST;
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return r;
    }

    return request_post_read(r, conn);
}

    int checking_standby = 0;
    int checked_standby = 0;
    
    proxy_worker *worker;
    while (!checked_standby) {
        worker = (proxy_worker *)balancer->workers->elts;
        for (i = 0; i < balancer->workers->nelts; i++, worker++) {
            if ( (checking_standby ? !PROXY_WORKER_IS_STANDBY(worker) : PROXY_WORKER_IS_STANDBY(worker)) )
                continue;
            if (*(worker->s->route) && strcmp(worker->s->route, route) == 0) {
                if (worker && PROXY_WORKER_IS_USABLE(worker)) {
                    return worker;
                     * If the worker is in error state run
                     * retry on that worker. It will be marked as
                     * operational if the retry timeout is elapsed.
                     * The worker might still be unusable, but we try
                     * anyway.
                    ap_proxy_retry_worker("BALANCER", worker, r->server);
                    if (PROXY_WORKER_IS_USABLE(worker)) {
                            return worker;
                    } else {
                        /*
                         * We have a worker that is unusable.
                         * It can be in error or disabled, but in case
                         * it has a redirection set use that redirection worker.
                         * This enables to safely remove the member from the
                         * balancer. Of course you will need some kind of
                         * session replication between those two remote.
                         */
                        if (*worker->s->redirect) {
                            proxy_worker *rworker = NULL;
                            rworker = find_route_worker(balancer, worker->s->redirect, r);
                            /* Check if the redirect worker is usable */
                            if (rworker && !PROXY_WORKER_IS_USABLE(rworker)) {
                                /*
                                 * If the worker is in error state run
                                 * retry on that worker. It will be marked as
                                 * operational if the retry timeout is elapsed.
                                 * The worker might still be unusable, but we try
                                 * anyway.
                                 */
                                ap_proxy_retry_worker("BALANCER", rworker, r->server);
                            }
                            if (rworker && PROXY_WORKER_IS_USABLE(rworker))
                                return rworker;
        checked_standby = checking_standby++;
                if (worker->s->status & PROXY_WORKER_DISABLED)
                   ap_rputs("Dis ", r);
                if (worker->s->status & PROXY_WORKER_IN_ERROR)
                   ap_rputs("Err ", r);
                if (worker->s->status & PROXY_WORKER_STOPPED)
                   ap_rputs("Stop ", r);
                if (worker->s->status & PROXY_WORKER_HOT_STANDBY)
                   ap_rputs("Stby ", r);
                if (!PROXY_WORKER_IS_INITIALIZED(worker))
                    ap_rputs("-", r);
    proxy_worker *worker;
    int checking_standby = 0;
    int checked_standby = 0;
    
    while (!mycandidate && !checked_standby) {
        for (i = 0; i < balancer->workers->nelts; i++, worker++) {
            if ( (checking_standby ? !PROXY_WORKER_IS_STANDBY(worker) : PROXY_WORKER_IS_STANDBY(worker)) )
                continue;
            /* If the worker is in error state run
             * retry on that worker. It will be marked as
             * operational if the retry timeout is elapsed.
             * The worker might still be unusable, but we try
             * anyway.
             */
            if (!PROXY_WORKER_IS_USABLE(worker))
                ap_proxy_retry_worker("BALANCER", worker, r->server);
            /* Take into calculation only the workers that are
             * not in error state or not disabled.
             */
            if (PROXY_WORKER_IS_USABLE(worker)) {
                worker->s->lbstatus += worker->s->lbfactor;
                total_factor += worker->s->lbfactor;
                if (!mycandidate || worker->s->lbstatus > mycandidate->s->lbstatus)
                    mycandidate = worker;
        checked_standby = checking_standby++;
    proxy_worker *worker;
    int checking_standby = 0;
    int checked_standby = 0;
    while (!mycandidate && !checked_standby) {
        for (i = 0; i < balancer->workers->nelts; i++, worker++) {
            if ( (checking_standby ? !PROXY_WORKER_IS_STANDBY(worker) : PROXY_WORKER_IS_STANDBY(worker)) )
                continue;
            /* If the worker is in error state run
             * retry on that worker. It will be marked as
             * operational if the retry timeout is elapsed.
             * The worker might still be unusable, but we try
             * anyway.
             */
            if (!PROXY_WORKER_IS_USABLE(worker))
                ap_proxy_retry_worker("BALANCER", worker, r->server);
            /* Take into calculation only the workers that are
             * not in error state or not disabled.
             */
            if (PROXY_WORKER_IS_USABLE(worker)) {
                mytraffic = (worker->s->transferred/worker->s->lbfactor) +
                            (worker->s->read/worker->s->lbfactor);
                if (!mycandidate || mytraffic < curmin) {
                    mycandidate = worker;
                    curmin = mytraffic;
        checked_standby = checking_standby++;
    if (!PROXY_WORKER_IS_USABLE(worker)) {
        if (!PROXY_WORKER_IS_USABLE(worker)) {
    if (!connected && PROXY_WORKER_IS_USABLE(worker) &&
#ifdef IS_MOD_PROXY_HTTP2
extern module AP_MODULE_DECLARE_DATA proxy_http2_module;
APLOG_USE_MODULE(proxy_http2);
#else
#endif 
#if (!defined(WIN32) && !defined(NETWARE)) || defined(DOXYGEN)
#endif
    stream->req = h2_req_create(1, stream->pool, 0);
    h2_req_make(stream->req, stream->pool, r->method, scheme,
                authority, path, r->headers_in);
                req = h2_req_createn(0, ctx->pool, method, ctx->req->scheme,
                                     ctx->req->authority, path, headers,
                                     ctx->req->serialize);
    status = h2_req_make(req, r->pool,  r->method, scheme, authority,
                         apr_uri_unparse(r->pool, &r->parsed_uri, 
                                         APR_URI_UNP_OMITSITEPART),
                         r->headers_in);
        status = h2_headers_add_h1(req->headers, pool, name, nlen, value, vlen);
static void H2_STREAM_OUT_LOG(int lvl, h2_stream *s, char *tag)
{
    if (APLOG_C_IS_LEVEL(s->session->c, lvl)) {
        conn_rec *c = s->session->c;
        char buffer[4 * 1024];
        const char *line = "(null)";
        apr_size_t len, bmax = sizeof(buffer)/sizeof(buffer[0]);
        
        len = h2_util_bb_print(buffer, bmax, tag, "", s->buffer);
        ap_log_cerror(APLOG_MARK, lvl, 0, c, "bb_dump(%ld-%d): %s", 
                      c->id, s->id, len? buffer : line);
    }
}
        req = h2_req_create(id, pool, 
    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(03058)
                  "h2_request(%d): rwrite %s host=%s://%s%s",
                  stream->request->id, stream->request->method, 
                  stream->request->scheme, stream->request->authority, 
                  stream->request->path);
#include "h2.h"
apr_status_t h2_headers_add_h1(apr_table_t *headers, apr_pool_t *pool, 
                               const char *name, size_t nlen,
                               const char *value, size_t vlen)
{
    char *hname, *hvalue;
    
    if (h2_req_ignore_header(name, nlen)) {
        return APR_SUCCESS;
    }
    else if (H2_HD_MATCH_LIT("cookie", name, nlen)) {
        const char *existing = apr_table_get(headers, "cookie");
        if (existing) {
            char *nval;
            
            /* Cookie header come separately in HTTP/2, but need
             * to be merged by "; " (instead of default ", ")
             */
            hvalue = apr_pstrndup(pool, value, vlen);
            nval = apr_psprintf(pool, "%s; %s", existing, hvalue);
            apr_table_setn(headers, "Cookie", nval);
            return APR_SUCCESS;
        }
    }
    else if (H2_HD_MATCH_LIT("host", name, nlen)) {
        if (apr_table_get(headers, "Host")) {
            return APR_SUCCESS; /* ignore duplicate */
        }
    }
    
    hname = apr_pstrndup(pool, name, nlen);
    hvalue = apr_pstrndup(pool, value, vlen);
    h2_util_camel_case_header(hname, nlen);
    apr_table_mergen(headers, hname, hvalue);
    
    return APR_SUCCESS;
}

/*******************************************************************************
 * h2 request handling
 ******************************************************************************/

h2_request *h2_req_createn(int id, apr_pool_t *pool, const char *method, 
                           const char *scheme, const char *authority, 
                           const char *path, apr_table_t *header, int serialize)
{
    h2_request *req = apr_pcalloc(pool, sizeof(h2_request));
    
    req->id             = id;
    req->method         = method;
    req->scheme         = scheme;
    req->authority      = authority;
    req->path           = path;
    req->headers        = header? header : apr_table_make(pool, 10);
    req->request_time   = apr_time_now();
    req->serialize      = serialize;
    
    return req;
}

h2_request *h2_req_create(int id, apr_pool_t *pool, int serialize)
{
    return h2_req_createn(id, pool, NULL, NULL, NULL, NULL, NULL, serialize);
}

typedef struct {
    apr_table_t *headers;
    apr_pool_t *pool;
} h1_ctx;

static int set_h1_header(void *ctx, const char *key, const char *value)
{
    h1_ctx *x = ctx;
    size_t klen = strlen(key);
    if (!h2_req_ignore_header(key, klen)) {
        h2_headers_add_h1(x->headers, x->pool, key, klen, value, strlen(value));
    }
    return 1;
}

apr_status_t h2_req_make(h2_request *req, apr_pool_t *pool,
                         const char *method, const char *scheme, 
                         const char *authority, const char *path, 
                         apr_table_t *headers)
{
    h1_ctx x;

    req->method    = method;
    req->scheme    = scheme;
    req->authority = authority;
    req->path      = path;

    AP_DEBUG_ASSERT(req->scheme);
    AP_DEBUG_ASSERT(req->authority);
    AP_DEBUG_ASSERT(req->path);
    AP_DEBUG_ASSERT(req->method);

    x.pool = pool;
    x.headers = req->headers;
    apr_table_do(set_h1_header, &x, headers, NULL);
    return APR_SUCCESS;
}
apr_status_t h2_headers_add_h1(apr_table_t *headers, apr_pool_t *pool, 
                               const char *name, size_t nlen,
                               const char *value, size_t vlen);

/*******************************************************************************
 * h2_request helpers
 ******************************************************************************/

struct h2_request *h2_req_createn(int id, apr_pool_t *pool, const char *method, 
                                  const char *scheme, const char *authority, 
                                  const char *path, apr_table_t *header,
                                  int serialize);
struct h2_request *h2_req_create(int id, apr_pool_t *pool, int serialize);

apr_status_t h2_req_make(struct h2_request *req, apr_pool_t *pool,
                         const char *method, const char *scheme, 
                         const char *authority, const char *path, 
                         apr_table_t *headers);

#define h2_util_bb_log(c, i, level, tag, bb) \
do { \
    char buffer[4 * 1024]; \
    const char *line = "(null)"; \
    apr_size_t len, bmax = sizeof(buffer)/sizeof(buffer[0]); \
    len = h2_util_bb_print(buffer, bmax, (tag), "", (bb)); \
    ap_log_cerror(APLOG_MARK, level, 0, (c), "bb_dump(%ld-%d): %s", \
        (c)->id, (int)(i), (len? buffer : line)); \
} while(0)

#include "h2.h"

    /** Which allow-override-opts bits are set */
    int override_opts;
                                       int override_opts,
    allow_options_t override_opts;
    /** the override options allowed for the .htaccess file */
    int override_opts;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
				       int override_opts,
    parms.override_opts = override_opts;
    new->override_opts = override_opts;
    conf->override_opts = OPT_UNSET | OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER
   			 | OPT_MULTI;
    if (!(new->override_opts & OPT_UNSET)) {
	conf->override_opts = new->override_opts;
    }

static const char *set_allow_opts(cmd_parms *cmd, allow_options_t *opts,
                                  const char *l)
{
    allow_options_t opt;
    int first = 1;

    char *p = (char *) l;

    while (p && *p) {
        char *w = strsep(&p, ",");

        if (first) {
            *opts = OPT_NONE;
            first = 0;
        }

	if (!w)
	    continue;

        if (!strcasecmp(w, "Indexes")) {
            opt = OPT_INDEXES;
        }
        else if (!strcasecmp(w, "Includes")) {
            opt = OPT_INCLUDES;
        }
        else if (!strcasecmp(w, "IncludesNOEXEC")) {
            opt = (OPT_INCLUDES | OPT_INCNOEXEC);
        }
        else if (!strcasecmp(w, "FollowSymLinks")) {
            opt = OPT_SYM_LINKS;
        }
        else if (!strcasecmp(w, "SymLinksIfOwnerMatch")) {
            opt = OPT_SYM_OWNER;
        }
        else if (!strcasecmp(w, "ExecCGI")) {
            opt = OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "MultiViews")) {
            opt = OPT_MULTI;
        }
        else if (!strcasecmp(w, "RunScripts")) { /* AI backcompat. Yuck */
            opt = OPT_MULTI|OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "None")) {
            opt = OPT_NONE;
        }
        else if (!strcasecmp(w, "All")) {
            opt = OPT_ALL;
        }
        else {
            return apr_pstrcat(cmd->pool, "Illegal option ", w, NULL);
        }

        *opts |= opt;
    }

    (*opts) &= (~OPT_UNSET);

    return NULL;
}

    char *k, *v;

	k = w;
	v = strchr(k, '=');
	if (v) {
		*v++ = '\0';
	}

        else if (!strcasecmp(k, "Options")) {
	    if (v) 
                set_allow_opts(cmd, &(d->override_opts), v);
	    else
	        d->override_opts = OPT_ALL;
        else if (!strcasecmp(w, "ExecCGI")) {
	if (!(cmd->override_opts & opt) && opt != OPT_NONE) {
	    return apr_pstrcat(cmd->pool, "Option ", w, " not allowed here", NULL);
        }
        else if (action == '-') {
            /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        overrides_t override_opts;
    if (!(this_dir->override_opts & OR_UNSET)) {
        opts->override_opts = this_dir->override_opts;
    }
					opts.override_opts,
                                                   apr_bucket_brigade *bb);
static int ftp_getrc_msg(conn_rec *ftp_ctrl, apr_bucket_brigade *bb, char *msgbuf, int msglen)
    if (APR_SUCCESS != (rv = ap_proxy_string_read(ftp_ctrl, bb, response, sizeof(response), &eos))) {
/*
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, NULL,
                 "proxy: <FTP: %s", response);
*/
            if (APR_SUCCESS != (rv = ap_proxy_string_read(ftp_ctrl, bb, response, sizeof(response), &eos))) {
apr_status_t ap_proxy_send_dir_filter(ap_filter_t *f, apr_bucket_brigade *in)
                           "\n\n<html>\n<head>\n<title>%s%s</title>\n"
                           "<base href=\"%s%s\">\n</head>\n\n"
                           "<body>\n\n<h2>Directory of "
                           "<a href=\"/\">%s</a>/",
                           site, ap_escape_uri(p, path),
                           site, ap_escape_html(p, path), site);
            str = apr_psprintf(p, "<a href=\"/%s/\">%s</a>/",
                               ap_escape_uri(p, path + 1),
                               ap_escape_html(p, reldir));
            str = apr_psprintf(p, "</h2>\n\n<hr />\n\n<pre>");
            str = apr_psprintf(p, "</h2>\n\n(%s)\n\n<hr />\n\n<pre>", pwd);
            str = apr_psprintf(p, "%s\n</pre>\n\n<hr />\n\n<pre>\n",
                               ap_escape_html(p, readme));
            } while (filename[0] != ' ' && filename > ctx->buffer);
            if (filename > ctx->buffer)
                *(filename++) = '\0';
            str = apr_psprintf(p, "%s <a href=\"%s\">%s %s</a>\n",
                               ap_escape_html(p, ctx->buffer),
                               ap_escape_uri(p, filename),
                               ap_escape_html(p, filename),
                               ap_escape_html(p, link_ptr));
                str = apr_psprintf(p, "%s <a href=\"%s/\">%s</a>\n",
                                   ap_escape_html(p, ctx->buffer),
                                   ap_escape_uri(p, filename),
                                   ap_escape_html(p, filename));
                str = apr_psprintf(p, "%s <a href=\"%s\">%s</a>\n",
                                   ap_escape_html(p, ctx->buffer),
                                   ap_escape_uri(p, filename),
                                   ap_escape_html(p, filename));
            str = ap_escape_html(p, ctx->buffer);
        str = apr_psprintf(p, "</pre>\n\n<hr />\n\n%s\n\n</body>\n</html>\n", ap_psignature("", r));
    apr_socket_t *sock, *local_sock, *data_sock = NULL;
    conn_rec *origin, *data;
     *
     *
     *
     *
         *
     *
        apr_sockaddr_t *data_addr;
        char *data_ip;
        apr_port_t data_port;
                data_port = atoi(pstr + 3);
                             data_port);
                if ((rv = apr_socket_create(&data_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(data_sock, APR_SO_RCVBUF,
                apr_socket_addr_get(&data_addr, APR_REMOTE, sock);
                apr_sockaddr_ip_get(&data_ip, data_addr);
                apr_sockaddr_info_get(&epsv_addr, data_ip, APR_INET, data_port, 0, p);
                rv = apr_connect(data_sock, epsv_addr);
                apr_socket_close(data_sock);
                if ((rv = apr_socket_create(&data_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(data_sock, APR_SO_RCVBUF,
                rv = apr_connect(data_sock, pasv_addr);
                apr_socket_close(data_sock);
     *
            rv = apr_accept(&data_sock, local_sock, r->pool);
    data = ap_new_connection(p, r->server, data_sock, r->connection->id, r->connection->sbh);
    if (!data) {
    ap_proxy_pre_http_connection(data);
     *
        while (ap_get_brigade(data->input_filters, bb, AP_MODE_EXHAUSTIVE,
    ap_flush_conn(data);
    apr_socket_close(data_sock);
     *
static void ap_proxy_ftp_register_hook(apr_pool_t *p)
#include "apr_support.h"
    apr_bucket_brigade *tmpbb;
static apr_status_t check_time_left(reqtimeout_con_cfg *ccfg,
                                    apr_time_t *time_left_p)
{
    *time_left_p = ccfg->timeout_at - apr_time_now();
    if (*time_left_p <= 0)
        return APR_TIMEUP;
    
    if (*time_left_p < apr_time_from_sec(1)) {
        *time_left_p = apr_time_from_sec(1);
    }
    return APR_SUCCESS;
}

static apr_status_t have_lf_or_eos(apr_bucket_brigade *bb)
{
    apr_bucket *b = APR_BRIGADE_LAST(bb);

    for ( ; b != APR_BRIGADE_SENTINEL(bb) ; b = APR_BUCKET_PREV(b) ) {
    	const char *str;
    	apr_size_t len;
    	apr_status_t rv;

        if (APR_BUCKET_IS_EOS(b))
            return APR_SUCCESS;

        if (APR_BUCKET_IS_METADATA(b))
            continue;

        rv = apr_bucket_read(b, &str, &len, APR_BLOCK_READ);
        if (rv != APR_SUCCESS)
            return rv;

        if (len == 0)
            continue;

        if (str[len-1] == APR_ASCII_LF)
            return APR_SUCCESS;
    }
    return APR_INCOMPLETE;
}


#define MIN(x,y) ((x) < (y) ? (x) : (y))
    rv = check_time_left(ccfg, &time_left);
    if (rv != APR_SUCCESS)
        goto out;
    rv = apr_socket_timeout_set(ccfg->socket, MIN(time_left, saved_sock_timeout));
    AP_DEBUG_ASSERT(rv == APR_SUCCESS);
    if (mode == AP_MODE_GETLINE) {
        /*
         * For a blocking AP_MODE_GETLINE read, apr_brigade_split_line()
         * would loop until a whole line has been read. As this would make it
         * impossible to enforce a total timeout, we only do non-blocking
         * reads.
         */
        apr_size_t remaining = HUGE_STRING_LEN;
        do {
            apr_off_t bblen;
            rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE, APR_NONBLOCK_READ, remaining);
            if (APR_STATUS_IS_EAGAIN(rv)) {
                rv = APR_SUCCESS;
            }
            else if (rv != APR_SUCCESS) {
                break;
            }

            if (!APR_BRIGADE_EMPTY(bb)) {
                rv = have_lf_or_eos(bb);
                if (rv != APR_INCOMPLETE) {
                    break;
                }

                if (ccfg->min_rate > 0) {
                    extend_timeout(ccfg, bb);
                }

                rv = apr_brigade_length(bb, 1, &bblen);
                if (rv != APR_SUCCESS) {
                    break;
                }
                remaining -= bblen;
                if (remaining <= 0) {
                    break;
                }

                /* Haven't got a whole line yet, save what we have ... */
                if (!ccfg->tmpbb) {
                    ccfg->tmpbb = apr_brigade_create(f->c->pool, f->c->bucket_alloc);
                }
                APR_BRIGADE_CONCAT(ccfg->tmpbb, bb);
            }

            /* ... and wait for more */
            rv = apr_wait_for_io_or_timeout(NULL, ccfg->socket, 1);
            if (rv != APR_SUCCESS)
                break;

            rv = check_time_left(ccfg, &time_left);
            if (rv != APR_SUCCESS)
                break;
            rv = apr_socket_timeout_set(ccfg->socket,
                                   MIN(time_left, saved_sock_timeout));
            AP_DEBUG_ASSERT(rv == APR_SUCCESS);

        } while (1);

        if (ccfg->tmpbb)
            APR_BRIGADE_PREPEND(bb, ccfg->tmpbb);

    }
    else {
        /* mode != AP_MODE_GETLINE */
        rv = ap_get_brigade(f->next, bb, mode, block, readbytes);
        if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {
            extend_timeout(ccfg, bb);
        }
    apr_socket_timeout_set(ccfg->socket, saved_sock_timeout);

out:
        /*
         * If we allow lingering close, the client may keep this
         * process/thread busy for another 30s (MAX_SECS_TO_LINGER).
         * Therefore we have to abort the connection. The downside is
         * that the client will most likely not receive the error
         * message.
         */
        f->c->aborted = 1;
module AP_MODULE_DECLARE_DATA imagemap_module;
    icr = ap_get_module_config(r->per_dir_config, &imagemap_module);
module AP_MODULE_DECLARE_DATA imagemap_module =
    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, "text/xml");
    ap_set_content_type(r, apr_pstrdup(r->pool, info->content_type));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html;charset=utf-8");
    ap_set_content_type(r, "text/html");
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html");
                    ap_set_content_type(r, "text/plain");
    ap_set_content_type(r, "message/http");
AP_DECLARE(void) ap_set_content_type(request_rec *r, const char *ct)
        ap_set_content_type(r, "text/html; charset=iso-8859-1");
            ap_set_content_type(r, apr_pstrcat(r->pool, "multipart",
                                               use_range_x(r) ? "/x-" : "/",
                                               "byteranges; boundary=",
                                               r->boundary, NULL));
    ap_set_content_type(r, rr->content_type);
        ap_set_content_type(new, r->content_type);
        ap_set_content_type(r, DIR_MAGIC_TYPE);
                ap_set_content_type(r, (char*) type);
                ap_set_content_type(r, exinfo->forced_type);
	    ap_set_content_type(r, apr_pstrcat(r->pool, ctp->type, "/",
                                               ctp->subtype, NULL));
			ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                           "; charset=", charset,
                                                           NULL));
		    ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                       "; ", pp->attr,
                                                       "=", pp->val,
                                                       NULL));
		ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                   "; charset=", charset,
                                                   NULL));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(sub_req, CGI_MAGIC_TYPE);
        ap_set_content_type(r, t);
                ap_set_content_type(r, p->forced_mimetype);
	    ap_set_content_type(r, tmp);
	ap_set_content_type(r, tmp);
	ap_set_content_type(r, apr_pstrdup(r->pool, sub->content_type));
        ap_set_content_type(r, "text/html");
            ap_set_content_type(r, ap_default_type(r));
                    ap_set_content_type(r, apr_pstrdup(p, buf));
#include "util_script.h"

/*
 * mod_disk_cache configuration
 */
typedef struct {
    const char* cache_root;
    off_t space;                 /* Maximum cache size (in 1024 bytes) */
    apr_time_t maxexpire;        /* Maximum time to keep cached files in msecs */
    apr_time_t defaultexpire;    /* default time to keep cached file in msecs */
    double lmfactor;             /* factor for estimating expires date */
    apr_time_t gcinterval;       /* garbage collection interval, in msec */
    int dirlevels;               /* Number of levels of subdirectories */
    int dirlength;               /* Length of subdirectory names */
    int	expirychk;               /* true if expiry time is observed for cached files */
    apr_size_t minfs;            /* minumum file size for cached files */
    apr_size_t maxfs;            /* maximum file size for cached files */
    apr_time_t mintm;            /* minimum time margin for caching files */
    dgc_time_t gcdt;             /* time of day for daily garbage collection */
    apr_array_header_t *gcclnun; /* gc_retain_t entries for unused files */
    apr_array_header_t *gcclean; /* gc_retain_t entries for all files */
    int maxgcmem;                /* maximum memory used by garbage collection */
} disk_cache_conf;

apr_status_t file_cache_el_final(cache_info *info, cache_handle_t *h, request_rec *r);
static int file_cache_write_mydata(apr_file_t *fd , cache_info *info, request_rec *r);

/* XXX: This is defined in cache_util... Needs implementing */
extern int mkdir_structure(char *file, const char *root);
/* Forward declarations */
static int remove_entity(cache_handle_t *h);
static int write_headers(cache_handle_t *h, request_rec *r, cache_info *i);
static int write_body(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b);
static int read_headers(cache_handle_t *h, request_rec *r);
static int read_body(cache_handle_t *h, apr_pool_t *p, apr_bucket_brigade *bb);

static int create_entity(cache_handle_t *h, request_rec *r,
                         const char *type, 
                         const char *key, 
                         apr_size_t len)
{ 
    cache_object_t *obj;
    cache_info *info;
#ifdef AS400
    char tempfile[L_tmpnam];	/* L_tmpnam defined in stdio.h */
#endif

    if (strcasecmp(type, "disk")) {
	return DECLINED;
    }

    /* Allocate and initialize cache_object_t */
    obj = apr_pcalloc(r->pool, sizeof(cache_object_t));

    if (!obj) {
	return DECLINED;
    }

    obj->key = apr_pcalloc(r->pool, (strlen(key) + 1));
    if (!obj->key) {
	return DECLINED;
    }

    strncpy(obj->key, key, strlen(key) + 1);
    obj->info.len = len;
    obj->complete = 0;   /* Cache object is not complete */

    info = create_cache_el(r->pool, h, key);
    obj->info = *(info);

#ifdef AS400
    AP_INFO_TRACE("file_cache_element(): >>Generating temporary cache file name. (AP_CACHE_CREATE)\n");

    /* open temporary file */
    /* The RPM mktemp() utility is not available on the AS/400 so the	*/
    /* following is used to generate a unique, temporary file for the	*/
    /* cache element.							*/
    /* NOTE: Since this temporary file will need to be hard linked within	*/
    /*       the QOpenSys file system later on [by the file_cache_el_final()*/
    /*       routine] to make it a permanent file we must generate a name	*/
    /*       relative to the same file system, that is, QOpenSys. If we	*/
    /*       don't, the link() API will fail since hard links can't cross	*/
    /*       file systems on the AS/400.					*/

    /* 1st, a unique tempfile is made relative to root. */
    if(!tmpnam(tempfile)) {
	AP_ERROR_TRACE("file_cache_element(): R>Failed to produce unique temporary cache file name.\n");
	return APR_ENOENT;
    }
    /* Then a unique tempfile is made relative to QOpenSys. */
    if(!(obj->tempfile = apr_pstrcat(r->pool, AS400_CTEMP_ROOT, ap_strrchr_c(tempfile, '/')+1, NULL))) {
	return APR_ENOMEM;
    }
    
    AP_INFO_TRACE("file_cache_element(): .>Cache element using temporary file name %s.\n", obj->tempfile);
    ap_log_error400(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL, ZSRV_MSG153D, obj->tempfile);

#endif

    /* Populate the cache handle */
    h->cache_obj = obj;
    h->read_body = &read_body;
    h->read_headers = &read_headers;
    h->write_body = &write_body;
    h->write_headers = &write_headers;
    h->remove_entity = &remove_entity;

    return OK;
}

static int open_entity(cache_handle_t *h, apr_pool_t *p, const char *type, const char *key)
    apr_status_t ret = DECLINED;
    apr_status_t rc;
    char *data = data_file(h, p, key);
    apr_file_t *fd;
    apr_finfo_t finfo;
    cache_object_t *obj;
    cache_info *info;

    /* Look up entity keyed to 'url' */
    if (strcasecmp(type, "disk")) {
	return DECLINED;
    }

    obj = apr_pcalloc(p, sizeof(cache_object_t));
    obj->key = key;

    if((rc = apr_file_open(&fd, data, APR_WRITE | APR_READ | APR_BINARY, 0, p)) == APR_SUCCESS)  /*  Open the file  */
    {
	info = create_cache_el(p, h, key);
        /* XXX log message */
	info->fd = fd;
	info->datafile = data;
	info->hdrsfile = header_file(h, p, key);
	rc = apr_file_info_get(&finfo, APR_FINFO_SIZE, fd);
	if (rc == APR_SUCCESS)
	    info->file_size = finfo.size;
    }
    else if(errno==APR_ENOENT) {
        /* XXX log message */
	return DECLINED;
    }
    else {
        /* XXX log message */
	return DECLINED;
    }
    obj->info = *(info);

    /* Initialize the cache_handle */
    h->read_body = &read_body;
    h->read_headers = &read_headers;
    h->write_body = &write_body;
    h->write_headers = &write_headers;
    h->remove_entity = &remove_entity;
    h->cache_obj = obj;
    return OK;
}

static int remove_url(const char *type, char *key) 
{
}

static int remove_entity(cache_handle_t *h) 
{
    cache_object_t *obj = h->cache_obj;

    /* Null out the cache object pointer so next time we start from scratch  */
    h->cache_obj = NULL;

    return OK;
}

/*
 * Reads headers from a buffer and returns an array of headers.
 * Returns NULL on file error
 * This routine tries to deal with too long lines and continuation lines.
 * @@@: XXX: FIXME: currently the headers are passed thru un-merged. 
 * Is that okay, or should they be collapsed where possible?
 */
static int read_headers(cache_handle_t *h, request_rec *r) 
{
    char *temp;
    char urlbuff[1034];
    int urllen = sizeof(urlbuff);

    cache_info *info = &(h->cache_obj->info);

    if(!r->headers_out)
	r->headers_out = apr_table_make(r->pool, 20);

    if(!info->fd) {
        /* XXX log message */
        return APR_NOTFOUND; 
    }
    
    if (!info->hdrsfile || (apr_file_open(&fd, info->hdrsfile, 
                                         APR_READ | APR_BINARY,         /*  | APR_NONQSYS,  */
                                         0, r->pool) != APR_SUCCESS))
    {
	/* Error. Figure out which message(s) to log. */
	if(!info->hdrsfile) {
            /* XXX log message */
	    return APR_NOTFOUND;
	}
	else if(errno==APR_ENOENT) {
            /* XXX log message */
	}
	else {
            /* XXX log message */
	}
	return errno;
    }

    /* XXX log */
    if(rv = file_cache_read_mydata(fd, info, r) != APR_SUCCESS)
    {
        /* XXX log message */
        apr_file_close(fd);
        return rv;
    }
    
    /*
     * Call routine to read the header lines/status line 
    ap_scan_script_header_err(r, fd, NULL);
 
    apr_table_setn(r->headers_out, "Content-Type", ap_make_content_type(r,
        r->content_type));                           /* Set content type   */

    rv = apr_file_gets(&urlbuff[0], urllen, fd);           /* Read status  */
    if (rv != APR_SUCCESS)
    {
        /* XXX log message */
	return rv;
    r->status = atoi(urlbuff);                           /* Save status line into request rec  */

    rv = apr_file_gets(&urlbuff[0], urllen, fd);               /* Read status line */
    if (rv != APR_SUCCESS)
    {
        /* XXX log message */
	return rv;
    }

    if ((temp = strchr(&urlbuff[0], '\n')) != NULL)       /* trim off new line character */
	*temp = '\0';              /* overlay it with the null terminator */

    r->status_line = apr_pstrdup(r->pool, urlbuff);            /* Save status line into request rec  */


    apr_file_close(fd);

    return APR_SUCCESS;
}

static int read_body(cache_handle_t *h, apr_pool_t *p, apr_bucket_brigade *bb) 
{
    apr_bucket *e;
    cache_info *info = &(h->cache_obj->info);

    e = apr_bucket_file_create(info->fd, 0, info->file_size, p);
static int write_headers(cache_handle_t *h, request_rec *r, cache_info *info)
    disk_cache_conf *conf = ap_get_module_config(r->server->module_config, 
                                                 &disk_cache_module);
    apr_file_t *hfd = NULL;
    apr_status_t rc;
    char *buf;
    char statusbuf[8];
    apr_size_t amt;
    if (!info->fd)  {
        if(!info->hdrsfile) info->hdrsfile = header_file(h, r->pool, h->cache_obj->key);
        if(unlink(info->hdrsfile)) /* if we can remove it, we clearly don't have to build the dirs */
            mkdir_structure(info->hdrsfile, conf->cache_root);
        else {
            /* XXX log message */
        }
        if(rc = apr_file_open(&hfd, info->hdrsfile,
                              APR_WRITE | APR_CREATE | APR_BINARY | APR_EXCL, /* XXX:? | APR_INHERIT | APR_NONQSYS, */
                              0, r->pool) != APR_SUCCESS)   {
            /* XXX log message */
            return rc;
        }
	file_cache_write_mydata(hfd, info, r);
        if (r->headers_out) {
            int i;
            apr_table_entry_t *elts = (apr_table_entry_t *) apr_table_elts(r->headers_out)->elts;
            for (i = 0; i < apr_table_elts(r->headers_out)->nelts; ++i) {
                if (elts[i].key != NULL) {
                    buf = apr_pstrcat(r->pool, elts[i].key, ": ",  elts[i].val, CRLF, NULL);
                    amt = strlen(buf);
                    apr_file_write(hfd, buf, &amt);
                }
            }
            buf = apr_pstrcat(r->pool, CRLF, NULL);
            amt = strlen(buf);
            apr_file_write(hfd, buf, &amt);
        }
        sprintf(statusbuf,"%d", r->status);
        buf = apr_pstrcat(r->pool, statusbuf, CRLF, NULL);
        amt = strlen(buf);
        apr_file_write(hfd, buf, &amt);
        buf = apr_pstrcat(r->pool, r->status_line, '\n', NULL);
        amt = strlen(buf);
        apr_file_write(hfd, buf, &amt);
        buf = apr_pstrcat(r->pool, CRLF, NULL);
        amt = strlen(buf);
        apr_file_write(hfd, buf, &amt);
        apr_file_close(hfd); /* flush and close */
    }
    else {
        /* XXX log message */
    }
    return OK;
}
static int write_body(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b) 
{
    apr_bucket *e;
    apr_status_t rv;
    cache_info *info = &(h->cache_obj->info);
 
    if(!info->fd) {
        if ((rv = apr_file_open(&info->fd, h->cache_obj->tempfile, 
                                APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BUFFERED,
                                APR_UREAD | APR_UWRITE, r->pool)) != APR_SUCCESS) {
    }
    APR_BRIGADE_FOREACH(e, b) {
        apr_file_write(info->fd, str, &length);
    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(b))) {
        file_cache_el_final(info, h, r);    /* Link to the perm file, and close the descriptor  */
static int file_cache_write_mydata(apr_file_t *fd , cache_info *info, request_rec *r)
{
    apr_status_t rc;
    char *buf;
    apr_size_t amt;

    char	dateHexS[sizeof(apr_time_t) * 2 + 1];
    char	expireHexS[sizeof(apr_time_t) * 2 + 1];
    char	verHexS[sizeof(apr_time_t) * 2 + 1];
    
    if(!r->headers_out)
    {
        /* XXX log message */
        return 0;
    }

    ap_cache_msec2hex(info->date, dateHexS);
    ap_cache_msec2hex(info->expire, expireHexS);
    ap_cache_msec2hex(info->version++, verHexS);
    buf = apr_pstrcat(r->pool, dateHexS, " ", expireHexS, " ", verHexS, "\n", NULL);
    amt = strlen(buf);
    rc = apr_file_write(fd, buf, &amt);
    if(rc != APR_SUCCESS) {
        /* XXX log message */
        return 0;
    }

    buf = apr_pstrcat(r->pool, "X-NAME: ", info->name, "\n", NULL);
    amt = strlen(buf);
    rc = apr_file_write(fd, buf, &amt);
    if(rc != APR_SUCCESS) {
        /* XXX log message */
        return 0;
    }
    return 1;
}

apr_status_t file_cache_el_final(cache_info *info, cache_handle_t *h, request_rec *r)
{
    disk_cache_conf *conf = ap_get_module_config(r->server->module_config,
                                                 &disk_cache_module);

    /* move the data over */
    if (info->fd) {
        apr_file_flush(info->fd);
        if (!info->datafile) info->datafile = data_file(h, r->pool, h->cache_obj->key);  /* by: wsf @A1A */
        if (unlink(info->datafile)) /* if we can remove it, we clearly don't have to build the dirs */
            mkdir_structure(info->datafile, conf->cache_root);
        else {
            /* XXX log */
        }
        if (link(h->cache_obj->tempfile, info->datafile) == -1) {
            /* XXX log */
        }
        else {
            /* XXX log message */
        }
       if (unlink(h->cache_obj->tempfile) == -1) {
           /* XXX log message */
       }
       else {
           /* XXX log message */
       }
   }
   if (info->fd) {
       apr_file_close(info->fd);     /* if you finalize, you are done writing, so close it */
       info->fd = 0;
       /* XXX log */
   }

   return APR_SUCCESS;
}

static void *create_config(apr_pool_t *p, server_rec *s)
{
    disk_cache_config conf = apr_pcalloc(p, sizeof(disk_cache_conf));

    /* XXX: Set default values */

    return conf;
}

/*
 * mod_disk_cache configuration directives
 */
static const char
*set_cache_root(cmd_parms *parms, void *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    conf->cache_root = arg;
    return NULL;
}
static const char
*set_cache_size(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
static const char
*set_cache_gcint(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
static const char
*set_cache_dirlevels(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
static const char
*set_cache_dirlength(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
static const char
*set_cache_exchk(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
static const char
*set_cache_minfs(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
static const char
*set_cache_maxfs(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
static const char
*set_cache_minetm(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
static const char
*set_cache_gctime(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
static const char
*add_cache_gcclean(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
static const char
*add_cache_gcclnun(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
*set_cache_maxgcmem(cmd_parms *parms, char *struct_ptr, char *arg)
{
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                 &disk_cache_module);
    /* XXX */
    return NULL;
}
static const command_rec disk_cache_cmds[] =
{
    AP_INIT_FLAG("CacheRoot", set_cache_root, NULL, RSRC_CONF,
                 "The directory to store cache files"),
    AP_INIT_TAKE1("CacheSize", set_cache_size, NULL, RSRC_CONF,
                  "The maximum disk space used by the cache in Kb"),
    AP_INIT_TAKE1("CacheGcInterval", set_cache_gcint, NULL, RSRC_CONF,
                  "The interval between garbage collections, in hours"),
    AP_INIT_TAKE1("CacheDirLevels", set_cache_dirlevels, NULL, RSRC_CONF,
                  "The number of levels of subdirectories in the cache"),
    AP_INIT_TAKE1("CacheDirLength", set_cache_dirlength, NULL, RSRC_CONF,
                  "The number of characters in subdirectory names"),
    AP_INIT_FLAG("CacheExpiryCheck", set_cache_exchk, NULL, RSRC_CONF,
                 "on if cache observes Expires date when seeking files"),
    AP_INIT_TAKE1("CacheMinFileSize", set_cache_minfs, NULL, RSRC_CONF,
                  "The minimum file size to cache a document"),
    AP_INIT_TAKE1("CacheMaxFileSize", set_cache_maxfs, NULL, RSRC_CONF,
                  "The maximum file size to cache a document"),
    AP_INIT_TAKE1("CacheTimeMargin", set_cache_minetm, NULL, RSRC_CONF,
                  "The minimum time margin to cache a document"),
    AP_INIT_TAKE1("CacheGcDaily", set_cache_gctime, NULL, RSRC_CONF,
                  "The time of day for garbage collection (24 hour clock)"),
    AP_INIT_TAKE2("CacheGcUnused", add_cache_gcclnun, NULL, RSRC_CONF,
                  "The time in hours to retain unused file that match a url"),
    AP_INIT_TAKE2("CacheGcClean", add_cache_gcclean, NULL, RSRC_CONF,
                  "The time in hours to retain unchanged files that match a url"),
    AP_INIT_TAKE1("CacheGcMemUsage", set_cache_maxgcmem, NULL, RSRC_CONF,
                  "The maximum kilobytes of memory used for garbage collection"),
    {NULL}
};

    /* cache initializer */
    cache_hook_create_entity(create_entity, NULL, NULL, APR_HOOK_MIDDLE);
    cache_hook_open_entity(open_entity,  NULL, NULL, APR_HOOK_MIDDLE);
/*    cache_hook_remove_entity(remove_entity, NULL, NULL, APR_HOOK_MIDDLE); */
    NULL,                       /* create per-directory config structure */
    NULL,                       /* merge per-directory config structures */
    create_config,              /* create per-server config structure */
    NULL,                       /* merge per-server config structures */
    disk_cache_cmds,	        /* command apr_table_t */
    proxy_server_conf *ps = apr_pcalloc(p, sizeof(proxy_server_conf));

    ps->sec_proxy = apr_array_make(p, 10, sizeof(ap_conf_vector_t *));
    ps->proxies = apr_array_make(p, 10, sizeof(struct proxy_remote));
    ps->aliases = apr_array_make(p, 10, sizeof(struct proxy_alias));
    ps->raliases = apr_array_make(p, 10, sizeof(struct proxy_alias));
    ps->noproxies = apr_array_make(p, 10, sizeof(struct noproxy_entry));
    ps->dirconn = apr_array_make(p, 10, sizeof(struct dirconn_entry));
    ps->allowed_connect_ports = apr_array_make(p, 10, sizeof(int));
    proxy_server_conf *ps = apr_pcalloc(p, sizeof(proxy_server_conf));
        if (ch == '%' && apr_isxdigit(x[i + 1]) && apr_isxdigit(x[i + 2])) {
        if (ch == '%' && apr_isxdigit(x[i + 1]) && apr_isxdigit(x[i + 2])) {
        apr_cpystrn(message, cmd, sizeof(message));
        *pmessage = apr_pstrdup(r->pool, message);
    char dates[APR_RFC822_DATE_LEN];
        backend = apr_pcalloc(c->pool, sizeof(proxy_conn_rec));
        && apr_isalpha(type_suffix[5])) {
        if ( ! (dirlisting = (apr_tolower(type_suffix[5]) == 'd')))
            xfer_type = apr_toupper(type_suffix[5]);
            apr_table_add(r->headers_out, "Retry-After",
                          apr_psprintf(p, "%lu", (unsigned long)(60 * secs)));
                apr_table_mergen(r->headers_out, "Via",
                                 (conf->viaopt == via_full)
                                     ? apr_psprintf(p, "%d.%d %s%s (%s)",
                                           HTTP_VERSION_MAJOR(r->proto_num),
                                           HTTP_VERSION_MINOR(r->proto_num),
                                           ap_get_server_name(r),
                                           server_portstr,
                                           AP_SERVER_BASEVERSION)
                                     : apr_psprintf(p, "%d.%d %s%s",
                                           HTTP_VERSION_MAJOR(r->proto_num),
                                           HTTP_VERSION_MINOR(r->proto_num),
                                           ap_get_server_name(r),
                                           server_portstr)
        backend = apr_pcalloc(c->pool, sizeof(proxy_conn_rec));
	    if (!apr_isxdigit(x[i + 1]) || !apr_isxdigit(x[i + 2]))
	    if (strcmp(week, apr_day_snames[wk]) == 0)
	if (strcmp(month, apr_month_snames[mon]) == 0)
    apr_snprintf(q, 30, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", apr_day_snames[wk],
       mday, apr_month_snames[mon], year, hour, min, sec);
    headers_out = apr_table_make(r->pool, 20);
    apr_pool_t *pool;
    apr_table_t *header_out;
    apr_table_t *req_hdrs; /* for Vary negotiation */

    apr_pool_destroy(mobj->pool);
    apr_status_t rv;
    apr_pool_t *pool;
    rv = apr_pool_create(&pool, NULL);

    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_WARNING, rv, r->server,
                     "mem_cache: Failed to create memory pool.");

    /* Allocate and initialize cache_object_t */
    obj = apr_pcalloc(pool, sizeof(*obj));
    obj->key = apr_pstrdup(pool, key);
    mobj = apr_pcalloc(pool, sizeof(*mobj));
    mobj->pool = pool;
    h->req_hdrs = apr_table_copy(r->pool, mobj->req_hdrs);
    h->resp_hdrs = apr_table_copy(r->pool, mobj->header_out);
    return OK;
    mobj->req_hdrs = apr_table_copy(mobj->pool, r->headers_in);
    mobj->header_out = apr_table_copy(mobj->pool, headers_out);
                mobj->m = realloc(mobj->m, obj->count);
                if (!mobj->m) {
typedef struct
{
    const char *name;           /* matching module name */
    const char *info;           /* additional info */
typedef struct
{
static void *create_info_config(apr_pool_t * p, server_rec *s)
    info_svr_conf *conf =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t * p, void *basev, void *overridesv)
    info_svr_conf *new =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info =
        apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec *r, int nest, const char *thisfn,
                            int linenum)
    const char *prevfn =
        ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL)
        thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n",
                   thisfn);
    if (linenum > 0)
        sprintf(buf, "%d", linenum);
    else
        buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i)
        ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i)
        ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec *r, const ap_directive_t * dir,
                              int nest)
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec *r, const ap_directive_t * dir,
                               int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n",
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec *r, const ap_directive_t * dir,
    }
    else {
        ap_rprintf(r, "/%s</tt></dd>", ap_escape_html(r->pool, dirname));
    }

static int mod_info_has_cmd(const command_rec *cmds, ap_directive_t * dir)
    const command_rec *cmd;
    if (cmds == NULL)
        return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0)
            return 1;
    }
static void mod_info_show_parents(request_rec *r, ap_directive_t * node,
                                  int from, int to)
{
    if (from < to)
        mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec *r, const command_rec *cmds,
    ap_directive_t *dir;
    if (level == 0)
        ap_set_module_config(r->request_config, &info_module, NULL);
                                             shown, level + 1)) {
        }
        else if (mod_info_has_cmd(cmds, dir)) {
        }
typedef struct
{                               /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc) (void);       /* just to get the right size */
    const char *const *aszPredecessors;
    const char *const *aszSuccessors;
typedef apr_array_header_t *(
                                __stdcall
                                * hook_get_t)      (void);
typedef struct
{
static int module_find_hook(module *modp, hook_get_t hook_get)
    elts = (hook_struct_t *) hooks->elts;
    for (i = 0; i < hooks->nelts; i++) {
                               hook_lookup_t * lookup, int *comma)
    int i, comma = 0;
    for (i = 0; request_hooks[i].name; i++) {
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
        return DECLINED;
             "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n",
             r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ",
                     r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name,
                           modp->name);
            ap_rprintf(r,
                       "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                       ap_get_server_version());
            ap_rprintf(r,
                       "<dt><strong>Server Built:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                       ap_get_server_built());
            ap_rprintf(r,
                       "<dt><strong>API Version:</strong> "
                       "<tt>%d:%d</tt></dt>\n", MODULE_MAGIC_NUMBER_MAJOR,
                       MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r,
                       "<dt><strong>Hostname/port:</strong> "
                       "<tt>%s:%u</tt></dt>\n", ap_get_server_name(r),
                       ap_get_server_port(r));
            ap_rprintf(r,
                       "<dt><strong>Timeouts:</strong> "
                       "<tt>connection: %d &nbsp;&nbsp; "
                       "keep-alive: %d</tt></dt>",
                       (int) (apr_time_sec(serv->timeout)),
                       (int) (apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n",
                       ap_show_mpm());
            ap_rprintf(r,
                       "<dt><strong>MPM Information:</strong> "
                       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r,
                       "<dt><strong>Server Root:</strong> "
                       "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r,
                       "<dt><strong>Config File:</strong> "
                       "<tt>%s</tt></dt>\n", ap_conftree->filename);
            for (modp = ap_top_module; modp; modp = modp->next) {
                if (!r->args || !strcasecmp(modp->name, r->args)) {
                    ap_rprintf(r,
                               "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                               "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                               modp->name, modp->name);
                    ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                    hand = modp->handlers;
                    if (hand) {
                        while (hand) {
                            if (hand->content_type) {
                                ap_rprintf(r, " <tt>%s</tt>\n",
                                           hand->content_type);
                            }
                            else {
                                break;
                            }
                            hand++;
                            if (hand && hand->content_type) {
                                ap_rputs(",", r);
                            }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    if (module_find_hook(modp, ap_hook_get_handler)) {
                        ap_rputs("<tt> <em>yes</em></tt>", r);
                    }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    ap_rputs("</dt>", r);
                    ap_rputs
                        ("<dt><strong>Configuration Phase Participation:</strong>\n",
                         r);
                    if (modp->create_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Directory Config</tt>", r);
                        comma = 1;
                    if (modp->merge_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Directory Configs</tt>", r);
                        comma = 1;
                    if (modp->create_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Server Config</tt>", r);
                        comma = 1;
                    if (modp->merge_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Server Configs</tt>", r);
                        comma = 1;
                    if (!comma)
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    comma = 0;
                    ap_rputs("</dt>", r);

                    module_request_hook_participate(r, modp);

                    cmd = modp->cmds;
                    if (cmd) {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong></dt>",
                             r);
                        while (cmd) {
                            if (cmd->name) {
                                ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                           ap_escape_html(r->pool, cmd->name),
                                           cmd->name[0] == '<' ? "&gt;" : "");
                                if (cmd->errmsg) {
                                    ap_rputs(cmd->errmsg, r);
                                }
                                ap_rputs("</i></tt></dd>\n", r);
                            else {
                                break;
                            }
                            cmd++;
                        ap_rputs
                            ("<dt><strong>Current Configuration:</strong></dt>\n",
                             r);
                        mod_info_module_cmds(r, modp->cmds, ap_conftree, 0,
                                             0);
                    }
                    else {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>",
                             r);
                    }
                    more_info = find_more_info(serv, modp->name);
                    if (more_info) {
                        ap_rputs
                            ("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                             r);
                        ap_rputs(more_info, r);
                        ap_rputs("</dd>", r);
                    }
                    ap_rputs("</dl><hr />\n", r);
                    if (r->args) {
                        break;
            if (!modp && r->args && strcasecmp(r->args, "server")) {
                ap_rputs("<p><b>No such module</b></p>\n", r);
            }
    ap_rputs(ap_psignature("", r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy,
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
static const command_rec info_cmds[] = {
static void register_hooks(apr_pool_t * p)
module AP_MODULE_DECLARE_DATA info_module = {
    int interim_response; /* non-zero whilst interim 1xx responses
                           * are being read. */
    do {
        interim_response = ap_is_HTTP_INFO(r->status);
        if (interim_response) {
                         "proxy: HTTP: received interim %d response",
                         r->status);
            !interim_response &&                   /* not any 1xx response */
    } while (interim_response);
            if ((status != HTTP_NO_CONTENT) && /* not 204 */
#if !APR_HAS_SHARED_MEMORY
    if (flag) {
        return "AuthDigestNcCheck: ERROR: nonce-count checking "
                     "support";
#endif
        return "AuthDigestAlgorithm: ERROR: algorithm `MD5-sess' "
                "is not fully implemented";
    if (conf->check_nc && !client_shm) {
        /* Shouldn't happen, but just in case... */
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                      "Digest: cannot check nonce count without shared memory");
        return OK;
    }

    /** Did we use HTTP Keep-Alive? */
    unsigned keptalive:1;
    /** How many times have we used it? */
    int keepalives;
	    || (r->server->keep_alive_max > r->connection->keepalives))
        int left = r->server->keep_alive_max - r->connection->keepalives;
        r->connection->keepalives++;
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;

#if 0
    conn_rec *conn = r->connection;
#endif
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
	    /* this is a hack to make sure that request time is set,
	     * it's not perfect, but it's better than nothing 
	     */
	    r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */

    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk

#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */

    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);

#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week 
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method); 
#endif
    uri = ap_getword_white(r->pool, &ll);

    /* Provide quick information about the request method as soon as known */

    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }

    ap_parse_uri(r, uri);

    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }

    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
 	r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))	/* don't allow HTTP/0.1000 */
	r->proto_num = HTTP_VERSION(major, minor);
    else
	r->proto_num = HTTP_VERSION(1,0);

    return 1;
}

    conn->keptalive    = conn->keepalive == 1;
    conn->keepalive    = 0;

    ap_run_create_request(r);
    r->the_request     = NULL;
    apr_setsocketopt(conn->client_socket, APR_SO_TIMEOUT, 
                     (int)(conn->keptalive
                     ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                     : r->server->timeout * APR_USEC_PER_SEC));
                     
    /* Get the request... */
    if (!read_request_line(r)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
			  "request failed: URI too long");
            ap_send_error_response(r, 0);
            ap_run_log_transaction(r);
            return r;
        }
        return NULL;
    }
    if (r->connection->keptalive) {
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(r->server->timeout * APR_USEC_PER_SEC));
    }
    conn->keptalive = 0;        /* We now have a request to play with */

    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, "text/xml");
    ap_set_content_type(r, apr_pstrdup(r->pool, info->content_type));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html;charset=utf-8");
    ap_set_content_type(r, "text/html");
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html");
                    ap_set_content_type(r, "text/plain");
    ap_set_content_type(r, "message/http");
AP_DECLARE(void) ap_set_content_type(request_rec *r, const char *ct)
        ap_set_content_type(r, "text/html; charset=iso-8859-1");
            ap_set_content_type(r, apr_pstrcat(r->pool, "multipart",
                                               use_range_x(r) ? "/x-" : "/",
                                               "byteranges; boundary=",
                                               r->boundary, NULL));
    ap_set_content_type(r, rr->content_type);
        ap_set_content_type(new, r->content_type);
        ap_set_content_type(r, DIR_MAGIC_TYPE);
                ap_set_content_type(r, (char*) type);
                ap_set_content_type(r, exinfo->forced_type);
	    ap_set_content_type(r, apr_pstrcat(r->pool, ctp->type, "/",
                                               ctp->subtype, NULL));
			ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                           "; charset=", charset,
                                                           NULL));
		    ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                       "; ", pp->attr,
                                                       "=", pp->val,
                                                       NULL));
		ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                   "; charset=", charset,
                                                   NULL));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(sub_req, CGI_MAGIC_TYPE);
        ap_set_content_type(r, t);
                ap_set_content_type(r, p->forced_mimetype);
	    ap_set_content_type(r, tmp);
	ap_set_content_type(r, tmp);
	ap_set_content_type(r, apr_pstrdup(r->pool, sub->content_type));
        ap_set_content_type(r, "text/html");
            ap_set_content_type(r, ap_default_type(r));
                    ap_set_content_type(r, apr_pstrdup(p, buf));
    cache_server_conf *conf =
      (cache_server_conf *)ap_get_module_config(r->server->module_config,
                                                &cache_module);
                     "Incoming request is asking for a uncached version of "
    if (!conf->ignorecachecontrol
        && cc_req && ap_cache_liststr(r->pool, cc_req, "max-age", &val)) {
    if (!conf->ignorecachecontrol
        && cc_req && ap_cache_liststr(r->pool, cc_req, "min-fresh", &val)) {
        const char *escpath;
        escpath = ap_escape_html(p, path);
                "<base href=\"%s%s%s\">\n"
                site, basedir, escpath, site, basedir, escpath, site, str);

/**
 * Send an interim (HTTP 1xx) response immediately.
 * @param r The request
 */
AP_DECLARE(void) ap_send_interim_response(request_rec *r);
typedef struct hdr_ptr {
    ap_filter_t *f;
    apr_bucket_brigade *bb;
} hdr_ptr;
static int send_header(void *data, const char *key, const char *val)
{
    ap_fputstrs(((hdr_ptr*)data)->f, ((hdr_ptr*)data)->bb,
                key, ": ", val, CRLF, NULL);
    return 1;
}
AP_DECLARE(void) ap_send_interim_response(request_rec *r)
{
    hdr_ptr x;

    if (r->proto_num < 1001) {
        /* don't send interim response to HTTP/1.0 Client */
        return;
    }
    if (!ap_is_HTTP_INFO(r->status)) {
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                      "Status is %d - not sending interim response", r->status);
        return;
    }

    x.f = r->connection->output_filters;
    x.bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    ap_fputstrs(x.f, x.bb, AP_SERVER_PROTOCOL, " ", r->status_line, CRLF, NULL);
    apr_table_do(send_header, &x, r->headers_out, NULL);
    ap_fputs(x.f, x.bb, CRLF);
    ap_fflush(x.f, x.bb);
    apr_brigade_destroy(x.bb);
    apr_table_clear(r->headers_out);
}


    int connect = 0, use_port = 0;
		 "proxy: FTP: connecting %s to %s:%d", url, connectname, connectport);
                      "proxy: FTP: error creating socket");
		     "proxy: FTP: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
		 "proxy: FTP: socket has been created");
			     "proxy: FTP: attempt to connect to %pI (%s) failed", connect_addr, connectname);
		     "proxy: FTP: an error occurred creating a new connection to %pI (%s)", connect_addr, connectname);
		 "proxy: FTP: control connection complete");
    apr_table_set(r->notes, "Directory-README", buffer);
     * Try EPSV, if that fails...
     * try PASV, if that fails...
     * try PORT.
/* this temporarily switches off EPSV/PASV */
    /* set up data connection - EPSV */
    {
	apr_sockaddr_t *remote_addr;
	char *remote_ip;
	apr_port_t remote_port;

	/* The EPSV command replaces PASV where both IPV4 and IPV6 is supported. Only
	 * the port is returned, the IP address is always the same as that on the
	 * control connection. Example:
	 *   Entering Extended Passive Mode (|||6446|)
	 */
	buf = apr_pstrcat(p, "EPSV", CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                     "proxy: FTP: EPSV");
	/* possible results: 227, 421, 500, 501, 502, 530 */
	/*   227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   502 Command not implemented. */
	/*   530 Not logged in. */
	i = ftp_getrc_msg(origin, cbb, buffer, sizeof(buffer));
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: FTP: %d %s", i, buffer);
	if (i == -1) {
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				 "Error reading from remote server");
	}
	if (i != 229 && i != 500 && i != 501 && i != 502) {
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
	}
	else if (i == 229) {
	    char *pstr;

	    pstr = apr_pstrdup(p, buffer);
	    pstr = strtok(pstr, " ");	/* separate result code */
	    if (pstr != NULL) {
		if (*(pstr + strlen(pstr) + 1) == '=') {
		    pstr += strlen(pstr) + 2;
		}
		else {
		    pstr = strtok(NULL, "(");  /* separate address & port params */
		    if (pstr != NULL)
			pstr = strtok(NULL, ")");
		}
	    }
	    if (pstr) {
		apr_sockaddr_t *epsv_addr;
		remote_port = atoi(pstr+3);

        	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                             "proxy: FTP: EPSV contacting remote host on port %d",
                             remote_port);
		if ((rv = apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
			          "proxy: FTP: error creating EPSV socket");
		    return HTTP_INTERNAL_SERVER_ERROR;
		}

#if !defined (TPF) && !defined(BEOS)
		if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
		    conf->recv_buffer_size))) {
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
				  "proxy: FTP: setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
		}
#endif

		/* make the connection */
		apr_socket_addr_get(&remote_addr, APR_REMOTE, sock);
		apr_sockaddr_ip_get(&remote_ip, remote_addr);
		apr_sockaddr_info_get(&epsv_addr, remote_ip, APR_INET, remote_port, 0, p);
		rv = apr_connect(remote_sock, epsv_addr);
		if (rv != APR_SUCCESS) {
		    ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
				 "proxy: FTP: EPSV attempt to connect to %pI failed - Firewall/NAT?", epsv_addr);
		    return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_psprintf(r->pool,
				         "EPSV attempt to connect to %pI failed - firewall/NAT?", epsv_addr));
		}
		else {
		    connect = 1;
		}
		/* and try the regular way */
		apr_socket_close(remote_sock);
    }

    /* set up data connection - PASV */
    if (!connect) {
	buf = apr_pstrcat(p, "PASV", CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                     "proxy: FTP: PASV");
	/* possible results: 227, 421, 500, 501, 502, 530 */
	/*   227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   502 Command not implemented. */
	/*   530 Not logged in. */
	i = ftp_getrc_msg(origin, cbb, buffer, sizeof(buffer));
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: FTP: %d %s", i, buffer);
	if (i == -1) {
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				 "Error reading from remote server");
	}
	if (i != 227 && i != 502) {
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
	}
	else if (i == 227) {
	    unsigned int h0, h1, h2, h3, p0, p1;
	    char *pstr;

/* FIXME: Check PASV against RFC1123 */

	    pstr = apr_pstrdup(p, buffer);
	    pstr = strtok(pstr, " ");	/* separate result code */
	    if (pstr != NULL) {
		if (*(pstr + strlen(pstr) + 1) == '=') {
		    pstr += strlen(pstr) + 2;
		}
		else {
		    pstr = strtok(NULL, "(");  /* separate address & port params */
		    if (pstr != NULL)
			pstr = strtok(NULL, ")");
		}
	    }
	    if (pstr != NULL && (sscanf(pstr,
		"%d,%d,%d,%d,%d,%d", &h3, &h2, &h1, &h0, &p1, &p0) == 6)) {
		apr_sockaddr_t *pasv_addr;
		int pasvport = (p1 << 8) + p0;
        	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                             "proxy: FTP: PASV contacting host %d.%d.%d.%d:%d",
                             h3, h2, h1, h0, pasvport);
		if ((rv = apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
			          "proxy: error creating PASV socket");
		    return HTTP_INTERNAL_SERVER_ERROR;
		}
		if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
		    conf->recv_buffer_size))) {
				  "proxy: FTP: setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
		}
		/* make the connection */
		apr_sockaddr_info_get(&pasv_addr, apr_psprintf(p, "%d.%d.%d.%d", h3, h2, h1, h0), APR_INET, pasvport, 0, p);
		rv = apr_connect(remote_sock, pasv_addr);
		if (rv != APR_SUCCESS) {
		    ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
				 "proxy: FTP: PASV attempt to connect to %pI failed - Firewall/NAT?", pasv_addr);
		    return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_psprintf(r->pool,
				         "PASV attempt to connect to %pI failed - firewall/NAT?", pasv_addr));
		}
		else {
		    connect = 1;
		}
	    }
		/* and try the regular way */
		apr_socket_close(remote_sock);
    /* set up data connection - PORT */
    if (!connect) {

	    /* signal that we must use the EPRT/PORT loop */
	    use_port = 1;
	    return ap_proxyerror(r, HTTP_NOT_IMPLEMENTED, "Connect to IPV6 ftp server using EPRT not supported. Enable EPSV.");
    if (use_port) {
     * - white space between the tokens
                char *last;
                value += strspn(value, " \t");  /* Move past leading WS */
                last = value + strlen(value);
                while (last >= value && apr_isspace(*last)) {
                   *last = '\0';
                   --last;
                }

    note = apr_pstrcat(m->pool, MOD_SESSION_COOKIE, name, NULL);
    zz = (session_rec *) apr_pcalloc(m->pool, sizeof(session_rec));
    zz->pool = m->pool;
    zz->entries = apr_table_make(m->pool, 10);
    zz->uuid = (apr_uuid_t *) apr_pcalloc(m->pool, sizeof(apr_uuid_t));
    imap_conf_rec *new = (imap_conf_rec *) apr_palloc(p, sizeof(imap_conf_rec));
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted") && *comment) {
    else if (!strcasecmp(menu, "unformatted") && *comment) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    X509 *peercert;
                    ((peercert = SSL_get_peer_certificate(ssl)) != NULL))
                    X509_free(peercert);
            if (do_verify) {
                if ((peercert = SSL_get_peer_certificate(ssl)) == NULL) {
                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                                 "Re-negotiation handshake failed: "
                                 "Client certificate missing");
                    return HTTP_FORBIDDEN;
                }

                X509_free(peercert);
    /** Did we use HTTP Keep-Alive? */
    unsigned keptalive:1;
    /** How many times have we used it? */
    int keepalives;
	    || (r->server->keep_alive_max > r->connection->keepalives))
        int left = r->server->keep_alive_max - r->connection->keepalives;
        r->connection->keepalives++;
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;

#if 0
    conn_rec *conn = r->connection;
#endif
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
	    /* this is a hack to make sure that request time is set,
	     * it's not perfect, but it's better than nothing 
	     */
	    r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */

    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk

#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */

    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);

#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week 
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method); 
#endif
    uri = ap_getword_white(r->pool, &ll);

    /* Provide quick information about the request method as soon as known */

    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }

    ap_parse_uri(r, uri);

    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }

    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
 	r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))	/* don't allow HTTP/0.1000 */
	r->proto_num = HTTP_VERSION(major, minor);
    else
	r->proto_num = HTTP_VERSION(1,0);

    return 1;
}

    conn->keptalive    = conn->keepalive == 1;
    conn->keepalive    = 0;

    ap_run_create_request(r);
    r->the_request     = NULL;
    apr_setsocketopt(conn->client_socket, APR_SO_TIMEOUT, 
                     (int)(conn->keptalive
                     ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                     : r->server->timeout * APR_USEC_PER_SEC));
                     
    /* Get the request... */
    if (!read_request_line(r)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
			  "request failed: URI too long");
            ap_send_error_response(r, 0);
            ap_run_log_transaction(r);
            return r;
        }
        return NULL;
    }
    if (r->connection->keptalive) {
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(r->server->timeout * APR_USEC_PER_SEC));
    }
    conn->keptalive = 0;        /* We now have a request to play with */

    /* RFC 2616:
     *   Request-URI    = "*" | absoluteURI | abs_path | authority
     *
     * authority is a special case for CONNECT.  If the request is not
     * using CONNECT, and the parsed URI does not have scheme, and
     * it does not begin with '/', and it is not '*', then, fail
     * and give a 400 response. */
    if (r->method_number != M_CONNECT 
        && !r->parsed_uri.scheme 
        && uri[0] != '/'
        && !(uri[0] == '*' && uri[1] == '\0')) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "invalid request-URI %s", uri);
        r->args = NULL;
        r->hostname = NULL;
        r->status = HTTP_BAD_REQUEST;
        r->uri = apr_pstrdup(r->pool, uri);
    }

/**
 * Unescape a string
 * @param url The string to unescape
 * @return 0 on success, non-zero otherwise
 */
AP_DECLARE(int) ap_unescape_all(char *url);

/**
 * Escape a path segment, as defined in RFC 1808, to a preallocated buffer.
 * @param c The preallocated buffer to write to
 * @param s The path to convert
 * @return The converted URL (c)
 */
AP_DECLARE(char *) ap_escape_path_segment_b(char *c, const char *s);

/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define CORE_PRIVATE

#include "mod_session.h"
#include "apr_lib.h"
#include "apr_strings.h"
#include "util_filter.h"
#include "http_log.h"
#include "http_request.h"
#include "http_protocol.h"

#define SESSION_PREFIX "mod_session: "
#define SESSION_EXPIRY "expiry"
#define HTTP_SESSION "HTTP_SESSION"

APR_HOOK_STRUCT(
                APR_HOOK_LINK(session_load)
                APR_HOOK_LINK(session_save)
                APR_HOOK_LINK(session_encode)
                APR_HOOK_LINK(session_decode)
)
AP_IMPLEMENT_HOOK_RUN_FIRST(int, session_load,
                      (request_rec * r, session_rec ** z), (r, z), DECLINED)
AP_IMPLEMENT_HOOK_RUN_FIRST(int, session_save,
                       (request_rec * r, session_rec * z), (r, z), DECLINED)
AP_IMPLEMENT_HOOK_RUN_ALL(int, session_encode,
                   (request_rec * r, session_rec * z), (r, z), OK, DECLINED)
AP_IMPLEMENT_HOOK_RUN_ALL(int, session_decode,
                   (request_rec * r, session_rec * z), (r, z), OK, DECLINED)
/**
 * Should the session be included within this URL.
 *
 * This function tests whether a session is valid for this URL. It uses the
 * include and exclude arrays to determine whether they should be included.
 */
    static int session_included(request_rec * r, session_dir_conf * conf)
{

    const char **includes = (const char **) conf->includes->elts;
    const char **excludes = (const char **) conf->excludes->elts;
    int included = 1;                /* defaults to included */
    int i;

    if (conf->includes->nelts) {
        included = 0;
        for (i = 0; !included && i < conf->includes->nelts; i++) {
            const char *include = includes[i];
            if (strncmp(r->parsed_uri.path, include, strlen(include))) {
                included = 1;
            }
        }
    }

    if (conf->excludes->nelts) {
        for (i = 0; included && i < conf->includes->nelts; i++) {
            const char *exclude = excludes[i];
            if (strncmp(r->parsed_uri.path, exclude, strlen(exclude))) {
                included = 0;
            }
        }
    }

    return included;
}

/**
 * Get a particular value from the session.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to get.
 * @param value The buffer to write the value to.
 */
AP_DECLARE(void) ap_session_get(request_rec * r, session_rec * z, const char *key, const char **value)
{
    if (!z) {
        ap_session_load(r, &z);
    }
    *value = apr_table_get(z->entries, key);
}

/**
 * Set a particular value to the session.
 *
 * Using this method ensures that the dirty flag is set correctly, so that
 * the session can be saved efficiently.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to set. The existing key value will be replaced.
 * @param value The value to set.
 */
AP_DECLARE(void) ap_session_set(request_rec * r, session_rec * z,
                                const char *key, const char *value)
{
    if (!z) {
        ap_session_load(r, &z);
    }
    if (value) {
        apr_table_set(z->entries, key, value);
    }
    else {
        apr_table_unset(z->entries, key);
    }
    z->dirty = 1;
}

/**
 * Load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_load(request_rec * r, session_rec ** z)
{

    session_dir_conf *dconf = ap_get_module_config(r->per_dir_config,
                                                   &session_module);
    apr_time_t now;
    session_rec *zz = NULL;

    /* is the session enabled? */
    if (!dconf->enabled) {
        return APR_SUCCESS;
    }

    /* should the session be loaded at all? */
    if (!session_included(r, dconf)) {
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, SESSION_PREFIX
                      "excluded by configuration for: %s", r->uri);
        return APR_SUCCESS;
    }

    /* load the session from the session hook */
    int rv = ap_run_session_load(r, &zz);
    if (DECLINED == rv) {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                      "session is enabled but no session modules have been configured, "
                      "session not loaded: %s", r->uri);
        return APR_EGENERAL;
    }
    else if (OK != rv) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                      "error while loading the session, "
                      "session not loaded: %s", r->uri);
        return rv;
    }

    /* found a session that hasn't expired? */
    now = apr_time_now();
    if (!zz || (zz->expiry && zz->expiry < now)) {

        /* no luck, create a blank session */
        zz = (session_rec *) apr_pcalloc(r->pool, sizeof(session_rec));
        zz->pool = r->pool;
        zz->entries = apr_table_make(zz->pool, 10);
        zz->uuid = (apr_uuid_t *) apr_pcalloc(zz->pool, sizeof(apr_uuid_t));
        apr_uuid_get(zz->uuid);

    }
    else {
        rv = ap_run_session_decode(r, zz);
        if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while decoding the session, "
                          "session not loaded: %s", r->uri);
            return rv;
        }
    }

    /* make sure the expiry is set, if present */
    if (!zz->expiry && dconf->maxage) {
        zz->expiry = now + dconf->maxage * APR_USEC_PER_SEC;
        zz->maxage = dconf->maxage;
    }

    *z = zz;

    return APR_SUCCESS;

}

/**
 * Save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_save(request_rec * r, session_rec * z)
{
    if (z) {
        apr_time_t now = apr_time_now();
        int rv = 0;

        /* sanity checks, should we try save at all? */
        if (z->written) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, SESSION_PREFIX
                          "attempt made to save the session twice, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }
        if (z->expiry && z->expiry < now) {
            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                          "attempt made to save a session when the session had already expired, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }

        /* encode the session */
        rv = ap_run_session_encode(r, z);
        if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while encoding the session, "
                          "session not saved: %s", r->uri);
            return rv;
        }

        /* try the save */
        rv = ap_run_session_save(r, z);
        if (DECLINED == rv) {
            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                          "session is enabled but no session modules have been configured, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }
        else if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while saving the session, "
                          "session not saved: %s", r->uri);
            return rv;
        }
        else {
            z->written = 1;
        }
    }

    return APR_SUCCESS;

}

static int identity_count(int *count, const char *key, const char *val)
{
    *count += strlen(key) * 3 + strlen(val) * 3 + 1;
    return 1;
}

static int identity_concat(char *buffer, const char *key, const char *val)
{
    char *slider = buffer;
    int length = strlen(slider);
    slider += length;
    if (length) {
        *slider = '&';
        slider++;
    }
    ap_escape_path_segment_b(slider, key);
    slider += strlen(slider);
    *slider = '=';
    slider++;
    ap_escape_path_segment_b(slider, val);
    return 1;
}

/**
 * Default identity encoding for the session.
 *
 * By default, the name value pairs in the session are URLEncoded, separated
 * by equals, and then in turn separated by ampersand, in the format of an
 * html form.
 *
 * This was chosen to make it easy for external code to unpack a session,
 * should there be a need to do so.
 *
 * @param r The request pointer.
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_identity_encode(request_rec * r, session_rec * z)
{

    char *buffer = NULL;
    int length = 0;
    if (z->expiry) {
        char *expiry = apr_psprintf(r->pool, "%" APR_INT64_T_FMT, z->expiry);
        apr_table_set(z->entries, SESSION_EXPIRY, expiry);
    }
    apr_table_do((int (*) (void *, const char *, const char *))
                 identity_count, &length, z->entries, NULL);;
    buffer = apr_pcalloc(r->pool, length + 1);
    apr_table_do((int (*) (void *, const char *, const char *))
                 identity_concat, buffer, z->entries, NULL);
    z->encoded = buffer;
    return OK;

}

/**
 * Default identity decoding for the session.
 *
 * By default, the name value pairs in the session are URLEncoded, separated
 * by equals, and then in turn separated by ampersand, in the format of an
 * html form.
 *
 * This was chosen to make it easy for external code to unpack a session,
 * should there be a need to do so.
 *
 * This function reverses that process, and populates the session table.
 *
 * Name / value pairs that are not encoded properly are ignored.
 *
 * @param r The request pointer.
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_identity_decode(request_rec * r, session_rec * z)
{

    char *last = NULL;
    char *encoded, *pair;
    const char *sep = "&";

    /* sanity check - anything to decode? */
    if (!z->encoded) {
        return OK;
    }

    /* decode what we have */
    encoded = apr_pstrcat(r->pool, z->encoded, NULL);
    pair = apr_strtok(encoded, sep, &last);
    while (pair && pair[0]) {
        char *plast = NULL;
        const char *psep = "=";
        char *key = apr_strtok(pair, psep, &plast);
        char *val = apr_strtok(NULL, psep, &plast);
        if (key && *key) {
            if (!val || !*val) {
                apr_table_unset(z->entries, key);
            }
            if (!ap_unescape_all(key) && !ap_unescape_all(val)) {
                if (!strcmp(SESSION_EXPIRY, key)) {
                    z->expiry = (apr_time_t) apr_atoi64(val);
                }
                else {
                    apr_table_set(z->entries, key, val);
                }
            }
        }
        pair = apr_strtok(NULL, sep, &last);
    }
    z->encoded = NULL;
    return OK;

}

/**
 * Ensure any changes to the session are committed.
 *
 * This is done in an output filter so that our options for where to
 * store the session can include storing the session within a cookie:
 * As an HTTP header, the cookie must be set before the output is
 * written, but after the handler is run.
 *
 * NOTE: It is possible for internal redirects to cause more than one
 * request to be present, and each request might have a session
 * defined. We need to go through each session in turn, and save each
 * one.
 * 
 * The same session might appear in more than one request. The first
 * attempt to save the session will be called
 */
static apr_status_t ap_session_output_filter(ap_filter_t * f,
                                                    apr_bucket_brigade * in)
{

    /* save all the sessions in all the requests */
    request_rec *r = f->r->main;
    if (!r) {
        r = f->r;
    }
    while (r) {
        session_rec *z = NULL;
        session_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_module);

        /* load the session, or create one if necessary */
        ap_session_load(r, &z);
        if (!z || z->written) {
            r = r->next;
            continue;
        }

        /* if a header was specified, insert the new values from the header */
        if (conf->header_set) {
            const char *override = apr_table_get(r->err_headers_out, conf->header);
            if (!override) {
                override = apr_table_get(r->headers_out, conf->header);
            }
            if (override) {
                z->encoded = override;
                ap_session_identity_decode(r, z);
            }
        }

        /* save away the session, and we're done */
        ap_session_save(r, z);

        r = r->next;
    }

    /* remove ourselves from the filter chain */
    ap_remove_output_filter(f);

    /* send the data up the stack */
    return ap_pass_brigade(f->next, in);

}

/**
 * Insert the output filter.
 */
static void ap_session_insert_output_filter(request_rec * r)
{
    ap_add_output_filter("MOD_SESSION_OUT", NULL, r, r->connection);
}

/**
 * Fixups hook.
 *
 * Load the session within a fixup - this ensures that the session is
 * properly loaded prior to the handler being called.
 * 
 * The fixup is also responsible for injecting the session into the CGI
 * environment, should the admin have configured it so.
 * 
 * @param r The request
 */
AP_DECLARE(int) ap_session_fixups(request_rec * r)
{
    session_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                  &session_module);

    session_rec *z = NULL;
    ap_session_load(r, &z);

    if (conf->env) {
        ap_session_identity_encode(r, z);
        if (z->encoded) {
            apr_table_set(r->subprocess_env, HTTP_SESSION, z->encoded);
            z->encoded = NULL;
        }
    }

    return OK;

}


static void *create_session_dir_config(apr_pool_t * p, char *dummy)
{
    session_dir_conf *new =
    (session_dir_conf *) apr_pcalloc(p, sizeof(session_dir_conf));

    new->includes = apr_array_make(p, 10, sizeof(const char **));
    new->excludes = apr_array_make(p, 10, sizeof(const char **));

    return (void *) new;
}

static void *merge_session_dir_config(apr_pool_t * p, void *basev, void *addv)
{
    session_dir_conf *new = (session_dir_conf *) apr_pcalloc(p, sizeof(session_dir_conf));
    session_dir_conf *add = (session_dir_conf *) addv;
    session_dir_conf *base = (session_dir_conf *) basev;

    new->enabled = (add->enabled_set == 0) ? base->enabled : add->enabled;
    new->enabled_set = add->enabled_set || base->enabled_set;
    new->maxage = (add->maxage_set == 0) ? base->maxage : add->maxage;
    new->maxage_set = add->maxage_set || base->maxage_set;
    new->header = (add->header_set == 0) ? base->header : add->header;
    new->header_set = add->header_set || base->header_set;
    new->env = (add->env_set == 0) ? base->env : add->env;
    new->env_set = add->env_set || base->env_set;
    new->includes = apr_array_append(p, base->includes, add->includes);
    new->excludes = apr_array_append(p, base->excludes, add->excludes);

    return new;
}


static const char *
     set_session_enable(cmd_parms * parms, void *dconf, int flag)
{
    session_dir_conf *conf = dconf;

    conf->enabled = flag;
    conf->enabled_set = 1;

    return NULL;
}

static const char *
     set_session_maxage(cmd_parms * parms, void *dconf, const char *arg)
{
    session_dir_conf *conf = dconf;

    conf->maxage = atol(arg);
    conf->maxage_set = 1;

    return NULL;
}

static const char *
     set_session_header(cmd_parms * parms, void *dconf, const char *arg)
{
    session_dir_conf *conf = dconf;

    conf->header = arg;
    conf->header_set = 1;

    return NULL;
}

static const char *
     set_session_env(cmd_parms * parms, void *dconf, int flag)
{
    session_dir_conf *conf = dconf;

    conf->env = flag;
    conf->env_set = 1;

    return NULL;
}

static const char *add_session_include(cmd_parms * cmd, void *dconf, const char *f)
{
    session_dir_conf *conf = dconf;

    const char **new = apr_array_push(conf->includes);
    *new = f;

    return NULL;
}

static const char *add_session_exclude(cmd_parms * cmd, void *dconf, const char *f)
{
    session_dir_conf *conf = dconf;

    const char **new = apr_array_push(conf->excludes);
    *new = f;

    return NULL;
}


static const command_rec session_cmds[] =
{
    AP_INIT_FLAG("Session", set_session_enable, NULL, OR_AUTHCFG,
                 "on if a session should be maintained for these URLs"),
    AP_INIT_TAKE1("SessionMaxAge", set_session_maxage, NULL, OR_AUTHCFG,
                  "length of time for which a session should be valid. Zero to disable"),
    AP_INIT_TAKE1("SessionHeader", set_session_header, NULL, OR_AUTHCFG,
                  "output header, if present, whose contents will be injected into the session."),
    AP_INIT_FLAG("SessionEnv", set_session_env, NULL, OR_AUTHCFG,
                 "on if a session should be written to the CGI environment. Defaults to off"),
    AP_INIT_TAKE1("SessionInclude", add_session_include, NULL, OR_AUTHCFG,
                  "URL prefixes to include in the session. Defaults to all URLs"),
    AP_INIT_TAKE1("SessionExclude", add_session_exclude, NULL, OR_AUTHCFG,
                  "URL prefixes to exclude from the session. Defaults to no URLs"),
    {NULL}
};

static void register_hooks(apr_pool_t * p)
{
    ap_register_output_filter("MOD_SESSION_OUT", ap_session_output_filter,
                              NULL, AP_FTYPE_CONTENT_SET);
    ap_hook_insert_filter(ap_session_insert_output_filter, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_insert_error_filter(ap_session_insert_output_filter,
                                NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_fixups(ap_session_fixups, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_session_encode(ap_session_identity_encode, NULL, NULL, APR_HOOK_REALLY_FIRST);
    ap_hook_session_decode(ap_session_identity_decode, NULL, NULL, APR_HOOK_REALLY_LAST);
    APR_REGISTER_OPTIONAL_FN(ap_session_get);
    APR_REGISTER_OPTIONAL_FN(ap_session_set);
    APR_REGISTER_OPTIONAL_FN(ap_session_load);
    APR_REGISTER_OPTIONAL_FN(ap_session_save);
}

module AP_MODULE_DECLARE_DATA session_module =
{
    STANDARD20_MODULE_STUFF,
    create_session_dir_config,   /* dir config creater */
    merge_session_dir_config,    /* dir merger --- default is to override */
    NULL,                        /* server config */
    NULL,                        /* merge server config */
    session_cmds,                /* command apr_table_t */
    register_hooks               /* register hooks */
};
/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef MOD_SESSION_H
#define MOD_SESSION_H

/**
 * @file  mod_session.h
 * @brief Session Module for Apache
 *
 * @defgroup MOD_SESSION mod_session
 * @ingroup  APACHE_MODS
 * @{
 */

#define CORE_PRIVATE

#include "apr_hooks.h"
#include "apr_optional.h"
#include "apr_tables.h"
#include "apr_uuid.h"
#include "apr_pools.h"
#include "apr_time.h"

#include "httpd.h"
#include "http_config.h"
#include "ap_config.h"

#define MOD_SESSION_NOTES_KEY "mod_session_key"

/**
 * Define the name of a username stored in the session, so that modules interested
 * in the username can find it in a standard place.
 */
#define MOD_SESSION_USER "user"

/**
 * Define the name of a password stored in the session, so that modules interested
 * in the password can find it in a standard place.
 */
#define MOD_SESSION_PW "pw"

/**
 * A session structure.
 *
 * At the core of the session is a set of name value pairs making up the
 * session.
 *
 * The session might be uniquely identified by an anonymous uuid, or
 * a remote_user value, or both.
 */
typedef struct {
    apr_pool_t *pool;             /* pool to be used for this session */
    apr_uuid_t *uuid;             /* anonymous uuid of this particular session */
    const char *remote_user;      /* user who owns this particular session */
    apr_table_t *entries;         /* key value pairs */
    const char *encoded;          /* the encoded version of the key value pairs */
    apr_time_t expiry;            /* if > 0, the time of expiry of this session */
    long maxage;                  /* if > 0, the maxage of the session, from
                                   * which expiry is calculated */
    int dirty;                    /* dirty flag */
    int cached;                   /* true if this session was loaded from a
                                   * cache of some kind */
    int written;                  /* true if this session has already been
                                   * written */
} session_rec;

/**
 * Structure to carry the per-dir session config.
 */
typedef struct {
    int enabled;                  /* whether the session has been enabled for
                                   * this directory */
    int enabled_set;
    long maxage;                  /* seconds until session expiry */
    int maxage_set;
    const char *header;           /* header to inject session */
    int header_set;
    int env;                      /* whether the session has been enabled for
                                   * this directory */
    int env_set;
    apr_array_header_t *includes; /* URL prefixes to be included. All
                                   * URLs included if empty */
    apr_array_header_t *excludes; /* URL prefixes to be excluded. No
                                   * URLs excluded if empty */
} session_dir_conf;

/**
 * Get a particular value from the session.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to get.
 * @param value The buffer to write the value to.
 */
AP_DECLARE(void) ap_session_get(request_rec * r, session_rec * z, const char *key, const char **value);

/**
 * Set a particular value to the session.
 *
 * Using this method ensures that the dirty flag is set correctly, so that
 * the session can be saved efficiently.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to set. The existing key value will be replaced.
 * @param value The value to set.
 */
AP_DECLARE(void) ap_session_set(request_rec * r, session_rec * z,
                                const char *key, const char *value);

/**
 * Load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_load(request_rec * r, session_rec ** z);

/**
 * Hook to load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_load, (request_rec * r, session_rec ** z))

/**
 * Save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_save(request_rec * r, session_rec * z);

/**
 * Hook to save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_save, (request_rec * r, session_rec * z))

/**
 * Hook to encode the session.
 *
 * In the default implementation, the key value pairs are encoded using
 * key value pairs separated by equals, in turn separated by ampersand,
 * like a web form.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_encode, (request_rec * r, session_rec * z))

/**
 * Hook to decode the session.
 *
 * In the default implementation, the key value pairs are encoded using
 * key value pairs separated by equals, in turn separated by ampersand,
 * like a web form.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_decode, (request_rec * r, session_rec * z))

APR_DECLARE_OPTIONAL_FN(void, ap_session_get, (request_rec * r, session_rec * z,
                                               const char *key, const char **value));
APR_DECLARE_OPTIONAL_FN(void, ap_session_set, (request_rec * r, session_rec * z,
                                               const char *key, const char *value));
APR_DECLARE_OPTIONAL_FN(int, ap_session_load, (request_rec *, session_rec **));
APR_DECLARE_OPTIONAL_FN(int, ap_session_save, (request_rec *, session_rec *));

/**
 * The name of the module.
 */
extern module AP_MODULE_DECLARE_DATA session_module;

#endif /* MOD_SESSION_H */
/** @} */
AP_DECLARE(int) ap_unescape_all(char *url)
{
    return unescape_url(url, NULL, NULL);
}

AP_DECLARE(char *) ap_escape_path_segment_b(char *copy, const char *segment)
AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char *segment)
{
    return ap_escape_path_segment_b(apr_palloc(p, 3 * strlen(segment) + 1), segment);
}

                recycled_pool = NULL;
                    recycled_pool = ptrans;
            else {
                recycled_pool = ptrans;
            }
        return 0;
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            else if (r->method == NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                              "request failed: invalid characters in URI");
            }
/* Copyright 1999-2004 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Load balancer module for Apache proxy */

#define CORE_PRIVATE

#include "mod_proxy.h"
#include "ap_mpm.h"
#include "apr_version.h"

module AP_MODULE_DECLARE_DATA proxy_balancer_module;

#if APR_HAS_THREADS1
#define PROXY_BALANCER_LOCK(b)      apr_thread_mutex_lock((b)->mutex)
#define PROXY_BALANCER_UNLOCK(b)    apr_thread_mutex_unlock((b)->mutex)
#else
#define PROXY_BALANCER_LOCK(b)      APR_SUCCESS
#define PROXY_BALANCER_UNLOCK(b)    APR_SUCCESS
#endif

/* Retrieve the parameter with the given name                                */
static char *get_path_param(apr_pool_t *pool, char *url,
                            const char *name)
{
    char *path = NULL;
    
    for (path = strstr(url, name); path; path = strstr(path + 1, name)) {
        path += (strlen(name) + 1);
        if (*path == '=') {
            /*
             * Session path was found, get it's value
             */
            ++path;
            if (strlen(path)) {
                char *q;
                path = apr_pstrdup(pool, path);
                if ((q = strchr(path, '?')))
                    *q = '\0';
                return path;
            }
        }
    }
    return NULL;
}

static char *get_cookie_param(request_rec *r, const char *name)
{
    const char *cookies;
    const char *start_cookie;

    if ((cookies = apr_table_get(r->headers_in, "Cookie"))) {
        for (start_cookie = strstr(cookies, name); start_cookie; 
             start_cookie = strstr(start_cookie + 1, name)) {
            if (start_cookie == cookies ||
                start_cookie[-1] == ';' ||
                start_cookie[-1] == ',' ||
                isspace(start_cookie[-1])) {
                
                start_cookie += strlen(name);
                while(*start_cookie && isspace(*start_cookie))
                    ++start_cookie;
                if (*start_cookie == '=' && start_cookie[1]) {
                    /*
                     * Session cookie was found, get it's value
                     */
                    char *end_cookie, *cookie;
                    ++start_cookie;
                    cookie = apr_pstrdup(r->pool, start_cookie);
                    if ((end_cookie = strchr(cookie, ';')) != NULL)
                        *end_cookie = '\0';
                    if((end_cookie = strchr(cookie, ',')) != NULL)
                        *end_cookie = '\0';
                    return cookie;
                }
            }
        }     
    }
    return NULL;
}

static proxy_runtime_worker *find_route_worker(proxy_balancer *balancer,
                                               const char *route)
{
    int i;
    proxy_runtime_worker *worker = (proxy_runtime_worker *)balancer->workers->elts;
    for (i = 0; i < balancer->workers->nelts; i++) {
        if (worker->route && strcmp(worker->route, route) == 0) {
            return worker;
        }
        worker++;
    }
    return NULL;
}

static proxy_runtime_worker *find_session_route(proxy_balancer *balancer,
                                                request_rec *r,
                                                char **route,
                                                char **url)
{
    if (!balancer->sticky)
        return NULL;
    /* Try to find the sticky route inside url */
    *route = get_path_param(r->pool, *url, balancer->sticky);
    if (!*route)
        *route = get_cookie_param(r, balancer->sticky);
    if (*route) {
        proxy_runtime_worker *worker =  find_route_worker(balancer, *route);
        /* TODO: make worker status codes */
        /* See if we have a redirection route */
        if (worker && worker->w->status < 2 && worker->redirect)
            worker = find_route_worker(balancer, worker->redirect);
        else
            worker = NULL;
        return worker;
    }
    else
        return NULL;
}

static int proxy_balancer_pre_request(proxy_worker **worker,
                                      proxy_balancer **balancer,
                                      request_rec *r,
                                      proxy_server_conf *conf, char **url)
{
    int access_status = OK;
    proxy_runtime_worker *runtime;
    char *route;
    apr_status_t rv;

    /* Spet 1: check if the url is for us */
    if (!(*balancer = ap_proxy_get_balancer(r->pool, conf, *url)))
        return DECLINED;
    
    /* Step 2: find the session route */
    
    runtime = find_session_route(*balancer, r, &route, url);
    if (!runtime) {
        if (route && (*balancer)->sticky_force) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "balancer: (%s). All workers in error state for route (%s)",
                         (*balancer)->name, route);
            return HTTP_SERVICE_UNAVAILABLE;
        }
    }
    /* Lock the LoadBalancer
     * XXX: perhaps we need the process lock here
     */
    if ((rv = PROXY_BALANCER_LOCK(*balancer)) != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                     "proxy_balancer_pre_request: lock");
        return DECLINED;
    }

    PROXY_BALANCER_UNLOCK(*balancer);

    return access_status;
} 

static int proxy_balancer_post_request(proxy_worker *worker,
                                       proxy_balancer *balancer,
                                       request_rec *r,
                                       proxy_server_conf *conf)
{
    int access_status;
    if (!balancer)
        access_status = DECLINED;
    else { 
        

        access_status = OK;
    }

    return access_status;
} 

static void ap_proxy_balancer_register_hook(apr_pool_t *p)
{
    proxy_hook_pre_request(proxy_balancer_pre_request, NULL, NULL, APR_HOOK_FIRST);    
    proxy_hook_post_request(proxy_balancer_post_request, NULL, NULL, APR_HOOK_FIRST);    
}

module AP_MODULE_DECLARE_DATA proxy_balancer_module = {
    STANDARD20_MODULE_STUFF,
    NULL,		/* create per-directory config structure */
    NULL,		/* merge per-directory config structures */
    NULL,		/* create per-server config structure */
    NULL,		/* merge per-server config structures */
    NULL,		/* command apr_table_t */
    ap_proxy_balancer_register_hook	/* register hooks */
};
                                    (REG_EXTENDED | (icase ? REG_ICASE : 0)));
    regmatch_t regm[10];
            (!b->pattern && !ap_regexec(b->preg, val, b->preg->re_nsub + 1,
                                        regm, 0))) {
                    if (!b->pattern) {
                        char *replaced = ap_pregsub(r->pool, elts[j].val, val,
                                                    b->preg->re_nsub + 1, regm);
                        if (replaced) {
                            apr_table_setn(r->subprocess_env, elts[j].key,
                                           replaced);
                        }
                    }
                    else {
                        apr_table_setn(r->subprocess_env, elts[j].key,
                                       elts[j].val);
                    }
    bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)(bio->ptr);
    if (!outctx->length && (inl + outctx->blen < sizeof(outctx->buffer))) {
        memcpy(&outctx->buffer[outctx->blen], in, inl);
        outctx->blen += inl;
                                             outctx->bb->bucket_alloc);
        outctx->length += inl;
        APR_BRIGADE_INSERT_TAIL(outctx->bb, bucket);
    bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)(bio->ptr);
        outctx->blen = outctx->length = 0;
        ret = (long)((outctx->blen + outctx->length) == 0);
        outctx->blen = outctx->length = (apr_size_t)num;
        ret = (long)(outctx->blen + outctx->length);
            *pptr = (char *)&(outctx->buffer[0]);
        ret = (long)(outctx->blen + outctx->length);
    bio_filter_in_ctx_t *inctx = (bio_filter_in_ctx_t *)(bio->ptr);
    apr_read_type_e block = inctx->block;
    SSLConnRec *sslconn = myConnConfig(inctx->f->c);
    inctx->rc = APR_SUCCESS;
    if ((SSL_version(inctx->ssl) == SSL2_VERSION) || sslconn->is_proxy) {
        bio_filter_out_flush(inctx->wbio);
    if (!inctx->bb) {
        inctx->rc = APR_EOF;
    if (APR_BRIGADE_EMPTY(inctx->bb)) {
        inctx->rc = ap_get_brigade(inctx->f->next, inctx->bb,
        if (APR_STATUS_IS_EAGAIN(inctx->rc) || APR_STATUS_IS_EINTR(inctx->rc)
               || (inctx->rc == APR_SUCCESS && APR_BRIGADE_EMPTY(inctx->bb))) {
        if (inctx->rc != APR_SUCCESS) {
            apr_brigade_cleanup(inctx->bb);
            inctx->bb = NULL;
    inctx->rc = brigade_consume(inctx->bb, block, in, &inl);
    if (inctx->rc == APR_SUCCESS) {
    if (APR_STATUS_IS_EAGAIN(inctx->rc) 
            || APR_STATUS_IS_EINTR(inctx->rc)) {
    apr_brigade_cleanup(inctx->bb);
    inctx->bb = NULL;
    if (APR_STATUS_IS_EOF(inctx->rc) && inl) {
    SSLFilterRec *frec = f->ctx;
    n = ssl_io_hook_write(frec->pssl, (unsigned char *)data, len);
        if (SSL_total_renegotiations(frec->pssl)) {
    SSLFilterRec *frec = f->ctx;
    if (!frec->pssl) {
    if ((status = ssl_hook_process_connection(frec)) != APR_SUCCESS) {
            if ((status = bio_filter_out_flush(frec->pbioWrite)) != APR_SUCCESS) {
static apr_status_t ssl_io_input_read(bio_filter_in_ctx_t *inctx,
    if ((bytes = char_buffer_read(&inctx->cbuf, buf, wanted))) {
        if (inctx->mode == AP_MODE_SPECULATIVE) {
            inctx->cbuf.value -= bytes;
            inctx->cbuf.length += bytes;
        if ((*len >= wanted) || inctx->mode == AP_MODE_GETLINE) {
        rc = SSL_read(inctx->frec->pssl, buf + bytes, wanted - bytes);
            if (inctx->mode == AP_MODE_SPECULATIVE) {
                char_buffer_write(&inctx->cbuf, buf, rc);
            return inctx->rc;
            if (APR_STATUS_IS_EAGAIN(inctx->rc)
                    || APR_STATUS_IS_EINTR(inctx->rc)) {
                if (inctx->block == APR_NONBLOCK_READ) {
                inctx->rc = APR_EOF;
            int ssl_err = SSL_get_error(inctx->frec->pssl, rc);
                if (inctx->block == APR_NONBLOCK_READ) {
                    inctx->rc = APR_EAGAIN;
                conn_rec *c = (conn_rec *)SSL_get_app_data(inctx->frec->pssl);
                ap_log_error(APLOG_MARK, APLOG_ERR, inctx->rc, c->base_server,
                conn_rec *c = (conn_rec *)SSL_get_app_data(inctx->frec->pssl);
                ap_log_error(APLOG_MARK, APLOG_ERR, inctx->rc, c->base_server,
                if (inctx->rc == APR_SUCCESS) {
                    inctx->rc = APR_EGENERAL;
    return inctx->rc;
static apr_status_t ssl_io_input_getline(bio_filter_in_ctx_t *inctx,
        status = ssl_io_input_read(inctx, buf + offset, &tmplen);
        char_buffer_write(&inctx->cbuf, value, length);
    bio_filter_in_ctx_t *inctx = f->ctx;
    inctx->ssl = NULL;
    inctx->frec->pssl = NULL;
    bio_filter_in_ctx_t *inctx = f->ctx;
    apr_size_t len = sizeof(inctx->buffer);
    if (!inctx->ssl) {
    inctx->mode = mode;
    inctx->block = block;
    status = ssl_hook_process_connection(inctx->frec);
    if (inctx->mode == AP_MODE_READBYTES || 
        inctx->mode == AP_MODE_SPECULATIVE) {
        status = ssl_io_input_read(inctx, inctx->buffer, &len);
    else if (inctx->mode == AP_MODE_GETLINE) {
        status = ssl_io_input_getline(inctx, inctx->buffer, &len);
            apr_bucket_transient_create(inctx->buffer, len, f->c->bucket_alloc);
    bio_filter_in_ctx_t *inctx;
    inctx = apr_palloc(c->pool, sizeof(*inctx));
    frec->pInputFilter = ap_add_input_filter(ssl_io_filter, inctx, NULL, c);
    frec->pbioRead->ptr = (void *)inctx;
    inctx->frec = frec;
    inctx->ssl = ssl;
    inctx->wbio = frec->pbioWrite;
    inctx->f = frec->pInputFilter;
    inctx->bb = apr_brigade_create(c->pool, c->bucket_alloc);
    inctx->cbuf.length = 0;
    inctx->pool = c->pool;
/* used to denote that mod_dav will be handling this request */
#define DAV_HANDLER_NAME "dav-handler"

    if (strcmp(r->handler, DAV_HANDLER_NAME) != 0)
static int dav_fixups(request_rec *r)
{
    dav_dir_conf *conf;

    /* quickly ignore any HTTP/0.9 requests which aren't subreqs. */
    if (r->assbackwards && !r->main) {
        return DECLINED;
    }

    conf = (dav_dir_conf *)ap_get_module_config(r->per_dir_config,
                                                &dav_module);

    /* if DAV is not enabled, then we've got nothing to do */
    if (conf->provider == NULL) {
        return DECLINED;
    }

    /* We are going to handle almost every request. In certain cases,
       the provider maps to the filesystem (thus, handle_get is
       FALSE), and core Apache will handle it. a For that case, we
       just return right away.  */
    if (r->method_number == M_GET) {
        /*
         * ### need some work to pull Content-Type and Content-Language
         * ### from the property database.
         */

        /*
         * If the repository hasn't indicated that it will handle the
         * GET method, then just punt.
         *
         * ### this isn't quite right... taking over the response can break
         * ### things like mod_negotiation. need to look into this some more.
         */
        if (!conf->provider->repos->handle_get) {
            return DECLINED;
        }
    }

    /* We are going to be handling the response for this resource. */
    r->handler = DAV_HANDLER_NAME;

    return OK;
}

    ap_hook_fixups(dav_fixups, NULL, NULL, APR_HOOK_MIDDLE);
#define MAX_NMATCH 10

typedef struct {
    const char *source;
    const char *rexp;
    apr_size_t  nsub;
    regmatch_t  match[MAX_NMATCH];
} backref_t;

    backref_t    *re;            /* NULL if there wasn't a regex yet */
    request_rec *r = ctx->intern->r;

        int idx = *var - '0';
        backref_t *re = ctx->intern->re;

        if (!re) {
            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, "regex capture $%d "
                          "refers to no regex in %s", idx, r->filename);
            if (re->nsub < idx) {
                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,
                              "regex capture $%d is out of range (last regex "
                              "was: '%s') in %s", idx, re->rexp, r->filename);
                return NULL;
            }

            if (re->match[idx].rm_so < 0 || re->match[idx].rm_eo < 0) {

            val = apr_pstrmemdup(ctx->dpool, re->source + re->match[idx].rm_so,
                                 re->match[idx].rm_eo - re->match[idx].rm_so);
        val = apr_table_get(r->subprocess_env, var);
        if (val == LAZY_VALUE) {
            val = add_include_vars_lazy(r, var);
        }

static APR_INLINE int re_check(include_ctx_t *ctx, char *string, char *rexp)
    backref_t *re = ctx->intern->re;
    int rc;
    compiled = ap_pregcomp(ctx->dpool, rexp, REG_EXTENDED);
    if (!compiled) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->intern->r, "unable to "
                      "compile pattern \"%s\"", rexp);

    if (!re) {
        re = ctx->intern->re = apr_palloc(ctx->pool, sizeof(*re));

    re->source = string;
    re->rexp = rexp;
    re->nsub = compiled->re_nsub;
    rc = !ap_regexec(compiled, string, MAX_NMATCH, re->match, 0);

    ap_pregfree(ctx->dpool, compiled);
    return rc;
                    re_check(ctx, current->left->token.value,
        intern->re = NULL;
 * 20120109.0 (2.5.0-dev)  Changes sizeof(overrides_t) in core config.
#define MODULE_MAGIC_NUMBER_MAJOR 20120109
#define MODULE_MAGIC_NUMBER_MINOR 0                   /* 0...n */
/* Flags to determine whether syntax errors in .htaccess should be
 * treated as nonfatal (log and ignore errors)
 */
#define NONFATAL_OVERRIDE 512    /* Violation of AllowOverride rule */
#define NONFATAL_UNKNOWN 1024    /* Unrecognised directive */
#define NONFATAL_ALL (NONFATAL_OVERRIDE|NONFATAL_UNKNOWN)

typedef unsigned int overrides_t;
    if ((parms->override & cmd->req_override) == 0 && !override_list_ok) {
        if (parms->override & NONFATAL_OVERRIDE) {
            ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, parms->temp_pool,
                          APLOGNO(02295)
                          "%s in .htaccess forbidden by AllowOverride",
                          cmd->name);
            return NULL;
        }
        else {
            return apr_pstrcat(parms->pool, cmd->name,
                               " not allowed here", NULL);
        }
    }
        if (parms->override & NONFATAL_UNKNOWN) {
            ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, parms->temp_pool,
                          APLOGNO(02296) "Unknown directive %s "
                          "perhaps misspelled or defined by a module "
                          "not included in the server configuration", dir);
            return NULL;
        }
        else {
            return apr_pstrcat(parms->pool, "Invalid command '",
                               current->directive,
                               "', perhaps misspelled or defined by a module "
                               "not included in the server configuration",
                               NULL);
        }
        else if (!strcasecmp(w, "Nonfatal")) {
            if (!strcasecmp(v, "Override")) {
                d->override |= NONFATAL_OVERRIDE;
            }
            else if (!strcasecmp(v, "Unknown")) {
                d->override |= NONFATAL_UNKNOWN;
            }
            else if (!strcasecmp(v, "All")) {
                d->override |= NONFATAL_ALL;
            }
        }
    if (apr_table_get(r->subprocess_env, "force-proxy-request-1.0")) {
        p_conn->close++;
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type("text/xml", r);
    ap_rset_content_type(apr_pstrdup(r->pool, info->content_type), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html;charset=utf-8", r);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html", r);
                    ap_rset_content_type("text/plain", r);
    ap_rset_content_type("message/http", r);
AP_DECLARE(void) ap_rset_content_type(char *ct, request_rec *r)
{
    r->content_type = ct;

    /* Insert filters requested by the AddOutputFiltersByType 
     * configuration directive. Content-type filters must be 
     * inserted after the content handlers have run because 
     * only then, do we reliably know the content-type.
     */
    ap_add_output_filters_by_type(r);
}
        ap_rset_content_type("text/html; charset=iso-8859-1", r);
            ap_rset_content_type(apr_pstrcat(r->pool, "multipart",
                                             use_range_x(r) ? "/x-" : "/",
                                             "byteranges; boundary=",
                                             r->boundary, NULL), r);
    ap_rset_content_type(rr->content_type, r);
        ap_rset_content_type(r->content_type, new);
#include "http_protocol.h"
        ap_rset_content_type(DIR_MAGIC_TYPE, r);
                ap_rset_content_type((char*) type, r);
                ap_rset_content_type(exinfo->forced_type, r);
	    ap_rset_content_type(apr_pstrcat(r->pool, ctp->type, "/",
                                             ctp->subtype, NULL), r);
			ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                         "; charset=", charset,
                                                         NULL), r);
		    ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                     "; ", pp->attr,
                                                     "=", pp->val,
                                                     NULL), r);
		ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                 "; charset=", charset,
                                                 NULL), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type(CGI_MAGIC_TYPE, sub_req);
        ap_rset_content_type(t, r);
                ap_rset_content_type(p->forced_mimetype, r);
#include "http_protocol.h"
	    ap_rset_content_type(tmp, r);
	ap_rset_content_type(tmp, r);
	ap_rset_content_type(apr_pstrdup(r->pool, sub->content_type), r);
        ap_rset_content_type("text/html", r);
            ap_rset_content_type(ap_default_type(r), r);
                    ap_rset_content_type(apr_pstrdup(p, buf), r);
 * is converted to the RFC 1123 format.
     ap_proxy_date_canon(apr_pool_t *p, const char *date)
    apr_status_t rv;
    apr_time_exp_t tm;
    apr_size_t retsize;
    char* ndate;
    static const char format[] = "%a, %d %b %Y %H:%M:%S GMT";
    apr_time_t time = apr_date_parse_http(date);
    if (!time) {
        return date;
    rv = apr_time_exp_gmt(&tm, time);

    if (rv != APR_SUCCESS) {
        return date;

    ndate = apr_palloc(p, APR_RFC822_DATE_LEN);
    rv = apr_strftime(ndate, &retsize, APR_RFC822_DATE_LEN, format, &tm);

    if (rv != APR_SUCCESS || !retsize) {
        return date;
    return ndate;
/* if a request with a body creates a subrequest, clone the original request's
 * input headers minus any headers pertaining to the body which has already
 * been read.  out-of-line helper function for ap_set_sub_req_protocol.
 */

static void clone_headers_no_body(request_rec *rnew,
                                  const request_rec *r)
{
    rnew->headers_in = apr_table_copy(rnew->pool, r->headers_in);
    apr_table_unset(rnew->headers_in, "Content-Length");
    apr_table_unset(rnew->headers_in, "Transfer-Encoding");
    apr_table_unset(rnew->headers_in, "Content-Type");
    apr_table_unset(rnew->headers_in, "Content-Encoding");
}        

    /* did the original request have a body?  (e.g. POST w/SSI tags)
     * if so, make sure the subrequest doesn't inherit body headers
     */
    if (r->read_length) {
        clone_headers_no_body(rnew, r);
    } else {
        /* no body (common case).  clone headers the cheap way */
        rnew->headers_in      = r->headers_in;
    }
 * created at config time in the parent are valid across children.  However,
 * this can't work effectively with non-forked architectures.  So while the
 * arrays in the scoreboard never change between the parent and forked
 * children, so they do not require shm storage, the contents of the shm
 * may contain no pointers.
    SB_NOT_SHARED = 1,
    SB_SHARED = 2,      /* PARENT */
    SB_SHARED_CHILD = 3
    char vhost[32];	        /* What virtual host is being accessed? */
/* Scoreboard is now in 'local' memory, since it isn't updated once created,
 * even in forked architectures.  Child created-processes (non-fork) will
 * set up these indicies into the (possibly relocated) shmem records.
 */
    global_score *global;
typedef struct ap_sb_handle_t ap_sb_handle_t;
AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sbh, request_rec *r);
void ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e t);
apr_status_t reopen_scoreboard(apr_pool_t *p, int detached);
void ap_init_scoreboard(void *shared_score);
AP_DECLARE(void) ap_create_sb_handle(ap_sb_handle_t **new_sbh, apr_pool_t *p,
AP_DECLARE(int) ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r);

AP_DECLARE(worker_score *) ap_get_scoreboard_worker(int x, int y);
AP_DECLARE(process_score *) ap_get_scoreboard_process(int x);
AP_DECLARE(global_score *) ap_get_scoreboard_global(void);
#include "apr_shm.h"
#include "apr_rmm.h"
#define APR_HAS_SHARED_MEMORY 1
static apr_shm_t      *client_shm =  NULL;
static apr_rmm_t      *client_rmm = NULL;
static unsigned long  *opaque_cntr;
    ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
    sts = apr_shm_create(&client_shm, shmem_size, tmpnam(NULL), ctx);
    client_list = apr_rmm_malloc(client_rmm, sizeof(*client_list) +
    opaque_cntr = apr_rmm_malloc(client_rmm, sizeof(*opaque_cntr));
    otn_counter = apr_rmm_malloc(client_rmm, sizeof(*otn_counter));
            apr_rmm_free(client_rmm, entry);
    entry = apr_rmm_malloc(client_rmm, sizeof(client_entry));
        entry = apr_rmm_malloc(client_rmm, sizeof(client_entry));
	    
			    ap_escape_html(r->pool, ws_record.vhost));
			     ap_escape_html(r->pool, ws_record.vhost),
                    n = ssl_rand_choosenum(0,ap_calc_scoreboard_size()-1024-1);

/*  A Bison parser, made from ssl_expr_parse.y
    by GNU Bison version 1.28  */

#define YYBISON 1  /* Identify Bison output.  */

#define	T_TRUE	257
#define	T_FALSE	258
#define	T_DIGIT	259
#define	T_ID	260
#define	T_STRING	261
#define	T_REGEX	262
#define	T_REGEX_I	263
#define	T_FUNC_FILE	264
#define	T_OP_EQ	265
#define	T_OP_NE	266
#define	T_OP_LT	267
#define	T_OP_LE	268
#define	T_OP_GT	269
#define	T_OP_GE	270
#define	T_OP_REG	271
#define	T_OP_NRE	272
#define	T_OP_IN	273
#define	T_OP_OR	274
#define	T_OP_AND	275
#define	T_OP_NOT	276

#line 68 "ssl_expr_parse.y"


#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		53
#define	YYFLAG		-32768
#define	YYNTBASE	29

#define YYTRANSLATE(x) ((unsigned)(x) <= 276 ? ssl_expr_yytranslate[x] : 36)

static const char ssl_expr_yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,    28,     2,     2,    23,
    24,     2,     2,    27,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,    25,     2,    26,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
    17,    18,    19,    20,    21,    22

#if YYDEBUG != 0
static const short ssl_expr_yyprhs[] = {     0,
     0,     2,     4,     6,     9,    13,    17,    19,    23,    27,
    31,    35,    39,    43,    47,    53,    57,    61,    63,    67,
    69,    71,    76,    78,    80,    82

static const short ssl_expr_yyrhs[] = {    30,
     0,     3,     0,     4,     0,    22,    30,     0,    30,    20,
    30,     0,    30,    21,    30,     0,    31,     0,    23,    30,
    24,     0,    33,    11,    33,     0,    33,    12,    33,     0,
    33,    13,    33,     0,    33,    14,    33,     0,    33,    15,
    33,     0,    33,    16,    33,     0,    33,    19,    25,    32,
    26,     0,    33,    17,    34,     0,    33,    18,    34,     0,
    33,     0,    32,    27,    33,     0,     5,     0,     7,     0,
    28,    25,     6,    26,     0,    35,     0,     8,     0,     9,
     0,    10,    23,     7,    24,     0

#endif

#if YYDEBUG != 0
static const short ssl_expr_yyrline[] = { 0,
   115,   118,   119,   120,   121,   122,   123,   124,   127,   128,
   129,   130,   131,   132,   133,   134,   135,   138,   139,   142,
   143,   144,   145,   148,   158,   170
#endif


#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)

static const char * const ssl_expr_yytname[] = {   "$","error","$undefined.","T_TRUE",
"T_FALSE","T_DIGIT","T_ID","T_STRING","T_REGEX","T_REGEX_I","T_FUNC_FILE","T_OP_EQ",
"T_OP_NE","T_OP_LT","T_OP_LE","T_OP_GT","T_OP_GE","T_OP_REG","T_OP_NRE","T_OP_IN",
"T_OP_OR","T_OP_AND","T_OP_NOT","'('","')'","'{'","'}'","','","'%'","root","expr",
"comparison","words","word","regex","funccall", NULL
};
#endif

static const short ssl_expr_yyr1[] = {     0,
    29,    30,    30,    30,    30,    30,    30,    30,    31,    31,
    31,    31,    31,    31,    31,    31,    31,    32,    32,    33,
    33,    33,    33,    34,    34,    35

static const short ssl_expr_yyr2[] = {     0,
     1,     1,     1,     2,     3,     3,     1,     3,     3,     3,
     3,     3,     3,     3,     5,     3,     3,     1,     3,     1,
     1,     4,     1,     1,     1,     4
};

static const short ssl_expr_yydefact[] = {     0,
     2,     3,    20,    21,     0,     0,     0,     0,     1,     7,
     0,    23,     0,     4,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     8,     0,
     5,     6,     9,    10,    11,    12,    13,    14,    24,    25,
    16,    17,     0,    26,    22,     0,    18,    15,     0,    19,
     0,     0,     0

static const short ssl_expr_yydefgoto[] = {    51,
     9,    10,    46,    11,    41,    12

static const short ssl_expr_yypact[] = {     3,
-32768,-32768,-32768,-32768,   -11,     3,     3,   -10,     0,-32768,
    22,-32768,    16,-32768,    -2,    23,     3,     3,     4,     4,
     4,     4,     4,     4,    34,    34,    21,    24,-32768,    25,
    26,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,     4,-32768,-32768,    18,-32768,-32768,     4,-32768,
    49,    50,-32768

static const short ssl_expr_yypgoto[] = {-32768,
    10,-32768,-32768,   -19,    27,-32768


#define	YYLAST		53


static const short ssl_expr_yytable[] = {    33,
    34,    35,    36,    37,    38,     1,     2,     3,     3,     4,
     4,    13,     5,     5,    16,    14,    15,    17,    18,    17,
    18,    29,    28,    47,     6,     7,    31,    32,    30,    50,
     8,     8,    19,    20,    21,    22,    23,    24,    25,    26,
    27,    39,    40,    48,    49,    43,    18,    44,    52,    53,
    45,     0,    42

static const short ssl_expr_yycheck[] = {    19,
    20,    21,    22,    23,    24,     3,     4,     5,     5,     7,
     7,    23,    10,    10,    25,     6,     7,    20,    21,    20,
    21,    24,     7,    43,    22,    23,    17,    18,     6,    49,
    28,    28,    11,    12,    13,    14,    15,    16,    17,    18,
    19,     8,     9,    26,    27,    25,    21,    24,     0,     0,
    26,    -1,    26
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/usr/local/share/bison.simple"
/* This file comes from bison-1.28.  */

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

#ifndef YYSTACK_USE_ALLOCA
#ifdef alloca
#define YYSTACK_USE_ALLOCA
#else /* alloca not defined */
#ifdef __GNUC__
#define YYSTACK_USE_ALLOCA
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
#define YYSTACK_USE_ALLOCA
#include <alloca.h>
#else /* not sparc */
/* We think this test detects Watcom and Microsoft C.  */
/* This used to test MSDOS, but that is a bad idea
   since that symbol is in the user namespace.  */
#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
#if 0 /* No need for malloc.h, which pollutes the namespace;
	 instead, just don't use alloca.  */
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
/* I don't know what this was needed for, but it pollutes the namespace.
   So I turned it off.   rms, 2 May 1997.  */
/* #include <malloc.h>  */
 #pragma alloca
#define YYSTACK_USE_ALLOCA
#else /* not MSDOS, or __TURBOC__, or _AIX */
#if 0
#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
		 and on HPUX 10.  Eventually we can turn this on.  */
#define YYSTACK_USE_ALLOCA
#define alloca __builtin_alloca
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc */
#endif /* not GNU C */
#endif /* alloca not defined */
#endif /* YYSTACK_USE_ALLOCA not defined */

#ifdef YYSTACK_USE_ALLOCA
#define YYSTACK_ALLOC alloca
#define YYSTACK_ALLOC malloc
#endif

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define ssl_expr_yyerrok		(ssl_expr_yyerrstatus = 0)
#define ssl_expr_yyclearin	(ssl_expr_yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	goto ssl_expr_yyacceptlab
#define YYABORT 	goto ssl_expr_yyabortlab
#define YYERROR		goto ssl_expr_yyerrlab1
/* Like YYERROR except do call ssl_expr_yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto ssl_expr_yyerrlab
#define YYRECOVERING()  (!!ssl_expr_yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (ssl_expr_yychar == YYEMPTY && ssl_expr_yylen == 1)				\
    { ssl_expr_yychar = (token), ssl_expr_yylval = (value);			\
      ssl_expr_yychar1 = YYTRANSLATE (ssl_expr_yychar);				\
      YYPOPSTACK;						\
      goto ssl_expr_yybackup;						\
    }								\
  else								\
    { ssl_expr_yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		ssl_expr_yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, &ssl_expr_yylloc, YYLEX_PARAM)
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, &ssl_expr_yylloc)
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, YYLEX_PARAM)
#else
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval)
#endif
#endif /* not YYLSP_NEEDED */
/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	ssl_expr_yychar;			/*  the lookahead symbol		*/
YYSTYPE	ssl_expr_yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE ssl_expr_yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int ssl_expr_yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int ssl_expr_yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Define __ssl_expr_yy_memcpy.  Note that the size argument
   should be passed with type unsigned int, because that is what the non-GCC
   definitions require.  With GCC, __builtin_memcpy takes an arg
   of type size_t, but it can handle unsigned int.  */

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __ssl_expr_yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__ssl_expr_yy_memcpy (to, from, count)
     char *to;
     char *from;
     unsigned int count;
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__ssl_expr_yy_memcpy (char *to, char *from, unsigned int count)
  register char *t = to;
  register char *f = from;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
#endif
#endif

#line 217 "/usr/local/share/bison.simple"

/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into ssl_expr_yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */
#ifdef YYPARSE_PARAM
#ifdef __cplusplus
#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
#else /* not __cplusplus */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#endif /* not __cplusplus */
#else /* not YYPARSE_PARAM */
#endif /* not YYPARSE_PARAM */

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
#ifdef YYPARSE_PARAM
int ssl_expr_yyparse (void *);
#else
int ssl_expr_yyparse (void);
#endif
ssl_expr_yyparse(YYPARSE_PARAM_ARG)
     YYPARSE_PARAM_DECL
  register int ssl_expr_yystate;
  register int ssl_expr_yyn;
  register short *ssl_expr_yyssp;
  register YYSTYPE *ssl_expr_yyvsp;
  int ssl_expr_yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int ssl_expr_yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	ssl_expr_yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE ssl_expr_yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *ssl_expr_yyss = ssl_expr_yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *ssl_expr_yyvs = ssl_expr_yyvsa;	/*  to allow ssl_expr_yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE ssl_expr_yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *ssl_expr_yyls = ssl_expr_yylsa;
  YYLTYPE *ssl_expr_yylsp;

#define YYPOPSTACK   (ssl_expr_yyvsp--, ssl_expr_yyssp--, ssl_expr_yylsp--)
#else
#define YYPOPSTACK   (ssl_expr_yyvsp--, ssl_expr_yyssp--)
#endif

  int ssl_expr_yystacksize = YYINITDEPTH;
  int ssl_expr_yyfree_stacks = 0;

#ifdef YYPURE
  int ssl_expr_yychar;
  YYSTYPE ssl_expr_yylval;
  int ssl_expr_yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE ssl_expr_yylloc;
#endif
#endif

  YYSTYPE ssl_expr_yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int ssl_expr_yylen;
#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  ssl_expr_yystate = 0;
  ssl_expr_yyerrstatus = 0;
  ssl_expr_yynerrs = 0;
  ssl_expr_yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  ssl_expr_yyssp = ssl_expr_yyss - 1;
  ssl_expr_yyvsp = ssl_expr_yyvs;
#ifdef YYLSP_NEEDED
  ssl_expr_yylsp = ssl_expr_yyls;
#endif

/* Push a new state, which is found in  ssl_expr_yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
ssl_expr_yynewstate:

  *++ssl_expr_yyssp = ssl_expr_yystate;

  if (ssl_expr_yyssp >= ssl_expr_yyss + ssl_expr_yystacksize - 1)
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *ssl_expr_yyvs1 = ssl_expr_yyvs;
      short *ssl_expr_yyss1 = ssl_expr_yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *ssl_expr_yyls1 = ssl_expr_yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = ssl_expr_yyssp - ssl_expr_yyss + 1;

#ifdef ssl_expr_yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if ssl_expr_yyoverflow is a macro.  */
      ssl_expr_yyoverflow("parser stack overflow",
		 &ssl_expr_yyss1, size * sizeof (*ssl_expr_yyssp),
		 &ssl_expr_yyvs1, size * sizeof (*ssl_expr_yyvsp),
		 &ssl_expr_yyls1, size * sizeof (*ssl_expr_yylsp),
		 &ssl_expr_yystacksize);
#else
      ssl_expr_yyoverflow("parser stack overflow",
		 &ssl_expr_yyss1, size * sizeof (*ssl_expr_yyssp),
		 &ssl_expr_yyvs1, size * sizeof (*ssl_expr_yyvsp),
		 &ssl_expr_yystacksize);
#endif

      ssl_expr_yyss = ssl_expr_yyss1; ssl_expr_yyvs = ssl_expr_yyvs1;
#ifdef YYLSP_NEEDED
      ssl_expr_yyls = ssl_expr_yyls1;
#endif
#else /* no ssl_expr_yyoverflow */
      /* Extend the stack our own way.  */
      if (ssl_expr_yystacksize >= YYMAXDEPTH)
	{
	  ssl_expr_yyerror("parser stack overflow");
	  if (ssl_expr_yyfree_stacks)
	    {
	      free (ssl_expr_yyss);
	      free (ssl_expr_yyvs);
#ifdef YYLSP_NEEDED
	      free (ssl_expr_yyls);
#endif
	    }
	  return 2;
	}
      ssl_expr_yystacksize *= 2;
      if (ssl_expr_yystacksize > YYMAXDEPTH)
	ssl_expr_yystacksize = YYMAXDEPTH;
#ifndef YYSTACK_USE_ALLOCA
      ssl_expr_yyfree_stacks = 1;
#endif
      ssl_expr_yyss = (short *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yyssp));
      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyss, (char *)ssl_expr_yyss1,
		   size * (unsigned int) sizeof (*ssl_expr_yyssp));
      ssl_expr_yyvs = (YYSTYPE *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yyvsp));
      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyvs, (char *)ssl_expr_yyvs1,
		   size * (unsigned int) sizeof (*ssl_expr_yyvsp));
#ifdef YYLSP_NEEDED
      ssl_expr_yyls = (YYLTYPE *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yylsp));
      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyls, (char *)ssl_expr_yyls1,
		   size * (unsigned int) sizeof (*ssl_expr_yylsp));
#endif
#endif /* no ssl_expr_yyoverflow */

      ssl_expr_yyssp = ssl_expr_yyss + size - 1;
      ssl_expr_yyvsp = ssl_expr_yyvs + size - 1;
#ifdef YYLSP_NEEDED
      ssl_expr_yylsp = ssl_expr_yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Stack size increased to %d\n", ssl_expr_yystacksize);
#endif

      if (ssl_expr_yyssp >= ssl_expr_yyss + ssl_expr_yystacksize - 1)
	YYABORT;

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Entering state %d\n", ssl_expr_yystate);
  goto ssl_expr_yybackup;
 ssl_expr_yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* ssl_expr_yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */
  ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];
  if (ssl_expr_yyn == YYFLAG)
    goto ssl_expr_yydefault;
  /* Not known => get a lookahead token if don't already have one.  */

  /* ssl_expr_yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (ssl_expr_yychar == YYEMPTY)
#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Reading a token: ");
      ssl_expr_yychar = YYLEX;

  /* Convert token to internal form (in ssl_expr_yychar1) for indexing tables with */

  if (ssl_expr_yychar <= 0)		/* This means end of input. */
      ssl_expr_yychar1 = 0;
      ssl_expr_yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
  else
      ssl_expr_yychar1 = YYTRANSLATE(ssl_expr_yychar);

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, ssl_expr_yychar, ssl_expr_yylval);
	  fprintf (stderr, ")\n");
	}

  ssl_expr_yyn += ssl_expr_yychar1;
  if (ssl_expr_yyn < 0 || ssl_expr_yyn > YYLAST || ssl_expr_yycheck[ssl_expr_yyn] != ssl_expr_yychar1)
    goto ssl_expr_yydefault;

  ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];

  /* ssl_expr_yyn is what to do for this token type in this state.
     Negative => reduce, -ssl_expr_yyn is rule number.
     Positive => shift, ssl_expr_yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (ssl_expr_yyn < 0)
      if (ssl_expr_yyn == YYFLAG)
	goto ssl_expr_yyerrlab;
      ssl_expr_yyn = -ssl_expr_yyn;
      goto ssl_expr_yyreduce;
  else if (ssl_expr_yyn == 0)
    goto ssl_expr_yyerrlab;

  if (ssl_expr_yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (ssl_expr_yychar != YYEOF)
    ssl_expr_yychar = YYEMPTY;

  *++ssl_expr_yyvsp = ssl_expr_yylval;
#ifdef YYLSP_NEEDED
  *++ssl_expr_yylsp = ssl_expr_yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (ssl_expr_yyerrstatus) ssl_expr_yyerrstatus--;

  ssl_expr_yystate = ssl_expr_yyn;
  goto ssl_expr_yynewstate;

/* Do the default action for the current state.  */
ssl_expr_yydefault:

  ssl_expr_yyn = ssl_expr_yydefact[ssl_expr_yystate];
  if (ssl_expr_yyn == 0)
    goto ssl_expr_yyerrlab;

/* Do a reduction.  ssl_expr_yyn is the number of a rule to reduce with.  */
  ssl_expr_yylen = ssl_expr_yyr2[ssl_expr_yyn];
  if (ssl_expr_yylen > 0)
    ssl_expr_yyval = ssl_expr_yyvsp[1-ssl_expr_yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       ssl_expr_yyn, ssl_expr_yyrline[ssl_expr_yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = ssl_expr_yyprhs[ssl_expr_yyn]; ssl_expr_yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", ssl_expr_yytname[ssl_expr_yyrhs[i]]);
      fprintf (stderr, " -> %s\n", ssl_expr_yytname[ssl_expr_yyr1[ssl_expr_yyn]]);
    }
#endif


  switch (ssl_expr_yyn) {

{ ssl_expr_info.expr = ssl_expr_yyvsp[0].exVal; ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_True,  NULL, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_False, NULL, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Not,   ssl_expr_yyvsp[0].exVal,   NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Or,    ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_And,   ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Comp,  ssl_expr_yyvsp[0].exVal,   NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[-1].exVal; ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_EQ,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_IN,  ssl_expr_yyvsp[-4].exVal, ssl_expr_yyvsp[-1].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_REG, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NRE, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, ssl_expr_yyvsp[-2].exVal);   ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Digit,  ssl_expr_yyvsp[0].cpVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_String, ssl_expr_yyvsp[0].cpVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Var,    ssl_expr_yyvsp[-1].cpVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[0].exVal; ;
    break;}
            ;
    break;}
            ;
    break;}
            ;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 543 "/usr/local/share/bison.simple"

  ssl_expr_yyvsp -= ssl_expr_yylen;
  ssl_expr_yyssp -= ssl_expr_yylen;
#ifdef YYLSP_NEEDED
  ssl_expr_yylsp -= ssl_expr_yylen;
#endif

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    {
      short *ssp1 = ssl_expr_yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != ssl_expr_yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++ssl_expr_yyvsp = ssl_expr_yyval;

#ifdef YYLSP_NEEDED
  ssl_expr_yylsp++;
  if (ssl_expr_yylen == 0)
    {
      ssl_expr_yylsp->first_line = ssl_expr_yylloc.first_line;
      ssl_expr_yylsp->first_column = ssl_expr_yylloc.first_column;
      ssl_expr_yylsp->last_line = (ssl_expr_yylsp-1)->last_line;
      ssl_expr_yylsp->last_column = (ssl_expr_yylsp-1)->last_column;
      ssl_expr_yylsp->text = 0;
    }
  else
    {
      ssl_expr_yylsp->last_line = (ssl_expr_yylsp+ssl_expr_yylen-1)->last_line;
      ssl_expr_yylsp->last_column = (ssl_expr_yylsp+ssl_expr_yylen-1)->last_column;
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  ssl_expr_yyn = ssl_expr_yyr1[ssl_expr_yyn];

  ssl_expr_yystate = ssl_expr_yypgoto[ssl_expr_yyn - YYNTBASE] + *ssl_expr_yyssp;
  if (ssl_expr_yystate >= 0 && ssl_expr_yystate <= YYLAST && ssl_expr_yycheck[ssl_expr_yystate] == *ssl_expr_yyssp)
    ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yystate];
  else
    ssl_expr_yystate = ssl_expr_yydefgoto[ssl_expr_yyn - YYNTBASE];

  goto ssl_expr_yynewstate;

ssl_expr_yyerrlab:   /* here on detecting error */

  if (! ssl_expr_yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++ssl_expr_yynerrs;

#ifdef YYERROR_VERBOSE
      ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];

      if (ssl_expr_yyn > YYFLAG && ssl_expr_yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -ssl_expr_yyn if nec to avoid negative indexes in ssl_expr_yycheck.  */
	  for (x = (ssl_expr_yyn < 0 ? -ssl_expr_yyn : 0);
	       x < (sizeof(ssl_expr_yytname) / sizeof(char *)); x++)
	    if (ssl_expr_yycheck[x + ssl_expr_yyn] == x)
	      size += strlen(ssl_expr_yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (ssl_expr_yyn < 0 ? -ssl_expr_yyn : 0);
		       x < (sizeof(ssl_expr_yytname) / sizeof(char *)); x++)
		    if (ssl_expr_yycheck[x + ssl_expr_yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, ssl_expr_yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      ssl_expr_yyerror(msg);
	      free(msg);
	    }
	  else
	    ssl_expr_yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	ssl_expr_yyerror("parse error");
    }

  goto ssl_expr_yyerrlab1;
ssl_expr_yyerrlab1:   /* here on error raised explicitly by an action */

  if (ssl_expr_yyerrstatus == 3)
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (ssl_expr_yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
#endif

      ssl_expr_yychar = YYEMPTY;

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  ssl_expr_yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto ssl_expr_yyerrhandle;

ssl_expr_yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  ssl_expr_yyn = ssl_expr_yydefact[ssl_expr_yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (ssl_expr_yyn) goto ssl_expr_yydefault;
#endif

ssl_expr_yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (ssl_expr_yyssp == ssl_expr_yyss) YYABORT;
  ssl_expr_yyvsp--;
  ssl_expr_yystate = *--ssl_expr_yyssp;
#ifdef YYLSP_NEEDED
  ssl_expr_yylsp--;
#endif

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
      short *ssp1 = ssl_expr_yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != ssl_expr_yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
#endif

ssl_expr_yyerrhandle:

  ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];
  if (ssl_expr_yyn == YYFLAG)
    goto ssl_expr_yyerrdefault;

  ssl_expr_yyn += YYTERROR;
  if (ssl_expr_yyn < 0 || ssl_expr_yyn > YYLAST || ssl_expr_yycheck[ssl_expr_yyn] != YYTERROR)
    goto ssl_expr_yyerrdefault;

  ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];
  if (ssl_expr_yyn < 0)
    {
      if (ssl_expr_yyn == YYFLAG)
	goto ssl_expr_yyerrpop;
      ssl_expr_yyn = -ssl_expr_yyn;
      goto ssl_expr_yyreduce;
    }
  else if (ssl_expr_yyn == 0)
    goto ssl_expr_yyerrpop;

  if (ssl_expr_yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++ssl_expr_yyvsp = ssl_expr_yylval;
#ifdef YYLSP_NEEDED
  *++ssl_expr_yylsp = ssl_expr_yylloc;
#endif

  ssl_expr_yystate = ssl_expr_yyn;
  goto ssl_expr_yynewstate;

 ssl_expr_yyacceptlab:
  /* YYACCEPT comes here.  */
  if (ssl_expr_yyfree_stacks)
    {
      free (ssl_expr_yyss);
      free (ssl_expr_yyvs);
#ifdef YYLSP_NEEDED
      free (ssl_expr_yyls);
#endif
    }
  return 0;

 ssl_expr_yyabortlab:
  /* YYABORT comes here.  */
  if (ssl_expr_yyfree_stacks)
    {
      free (ssl_expr_yyss);
      free (ssl_expr_yyvs);
#ifdef YYLSP_NEEDED
      free (ssl_expr_yyls);
#endif
    }
  return 1;
}
#line 176 "ssl_expr_parse.y"


int ssl_expr_yyerror(char *s)
{
    ssl_expr_error = s;
    return 2;

#define	T_TRUE	257
#define	T_FALSE	258
#define	T_DIGIT	259
#define	T_ID	260
#define	T_STRING	261
#define	T_REGEX	262
#define	T_REGEX_I	263
#define	T_FUNC_FILE	264
#define	T_OP_EQ	265
#define	T_OP_NE	266
#define	T_OP_LT	267
#define	T_OP_LE	268
#define	T_OP_GT	269
#define	T_OP_GE	270
#define	T_OP_REG	271
#define	T_OP_NRE	272
#define	T_OP_IN	273
#define	T_OP_OR	274
#define	T_OP_AND	275
#define	T_OP_NOT	276


 * $Header: /home/striker/cvs2svn/dumps/httpd-2.0/../../httpd-2.0/modules/ssl/ssl_expr_scan.c,v 1.7 2002/01/10 00:28:00 wrowe Exp $
#include <unistd.h>
    ap_sb_handle_t *sbh;
    ap_sb_handle_t *sbh;
        ap_scoreboard_image->global->running_generation = ap_my_generation;
        void *sb_mem;
        rc = DosAllocSharedMem((PPVOID)&sbmem, ap_scoreboard_fname,
        ap_init_scoreboard(sb_mem);
    } while (!shutdown_pending && ap_my_generation == ap_scoreboard_image->global->running_generation);
    ap_sb_handle_t *sbh;
    ap_sb_handle_t *sbh;
        ap_scoreboard_image->global->running_generation = ap_my_generation;
    ap_sb_handle_t *sbh;
    ap_sb_handle_t *sbh;
    reopen_scoreboard(pchild, 0);
    ap_scoreboard_image->global->running_generation = ap_my_generation;
	ap_scoreboard_image->global->running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
	ap_scoreboard_image->global->running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
    ap_sb_handle_t *sbh;
    thread_control[THREAD_GLOBAL(thread_num)].generation = ap_scoreboard_image->global->running_generation;
    ++ap_scoreboard_image->global->running_generation;
#define AP_MPM_WANT_SET_SCOREBOARD
    ap_sb_handle_t *sbh;
            /* Set up the scoreboard. */
            ap_run_pre_mpm(pconf, SB_NOT_SHARED);
            /* Set up the scoreboard. */
            ap_run_pre_mpm(pconf, SB_SHARED_CHILD);
        ap_scoreboard_image->parent[0].pid = parent_pid;
        ap_scoreboard_image->parent[0].quiescing = 0;
            
        /* Set up the scoreboard. */
        ap_run_pre_mpm(pconf, SB_SHARED);

    ap_sb_handle_t *sbh;
    reopen_scoreboard(pchild, 0);
    ap_scoreboard_image->global->running_generation = ap_my_generation;
const char * ap_mpm_set_scoreboard(cmd_parms *cmd, void *dummy,
                                   const char *arg)
const char *ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
                                const char *arg)
#include "apr_shm.h"
static apr_shm_t *scoreboard_shm = NULL;
struct ap_sb_handle_t {
};
    free(ap_scoreboard_image);
    scoreboard_size = sizeof(global_score);
void ap_init_scoreboard(void *shared_score)
    ap_scoreboard_image = 
        calloc(1, sizeof(scoreboard) + server_limit * sizeof(worker_score *));
    more_storage = shared_score;
    ap_scoreboard_image->global = (global_score *)more_storage;
    more_storage += sizeof(global_score);
    ap_scoreboard_image->servers = 
        (worker_score **)((char*)ap_scoreboard_image + sizeof(scoreboard));
    ap_assert(more_storage == (char*)shared_score + scoreboard_size);
static apr_status_t open_scoreboard(apr_pool_t *p)
    char *fname = NULL;
    if (ap_scoreboard_fname) {
        fname = ap_server_root_relative(p, ap_scoreboard_fname);
    }
    rv = apr_shm_create(&scoreboard_shm, scoreboard_size, fname, p);
/* If detach is non-zero, this is a seperate child process,
 * if zero, it is a forked child.
 */
apr_status_t reopen_scoreboard(apr_pool_t *p, int detached)
#if APR_HAS_SHARED_MEMORY
    apr_status_t rv;
    char *fname = NULL;

    if (!detached) {
        return APR_SUCCESS;
    }
    if (ap_scoreboard_fname) {
        fname = ap_server_root_relative(p, ap_scoreboard_fname);
    }
    rv = apr_shm_attach(&scoreboard_shm, fname, p);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                     "Fatal error: could not open(create) scoreboard");
        return rv;
    }
    if (apr_shm_size_get(scoreboard_shm) < scoreboard_size) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                     "Fatal error: shared scoreboard too small for child!");
        apr_shm_detach(scoreboard_shm);
        scoreboard_shm = NULL;
    }
    /* everything will be cleared shortly */
#endif
    return APR_SUCCESS;
    if (ap_scoreboard_image->global->sb_type == SB_SHARED) {
        free(ap_scoreboard_image->global);
/* Create or reinit an existing scoreboard. The MPM can control whether
void ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
	running_gen = ap_scoreboard_image->global->running_generation;
            void *sb_shared;
            rv = open_scoreboard(p);
            if (rv || !(sb_shared = apr_shm_baseaddr_get(scoreboard_shm))) {
            memset(sb_shared, 0, scoreboard_size);
            ap_init_scoreboard(sb_shared);
        }
        else if (sb_type == SB_SHARED_CHILD) {
            void *sb_shared;
            rv = reopen_scoreboard(p, 1);
            if (rv || !(sb_shared = apr_shm_baseaddr_get(scoreboard_shm))) {
                exit(APEXIT_INIT); /* XXX need to return an error from this function */
            }
            ap_init_scoreboard(sb_shared);
            void *sb_mem = calloc(1, scoreboard_size);
            if (sb_mem == NULL) {
            ap_init_scoreboard(sb_mem);
    /* can't just memset() */
    if (sb_type != SB_SHARED_CHILD) {
        ap_scoreboard_image->global->sb_type = sb_type;
        ap_scoreboard_image->global->running_generation = running_gen;
        ap_restart_time = apr_time_now();
        apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
    }
				           worker_score *new_score_rec)
    lseek(scoreboard_fd, sizeof(global_score) 
                       + (long) child_num * sizeof(worker_score), 0);
    lseek(scoreboard_fd, 0, 0);
AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)
AP_DECLARE(void) ap_create_sb_handle(ap_sb_handle_t **new_sbh, apr_pool_t *p,
    *new_sbh = (ap_sb_handle_t *)apr_palloc(p, sizeof(ap_sb_handle_t));
    (*new_sbh)->child_num = child_num;
    (*new_sbh)->thread_num = thread_num;
    int old_status;
        ps->generation = ap_my_generation;
	    apr_cpystrn(ws->vhost, r->server->server_hostname, sizeof(ws->vhost));
AP_DECLARE(int)ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r)
    return ap_update_child_status_from_indexes(sbh->child_num, sbh->thread_num,
AP_DECLARE(worker_score *) ap_get_scoreboard_worker(int x, int y)
AP_DECLARE(process_score *) ap_get_scoreboard_process(int x)
AP_DECLARE(global_score *) ap_get_scoreboard_global()
    return(ap_scoreboard_image->global);
    ap_listen_rec **walk, *last;
    /* Initialize to our last configured ap_listener. */
    last = ap_listeners;
    while (last && last->next) {
        last = last->next;
    }

        new->next = 0;
        /* We need to preserve the order returned by getaddrinfo() */
        if (last == NULL) {
            ap_listeners = last = new;
        } else {
            last->next = new;
            last = new;
        }
    ap_listen_rec *previous;
    previous = NULL;
    for (lr = ap_listeners; lr; previous = lr, lr = lr->next) {
#if APR_HAVE_IPV6
            int v6only_setting;
            /* If we are trying to bind to 0.0.0.0 and the previous listener
             * was :: on the same port and in turn that socket does not have
             * the IPV6_V6ONLY flag set; we must skip the current attempt to
             * listen (which would generate an error). IPv4 will be handled
             * on the established IPv6 socket.
             */
            if (previous != NULL &&
                lr->bind_addr->family == APR_INET &&
                *((in_addr_t *)lr->bind_addr->ipaddr_ptr) == INADDR_ANY &&
                lr->bind_addr->port == previous->bind_addr->port &&
                previous->bind_addr->family == APR_INET6 &&
                IN6_IS_ADDR_UNSPECIFIED(
                        (struct in6_addr*)(previous->bind_addr->ipaddr_ptr)) &&
                apr_socket_opt_get(previous->sd, APR_IPV6_V6ONLY,
                                   &v6only_setting) == APR_SUCCESS &&
                v6only_setting == 0) {

                /* Remove the current listener from the list */
                previous->next = lr->next;
                continue;
            }
#endif
#if APR_HAVE_IPV6
                /* If we tried to bind to ::, and the next listener is
                 * on 0.0.0.0 with the same port, don't give a fatal
                 * error. The user will still get a warning from make_sock
                 * though.
                 */
                if (lr->next != NULL && lr->bind_addr->family == APR_INET6 &&
                    IN6_IS_ADDR_UNSPECIFIED(
                        (struct in6_addr*)(previous->bind_addr->ipaddr_ptr)) &&
                    lr->bind_addr->port == lr->next->bind_addr->port &&
                    *((in_addr_t *)lr->next->bind_addr->ipaddr_ptr)
                    == INADDR_ANY) {

                    /* Remove the current listener from the list */
                    if (previous) {
                        previous->next = lr->next;
                    }
                    else {
                        ap_listeners = lr->next;
                    }

                    /* So that previous becomes NULL in the next iteration */
                    lr = NULL;

                    continue;
                }
#endif
    apr_os_pipe_put(&tempsock, &sd, r->pool);
    apr_os_pipe_put(&tempsock, &sd, r->pool);
        rv = cache->provider->store_body(cache->handle, r, in);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, r->server,
                         "cache: Cache provider's store_body failed!");
            ap_remove_output_filter(f);
        }
        return ap_pass_brigade(f->next, in);
    rv = cache->provider->store_body(cache->handle, r, in);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, r->server,
                     "cache: store_body failed");
        ap_remove_output_filter(f);
    }
    return ap_pass_brigade(f->next, in);
    apr_status_t (*store_body)(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b);
 * Format #1:
 *   apr_uint32_t format;
 * Format #2:
 *   disk_cache_info_t (first sizeof(apr_uint32_t) bytes is the format)
static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b);
static void mkdir_structure(disk_cache_conf *conf, const char *file, apr_pool_t *pool)
    apr_status_t rv;
            /* XXX */
        *p = '/';
static apr_status_t file_cache_el_final(disk_cache_object_t *dobj,
                                        request_rec *r)
{
    /* move the data over */
    if (dobj->tfd) {
        apr_status_t rv;

        apr_file_close(dobj->tfd);

        /* This assumes that the tempfile is on the same file system
         * as the cache_root. If not, then we need a file copy/move
         * rather than a rename.
         */
        rv = apr_file_rename(dobj->tempfile, dobj->datafile, r->pool);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, r->server,
                         "disk_cache: rename tempfile to datafile failed:"
                         " %s -> %s", dobj->tempfile, dobj->datafile);
            apr_file_remove(dobj->tempfile, r->pool);
        }

        dobj->tfd = NULL;
    }

    return APR_SUCCESS;
}

/* These two functions get and put state information into the data
 * file for an ap_cache_el, this state information will be read
 * and written transparent to clients of this module
 */
static int file_cache_recall_mydata(apr_file_t *fd, cache_info *info,
                                    disk_cache_object_t *dobj, request_rec *r)
{
    apr_status_t rv;
    char *urlbuff;
    disk_cache_info_t disk_info;
    apr_size_t len;

    /* read the data from the cache file */
    len = sizeof(disk_cache_info_t);
    rv = apr_file_read_full(fd, &disk_info, len, &len);
    if (rv != APR_SUCCESS) {
        return rv;
    }

    /* Store it away so we can get it later. */
    dobj->disk_info = disk_info;

    info->status = disk_info.status;
    info->date = disk_info.date;
    info->expire = disk_info.expire;
    info->request_time = disk_info.request_time;
    info->response_time = disk_info.response_time;

    /* Note that we could optimize this by conditionally doing the palloc
     * depending upon the size. */
    urlbuff = apr_palloc(r->pool, disk_info.name_len + 1);
    len = disk_info.name_len;
    rv = apr_file_read_full(fd, urlbuff, len, &len);
    if (rv != APR_SUCCESS) {
        return rv;
    }
    urlbuff[disk_info.name_len] = '\0';

    /* check that we have the same URL */
    /* Would strncmp be correct? */
    if (strcmp(urlbuff, dobj->name) != 0) {
        return APR_EGENERAL;
    }

    return APR_SUCCESS;
}

static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
    apr_uint32_t format;
    apr_size_t len;
    const char *nkey;
    static int error_logged = 0;
    disk_cache_conf *conf = ap_get_module_config(r->server->module_config,
                                                 &disk_cache_module);
    apr_finfo_t finfo;
    cache_object_t *obj;
    cache_info *info;
    disk_cache_object_t *dobj;
    int flags;
    h->cache_obj = NULL;
    /* Look up entity keyed to 'url' */
    if (conf->cache_root == NULL) {
        if (!error_logged) {
            error_logged = 1;
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: Cannot cache files to disk without a CacheRoot specified.");
        return DECLINED;
    /* Create and init the cache object */
    h->cache_obj = obj = apr_pcalloc(r->pool, sizeof(cache_object_t));
    obj->vobj = dobj = apr_pcalloc(r->pool, sizeof(disk_cache_object_t));
    info = &(obj->info);
    /* Open the headers file */
    dobj->prefix = NULL;
    /* Save the cache root */
    dobj->root = apr_pstrndup(r->pool, conf->cache_root, conf->cache_root_len);
    dobj->root_len = conf->cache_root_len;
    dobj->hdrsfile = header_file(r->pool, conf, dobj, key);
    flags = APR_READ|APR_BINARY|APR_BUFFERED;
        return DECLINED;
    len = sizeof(format);
    apr_file_read_full(dobj->hfd, &format, len, &len);
        len = sizeof(expire);
        apr_file_read_full(dobj->hfd, &expire, len, &len);
            return DECLINED;
            return DECLINED;
        dobj->hashfile = NULL;
        dobj->hdrsfile = header_file(r->pool, conf, dobj, nkey);
        flags = APR_READ|APR_BINARY|APR_BUFFERED;
            return DECLINED;
    else if (format != DISK_FORMAT_VERSION) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "disk_cache: File '%s' has a version mismatch. File had version: %d.",
                     dobj->hdrsfile, format);
        return DECLINED;
    }
    else {
        apr_off_t offset = 0;
        /* This wasn't a Vary Format file, so we must seek to the
         * start of the file again, so that later reads work.
         */
        apr_file_seek(dobj->hfd, APR_SET, &offset);
        nkey = key;
    dobj->key = nkey;
    dobj->datafile = data_file(r->pool, conf, dobj, nkey);
    dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);
    /* Open the data file */
    flags = APR_READ|APR_BINARY;
#ifdef APR_SENDFILE_ENABLED
    flags |= APR_SENDFILE_ENABLED;
#endif
    rc = apr_file_open(&dobj->fd, dobj->datafile, flags, 0, r->pool);
    if (rc != APR_SUCCESS) {
        /* XXX: Log message */
        return DECLINED;

    rc = apr_file_info_get(&finfo, APR_FINFO_SIZE, dobj->fd);
    if (rc == APR_SUCCESS) {
        dobj->file_size = finfo.size;
    /* Read the bytes to setup the cache_info fields */
    rc = file_cache_recall_mydata(dobj->hfd, info, dobj, r);
    if (rc != APR_SUCCESS) {
        /* XXX log message */
        return DECLINED;
    }
    /* Initialize the cache_handle callback functions */
    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "disk_cache: Recalled cached URL info header %s",  dobj->name);
    return OK;
static int remove_entity(cache_handle_t *h)
    /* Null out the cache object pointer so next time we start from scratch  */
    h->cache_obj = NULL;
    return OK;
static int remove_url(cache_handle_t *h, apr_pool_t *p)
    disk_cache_object_t *dobj;
    /* Get disk cache object from cache handle */
    dobj = (disk_cache_object_t *) h->cache_obj->vobj;
    if (!dobj) {
        return DECLINED;
    }
    /* Delete headers file */
    if (dobj->hdrsfile) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                     "disk_cache: Deleting %s from cache.", dobj->hdrsfile);
        rc = apr_file_remove(dobj->hdrsfile, p);
        if ((rc != APR_SUCCESS) && !APR_STATUS_IS_ENOENT(rc)) {
            /* Will only result in an output if httpd is started with -e debug.
             * For reason see log_error_core for the case s == NULL.
             */
            ap_log_error(APLOG_MARK, APLOG_DEBUG, rc, NULL,
                   "disk_cache: Failed to delete headers file %s from cache.",
                         dobj->hdrsfile);
            return DECLINED;
     /* Delete data file */
    if (dobj->datafile) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                     "disk_cache: Deleting %s from cache.", dobj->datafile);
static apr_status_t read_table(cache_handle_t *handle, request_rec *r,
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "Premature end of cache headers.");
                             "CGI Interface Error: Script headers apparently ASCII: (CGI = %s)",
    h->req_hdrs = apr_table_make(r->pool, 20);
    h->resp_hdrs = apr_table_make(r->pool, 20);
    /* Call routine to read the header lines/status line */
    read_table(h, r, h->resp_hdrs, dobj->hfd);
    read_table(h, r, h->req_hdrs, dobj->hfd);
    apr_brigade_insert_file(bb, dobj->fd, 0, dobj->file_size, p);
static apr_status_t store_headers(cache_handle_t *h, request_rec *r, cache_info *info)
    disk_cache_conf *conf = ap_get_module_config(r->server->module_config,
                                                 &disk_cache_module);
    apr_size_t amt;
    disk_cache_object_t *dobj = (disk_cache_object_t*) h->cache_obj->vobj;
    disk_cache_info_t disk_info;
    struct iovec iov[2];
    /* This is flaky... we need to manage the cache_info differently */
    h->cache_obj->info = *info;
    if (r->headers_out) {
        const char *tmp;
        tmp = apr_table_get(r->headers_out, "Vary");
        if (tmp) {
            apr_array_header_t* varray;
            apr_uint32_t format = VARY_FORMAT_VERSION;
            mkdir_structure(conf, dobj->hdrsfile, r->pool);
            rv = apr_file_mktemp(&dobj->tfd, dobj->tempfile,
                                 APR_CREATE | APR_WRITE | APR_BINARY | APR_EXCL,
                                 r->pool);
            if (rv != APR_SUCCESS) {
                return rv;
            }
            amt = sizeof(format);
            apr_file_write(dobj->tfd, &format, &amt);
            amt = sizeof(info->expire);
            apr_file_write(dobj->tfd, &info->expire, &amt);
            varray = apr_array_make(r->pool, 6, sizeof(char*));
            tokens_to_array(r->pool, tmp, varray);
            store_array(dobj->tfd, varray);
            apr_file_close(dobj->tfd);
            dobj->tfd = NULL;
            rv = safe_file_rename(conf, dobj->tempfile, dobj->hdrsfile,
                                  r->pool);
            if (rv != APR_SUCCESS) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, r->server,
                    "disk_cache: rename tempfile to varyfile failed: %s -> %s",
                    dobj->tempfile, dobj->hdrsfile);
                apr_file_remove(dobj->tempfile, r->pool);
                return rv;
            }
            dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);
            tmp = regen_key(r->pool, r->headers_in, varray, dobj->name);
            dobj->prefix = dobj->hdrsfile;
            dobj->hashfile = NULL;
            dobj->datafile = data_file(r->pool, conf, dobj, tmp);
            dobj->hdrsfile = header_file(r->pool, conf, dobj, tmp);
        }
    rv = apr_file_mktemp(&dobj->hfd, dobj->tempfile,
                         APR_CREATE | APR_WRITE | APR_BINARY |
                         APR_BUFFERED | APR_EXCL, r->pool);
    if (rv != APR_SUCCESS) {
        return rv;
    }
    dobj->name = h->cache_obj->key;
    disk_info.format = DISK_FORMAT_VERSION;
    iov[0].iov_base = (void*)&disk_info;
    iov[0].iov_len = sizeof(disk_cache_info_t);
    iov[1].iov_base = (void*)dobj->name;
    iov[1].iov_len = disk_info.name_len;

    rv = apr_file_writev(dobj->hfd, (const struct iovec *) &iov, 2, &amt);
    apr_file_close(dobj->hfd); /* flush and close */
    /* Remove old file with the same name. If remove fails, then
     * perhaps we need to create the directory tree where we are
     * about to write the new headers file.
     */
    rv = apr_file_remove(dobj->hdrsfile, r->pool);
    if (rv != APR_SUCCESS) {
        mkdir_structure(conf, dobj->hdrsfile, r->pool);
    rv = safe_file_rename(conf, dobj->tempfile, dobj->hdrsfile, r->pool);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                     "disk_cache: rename tempfile to hdrsfile failed: %s -> %s",
                     dobj->tempfile, dobj->hdrsfile);
        apr_file_remove(dobj->tempfile, r->pool);
    dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);
static apr_status_t store_body(cache_handle_t *h, request_rec *r,
                               apr_bucket_brigade *bb)
    apr_bucket *e;
    /* We write to a temp file and then atomically rename the file over
     * in file_cache_el_final().
     */
    if (!dobj->tfd) {
        rv = apr_file_mktemp(&dobj->tfd, dobj->tempfile,
                             APR_CREATE | APR_WRITE | APR_BINARY |
                             APR_BUFFERED | APR_EXCL, r->pool);
        if (rv != APR_SUCCESS) {
            return rv;
        dobj->file_size = 0;
    for (e = APR_BRIGADE_FIRST(bb);
         e != APR_BRIGADE_SENTINEL(bb);
         e = APR_BUCKET_NEXT(e))
    {
        rv = apr_bucket_read(e, &str, &length, APR_BLOCK_READ);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: Error when reading bucket for URL %s",
                         h->cache_obj->key);
            /* Remove the intermediate cache file and return non-APR_SUCCESS */
            file_cache_errorcleanup(dobj, r);
            return rv;
        rv = apr_file_write_full(dobj->tfd, str, length, &written);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: Error when writing cache file for URL %s",
                         h->cache_obj->key);
            /* Remove the intermediate cache file and return non-APR_SUCCESS */
            file_cache_errorcleanup(dobj, r);
            return rv;
        }
        dobj->file_size += written;
        if (dobj->file_size > conf->maxfs) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                         "disk_cache: URL %s failed the size check "
                         "(%" APR_OFF_T_FMT ">%" APR_OFF_T_FMT ")",
                         h->cache_obj->key, dobj->file_size, conf->maxfs);
            /* Remove the intermediate cache file and return non-APR_SUCCESS */
            file_cache_errorcleanup(dobj, r);
            return APR_EGENERAL;
    /* Was this the final bucket? If yes, close the temp file and perform
     * sanity checks.
     */
    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
        if (r->connection->aborted || r->no_cache) {
            ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                         "disk_cache: Discarding body for URL %s "
                         "because connection has been aborted.",
                         h->cache_obj->key);
            /* Remove the intermediate cache file and return non-APR_SUCCESS */
            file_cache_errorcleanup(dobj, r);
            return APR_EGENERAL;
        }
        if (dobj->file_size < conf->minfs) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                         "disk_cache: URL %s failed the size check "
                         "(%" APR_OFF_T_FMT "<%" APR_OFF_T_FMT ")",
                         h->cache_obj->key, dobj->file_size, conf->minfs);
            /* Remove the intermediate cache file and return non-APR_SUCCESS */
            return APR_EGENERAL;
        /* All checks were fine. Move tempfile to final destination */
        /* Link to the perm file, and close the descriptor */
        file_cache_el_final(dobj, r);
                     "disk_cache: Body for URL %s cached.",  dobj->name);
    return APR_SUCCESS;
#define DISK_FORMAT_VERSION 4
    /* Indicates the format of the header struct stored on-disk. */
    apr_uint32_t format;
    const char *key;    /* On-disk prefix; URI with Vary bits (if present) */
static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b);
static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b)
                return rv;
            return APR_SUCCESS;
            return APR_ENOMEM;
                    return APR_ENOMEM;
           if ((obj->count + len) > mobj->m_len) {
               return APR_ENOMEM;
           }
           else {
           }
    return APR_SUCCESS;
        return 0;
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            else if (r->method == NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                              "request failed: invalid characters in URI");
            }
            char buff[512]; /* should be plenty */
            BIO *bio = BIO_new(BIO_s_mem());
            BIO_printf(bio, "CA CRL: Issuer: ");
            X509_NAME_print(bio, issuer, 0);

            BIO_printf(bio, ", lastUpdate: ");
            n = BIO_read(bio, buff, sizeof(buff));
            buff[n] = '\0';
            BIO_free(bio);
            ssl_log(s, SSL_LOG_TRACE, buff);
#define CORE_PRIVATE

#include "apr_strings.h"
#include "apr_buckets.h"
#include "util_filter.h"
#include "ap_config.h"
#include "http_main.h"
#include "http_connection.h"
#include "util_date.h"
int ap_proxy_ftp_canon(request_rec *r, char *url);
int ap_proxy_ftp_handler(request_rec *r, char *url);
static int ftp_getrc_msg(conn_rec *c, char *msgbuf, int msglen)
    char *response;
    char buff[5];
    apr_bucket *e;
    apr_bucket_brigade *bb = apr_brigade_create(c->pool);

    bb = apr_brigade_create(c->pool);
    /* Tell http_filter to grab the data one line at a time. */
    c->remain = 0;

    ap_get_brigade(c->input_filters, bb, AP_MODE_BLOCKING);
    e = APR_BRIGADE_FIRST(bb);
    apr_bucket_read(e, (const char **)&response, &len, APR_BLOCK_READ);
    if (len == -1) {
    }
    if (len < 5 || !apr_isdigit(response[0]) || !apr_isdigit(response[1]) ||
	!apr_isdigit(response[2]) || (response[3] != ' ' && response[3] != '-'))
	status = 100 * response[0] + 10 * response[1] + response[2] - 111 * '0';
    mb = apr_cpystrn(mb, response+4, me - mb);
/* FIXME: If the line was too long, read till LF */
    if (response[3] == '-') {
	memcpy(buff, response, 3);
	    apr_bucket_read(e, (const char **)&response, &len, APR_BLOCK_READ);

/* FIXME: If the line was too long, read till LF */

	    mb = apr_cpystrn(mb, response+4, me - mb);
	} while (memcmp(response, buff, 4) != 0);

    APR_BUCKET_REMOVE(e);
    apr_bucket_destroy(e);

/* this piece needs some serious overhauling */
#if 0
#endif
 * Filters by [Graham Leggett <minfrin@sharp.fm>]
int ap_proxy_ftp_handler(request_rec *r, char *url)
    apr_pool_t *p = r->pool;
    apr_socket_t *sock, *local_sock, *remote_sock;
    apr_sockaddr_t *uri_addr, *connect_addr;
    conn_rec *origin, *remote;
    int err;
    apr_bucket *e;
    apr_bucket_brigade *bb = apr_brigade_create(p);
    char *buf, *pasv, *connectname;
    apr_port_t connectport;
    char buffer[MAX_STRING_LEN];

    char *path, *strp, *parms;
    int i, j, len, rc;
    char *size = NULL;

    /* stuff for PASV mode */
    int pasvmode = 0;
    char dates[AP_RFC822_DATE_LEN];
    /*
     * I: Who Do I Connect To?
     * -----------------------
     *
     * Break up the URL to determine the host to connect to
     */
    /* we only support GET and HEAD */
    /* We break the URL into host, port, path-search */
    connectname = r->parsed_uri.hostname;
    connectport = (r->parsed_uri.port != 0)
	           ? r->parsed_uri.port
	           : ap_default_port_for_request(r);
    parms = strchr(path, ';');
    if (parms != NULL)
	*(parms++) = '\0';

    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: FTP connecting %s to %s:%d", url, connectname, connectport);

    /* do a DNS lookup for the destination host */
    err = apr_sockaddr_info_get(&uri_addr, connectname, APR_UNSPEC, connectport, 0, p);

    /* check if ProxyBlock directive on this host */
    if (OK != ap_proxy_checkproxyblock(r, conf, uri_addr)) {
	return ap_proxyerror(r, HTTP_FORBIDDEN,
			     "Connect to remote machine blocked");
    /*
     * II: Make the Connection
     * -----------------------
     *
     * We have determined who to connect to. Now make the connection.
     */

    /* get all the possible IP addresses for the destname and loop through them
     * until we get a successful connection
     */
    if (APR_SUCCESS != err) {
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_pstrcat(p,
                             "DNS lookup failure for: ",
                             connectname, NULL));
    }
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: socket has been created");


    /*
     * At this point we have a list of one or more IP addresses of
     * the machine to connect to. If configured, reorder this
     * list so that the "best candidate" is first try. "best
     * candidate" could mean the least loaded server, the fastest
     * responding server, whatever.
     *
     * For now we do nothing, ie we get DNS round robin.
     * XXX FIXME
     */


    /* try each IP address until we connect successfully */
    {
	int failed = 1;
	while (connect_addr) {

	    /* make the connection out of the socket */
	    err = apr_connect(sock, connect_addr);

	    /* if an error occurred, loop round and try again */
            if (err != APR_SUCCESS) {
		ap_log_error(APLOG_MARK, APLOG_ERR, err, r->server,
			     "proxy: attempt to connect to %pI (%s) failed", connect_addr, connectname);
		connect_addr = connect_addr->next;
		continue;
            }

	    /* if we get here, all is well */
	    failed = 0;
	    break;
	}

	/* handle a permanent error from the above loop */
	if (failed) {
	    apr_socket_close(sock);
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_pstrcat(r->pool,
				 "Could not connect to remote machine: ",
				 r->parsed_uri.hostname, NULL));
	}
    }

    /* the socket is now open, create a new connection */
    origin = ap_new_connection(p, r->server, sock, r->connection->id);
    if (!origin) {
	/* the peer reset the connection already; ap_new_connection() 
	 * closed the socket */
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: an error occurred creating a new connection to %pI (%s)", connect_addr, connectname);
	return HTTP_INTERNAL_SERVER_ERROR;
    conf->id = r->connection->id;
    /* allocate this out of the connection pool - the check on r->connection->id makes
     * sure that this string does not live past the connection lifetime */
    conf->connectname = apr_pstrdup(r->connection->pool, connectname);
    conf->connectport = connectport;

    /* if a keepalive connection is floating around, close it first! */
    if (conf->client_socket) {
	apr_socket_close(conf->client_socket);
    }
    conf->client_socket = sock;
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: connection complete");
    /*
     * III: Send Control Request
     * -------------------------
     *
     * Log into the ftp server, send the username & password, change to the correct
     * directory...
     */

    /* set up the connection filters */
    ap_proxy_pre_http_connection(origin);

    /* possible results: */
    /*   120 Service ready in nnn minutes. */
    /*   220 Service ready for new user. */
    /*   421 Service not available, closing control connection. */
    i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
				 "FTP: initial connect returned status %d", i);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
    buf = apr_pstrcat(p, "USER ", user, CRLF, NULL);
    bb = apr_brigade_create(p);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    apr_brigade_destroy(bb);
    /* possible results; 230, 331, 332, 421, 500, 501, 530 */
    /* states: 1 - error, 2 - success; 3 - send password, 4,5 fail */
    /*   230 User logged in, proceed. */
    /*   331 User name okay, need password. */
    /*   332 Need account for login. */
    /*   421 Service not available, closing control connection. */
    /*   500 Syntax error, command unrecognized. */
    /*       (This may include errors such as command line too long.) */
    /*   501 Syntax error in parameters or arguments. */
    /*   530 Not logged in. */
    i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
/* FIXME: Insert clean disconnect */
/* FIXME: Insert clean disconnect */
	buf = apr_pstrcat(p, "PASS ", password, CRLF, NULL);
	bb = apr_brigade_create(p);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,

	/* possible results 202, 230, 332, 421, 500, 501, 503, 530 */
	/*   230 User logged in, proceed. */
	/*   332 Need account for login. */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   503 Bad sequence of commands. */
	/*   530 Not logged in. */
	i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
				 apr_pstrcat(p, "Need account for login: ", buffer, NULL));
/* FIXME: Insert clean disconnect */
    /* set the directory (walk directory component by component):
     * this is what we must do if we don't know the OS type of the remote
     * machine
     */
	buf = apr_pstrcat(p, "CWD ", path, CRLF, NULL);
	bb = apr_brigade_create(p);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
	/* responses: 250, 421, 500, 501, 502, 530, 550 */
	/*   250 Requested file action okay, completed. */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   502 Command not implemented. */
	/*   530 Not logged in. */
	/*   550 Requested action not taken. */
	i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	    return ap_proxyerror(r, HTTP_NOT_FOUND, buffer);
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
	buf = apr_pstrcat(p, "TYPE I", CRLF, NULL);
	bb = apr_brigade_create(p);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	/* responses: 200, 421, 500, 501, 504, 530 */
	/*   200 Command okay. */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   504 Command not implemented for that parameter. */
	/*   530 Not logged in. */
	i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
	/* Allow not implemented */

    /*
     * IV: Make Data Connection?
     * -------------------------
     *
     * Try PASV, if that fails try normally.
     */

    /* try to set up PASV data connection first */
    if ((apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
    if (conf->recv_buffer_size > 0 && apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
    bb = apr_brigade_create(p);
    buf = apr_pstrcat(p, "PASV", CRLF, NULL);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    apr_brigade_destroy(bb);
    /* possible results: 227, 421, 500, 501, 502, 530 */
    /*   227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
    /*   421 Service not available, closing control connection. */
    /*   500 Syntax error, command unrecognized. */
    /*   501 Syntax error in parameters or arguments. */
    /*   502 Command not implemented. */
    /*   530 Not logged in. */
    bb = apr_brigade_create(p);
    origin->remain = 0;
    ap_get_brigade(origin->input_filters, bb, AP_MODE_BLOCKING);
    e = APR_BRIGADE_FIRST(bb);
    apr_bucket_read(e, (const char **)&buf, &len, APR_BLOCK_READ);
    if (len < 5) {
	apr_socket_close(remote_sock);
	return HTTP_BAD_GATEWAY;
	unsigned int presult, h0, h1, h2, h3, p0, p1;
	char *pstr;

	pasv = apr_pstrdup(p, buf);
	pasv[len - 1] = '\0';
                     "FTP: PASV returned status %d", presult);

/* FIXME: Only supports IPV4 */

	    apr_sockaddr_t *pasv_addr;
	    int pasvport = (p1 << 8) + p0;
                         "FTP: PASV contacting host %d.%d.%d.%d:%d",
                         h3, h2, h1, h0, pasvport);

	    /* make the connection */
	    apr_sockaddr_info_get(&pasv_addr, apr_psprintf(p, "%d.%d.%d.%d", h3, h2, h1, h0), APR_UNSPEC, pasvport, 0, p);
	    err = apr_connect(sock, pasv_addr);
            if (err != APR_SUCCESS) {
		return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_psprintf(r->pool,
				     "PASV attempt to connect to %pI failed - firewall/NAT?", pasv_addr));
            }
	    /* and try the regular way */
	    apr_socket_close(remote_sock);
    APR_BUCKET_REMOVE(e);
    apr_bucket_destroy(e);
    /* set up data connection */
    if (!pasvmode) {
	apr_sockaddr_t *local_addr;
	char *local_ip;
	apr_port_t local_port;

	if ((apr_socket_create(&local_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
        apr_socket_addr_get(&local_addr, APR_LOCAL, sock);
        apr_sockaddr_port_get(&local_port, local_addr);
        apr_sockaddr_ip_get(&local_ip, local_addr);
	if (apr_setsocketopt(local_sock, APR_SO_REUSEADDR, one) != APR_SUCCESS) {
	    apr_socket_close(local_sock);
        if (apr_sockaddr_info_get(&local_addr, local_ip, APR_INET,
				  local_port, 0, r->pool) != APR_SUCCESS) {
	if (apr_bind(local_sock, local_addr) != APR_SUCCESS) {
	    apr_snprintf(buff, sizeof(buff), "%s:%d", local_ip, local_port);
	    apr_socket_close(remote_sock);

	/* only need a short queue */
	apr_listen(local_sock, 2);

    /*
     * V: Set The Headers
     * -------------------
     *
     * Get the size of the request, set up the environment for HTTP.
     */

    /* set request; "path" holds last path component */
	bb = apr_brigade_create(p);
	buf = apr_pstrcat(p, "SIZE ", path, CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	i = ftp_getrc_msg(origin, buffer, sizeof buffer);
                     "FTP: returned status %d with response %s", i, buffer);
		bb = apr_brigade_create(p);
		buf = apr_pstrcat(p, "CWD ", path, CRLF, NULL);
		e = apr_bucket_pool_create(buf, strlen(buf), p);
		APR_BRIGADE_INSERT_TAIL(bb, e);
		e = apr_bucket_flush_create();
		APR_BRIGADE_INSERT_TAIL(bb, e);
		ap_pass_brigade(origin->output_filters, bb);
		apr_brigade_destroy(bb);
		i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
		    return ap_proxyerror(r, HTTP_NOT_FOUND, buffer);
		    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
		for (j = 0; j < sizeof(buffer) && apr_isdigit(buffer[j]); j++);
		buffer[j] = '\0';
		if (buffer[0] != '\0')
		    size = apr_pstrdup(p, buffer);
    bb = apr_brigade_create(p);
    buf = apr_pstrcat(p, "PWD", CRLF, NULL);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    apr_brigade_destroy(bb);
    /* responses: 257, 500, 501, 502, 421, 550 */
    /*   257 "<directory-name>" <commentary> */
    /*   421 Service not available, closing control connection. */
    /*   500 Syntax error, command unrecognized. */
    /*   501 Syntax error in parameters or arguments. */
    /*   502 Command not implemented. */
    /*   550 Requested action not taken. */
    i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	return ap_proxyerror(r, HTTP_NOT_FOUND, buffer);
	const char *dirp = buffer;
		    buf = apr_pstrcat(p, "LIST ", path, CRLF, NULL);
		    buf = apr_pstrcat(p, "LIST -lag", CRLF, NULL);
					 "FTP: LIST %s", (len == 0 ? "-lag" : path));
		buf = apr_pstrcat(p, "RETR ", path, CRLF, NULL);
    bb = apr_brigade_create(p);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    apr_brigade_destroy(bb);
    /* RETR: 110, 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 530, 550
     * NLST: 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 502, 530 */
    /*   110 Restart marker reply. */
    /*   125 Data connection already open; transfer starting. */
    /*   150 File status okay; about to open data connection. */
    /*   226 Closing data connection. */
    /*   250 Requested file action okay, completed. */
    /*   421 Service not available, closing control connection. */
    /*   425 Can't open data connection. */
    /*   426 Connection closed; transfer aborted. */
    /*   450 Requested file action not taken. */
    /*   451 Requested action aborted. Local error in processing. */
    /*   500 Syntax error, command unrecognized. */
    /*   501 Syntax error in parameters or arguments. */
    /*   530 Not logged in. */
    /*   550 Requested action not taken. */
    rc = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	bb = apr_brigade_create(p);
	buf = apr_pstrcat(p, "CWD ", path, CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	rc = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	    return ap_proxyerror(r, HTTP_NOT_FOUND, buffer);
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
	bb = apr_brigade_create(p);
	buf = apr_pstrcat(p, "PWD ", CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	    return ap_proxyerror(r, HTTP_NOT_FOUND, buffer);
	    const char *dirp = buffer;
	bb = apr_brigade_create(p);
	buf = apr_pstrcat(p, "LIST -lag", CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	rc = ftp_getrc_msg(origin, buffer, sizeof(buffer));
    if (rc != 125 && rc != 150 && rc != 226 && rc != 250) {
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
    }

    apr_table_setn(r->headers_out, "Date", dates);
    apr_table_setn(r->headers_out, "Server", ap_get_server_version());
		apr_table_setn(r->headers_out, "Content-Type", "text/html");
	    apr_table_setn(r->headers_out, "Content-Type", r->content_type);
	    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
			 "FTP: Content-Type set to %s", r->content_type);
	    apr_table_setn(r->headers_out, "Content-Type", ap_default_type(r));
	    apr_table_setn(r->headers_out, "Content-Length", size);
	apr_table_setn(r->headers_out, "Content-Encoding", r->content_encoding);
    /* wait for connection */
    if (!pasvmode) {
            switch(apr_accept(&remote_sock, local_sock, r->pool))
                apr_socket_close(local_sock);
    /* the transfer socket is now open, create a new connection */
    remote = ap_new_connection(p, r->server, remote_sock, r->connection->id);
    if (!remote) {
	/* the peer reset the connection already; ap_new_connection() 
	 * closed the socket */
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: an error occurred creating a new connection");
	apr_socket_close(remote_sock);
	apr_socket_close(local_sock);
	return HTTP_INTERNAL_SERVER_ERROR;
    /* set up the connection filters */
    ap_proxy_pre_http_connection(remote);

    /*
     * VI: Receive the Response
     * ------------------------
     *
     * Get response from the remote ftp socket, and pass it up the
     * filter chain.
     */

    /* send response */

   if (parms[0] == 'd') {
	/* insert directory filter */
/*	send_dir(data, r, c, cwd); */
   }


    /* send body */

	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: FTP start body send");

	/* read the body, pass it to the output filters */
	bb = apr_brigade_create(p);
	while (ap_get_brigade(remote->input_filters, bb, AP_MODE_BLOCKING) == APR_SUCCESS) {
	    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
		ap_pass_brigade(r->output_filters, bb);
		break;
	    }
	    ap_pass_brigade(r->output_filters, bb);
	    apr_brigade_destroy(bb);
	    bb = apr_brigade_create(p);
	}
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: FTP end body send");



	/* abort the transfer */
	bb = apr_brigade_create(p);
	buf = apr_pstrcat(p, "ABOR", CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	/* responses: 225, 226, 421, 500, 501, 502 */
	/*   225 Data connection open; no transfer in progress. */
	/*   226 Closing data connection. */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   502 Command not implemented. */
	i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
		     "FTP: returned status %d", i);

    /*
     * VII: Clean Up
     * -------------
     *
     * If there are no KeepAlives, or if the connection has been signalled
     * to close, close the socket and clean up
     */

    /* finish */
    bb = apr_brigade_create(p);
    buf = apr_pstrcat(p, "QUIT", CRLF, NULL);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    apr_brigade_destroy(bb);
    /* responses: 221, 500 */
    /*   221 Service closing control connection. */
    /*   500 Syntax error, command unrecognized. */
    i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
    ps->io_buffer_size = AP_IOBUFSIZE;
    ps->io_buffer_size_set = 0;
    ps->io_buffer_size = (overrides->io_buffer_size_set == 0) ? base->io_buffer_size : overrides->io_buffer_size;
static const char *
    set_io_buffer_size(cmd_parms *parms, void *dummy, const char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    long s = atol(arg);

    psf->io_buffer_size = MAX(s, AP_IOBUFSIZE);
    psf->io_buffer_size_set = 1;
    return NULL;
}

    AP_INIT_TAKE1("ProxyIOBufferSize", set_io_buffer_size, NULL, RSRC_CONF,
     "IO buffer size for outgoing HTTP and FTP connections in bytes"),
    apr_size_t recv_buffer_size;
    apr_size_t io_buffer_size;
    char io_buffer_size_set;
        apr_bucket *e;
        int finish = FALSE;
        while (ap_get_brigade(data->input_filters, 
                              bb, 
                              AP_MODE_READBYTES, 
                              APR_BLOCK_READ, 
                              conf->io_buffer_size) == APR_SUCCESS) {
#if DEBUGGING
            {
                apr_off_t readbytes;
                apr_brigade_length(bb, 0, &readbytes);
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0,
                             r->server, "proxy (PID %d): readbytes: %#x",
                             getpid(), readbytes);
            }
#endif
            /* sanity check */
            if (APR_BRIGADE_EMPTY(bb)) {
                apr_brigade_cleanup(bb);

            /* found the last brigade? */
            if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
                /* if this is the last brigade, cleanup the
                 * backend connection first to prevent the
                 * backend server from hanging around waiting
                 * for a slow client to eat these bytes
                 */
                ap_flush_conn(data);
                apr_socket_close(data_sock);
                data_sock = NULL;
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                             "proxy: FTP: data connection closed");
                /* signal that we must leave */
                finish = TRUE;
            }

            /* if no EOS yet, then we must flush */
            if (FALSE == finish) {
                e = apr_bucket_flush_create();
                APR_BRIGADE_INSERT_TAIL(bb, e);
            }

            /* try send what we read */
                finish = TRUE;

            /* make sure we always clean up after ourselves */

            /* if we are done, leave */
            if (TRUE == finish) {
                break;
            }
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                     "proxy: FTP: end body send");

    }
    if (data_sock) {
        ap_flush_conn(data);
        apr_socket_close(data_sock);
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                     "proxy: FTP: data connection closed");
static apr_status_t ap_proxy_http_cleanup(request_rec *r,
                                          proxy_http_conn_t *p_conn,
                                          proxy_conn_rec *backend);

             * if we are overriding the errors, we can't put the content
             * of the page into the brigade

                /* read the body, pass it to the output filters */
                int finish = FALSE;
                                      conf->io_buffer_size) == APR_SUCCESS) {
                    /* sanity check */
                        apr_brigade_cleanup(bb);

                    /* found the last brigade? */
                        /* if this is the last brigade, cleanup the
                         * backend connection first to prevent the
                         * backend server from hanging around waiting
                         * for a slow client to eat these bytes
                         */
                        ap_proxy_http_cleanup(r, p_conn, backend);
                        /* signal that we must leave */
                        finish = TRUE;

                    /* if no EOS yet, then we must flush */
                    if (FALSE == finish) {
                        e = apr_bucket_flush_create();
                        APR_BRIGADE_INSERT_TAIL(bb, e);
                    }

                    /* try send what we read */
                        finish = TRUE;

                    /* make sure we always clean up after ourselves */

                    /* if we are done, leave */
                    if (TRUE == finish) {
                        break;
                    }
        if (p_conn->sock) {
            apr_socket_close(p_conn->sock);
            p_conn->sock = NULL;
            backend->connection = NULL;
        }

                if ((fold_len - 1) > r->server->limit_req_fieldsize) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field " 
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

        rv = cache->provider->store_body(cache->handle, r, in);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, r->server,
                         "cache: Cache provider's store_body failed!");
            ap_remove_output_filter(f);
        }
        return ap_pass_brigade(f->next, in);
    rv = cache->provider->store_body(cache->handle, r, in);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, r->server,
                     "cache: store_body failed");
        ap_remove_output_filter(f);
    }
    return ap_pass_brigade(f->next, in);
    apr_status_t (*store_body)(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b);
 * Format #1:
 *   apr_uint32_t format;
 * Format #2:
 *   disk_cache_info_t (first sizeof(apr_uint32_t) bytes is the format)
static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b);
static void mkdir_structure(disk_cache_conf *conf, const char *file, apr_pool_t *pool)
    apr_status_t rv;
            /* XXX */
        *p = '/';
static apr_status_t file_cache_el_final(disk_cache_object_t *dobj,
                                        request_rec *r)
{
    /* move the data over */
    if (dobj->tfd) {
        apr_status_t rv;

        apr_file_close(dobj->tfd);

        /* This assumes that the tempfile is on the same file system
         * as the cache_root. If not, then we need a file copy/move
         * rather than a rename.
         */
        rv = apr_file_rename(dobj->tempfile, dobj->datafile, r->pool);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, r->server,
                         "disk_cache: rename tempfile to datafile failed:"
                         " %s -> %s", dobj->tempfile, dobj->datafile);
            apr_file_remove(dobj->tempfile, r->pool);
        }

        dobj->tfd = NULL;
    }

    return APR_SUCCESS;
}

/* These two functions get and put state information into the data
 * file for an ap_cache_el, this state information will be read
 * and written transparent to clients of this module
 */
static int file_cache_recall_mydata(apr_file_t *fd, cache_info *info,
                                    disk_cache_object_t *dobj, request_rec *r)
{
    apr_status_t rv;
    char *urlbuff;
    disk_cache_info_t disk_info;
    apr_size_t len;

    /* read the data from the cache file */
    len = sizeof(disk_cache_info_t);
    rv = apr_file_read_full(fd, &disk_info, len, &len);
    if (rv != APR_SUCCESS) {
        return rv;
    }

    /* Store it away so we can get it later. */
    dobj->disk_info = disk_info;

    info->status = disk_info.status;
    info->date = disk_info.date;
    info->expire = disk_info.expire;
    info->request_time = disk_info.request_time;
    info->response_time = disk_info.response_time;

    /* Note that we could optimize this by conditionally doing the palloc
     * depending upon the size. */
    urlbuff = apr_palloc(r->pool, disk_info.name_len + 1);
    len = disk_info.name_len;
    rv = apr_file_read_full(fd, urlbuff, len, &len);
    if (rv != APR_SUCCESS) {
        return rv;
    }
    urlbuff[disk_info.name_len] = '\0';

    /* check that we have the same URL */
    /* Would strncmp be correct? */
    if (strcmp(urlbuff, dobj->name) != 0) {
        return APR_EGENERAL;
    }

    return APR_SUCCESS;
}

static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
    apr_uint32_t format;
    apr_size_t len;
    const char *nkey;
    static int error_logged = 0;
    disk_cache_conf *conf = ap_get_module_config(r->server->module_config,
                                                 &disk_cache_module);
    apr_finfo_t finfo;
    cache_object_t *obj;
    cache_info *info;
    disk_cache_object_t *dobj;
    int flags;
    h->cache_obj = NULL;
    /* Look up entity keyed to 'url' */
    if (conf->cache_root == NULL) {
        if (!error_logged) {
            error_logged = 1;
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: Cannot cache files to disk without a CacheRoot specified.");
        return DECLINED;
    /* Create and init the cache object */
    h->cache_obj = obj = apr_pcalloc(r->pool, sizeof(cache_object_t));
    obj->vobj = dobj = apr_pcalloc(r->pool, sizeof(disk_cache_object_t));
    info = &(obj->info);
    /* Open the headers file */
    dobj->prefix = NULL;
    /* Save the cache root */
    dobj->root = apr_pstrndup(r->pool, conf->cache_root, conf->cache_root_len);
    dobj->root_len = conf->cache_root_len;
    dobj->hdrsfile = header_file(r->pool, conf, dobj, key);
    flags = APR_READ|APR_BINARY|APR_BUFFERED;
        return DECLINED;
    len = sizeof(format);
    apr_file_read_full(dobj->hfd, &format, len, &len);
        len = sizeof(expire);
        apr_file_read_full(dobj->hfd, &expire, len, &len);
            return DECLINED;
            return DECLINED;
        dobj->hashfile = NULL;
        dobj->hdrsfile = header_file(r->pool, conf, dobj, nkey);
        flags = APR_READ|APR_BINARY|APR_BUFFERED;
            return DECLINED;
    else if (format != DISK_FORMAT_VERSION) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "disk_cache: File '%s' has a version mismatch. File had version: %d.",
                     dobj->hdrsfile, format);
        return DECLINED;
    }
    else {
        apr_off_t offset = 0;
        /* This wasn't a Vary Format file, so we must seek to the
         * start of the file again, so that later reads work.
         */
        apr_file_seek(dobj->hfd, APR_SET, &offset);
        nkey = key;
    dobj->key = nkey;
    dobj->datafile = data_file(r->pool, conf, dobj, nkey);
    dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);
    /* Open the data file */
    flags = APR_READ|APR_BINARY;
#ifdef APR_SENDFILE_ENABLED
    flags |= APR_SENDFILE_ENABLED;
#endif
    rc = apr_file_open(&dobj->fd, dobj->datafile, flags, 0, r->pool);
    if (rc != APR_SUCCESS) {
        /* XXX: Log message */
        return DECLINED;

    rc = apr_file_info_get(&finfo, APR_FINFO_SIZE, dobj->fd);
    if (rc == APR_SUCCESS) {
        dobj->file_size = finfo.size;
    /* Read the bytes to setup the cache_info fields */
    rc = file_cache_recall_mydata(dobj->hfd, info, dobj, r);
    if (rc != APR_SUCCESS) {
        /* XXX log message */
        return DECLINED;
    }
    /* Initialize the cache_handle callback functions */
    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "disk_cache: Recalled cached URL info header %s",  dobj->name);
    return OK;
static int remove_entity(cache_handle_t *h)
    /* Null out the cache object pointer so next time we start from scratch  */
    h->cache_obj = NULL;
    return OK;
static int remove_url(cache_handle_t *h, apr_pool_t *p)
    disk_cache_object_t *dobj;
    /* Get disk cache object from cache handle */
    dobj = (disk_cache_object_t *) h->cache_obj->vobj;
    if (!dobj) {
        return DECLINED;
    }
    /* Delete headers file */
    if (dobj->hdrsfile) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                     "disk_cache: Deleting %s from cache.", dobj->hdrsfile);
        rc = apr_file_remove(dobj->hdrsfile, p);
        if ((rc != APR_SUCCESS) && !APR_STATUS_IS_ENOENT(rc)) {
            /* Will only result in an output if httpd is started with -e debug.
             * For reason see log_error_core for the case s == NULL.
             */
            ap_log_error(APLOG_MARK, APLOG_DEBUG, rc, NULL,
                   "disk_cache: Failed to delete headers file %s from cache.",
                         dobj->hdrsfile);
            return DECLINED;
     /* Delete data file */
    if (dobj->datafile) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                     "disk_cache: Deleting %s from cache.", dobj->datafile);
static apr_status_t read_table(cache_handle_t *handle, request_rec *r,
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "Premature end of cache headers.");
                             "CGI Interface Error: Script headers apparently ASCII: (CGI = %s)",
    h->req_hdrs = apr_table_make(r->pool, 20);
    h->resp_hdrs = apr_table_make(r->pool, 20);
    /* Call routine to read the header lines/status line */
    read_table(h, r, h->resp_hdrs, dobj->hfd);
    read_table(h, r, h->req_hdrs, dobj->hfd);
    apr_brigade_insert_file(bb, dobj->fd, 0, dobj->file_size, p);
static apr_status_t store_headers(cache_handle_t *h, request_rec *r, cache_info *info)
    disk_cache_conf *conf = ap_get_module_config(r->server->module_config,
                                                 &disk_cache_module);
    apr_size_t amt;
    disk_cache_object_t *dobj = (disk_cache_object_t*) h->cache_obj->vobj;
    disk_cache_info_t disk_info;
    struct iovec iov[2];
    /* This is flaky... we need to manage the cache_info differently */
    h->cache_obj->info = *info;
    if (r->headers_out) {
        const char *tmp;
        tmp = apr_table_get(r->headers_out, "Vary");
        if (tmp) {
            apr_array_header_t* varray;
            apr_uint32_t format = VARY_FORMAT_VERSION;
            mkdir_structure(conf, dobj->hdrsfile, r->pool);
            rv = apr_file_mktemp(&dobj->tfd, dobj->tempfile,
                                 APR_CREATE | APR_WRITE | APR_BINARY | APR_EXCL,
                                 r->pool);
            if (rv != APR_SUCCESS) {
                return rv;
            }
            amt = sizeof(format);
            apr_file_write(dobj->tfd, &format, &amt);
            amt = sizeof(info->expire);
            apr_file_write(dobj->tfd, &info->expire, &amt);
            varray = apr_array_make(r->pool, 6, sizeof(char*));
            tokens_to_array(r->pool, tmp, varray);
            store_array(dobj->tfd, varray);
            apr_file_close(dobj->tfd);
            dobj->tfd = NULL;
            rv = safe_file_rename(conf, dobj->tempfile, dobj->hdrsfile,
                                  r->pool);
            if (rv != APR_SUCCESS) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, r->server,
                    "disk_cache: rename tempfile to varyfile failed: %s -> %s",
                    dobj->tempfile, dobj->hdrsfile);
                apr_file_remove(dobj->tempfile, r->pool);
                return rv;
            }
            dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);
            tmp = regen_key(r->pool, r->headers_in, varray, dobj->name);
            dobj->prefix = dobj->hdrsfile;
            dobj->hashfile = NULL;
            dobj->datafile = data_file(r->pool, conf, dobj, tmp);
            dobj->hdrsfile = header_file(r->pool, conf, dobj, tmp);
        }
    rv = apr_file_mktemp(&dobj->hfd, dobj->tempfile,
                         APR_CREATE | APR_WRITE | APR_BINARY |
                         APR_BUFFERED | APR_EXCL, r->pool);
    if (rv != APR_SUCCESS) {
        return rv;
    }
    dobj->name = h->cache_obj->key;
    disk_info.format = DISK_FORMAT_VERSION;
    iov[0].iov_base = (void*)&disk_info;
    iov[0].iov_len = sizeof(disk_cache_info_t);
    iov[1].iov_base = (void*)dobj->name;
    iov[1].iov_len = disk_info.name_len;

    rv = apr_file_writev(dobj->hfd, (const struct iovec *) &iov, 2, &amt);
    apr_file_close(dobj->hfd); /* flush and close */
    /* Remove old file with the same name. If remove fails, then
     * perhaps we need to create the directory tree where we are
     * about to write the new headers file.
     */
    rv = apr_file_remove(dobj->hdrsfile, r->pool);
    if (rv != APR_SUCCESS) {
        mkdir_structure(conf, dobj->hdrsfile, r->pool);
    rv = safe_file_rename(conf, dobj->tempfile, dobj->hdrsfile, r->pool);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                     "disk_cache: rename tempfile to hdrsfile failed: %s -> %s",
                     dobj->tempfile, dobj->hdrsfile);
        apr_file_remove(dobj->tempfile, r->pool);
    dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);
static apr_status_t store_body(cache_handle_t *h, request_rec *r,
                               apr_bucket_brigade *bb)
    apr_bucket *e;
    /* We write to a temp file and then atomically rename the file over
     * in file_cache_el_final().
     */
    if (!dobj->tfd) {
        rv = apr_file_mktemp(&dobj->tfd, dobj->tempfile,
                             APR_CREATE | APR_WRITE | APR_BINARY |
                             APR_BUFFERED | APR_EXCL, r->pool);
        if (rv != APR_SUCCESS) {
            return rv;
        dobj->file_size = 0;
    for (e = APR_BRIGADE_FIRST(bb);
         e != APR_BRIGADE_SENTINEL(bb);
         e = APR_BUCKET_NEXT(e))
    {
        rv = apr_bucket_read(e, &str, &length, APR_BLOCK_READ);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: Error when reading bucket for URL %s",
                         h->cache_obj->key);
            /* Remove the intermediate cache file and return non-APR_SUCCESS */
            file_cache_errorcleanup(dobj, r);
            return rv;
        rv = apr_file_write_full(dobj->tfd, str, length, &written);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: Error when writing cache file for URL %s",
                         h->cache_obj->key);
            /* Remove the intermediate cache file and return non-APR_SUCCESS */
            file_cache_errorcleanup(dobj, r);
            return rv;
        }
        dobj->file_size += written;
        if (dobj->file_size > conf->maxfs) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                         "disk_cache: URL %s failed the size check "
                         "(%" APR_OFF_T_FMT ">%" APR_OFF_T_FMT ")",
                         h->cache_obj->key, dobj->file_size, conf->maxfs);
            /* Remove the intermediate cache file and return non-APR_SUCCESS */
            file_cache_errorcleanup(dobj, r);
            return APR_EGENERAL;
    /* Was this the final bucket? If yes, close the temp file and perform
     * sanity checks.
     */
    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
        if (r->connection->aborted || r->no_cache) {
            ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                         "disk_cache: Discarding body for URL %s "
                         "because connection has been aborted.",
                         h->cache_obj->key);
            /* Remove the intermediate cache file and return non-APR_SUCCESS */
            file_cache_errorcleanup(dobj, r);
            return APR_EGENERAL;
        }
        if (dobj->file_size < conf->minfs) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                         "disk_cache: URL %s failed the size check "
                         "(%" APR_OFF_T_FMT "<%" APR_OFF_T_FMT ")",
                         h->cache_obj->key, dobj->file_size, conf->minfs);
            /* Remove the intermediate cache file and return non-APR_SUCCESS */
            return APR_EGENERAL;
        /* All checks were fine. Move tempfile to final destination */
        /* Link to the perm file, and close the descriptor */
        file_cache_el_final(dobj, r);
                     "disk_cache: Body for URL %s cached.",  dobj->name);
    return APR_SUCCESS;
#define DISK_FORMAT_VERSION 4
    /* Indicates the format of the header struct stored on-disk. */
    apr_uint32_t format;
    const char *key;    /* On-disk prefix; URI with Vary bits (if present) */
static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b);
static apr_status_t store_body(cache_handle_t *h, request_rec *r, apr_bucket_brigade *b)
                return rv;
            return APR_SUCCESS;
            return APR_ENOMEM;
                    return APR_ENOMEM;
           if ((obj->count + len) > mobj->m_len) {
               return APR_ENOMEM;
           }
           else {
           }
    return APR_SUCCESS;
                                                   apr_bucket_brigade *bb);
static int ftp_getrc_msg(conn_rec *ftp_ctrl, apr_bucket_brigade *bb, char *msgbuf, int msglen)
    if (APR_SUCCESS != (rv = ap_proxy_string_read(ftp_ctrl, bb, response, sizeof(response), &eos))) {
/*
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, NULL,
                 "proxy: <FTP: %s", response);
*/
            if (APR_SUCCESS != (rv = ap_proxy_string_read(ftp_ctrl, bb, response, sizeof(response), &eos))) {
apr_status_t ap_proxy_send_dir_filter(ap_filter_t *f, apr_bucket_brigade *in)
                           "\n\n<html>\n<head>\n<title>%s%s</title>\n"
                           "<base href=\"%s%s\">\n</head>\n\n"
                           "<body>\n\n<h2>Directory of "
                           "<a href=\"/\">%s</a>/",
                           site, ap_escape_uri(p, path),
                           site, ap_escape_html(p, path), site);
            str = apr_psprintf(p, "<a href=\"/%s/\">%s</a>/",
                               ap_escape_uri(p, path + 1),
                               ap_escape_html(p, reldir));
            str = apr_psprintf(p, "</h2>\n\n<hr />\n\n<pre>");
            str = apr_psprintf(p, "</h2>\n\n(%s)\n\n<hr />\n\n<pre>", pwd);
            str = apr_psprintf(p, "%s\n</pre>\n\n<hr />\n\n<pre>\n",
                               ap_escape_html(p, readme));
            } while (filename[0] != ' ' && filename > ctx->buffer);
            if (filename > ctx->buffer)
                *(filename++) = '\0';
            str = apr_psprintf(p, "%s <a href=\"%s\">%s %s</a>\n",
                               ap_escape_html(p, ctx->buffer),
                               ap_escape_uri(p, filename),
                               ap_escape_html(p, filename),
                               ap_escape_html(p, link_ptr));
                str = apr_psprintf(p, "%s <a href=\"%s/\">%s</a>\n",
                                   ap_escape_html(p, ctx->buffer),
                                   ap_escape_uri(p, filename),
                                   ap_escape_html(p, filename));
                str = apr_psprintf(p, "%s <a href=\"%s\">%s</a>\n",
                                   ap_escape_html(p, ctx->buffer),
                                   ap_escape_uri(p, filename),
                                   ap_escape_html(p, filename));
            str = ap_escape_html(p, ctx->buffer);
        str = apr_psprintf(p, "</pre>\n\n<hr />\n\n%s\n\n</body>\n</html>\n", ap_psignature("", r));
    apr_socket_t *sock, *local_sock, *data_sock = NULL;
    conn_rec *origin, *data;
     *
     *
     *
     *
         *
     *
        apr_sockaddr_t *data_addr;
        char *data_ip;
        apr_port_t data_port;
                data_port = atoi(pstr + 3);
                             data_port);
                if ((rv = apr_socket_create(&data_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(data_sock, APR_SO_RCVBUF,
                apr_socket_addr_get(&data_addr, APR_REMOTE, sock);
                apr_sockaddr_ip_get(&data_ip, data_addr);
                apr_sockaddr_info_get(&epsv_addr, data_ip, APR_INET, data_port, 0, p);
                rv = apr_connect(data_sock, epsv_addr);
                apr_socket_close(data_sock);
                if ((rv = apr_socket_create(&data_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(data_sock, APR_SO_RCVBUF,
                rv = apr_connect(data_sock, pasv_addr);
                apr_socket_close(data_sock);
     *
            rv = apr_accept(&data_sock, local_sock, r->pool);
    data = ap_new_connection(p, r->server, data_sock, r->connection->id, r->connection->sbh);
    if (!data) {
    ap_proxy_pre_http_connection(data);
     *
        while (ap_get_brigade(data->input_filters, bb, AP_MODE_EXHAUSTIVE,
    ap_flush_conn(data);
    apr_socket_close(data_sock);
     *
static void ap_proxy_ftp_register_hook(apr_pool_t *p)
    /** Did we use HTTP Keep-Alive? */
    unsigned keptalive:1;
    /** How many times have we used it? */
    int keepalives;
	    || (r->server->keep_alive_max > r->connection->keepalives))
        int left = r->server->keep_alive_max - r->connection->keepalives;
        r->connection->keepalives++;
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;

#if 0
    conn_rec *conn = r->connection;
#endif
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
	    /* this is a hack to make sure that request time is set,
	     * it's not perfect, but it's better than nothing 
	     */
	    r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */

    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk

#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */

    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);

#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week 
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method); 
#endif
    uri = ap_getword_white(r->pool, &ll);

    /* Provide quick information about the request method as soon as known */

    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }

    ap_parse_uri(r, uri);

    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }

    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
 	r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))	/* don't allow HTTP/0.1000 */
	r->proto_num = HTTP_VERSION(major, minor);
    else
	r->proto_num = HTTP_VERSION(1,0);

    return 1;
}

    conn->keptalive    = conn->keepalive == 1;
    conn->keepalive    = 0;

    ap_run_create_request(r);
    r->the_request     = NULL;
    apr_setsocketopt(conn->client_socket, APR_SO_TIMEOUT, 
                     (int)(conn->keptalive
                     ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                     : r->server->timeout * APR_USEC_PER_SEC));
                     
    /* Get the request... */
    if (!read_request_line(r)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
			  "request failed: URI too long");
            ap_send_error_response(r, 0);
            ap_run_log_transaction(r);
            return r;
        }
        return NULL;
    }
    if (r->connection->keptalive) {
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(r->server->timeout * APR_USEC_PER_SEC));
    }
    conn->keptalive = 0;        /* We now have a request to play with */

    imap_conf_rec *new = (imap_conf_rec *) apr_palloc(p, sizeof(imap_conf_rec));
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted") && *comment) {
    else if (!strcasecmp(menu, "unformatted") && *comment) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    /* Prepend any earlier saved brigades. */
    APR_BRIGADE_PREPEND(bb, ctx->bb);
static int read_request_line(request_rec *r, apr_bucket_brigade *bb)

#if 0
    conn_rec *conn = r->connection;
#endif
    int num_blank_lines = 0;
    int max_blank_lines = r->server->limit_req_fields;

    if (max_blank_lines <= 0) {
        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
    }

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    do {
        apr_status_t rv;

        /* insure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */
        r->the_request = NULL;
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                         &len, r, 0, bb);

        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }
            return 0;
        }
    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));

    /* we've probably got something to do, ignore graceful restart requests */
    ll = r->the_request;
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method",
                                r->method);
#endif

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

             && (minor < HTTP_VERSION(1, 0)) ) /* don't allow HTTP/0.1000 */
    else
    return 1;
    char *last_field = NULL;
    apr_size_t last_len = 0;
    apr_size_t alloc_len = 0;
    char *value;
    int fields_read = 0;
    char *tmp_field;
        int folded = 0;

        if (last_field != NULL) {
            if ((len > 0) && ((*field == '\t') || *field == ' ')) {
                /* This line is a continuation of the preceding line(s),
                 * so append it to the line that we've set aside.
                 * Note: this uses a power-of-two allocator to avoid
                 * doing O(n) allocs and using O(n^2) space for
                 * continuations that span many many lines.
                 */
                apr_size_t fold_len = last_len + len + 1; /* trailing null */

                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field "
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                if (fold_len > alloc_len) {
                    char *fold_buf;
                    alloc_len += alloc_len;
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
                    }
                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);
                    memcpy(fold_buf, last_field, last_len);
                    last_field = fold_buf;
                }
                memcpy(last_field + last_len, field, len +1); /* +1 for nul */
                last_len += len;
                folded = 1;
            }
            else /* not a continuation line */ {

                if (r->server->limit_req_fields
                    && (++fields_read > r->server->limit_req_fields)) {
                    r->status = HTTP_BAD_REQUEST;
                    apr_table_setn(r->notes, "error-notes",
                                   "The number of request header fields "
                                   "exceeds this server's limit.");
                    return;
                }

                if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                    r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Request header field is "
                                               "missing ':' separator.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool,
                                                              last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                tmp_field = value - 1; /* last character of field-name */

                *value++ = '\0'; /* NUL-terminate at colon */

                while (*value == ' ' || *value == '\t') {
                    ++value;            /* Skip to start of value   */
                }

                /* Strip LWS after field-name: */
                while (tmp_field > last_field
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                /* Strip LWS after field-value: */
                tmp_field = last_field + last_len - 1;
                while (tmp_field > value
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                apr_table_addn(r->headers_in, last_field, value);

                /* reset the alloc_len so that we'll allocate a new
                 * buffer if we have to do any more folding: we can't
                 * use the previous buffer because its contents are
                 * now part of r->headers_in
                 */
                alloc_len = 0;

            } /* end if current line is not a continuation starting with tab */

        /* Found a blank line, stop. */
        if (len == 0) {
            break;
        }

        /* Keep track of this line so that we can parse it on
         * the next loop iteration.  (In the folded case, last_field
         * has been updated already.)
         */
        if (!folded) {
            last_field = field;
            last_len = len;

    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
request_rec *ap_read_request(conn_rec *conn)
    const char *expect;
    int access_status;
    apr_bucket_brigade *tmp_bb;
    apr_socket_t *csd;
    apr_interval_time_t cur_timeout;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    /* Get the request... */
    if (!read_request_line(r, tmp_bb)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        apr_brigade_destroy(tmp_bb);
        return NULL;
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_get(csd, &cur_timeout);
    if (cur_timeout != conn->base_server->timeout) {
        apr_socket_timeout_set(csd, conn->base_server->timeout);
        cur_timeout = conn->base_server->timeout;
    }

    if (!r->assbackwards) {
        ap_get_mime_headers_core(r, tmp_bb);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        if (apr_table_get(r->headers_in, "Transfer-Encoding")
            && apr_table_get(r->headers_in, "Content-Length")) {
            /* 2616 section 4.4, point 3: "if both Transfer-Encoding
             * and Content-Length are received, the latter MUST be
             * ignored"; so unset it here to prevent any confusion
             * later. */
            apr_table_unset(r->headers_in, "Content-Length");
        }
    }
    else {
        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }
    }

    apr_brigade_destroy(tmp_bb);
    if (cur_timeout != r->server->timeout) {
        apr_socket_timeout_set(csd, r->server->timeout);
        cur_timeout = r->server->timeout;
    sc->enabled                = SSL_ENABLED_FALSE;
    cfgMerge(enabled, SSL_ENABLED_UNSET);
        sc->enabled = SSL_ENABLED_TRUE;
        sc->enabled = SSL_ENABLED_FALSE;
        sc->enabled = SSL_ENABLED_OPTIONAL;
        if (sc->enabled == SSL_ENABLED_UNSET) {
            sc->enabled = SSL_ENABLED_FALSE;
    /* Initialize the server if SSL is enabled or optional.
    if ((sc->enabled == SSL_ENABLED_TRUE) || (sc->enabled == SSL_ENABLED_OPTIONAL)) {
        if ((sc->enabled == SSL_ENABLED_TRUE) && (s->port == DEFAULT_HTTP_PORT)) {
        if ((sc->enabled == SSL_ENABLED_FALSE) && (s->port == DEFAULT_HTTPS_PORT)) {
        if (!((sc->enabled == SSL_ENABLED_TRUE) && s->addrs)) {
        if (sc->enabled == SSL_ENABLED_OPTIONAL) {
    if (!((sc->enabled == SSL_ENABLED_TRUE) || (sc->enabled == SSL_ENABLED_OPTIONAL) || ssl)) {
    if (!((sc->enabled == SSL_ENABLED_TRUE || sc->enabled == SSL_ENABLED_OPTIONAL) && sslconn->ssl && sslconn->client_cert) ||
    if (sc->enabled == SSL_ENABLED_OPTIONAL) {
    if (!(((sc->enabled == SSL_ENABLED_TRUE) || (sc->enabled == SSL_ENABLED_OPTIONAL)) && sslconn && (ssl = sslconn->ssl))) {
/*
 * Define the SSL enabled state
 */
typedef enum {
    SSL_ENABLED_UNSET    = UNSET,
    SSL_ENABLED_FALSE    = 0,
    SSL_ENABLED_TRUE     = 1,
	SSL_ENABLED_OPTIONAL = 3
} ssl_enabled_t;

    ssl_enabled_t    enabled;
#include "apr_support.h"
    apr_bucket_brigade *tmpbb;
static apr_status_t check_time_left(reqtimeout_con_cfg *ccfg,
                                    apr_time_t *time_left_p)
{
    *time_left_p = ccfg->timeout_at - apr_time_now();
    if (*time_left_p <= 0)
        return APR_TIMEUP;
    
    if (*time_left_p < apr_time_from_sec(1)) {
        *time_left_p = apr_time_from_sec(1);
    }
    return APR_SUCCESS;
}

static apr_status_t have_lf_or_eos(apr_bucket_brigade *bb)
{
    apr_bucket *b = APR_BRIGADE_LAST(bb);

    for ( ; b != APR_BRIGADE_SENTINEL(bb) ; b = APR_BUCKET_PREV(b) ) {
    	const char *str;
    	apr_size_t len;
    	apr_status_t rv;

        if (APR_BUCKET_IS_EOS(b))
            return APR_SUCCESS;

        if (APR_BUCKET_IS_METADATA(b))
            continue;

        rv = apr_bucket_read(b, &str, &len, APR_BLOCK_READ);
        if (rv != APR_SUCCESS)
            return rv;

        if (len == 0)
            continue;

        if (str[len-1] == APR_ASCII_LF)
            return APR_SUCCESS;
    }
    return APR_INCOMPLETE;
}


#define MIN(x,y) ((x) < (y) ? (x) : (y))
    rv = check_time_left(ccfg, &time_left);
    if (rv != APR_SUCCESS)
        goto out;
    rv = apr_socket_timeout_set(ccfg->socket, MIN(time_left, saved_sock_timeout));
    AP_DEBUG_ASSERT(rv == APR_SUCCESS);
    if (mode == AP_MODE_GETLINE) {
        /*
         * For a blocking AP_MODE_GETLINE read, apr_brigade_split_line()
         * would loop until a whole line has been read. As this would make it
         * impossible to enforce a total timeout, we only do non-blocking
         * reads.
         */
        apr_size_t remaining = HUGE_STRING_LEN;
        do {
            apr_off_t bblen;
            rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE, APR_NONBLOCK_READ, remaining);
            if (APR_STATUS_IS_EAGAIN(rv)) {
                rv = APR_SUCCESS;
            }
            else if (rv != APR_SUCCESS) {
                break;
            }

            if (!APR_BRIGADE_EMPTY(bb)) {
                rv = have_lf_or_eos(bb);
                if (rv != APR_INCOMPLETE) {
                    break;
                }

                if (ccfg->min_rate > 0) {
                    extend_timeout(ccfg, bb);
                }

                rv = apr_brigade_length(bb, 1, &bblen);
                if (rv != APR_SUCCESS) {
                    break;
                }
                remaining -= bblen;
                if (remaining <= 0) {
                    break;
                }

                /* Haven't got a whole line yet, save what we have ... */
                if (!ccfg->tmpbb) {
                    ccfg->tmpbb = apr_brigade_create(f->c->pool, f->c->bucket_alloc);
                }
                APR_BRIGADE_CONCAT(ccfg->tmpbb, bb);
            }

            /* ... and wait for more */
            rv = apr_wait_for_io_or_timeout(NULL, ccfg->socket, 1);
            if (rv != APR_SUCCESS)
                break;

            rv = check_time_left(ccfg, &time_left);
            if (rv != APR_SUCCESS)
                break;
            rv = apr_socket_timeout_set(ccfg->socket,
                                   MIN(time_left, saved_sock_timeout));
            AP_DEBUG_ASSERT(rv == APR_SUCCESS);

        } while (1);

        if (ccfg->tmpbb)
            APR_BRIGADE_PREPEND(bb, ccfg->tmpbb);

    }
    else {
        /* mode != AP_MODE_GETLINE */
        rv = ap_get_brigade(f->next, bb, mode, block, readbytes);
        if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {
            extend_timeout(ccfg, bb);
        }
    apr_socket_timeout_set(ccfg->socket, saved_sock_timeout);

out:
        /*
         * If we allow lingering close, the client may keep this
         * process/thread busy for another 30s (MAX_SECS_TO_LINGER).
         * Therefore we have to abort the connection. The downside is
         * that the client will most likely not receive the error
         * message.
         */
        f->c->aborted = 1;
    const char *p;
    const char *allowed = "~$-_.+!*'(),;:@&=/"; /* allowed+reserved from
                                                   ap_proxy_canonenc */
    /* In a reverse proxy, our URL has been processed, so canonicalise
     * In a forward proxy, we have and MUST NOT MANGLE the original,
     * so just check it for disallowed chars.
     */
    switch (r->proxyreq) {
    default: /* wtf are we doing here? */
    case PROXYREQ_REVERSE:
        path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path, 0, r->proxyreq);
        break;
    case PROXYREQ_PROXY:
        for (p = url; *p; ++p) {
            if (!apr_isalnum(*p) && !strchr(allowed, *p)) {
                if (*p == '%' && apr_isxdigit(p[1]) && apr_isxdigit(p[2])) {
                    p += 2; /* an encoded char */
                }
                else {
                    return HTTP_BAD_REQUEST; /* reject bad char in URL */
                }
            }
        }
        path = url;
        break;
    }

    ap_set_content_type(r, "text/html");

static
apr_status_t ap_proxygetline(char *s, int n, request_rec *r,
                             int fold, int *writen)
{
    char *tmp_s = s;
    apr_status_t rv;
    apr_size_t len;
    apr_bucket_brigade *tmp_bb;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    rv = ap_rgetline(&tmp_s, n, &len, r, fold, tmp_bb);
    apr_brigade_destroy(tmp_bb);

    if (rv == APR_SUCCESS) {
        *writen = (int) len;
    } else {
        *writen = -1;
    }

    return rv;
}

        apr_status_t rc;

        rc = ap_proxygetline(buffer, sizeof(buffer), rp, 0, &len);
            rc = ap_proxygetline(buffer, sizeof(buffer), rp, 0, &len);
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,
static void recalc_factors(proxy_balancer *balancer,
                           proxy_runtime_worker *fixed)
{
    int i;
    double median, ffactor = 0.0;
    proxy_runtime_worker *workers;    


    /* Recalculate lbfactors */
    workers = (proxy_runtime_worker *)balancer->workers->elts;
    /* Special case if there is only one worker it's
     * load factor will always be 100
     */
    if (balancer->workers->nelts == 1) {
        workers->s->lbstatus = workers->s->lbfactor = 100.0;
        return;
    }
    for (i = 0; i < balancer->workers->nelts; i++) {
        if (workers[i].s->lbfactor > 100.0)
            workers[i].s->lbfactor = 100.0;
        ffactor += workers[i].s->lbfactor;
    }
    if (ffactor < 100.0) {
        median = (100.0 - ffactor) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (&(workers[i]) != fixed)
                workers[i].s->lbfactor += median;
        }
    }
    else if (fixed->s->lbfactor < 100.0) {
        median = (ffactor - 100.0) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (workers[i].s->lbfactor > median &&
                &(workers[i]) != fixed)
                workers[i].s->lbfactor -= median;
        }
    } 
    else {
        median = (ffactor - 100.0) / balancer->workers->nelts;
        for (i = 0; i < balancer->workers->nelts; i++) {
            workers[i].s->lbfactor -= median;
        }
    } 
    for (i = 0; i < balancer->workers->nelts; i++) {
        /* Update the status entires */
        workers[i].s->lbstatus = workers[i].s->lbfactor;
    }
}

/* Invoke handler */
static int balancer_handler(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *conf = (proxy_server_conf *)
        ap_get_module_config(sconf, &proxy_module);
    apr_array_header_t *proxies = conf->proxies;
    struct proxy_remote *ents = (struct proxy_remote *)proxies->elts;
    proxy_balancer *balancer, *bsel = NULL;
    proxy_runtime_worker *worker, *wsel = NULL;
    apr_table_t *params = apr_table_make(r->pool, 10);
    int access_status;
    int i, n;
    const char *name;

    /* is this for us? */
    if (strcmp(r->handler, "balancer-manager"))
        return DECLINED;
    r->allowed = (AP_METHOD_BIT << M_GET);
    if (r->method_number != M_GET)
        return DECLINED;

    if (r->args) {
        char *args = apr_pstrdup(r->pool, r->args);
        char *tok, *val;
        while (args && *args) {
            if ((val = ap_strchr_c(args, '='))) {
                *val++ = '\0';
                if ((tok = ap_strchr_c(val, '&')))
                    *tok++ = '\0';
                if ((access_status = ap_unescape_url(val)) != OK)
                    return access_status;
                apr_table_setn(params, args, val);
                args = tok;
            }
            else
                return HTTP_BAD_REQUEST;
        }
    }
    if ((name = apr_table_get(params, "b")))
        bsel = ap_proxy_get_balancer(r->pool, conf,
            apr_pstrcat(r->pool, "balancer://", name, NULL));
    if ((name = apr_table_get(params, "w"))) {
        const char *sc = apr_table_get(params, "s");
        char *asname = NULL;
        proxy_worker *ws = NULL;
        if (sc) {
            asname = apr_pstrcat(r->pool, sc, "://", name, NULL);
            ws = ap_proxy_get_worker(r->pool, conf, asname);
        }
        if (ws) {
            worker = (proxy_runtime_worker *)bsel->workers->elts;
            for (n = 0; n < bsel->workers->nelts; n++) {
                if (strcasecmp(worker->w->name, ws->name) == 0) {
                    wsel = worker;
                    break;
                }
                ++worker;
            }
        }
    }
    /* First set the params */
    if (bsel) {
        const char *val;
        if ((val = apr_table_get(params, "ss"))) {
            if (strlen(val))
                bsel->sticky = apr_pstrdup(conf->pool, val);
            else
                bsel->sticky = NULL;
        }
        if ((val = apr_table_get(params, "tm"))) {
            int ival = atoi(val);
            if (ival >= 0)
                bsel->timeout = apr_time_from_sec(ival);
        }
    }
    if (wsel) {
        const char *val;
        if ((val = apr_table_get(params, "lf"))) {
            char *ep;
            double dval = strtod(val, &ep);
            if (dval > 1) {
                wsel->s->lbfactor = dval;
                if (bsel)
                    recalc_factors(bsel, wsel);
            }
        }
        if ((val = apr_table_get(params, "wr"))) {
            if (strlen(val))
                wsel->w->route = apr_pstrdup(conf->pool, val);
            else
                wsel->w->route = NULL;
        }
        if ((val = apr_table_get(params, "rr"))) {
            if (strlen(val))
                wsel->w->redirect = apr_pstrdup(conf->pool, val);
            else
                wsel->w->redirect = NULL;
        }
        if ((val = apr_table_get(params, "dw")))
            wsel->w->status |= PROXY_WORKER_DISABLED;
        else
            wsel->w->status &= ~PROXY_WORKER_DISABLED;

    }
    if (apr_table_get(params, "xml")) {
        ap_set_content_type(r, "text/xml");
        ap_rputs("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n", r);
        ap_rputs("<httpd:manager xmlns:httpd=\"http://httpd.apache.org\">\n", r);
        ap_rputs("  <httpd:balancers>\n", r);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("    <httpd:balancer>\n", r);
            ap_rvputs(r, "      <httpd:name>", balancer->name, "</httpd:name>\n", NULL);
            ap_rputs("      <httpd:workers>\n", r);
            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {
                ap_rputs("        <httpd:worker>\n", r);
                ap_rvputs(r, "          <httpd:scheme>", worker->w->scheme,
                          "</httpd:scheme>\n", NULL);                
                ap_rvputs(r, "          <httpd:hostname>", worker->w->hostname,
                          "</httpd:hostname>\n", NULL);                
               ap_rprintf(r, "          <httpd:loadfactor>%.2f</httpd:loadfactor>\n",
                          worker->s->lbfactor);
                ap_rputs("        </httpd:worker>\n", r);
                ++worker;
            }
            ap_rputs("      </httpd:workers>\n", r);
            ap_rputs("    </httpd:balancer>\n", r);
            ++balancer;
        }
        ap_rputs("  </httpd:balancers>\n", r);
        ap_rputs("</httpd:manager>", r);         
    }
    else {
        ap_set_content_type(r, "text/html");
        ap_rputs(DOCTYPE_HTML_3_2
                 "<html><head><title>Balancer Manager</title></head>\n", r);
        ap_rputs("<body><h1>Load Balancer Manager for ", r);
        ap_rvputs(r, ap_get_server_name(r), "</h1>\n\n", NULL);
        ap_rvputs(r, "<dl><dt>Server Version: ",
                  ap_get_server_version(), "</dt>\n", NULL);
        ap_rvputs(r, "<dt>Server Built: ",
                  ap_get_server_built(), "\n</dt></dl>\n", NULL);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("<hr />\n<h3>LoadBalancer Status for ", r);
            ap_rvputs(r, "<a href=\"", r->uri, "?b=",
                      balancer->name + sizeof("balancer://") - 1,
                      "\">", NULL); 
            ap_rvputs(r, balancer->name, "</a></h3>\n\n", NULL);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>StickySesion</th><th>Timeout</th>"
                "</tr>\n<tr>", r);                
            ap_rvputs(r, "<td>", balancer->sticky, NULL);
            ap_rprintf(r, "</td><td>%" APR_TIME_T_FMT "</td>\n",
                apr_time_sec(balancer->timeout));
            ap_rputs("</table>\n", r);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>Scheme</th><th>Host</th>"
                "<th>Route</th><th>RouteRedir</th>"
                "<th>Factor</th><th>Status</th>"
                "</tr>\n", r);

            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {

                ap_rvputs(r, "<tr>\n<td>", worker->w->scheme, "</td><td>", NULL);
                ap_rvputs(r, "<a href=\"", r->uri, "?b=", 
                          balancer->name + sizeof("balancer://") - 1,
                          "&s=", worker->w->scheme, "&w=", worker->w->hostname,
                          "\">", NULL); 
                ap_rvputs(r, worker->w->hostname, "</a></td>", NULL);
                ap_rvputs(r, "<td>", worker->w->route, NULL);
                ap_rvputs(r, "</td><td>", worker->w->redirect, NULL);
                ap_rprintf(r, "</td><td>%.2f</td><td>", worker->s->lbfactor);
                if (worker->w->status & PROXY_WORKER_DISABLED)
                    ap_rputs("Dis", r);
                else if (worker->w->status & PROXY_WORKER_IN_ERROR)
                    ap_rputs("Err", r);
                else if (worker->w->status & PROXY_WORKER_INITIALIZED)
                    ap_rputs("Ok", r);
                else
                    ap_rputs("-", r);
                ap_rputs("</td></tr>\n", r);

                ++worker;
            }
            ap_rputs("</table>\n", r);
            ++balancer;
        }
        ap_rputs("<hr />\n", r);
        if (wsel && bsel) {
            ap_rputs("<h3>Edit worker settings for ", r);
            ap_rvputs(r, wsel->w->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>Load factor:</td><td><input name=\"lf\" type=text ", r);
            ap_rprintf(r, "value=\"%.2f\"></td><tr>\n", wsel->s->lbfactor);            
            ap_rputs("<tr><td>Route:</td><td><input name=\"wr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->route, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Route Redirect:</td><td><input name=\"rr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->redirect, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Disabled:</td><td><input name=\"dw\" type=checkbox", r);
            if (wsel->w->status & PROXY_WORKER_DISABLED)
                ap_rputs(" checked", r);
            ap_rputs("></td><tr>\n", r);            
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"s\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->scheme, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"w\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->hostname, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        else if (bsel) {
            ap_rputs("<h3>Edit balancer settings for ", r);
            ap_rvputs(r, bsel->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>StickySession Identifier:</td><td><input name=\"ss\" type=text ", r);
            if (bsel->sticky)
                ap_rvputs(r, "value=\"", bsel->sticky, "\"", NULL);
            ap_rputs("></td><tr>\n<tr><td>Timeout:</td><td><input name=\"tm\" type=text ", r);
            ap_rprintf(r, "value=\"%" APR_TIME_T_FMT "\"></td></tr>\n",
                       apr_time_sec(bsel->timeout));
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        ap_rputs(ap_psignature("",r), r);
        ap_rputs("</body></html>\n", r);
    }
    return OK;
}

    /* manager handler */
    ap_hook_handler(balancer_handler, NULL, NULL, APR_HOOK_FIRST);

                if ((fold_len - 1) > r->server->limit_req_fieldsize) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field " 
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

            if (rc == APR_TIMEUP) {
                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                              "proxy: read timeout");
            }
             * not do a retry. We should also not do this on a
             * connection which times out; instead handle as
             * we normally would handle timeouts
            if (r->proxyreq == PROXYREQ_REVERSE && c->keepalives &&
                rc != APR_TIMEUP) {
    SSLFilterRec *filter_ctx;
    apr_status_t rc;
static bio_filter_out_ctx_t *bio_filter_out_ctx_new(SSLFilterRec *filter_ctx,
                                                    conn_rec *c)
    outctx->filter_ctx = filter_ctx;
        outctx->rc = APR_SUCCESS;
        return 1;
    outctx->rc = ap_pass_brigade(outctx->filter_ctx->pOutputFilter->next,
                                 outctx->bb);
    return (outctx->rc == APR_SUCCESS) ? 1 : -1;
static int bio_filter_create(BIO *bio)
static int bio_filter_destroy(BIO *bio)
        if (bio_filter_out_flush(bio) < 0) {
            return -1;
        }
        ret = bio_filter_out_flush(bio);
    bio_filter_create,
    bio_filter_destroy,
    BIO *bio_out;
    SSLFilterRec *filter_ctx;
        if (bio_filter_out_flush(inctx->bio_out) < 0) {
            bio_filter_out_ctx_t *outctx = 
                   (bio_filter_out_ctx_t *)(inctx->bio_out->ptr);
            inctx->rc = outctx->rc;
            return -1;
        }
    bio_filter_create,
    bio_filter_destroy,
static apr_status_t ssl_filter_write(ap_filter_t *f,
                                     const char *data,
                                     apr_size_t len)
    SSLFilterRec *filter_ctx = f->ctx;
    bio_filter_out_ctx_t *outctx = 
           (bio_filter_out_ctx_t *)(filter_ctx->pbioWrite->ptr);
    int res;
    /* write SSL */
    if (filter_ctx->pssl == NULL) {
        return APR_EGENERAL;
    res = SSL_write(filter_ctx->pssl, (unsigned char *)data, len);
    if (res < 0) {
        int ssl_err = SSL_get_error(filter_ctx->pssl, res);
             * If OpenSSL wants to write more, and we were nonblocking,
             * report as an EAGAIN.  Otherwise loop, pushing more
             * data at the network filter.
             *
             * (This is usually the case when the client forces an SSL
             * renegotation which is handled implicitly by OpenSSL.)
            outctx->rc = APR_EAGAIN;
        }
        else if (ssl_err == SSL_ERROR_SYSCALL) {
            conn_rec *c = (conn_rec*)SSL_get_app_data(outctx->filter_ctx->pssl);
            ap_log_error(APLOG_MARK, APLOG_ERR, outctx->rc, c->base_server,
                        "SSL filter out error writing data");
        else /* if (ssl_err == SSL_ERROR_SSL) */ {
            conn_rec *c = (conn_rec *)SSL_get_app_data(filter_ctx->pssl);
            ap_log_error(APLOG_MARK, APLOG_ERR, outctx->rc, c->base_server,
                    "SSL library out error writing data");

        }
        if (outctx->rc == APR_SUCCESS) {
            outctx->rc = APR_EGENERAL;
    else if ((apr_size_t)res != len) {
        if (SSL_total_renegotiations(filter_ctx->pssl)) {
        ap_log_error(APLOG_MARK, APLOG_ERR, outctx->rc, c->base_server,
                     "failed to write %d of %d bytes (%s)",
                     len - (apr_size_t)res, len, reason);
        outctx->rc = APR_EGENERAL;
    return outctx->rc;
    SSLFilterRec *filter_ctx = f->ctx;
    if (!filter_ctx->pssl) {
    if ((status = ssl_hook_process_connection(filter_ctx)) != APR_SUCCESS) {
            if (bio_filter_out_flush(filter_ctx->pbioWrite) < 0) {
                bio_filter_out_ctx_t *outctx = 
                       (bio_filter_out_ctx_t *)(filter_ctx->pbioWrite->ptr);
                status = outctx->rc;
                break;
                /*
                 * By definition, nothing can come after EOS.
        if (inctx->mode == AP_MODE_GETLINE) {
            if (memchr(buf, APR_ASCII_LF, *len)) {
                return APR_SUCCESS;
            }
        }
        else {
            /* Down to a nonblock pattern as we have some data already
             */
            inctx->block = APR_NONBLOCK_READ;
        }
        rc = SSL_read(inctx->filter_ctx->pssl, buf + bytes, wanted - bytes);
                if (*len > 0) {
                    inctx->rc = APR_SUCCESS;
                }
                else {
                    inctx->rc = APR_EOF;
                }
            int ssl_err = SSL_get_error(inctx->filter_ctx->pssl, rc);
            conn_rec *c = (conn_rec*)SSL_get_app_data(inctx->filter_ctx->pssl);
                continue; /* try again */
                            "SSL filter in error reading data");
                            "SSL library in error reading data");
            if (inctx->rc == APR_SUCCESS) {
                inctx->rc = APR_EGENERAL;
            }
            break;
    inctx->filter_ctx->pssl = NULL;
    status = ssl_hook_process_connection(inctx->filter_ctx);
static void ssl_io_input_add_filter(SSLFilterRec *filter_ctx, conn_rec *c,
    filter_ctx->pInputFilter = ap_add_input_filter(ssl_io_filter, inctx, NULL, c);
    filter_ctx->pbioRead = BIO_new(&bio_filter_in_method);
    filter_ctx->pbioRead->ptr = (void *)inctx;
    inctx->filter_ctx = filter_ctx;
    inctx->bio_out = filter_ctx->pbioWrite;
    inctx->f = filter_ctx->pInputFilter;
    SSLFilterRec *filter_ctx = (SSLFilterRec *)data;
    if (!filter_ctx->pssl) {
    if ((ret = ssl_hook_CloseConnection(filter_ctx)) != APR_SUCCESS) {
    SSLFilterRec *filter_ctx;
    filter_ctx = apr_palloc(c->pool, sizeof(SSLFilterRec));
    filter_ctx->pOutputFilter   = ap_add_output_filter(ssl_io_filter,
                                                   filter_ctx, NULL, c);
    filter_ctx->pbioWrite       = BIO_new(&bio_filter_out_method);
    filter_ctx->pbioWrite->ptr  = (void *)bio_filter_out_ctx_new(filter_ctx, c);
    ssl_io_input_add_filter(filter_ctx, c, ssl);
    SSL_set_bio(ssl, filter_ctx->pbioRead, filter_ctx->pbioWrite);
    filter_ctx->pssl            = ssl;
    apr_pool_cleanup_register(c->pool, (void*)filter_ctx,
    apr_int64_t limited;
    apr_int64_t method_mask;
/* The index of the first bit field that is used to index into a limit
 * bitmask. M_INVALID + 1 to METHOD_NUMBER_LAST.
 */
#define METHOD_NUMBER_FIRST M_INVALID + 1

/* The max method number. Method numbers are used to shift bitmasks,
 * so this cannot exceed 63, and all bits high is equal to -1, which is a
 * special flag, so the last bit used has index 62.
 */
#define METHOD_NUMBER_LAST  62

/**
 * Register a new request method, and return the offset that will be
 * associated with that method.
 *
 * @param p        The pool to create registered method numbers from.
 * @param methname The name of the new method to register.
 * @return         Ab int value representing an offset into a bitmask.
 */
AP_DECLARE(int) ap_method_register(apr_pool_t *p, char *methname);

/**
 * Initialize the method_registry and allocate memory for it.
 *
 * @param p Pool to allocate memory for the registry from.
 */
AP_DECLARE(void) ap_method_registry_init(apr_pool_t *p);

/*
 * This is a convenience macro to ease with checking a mask
 * against a method name.
 */
#define AP_METHOD_CHECK_ALLOWED(mask, methname) ((mask) & (1 << ap_method_number_of((methname))))

/* METHODS needs to be equal to the number of bits
 * we are using for limit masks.
 */
#define METHODS     64
    apr_int64_t method_mask;
    /* the array used for extension methods */
    apr_int64_t allowed;
    apr_int64_t limited;

    apr_int64_t mmask = (1 << method);
/**
 * Singleton registry of additional methods. This maps new method names
 * such as "MYGET" to methnums, which are int offsets into bitmasks.
 *
 * This follows the same technique as standard M_GET, M_POST, etc. These
 * are dynamically assigned when modules are loaded and <Limit GET MYGET>
 * directives are processed.
 */
static apr_hash_t *methods_registry=NULL;
static int cur_method_number = METHOD_NUMBER_FIRST;

/* This internal function is used to clear the method registry
 * and reset the cur_method_number counter.
 */
static apr_status_t ap_method_registry_destroy(void *notused)
{
    methods_registry = NULL;
    cur_method_number = METHOD_NUMBER_FIRST;
    return APR_SUCCESS;
}

AP_DECLARE(void) ap_method_registry_init(apr_pool_t *p)
{
    methods_registry = apr_hash_make(p);
    apr_pool_cleanup_register(p, NULL,
			      ap_method_registry_destroy,
			      apr_pool_cleanup_null);
}

AP_DECLARE(int) ap_method_register(apr_pool_t *p, char *methname)
{
    int *newmethnum;

    if (methods_registry == NULL) {
	ap_method_registry_init(p);
    }

    if (methname == NULL) {
	return M_INVALID;
    }

    if (cur_method_number > METHOD_NUMBER_LAST) {
	/* The method registry  has run out of dynamically
	 * assignable method numbers. Log this and return M_INVALID.
	 */
	ap_log_perror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, 0, p,
		      "Maximum new request methods %d reached while registering method %s.",
		      METHOD_NUMBER_LAST, methname);
	return M_INVALID;
    }

    newmethnum  = (int*)apr_palloc(p,sizeof(int));
    *newmethnum = cur_method_number++;
    apr_hash_set(methods_registry, methname, APR_HASH_KEY_STRING, newmethnum);

    return *newmethnum;
}

    int *methnum = NULL;


    /* check if the method has been dynamically registered */
    if (methods_registry != NULL) {
	methnum = (int*)apr_hash_get(methods_registry,
				     method,
				     APR_HASH_KEY_STRING);
	if (methnum != NULL)
	    return *methnum;
    }

    apr_int64_t mask;
     * If it's a known methods, either builtin or registered
     * by a module, use the bitmask.

     * A method number either hardcoded into apache or
     * added by a module and registered.
	return  (cmd->limited & (1<<methnum));

    return 0; /* not found */
    apr_int64_t limited = 0;
        int methnum;

        /* check for builtin or module registered method number */
        methnum = ap_method_number_of(method);
            /* method has not been registered yet, but resorce restriction
             * is always checked before method handling, so register it.
             */
            methnum = ap_method_register(cmd->pool, method);
        limited |= (1 << methnum);
    char *buf;
    int   buf_size = 4096; /* start with a 4k buffer */
    buf = apr_palloc(r->pool, buf_size);
    while (1) {
	written = apr_vsnprintf(buf, buf_size, fmt, va);

	/*
	 * Per the apr_vsnprintf comments, in no event does apr_snprintf return a negative number.
	 * Therefore, it's not possible to distinguish between an output which was truncated,
	 * and an output which exactly filled the buffer.
	 */
	if (written == buf_size) {
	    buf_size *= 2;
	    buf = apr_palloc(r->pool, buf_size); /* want realloc */
	}
	else {
	    break;
	}
    }

 * @deffunc apr_off_t ap_get_limit_req_body(const request_rec *r)
AP_DECLARE(apr_off_t) ap_get_limit_req_body(const request_rec *r);
    apr_off_t limit_req_body;      /* limit on bytes in request msg body */
    apr_off_t limit;
    apr_off_t limit_used;
        ctx->remaining = 0;
        ctx->limit_used = 0;
        ctx->limit = ap_get_limit_req_body(f->r);
            
            /* If we have a limit in effect and we know the C-L ahead of
             * time, stop it here if it is invalid. 
             */ 
            if (ctx->limit && ctx->limit < ctx->remaining) {
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, f->r,
                          "Requested content-length of %" APR_OFF_T_FMT 
                          " is larger than the configured limit"
                          " of %" APR_OFF_T_FMT, ctx->remaining, ctx->limit);
                ap_die(HTTP_REQUEST_ENTITY_TOO_LARGE, f->r);
                return APR_EGENERAL;
            }
    /* We have a limit in effect. */
    if (ctx->limit) {
        /* FIXME: Note that we might get slightly confused on chunked inputs
         * as we'd need to compensate for the chunk lengths which may not
         * really count.  This seems to be up for interpretation.  */
        ctx->limit_used += *readbytes;
        if (ctx->limit < ctx->limit_used) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, f->r,
                          "Read content-length of %" APR_OFF_T_FMT 
                          " is larger than the configured limit"
                          " of %" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);
            ap_die(HTTP_REQUEST_ENTITY_TOO_LARGE, f->r);
            return APR_EGENERAL;
        }
    }

AP_DECLARE(apr_off_t) ap_get_limit_req_body(const request_rec *r)
    char *errp;
    conf->limit_req_body = (apr_off_t)strtol(arg, &errp, 10);
    if (*errp != '\0') {
        return "LimitRequestBody requires a non-negative integer.";
    }
static void recalc_factors(proxy_balancer *balancer,
                           proxy_runtime_worker *fixed)
{
    int i;
    double median, ffactor = 0.0;
    proxy_runtime_worker *workers;    


    /* Recalculate lbfactors */
    workers = (proxy_runtime_worker *)balancer->workers->elts;
    /* Special case if there is only one worker it's
     * load factor will always be 100
     */
    if (balancer->workers->nelts == 1) {
        workers->s->lbstatus = workers->s->lbfactor = 100.0;
        return;
    }
    for (i = 0; i < balancer->workers->nelts; i++) {
        if (workers[i].s->lbfactor > 100.0)
            workers[i].s->lbfactor = 100.0;
        ffactor += workers[i].s->lbfactor;
    }
    if (ffactor < 100.0) {
        median = (100.0 - ffactor) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (&(workers[i]) != fixed)
                workers[i].s->lbfactor += median;
        }
    }
    else if (fixed->s->lbfactor < 100.0) {
        median = (ffactor - 100.0) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (workers[i].s->lbfactor > median &&
                &(workers[i]) != fixed)
                workers[i].s->lbfactor -= median;
        }
    } 
    else {
        median = (ffactor - 100.0) / balancer->workers->nelts;
        for (i = 0; i < balancer->workers->nelts; i++) {
            workers[i].s->lbfactor -= median;
        }
    } 
    for (i = 0; i < balancer->workers->nelts; i++) {
        /* Update the status entires */
        workers[i].s->lbstatus = workers[i].s->lbfactor;
    }
}

/* Invoke handler */
static int balancer_handler(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *conf = (proxy_server_conf *)
        ap_get_module_config(sconf, &proxy_module);
    apr_array_header_t *proxies = conf->proxies;
    struct proxy_remote *ents = (struct proxy_remote *)proxies->elts;
    proxy_balancer *balancer, *bsel = NULL;
    proxy_runtime_worker *worker, *wsel = NULL;
    apr_table_t *params = apr_table_make(r->pool, 10);
    int access_status;
    int i, n;
    const char *name;

    /* is this for us? */
    if (strcmp(r->handler, "balancer-manager"))
        return DECLINED;
    r->allowed = (AP_METHOD_BIT << M_GET);
    if (r->method_number != M_GET)
        return DECLINED;

    if (r->args) {
        char *args = apr_pstrdup(r->pool, r->args);
        char *tok, *val;
        while (args && *args) {
            if ((val = ap_strchr_c(args, '='))) {
                *val++ = '\0';
                if ((tok = ap_strchr_c(val, '&')))
                    *tok++ = '\0';
                if ((access_status = ap_unescape_url(val)) != OK)
                    return access_status;
                apr_table_setn(params, args, val);
                args = tok;
            }
            else
                return HTTP_BAD_REQUEST;
        }
    }
    if ((name = apr_table_get(params, "b")))
        bsel = ap_proxy_get_balancer(r->pool, conf,
            apr_pstrcat(r->pool, "balancer://", name, NULL));
    if ((name = apr_table_get(params, "w"))) {
        const char *sc = apr_table_get(params, "s");
        char *asname = NULL;
        proxy_worker *ws = NULL;
        if (sc) {
            asname = apr_pstrcat(r->pool, sc, "://", name, NULL);
            ws = ap_proxy_get_worker(r->pool, conf, asname);
        }
        if (ws) {
            worker = (proxy_runtime_worker *)bsel->workers->elts;
            for (n = 0; n < bsel->workers->nelts; n++) {
                if (strcasecmp(worker->w->name, ws->name) == 0) {
                    wsel = worker;
                    break;
                }
                ++worker;
            }
        }
    }
    /* First set the params */
    if (bsel) {
        const char *val;
        if ((val = apr_table_get(params, "ss"))) {
            if (strlen(val))
                bsel->sticky = apr_pstrdup(conf->pool, val);
            else
                bsel->sticky = NULL;
        }
        if ((val = apr_table_get(params, "tm"))) {
            int ival = atoi(val);
            if (ival >= 0)
                bsel->timeout = apr_time_from_sec(ival);
        }
    }
    if (wsel) {
        const char *val;
        if ((val = apr_table_get(params, "lf"))) {
            char *ep;
            double dval = strtod(val, &ep);
            if (dval > 1) {
                wsel->s->lbfactor = dval;
                if (bsel)
                    recalc_factors(bsel, wsel);
            }
        }
        if ((val = apr_table_get(params, "wr"))) {
            if (strlen(val))
                wsel->w->route = apr_pstrdup(conf->pool, val);
            else
                wsel->w->route = NULL;
        }
        if ((val = apr_table_get(params, "rr"))) {
            if (strlen(val))
                wsel->w->redirect = apr_pstrdup(conf->pool, val);
            else
                wsel->w->redirect = NULL;
        }
        if ((val = apr_table_get(params, "dw")))
            wsel->w->status |= PROXY_WORKER_DISABLED;
        else
            wsel->w->status &= ~PROXY_WORKER_DISABLED;

    }
    if (apr_table_get(params, "xml")) {
        ap_set_content_type(r, "text/xml");
        ap_rputs("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n", r);
        ap_rputs("<httpd:manager xmlns:httpd=\"http://httpd.apache.org\">\n", r);
        ap_rputs("  <httpd:balancers>\n", r);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("    <httpd:balancer>\n", r);
            ap_rvputs(r, "      <httpd:name>", balancer->name, "</httpd:name>\n", NULL);
            ap_rputs("      <httpd:workers>\n", r);
            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {
                ap_rputs("        <httpd:worker>\n", r);
                ap_rvputs(r, "          <httpd:scheme>", worker->w->scheme,
                          "</httpd:scheme>\n", NULL);                
                ap_rvputs(r, "          <httpd:hostname>", worker->w->hostname,
                          "</httpd:hostname>\n", NULL);                
               ap_rprintf(r, "          <httpd:loadfactor>%.2f</httpd:loadfactor>\n",
                          worker->s->lbfactor);
                ap_rputs("        </httpd:worker>\n", r);
                ++worker;
            }
            ap_rputs("      </httpd:workers>\n", r);
            ap_rputs("    </httpd:balancer>\n", r);
            ++balancer;
        }
        ap_rputs("  </httpd:balancers>\n", r);
        ap_rputs("</httpd:manager>", r);         
    }
    else {
        ap_set_content_type(r, "text/html");
        ap_rputs(DOCTYPE_HTML_3_2
                 "<html><head><title>Balancer Manager</title></head>\n", r);
        ap_rputs("<body><h1>Load Balancer Manager for ", r);
        ap_rvputs(r, ap_get_server_name(r), "</h1>\n\n", NULL);
        ap_rvputs(r, "<dl><dt>Server Version: ",
                  ap_get_server_version(), "</dt>\n", NULL);
        ap_rvputs(r, "<dt>Server Built: ",
                  ap_get_server_built(), "\n</dt></dl>\n", NULL);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("<hr />\n<h3>LoadBalancer Status for ", r);
            ap_rvputs(r, "<a href=\"", r->uri, "?b=",
                      balancer->name + sizeof("balancer://") - 1,
                      "\">", NULL); 
            ap_rvputs(r, balancer->name, "</a></h3>\n\n", NULL);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>StickySesion</th><th>Timeout</th>"
                "</tr>\n<tr>", r);                
            ap_rvputs(r, "<td>", balancer->sticky, NULL);
            ap_rprintf(r, "</td><td>%" APR_TIME_T_FMT "</td>\n",
                apr_time_sec(balancer->timeout));
            ap_rputs("</table>\n", r);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>Scheme</th><th>Host</th>"
                "<th>Route</th><th>RouteRedir</th>"
                "<th>Factor</th><th>Status</th>"
                "</tr>\n", r);

            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {

                ap_rvputs(r, "<tr>\n<td>", worker->w->scheme, "</td><td>", NULL);
                ap_rvputs(r, "<a href=\"", r->uri, "?b=", 
                          balancer->name + sizeof("balancer://") - 1,
                          "&s=", worker->w->scheme, "&w=", worker->w->hostname,
                          "\">", NULL); 
                ap_rvputs(r, worker->w->hostname, "</a></td>", NULL);
                ap_rvputs(r, "<td>", worker->w->route, NULL);
                ap_rvputs(r, "</td><td>", worker->w->redirect, NULL);
                ap_rprintf(r, "</td><td>%.2f</td><td>", worker->s->lbfactor);
                if (worker->w->status & PROXY_WORKER_DISABLED)
                    ap_rputs("Dis", r);
                else if (worker->w->status & PROXY_WORKER_IN_ERROR)
                    ap_rputs("Err", r);
                else if (worker->w->status & PROXY_WORKER_INITIALIZED)
                    ap_rputs("Ok", r);
                else
                    ap_rputs("-", r);
                ap_rputs("</td></tr>\n", r);

                ++worker;
            }
            ap_rputs("</table>\n", r);
            ++balancer;
        }
        ap_rputs("<hr />\n", r);
        if (wsel && bsel) {
            ap_rputs("<h3>Edit worker settings for ", r);
            ap_rvputs(r, wsel->w->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>Load factor:</td><td><input name=\"lf\" type=text ", r);
            ap_rprintf(r, "value=\"%.2f\"></td><tr>\n", wsel->s->lbfactor);            
            ap_rputs("<tr><td>Route:</td><td><input name=\"wr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->route, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Route Redirect:</td><td><input name=\"rr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->redirect, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Disabled:</td><td><input name=\"dw\" type=checkbox", r);
            if (wsel->w->status & PROXY_WORKER_DISABLED)
                ap_rputs(" checked", r);
            ap_rputs("></td><tr>\n", r);            
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"s\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->scheme, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"w\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->hostname, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        else if (bsel) {
            ap_rputs("<h3>Edit balancer settings for ", r);
            ap_rvputs(r, bsel->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>StickySession Identifier:</td><td><input name=\"ss\" type=text ", r);
            if (bsel->sticky)
                ap_rvputs(r, "value=\"", bsel->sticky, "\"", NULL);
            ap_rputs("></td><tr>\n<tr><td>Timeout:</td><td><input name=\"tm\" type=text ", r);
            ap_rprintf(r, "value=\"%" APR_TIME_T_FMT "\"></td></tr>\n",
                       apr_time_sec(bsel->timeout));
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        ap_rputs(ap_psignature("",r), r);
        ap_rputs("</body></html>\n", r);
    }
    return OK;
}

    /* manager handler */
    ap_hook_handler(balancer_handler, NULL, NULL, APR_HOOK_FIRST);

    /** Which allow-override-opts bits are set */
    int override_opts;
                                       int override_opts,
    allow_options_t override_opts;
    /** the override options allowed for the .htaccess file */
    int override_opts;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
				       int override_opts,
    parms.override_opts = override_opts;
    new->override_opts = override_opts;
    conf->override_opts = OPT_UNSET | OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER
   			 | OPT_MULTI;
    if (!(new->override_opts & OPT_UNSET)) {
	conf->override_opts = new->override_opts;
    }

static const char *set_allow_opts(cmd_parms *cmd, allow_options_t *opts,
                                  const char *l)
{
    allow_options_t opt;
    int first = 1;

    char *p = (char *) l;

    while (p && *p) {
        char *w = strsep(&p, ",");

        if (first) {
            *opts = OPT_NONE;
            first = 0;
        }

	if (!w)
	    continue;

        if (!strcasecmp(w, "Indexes")) {
            opt = OPT_INDEXES;
        }
        else if (!strcasecmp(w, "Includes")) {
            opt = OPT_INCLUDES;
        }
        else if (!strcasecmp(w, "IncludesNOEXEC")) {
            opt = (OPT_INCLUDES | OPT_INCNOEXEC);
        }
        else if (!strcasecmp(w, "FollowSymLinks")) {
            opt = OPT_SYM_LINKS;
        }
        else if (!strcasecmp(w, "SymLinksIfOwnerMatch")) {
            opt = OPT_SYM_OWNER;
        }
        else if (!strcasecmp(w, "ExecCGI")) {
            opt = OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "MultiViews")) {
            opt = OPT_MULTI;
        }
        else if (!strcasecmp(w, "RunScripts")) { /* AI backcompat. Yuck */
            opt = OPT_MULTI|OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "None")) {
            opt = OPT_NONE;
        }
        else if (!strcasecmp(w, "All")) {
            opt = OPT_ALL;
        }
        else {
            return apr_pstrcat(cmd->pool, "Illegal option ", w, NULL);
        }

        *opts |= opt;
    }

    (*opts) &= (~OPT_UNSET);

    return NULL;
}

    char *k, *v;

	k = w;
	v = strchr(k, '=');
	if (v) {
		*v++ = '\0';
	}

        else if (!strcasecmp(k, "Options")) {
	    if (v) 
                set_allow_opts(cmd, &(d->override_opts), v);
	    else
	        d->override_opts = OPT_ALL;
        else if (!strcasecmp(w, "ExecCGI")) {
	if (!(cmd->override_opts & opt) && opt != OPT_NONE) {
	    return apr_pstrcat(cmd->pool, "Option ", w, " not allowed here", NULL);
        }
        else if (action == '-') {
            /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        overrides_t override_opts;
    if (!(this_dir->override_opts & OR_UNSET)) {
        opts->override_opts = this_dir->override_opts;
    }
					opts.override_opts,
        return 0;
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            else if (r->method == NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                              "request failed: invalid characters in URI");
            }
        ap_rvputs(r, ap_get_server_name(r), " (via ", r->connection->local_ip,
/* Is the scoreboard shared between processes or not? 
 * Set by the MPM when the scoreboard is created.
 */
typedef enum {
    SB_SHARED = 1,
    SB_NOT_SHARED = 2
} ap_scoreboard_e;

    ap_scoreboard_e sb_type;
AP_DECLARE(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e t);
void ap_sync_scoreboard_image(void);
/*    ap_sync_scoreboard_image(); */
/* mpm.h is the place to make declarations that are MPM specific but that must be 
 * shared with non-mpm specific code in the server.  Hummm, perhaps we can
 * move most of this stuff to mpm_common.h?
 */
extern int ap_threads_per_child;
/* AP_CHILD_THREAD_FROM_ID is used by the scoreboard.  */
#define AP_CHILD_THREAD_FROM_ID(i)       i, 0


#include "scoreboard.h"

int ap_threads_per_child = 0;
/* ap_get_max_daemons and ap_my_generation are used by the scoreboard
 * code
 */
ap_generation_t volatile ap_my_generation=0; /* Used by the scoreboard */
AP_DECLARE(int) ap_get_max_daemons(void)
{
    return 1;
}

    /* Set up the scoreboard. The scoreboard in this MPM only applies to the
     * child process and is not shared across processes
     */
    ap_create_scoreboard(pconf, SB_NOT_SHARED);
/* ToDo: Fix this right */
#ifndef WIN32
#endif

#endif
/*
 * ToDo:
 * This function should be renamed to cleanup_shared
 * and it should handle cleaning up a scoreboard shared
 * between processes using any form of IPC (file, shared memory
 * segment, etc.). Leave it as is now because it is being used
 * by various MPMs. 
 */
#if APR_HAD_SHARED_MEMORY
#endif
/* ToDo: This function should be made to handle setting up 
 * a scoreboard shared between processes using any IPC technique, 
 * not just a shared memory segment
 */
static void setup_shared(apr_pool_t *p)
#if APR_HAD_SHARED_MEMORY
#endif
AP_DECLARE(void) reopen_scoreboard(apr_pool_t *p)
/* ap_cleanup_scoreboard
 * 
 */
static void ap_cleanup_scoreboard(void *d) {
    if (ap_scoreboard_image == NULL)
        return;
    if (ap_scoreboard_image->global.sb_type == SB_SHARED) {
        ap_cleanup_shared_mem(NULL);
    }
    else {
        free(ap_scoreboard_image);
        ap_scoreboard_image = NULL;
    }
}

/* ap_create_scoreboard(apr_pool_t*, ap_scoreboard_e t)
 *
 * Create or reinit an existing scoreboard. The MPM can control whether
 * the scoreboard is shared across multiple processes or not
 */
AP_DECLARE(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
        if (sb_type == SB_SHARED) {
            setup_shared(p);
            ap_scoreboard_image->global.sb_type = SB_SHARED;
        }
        else {
            /* A simple malloc will suffice */
            char buf[512];
            ap_scoreboard_image = (scoreboard *) malloc(SCOREBOARD_SIZE);
            if (ap_scoreboard_image == NULL) {
                apr_snprintf(buf, sizeof(buf), "%s: cannot allocate scoreboard",
                             ap_server_argv0);
                perror(buf); /* o.k. since MM sets errno */
                exit(APEXIT_INIT);            
            }
            ap_scoreboard_image->global.sb_type = SB_NOT_SHARED;
        }
    apr_register_cleanup(p, NULL, ap_cleanup_scoreboard, apr_null_cleanup);
}

/* ToDo:
 * reinit_scoreboard should be eliminated when all MPMs migrate to
 * ap_create_scoreboard()
 */
void reinit_scoreboard(apr_pool_t *p)
{
    ap_create_scoreboard(p, SB_SHARED);
void ap_sync_scoreboard_image(void)
    /* RFC 2616:
     *   Request-URI    = "*" | absoluteURI | abs_path | authority
     *
     * authority is a special case for CONNECT.  If the request is not
     * using CONNECT, and the parsed URI does not have scheme, and
     * it does not begin with '/', and it is not '*', then, fail
     * and give a 400 response. */
    if (r->method_number != M_CONNECT 
        && !r->parsed_uri.scheme 
        && uri[0] != '/'
        && !(uri[0] == '*' && uri[1] == '\0')) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "invalid request-URI %s", uri);
        r->args = NULL;
        r->hostname = NULL;
        r->status = HTTP_BAD_REQUEST;
        r->uri = apr_pstrdup(r->pool, uri);
    }

 * 20091119.0 (2.3.4-dev)  dav_error interface uses apr_status_t parm, not errno
    err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, errcode, status, errstr);
                                 DAV_ERR_PROP_BAD_MAJOR, 0,
                                 DAV_ERR_PROP_BAD_MAJOR, 0,
                             HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN, 0,
                             DAV_ERR_LOCK_NO_DB, 0,
                             HTTP_INTERNAL_SERVER_ERROR, 0, 0,
                                 DAV_ERR_LOCK_CORRUPT_DB, 0,
                         DAV_ERR_LOCK_CORRUPT_DB, 0,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
    if ((rv = apr_file_read(file, pbuf->buf, &amt)) != APR_SUCCESS
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
    apr_status_t rv;
        if ((rv = apr_file_remove(pathname, p)) != APR_SUCCESS) {
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
    if ((rv = apr_file_open(&file, pathname,
                            APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BINARY,
                            APR_OS_DEFAULT, p)) != APR_SUCCESS) {
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
    if ((rv = apr_file_write(file, pbuf->buf, &amt)) != APR_SUCCESS
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
                             HTTP_INTERNAL_SERVER_ERROR, 0, 0,
            return dav_new_error(ctx->pool, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
            if ((status = apr_file_perms_set(dst, perms)) != APR_SUCCESS) {
                return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
    if ((status = apr_file_open(&inf, src, APR_READ | APR_BINARY, 
                                APR_OS_DEFAULT, p)) != APR_SUCCESS) {
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
        return dav_new_error(p, MAP_IO2HTTP(status), 0, status,
            apr_status_t lcl_status;

            if ((lcl_status = apr_file_remove(dst, p)) != APR_SUCCESS) {
                return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, 
                                     lcl_status,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
            apr_status_t lcl_status;

            if ((lcl_status = apr_file_remove(dst, p)) != APR_SUCCESS) {
                                     lcl_status,
            return dav_new_error(p, MAP_IO2HTTP(status), 0, status,
        apr_status_t lcl_status;
            err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
        else if ((lcl_status = apr_file_remove(dst, p)) != APR_SUCCESS) {
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, lcl_status,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
                return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, 0,
        return dav_new_error(p, MAP_IO2HTTP(rv), 0, rv,
            if ((rv = apr_file_remove(stream->pathname, stream->p))
                != APR_SUCCESS) {
                                     rv,
            return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
        return dav_new_error(stream->p, HTTP_INSUFFICIENT_STORAGE, 0, status,
        return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
    apr_status_t status;

    if ((status = apr_file_seek(stream->f, APR_SET, &abs_pos))
        != APR_SUCCESS) {
        return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
        return dav_new_error(pool, HTTP_CONFLICT, 0, 0,
        return dav_new_error(pool, HTTP_CONFLICT, 0, 0,
        return dav_new_error(pool, HTTP_FORBIDDEN, 0, status,
        return dav_new_error(pool, HTTP_FORBIDDEN, 0, status,
        return dav_new_error(ctx->pool, HTTP_INSUFFICIENT_STORAGE, 0, status,
        return dav_new_error(ctx->pool, HTTP_CONFLICT, 0, status,
        return dav_new_error(ctx->pool, HTTP_FORBIDDEN, 0, status,
    apr_status_t status;
            if ((status = apr_dir_make(dstinfo->pathname, APR_OS_DEFAULT,
                                       ctx->pool)) != APR_SUCCESS) {
                err = dav_new_error(ctx->pool, HTTP_FORBIDDEN, 0, status, NULL);
            return dav_new_error(src->info->pool, HTTP_MULTI_STATUS, 0, 0,
        return dav_new_error(src->info->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        return dav_new_error(src->info->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        return dav_new_error(srcinfo->pool, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
    apr_status_t status;
            return dav_new_error(info->pool, HTTP_MULTI_STATUS, 0, 0,
    if ((status = apr_file_remove(info->pathname, info->pool)) != APR_SUCCESS) {
        return dav_new_error(info->pool, HTTP_FORBIDDEN, 0, status, NULL);
    apr_status_t status;
    if ((status = apr_dir_open(&dirp, fsctx->path1.buf, pool)) != APR_SUCCESS) {
        return dav_new_error(pool, HTTP_NOT_FOUND, 0, status, NULL);
            err = dav_new_error(pool, HTTP_NOT_FOUND, 0, status, NULL);
        return dav_new_error(params->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,
            return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,
        return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,
    return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,
    apr_status_t status;
    if ((status = apr_file_perms_set(resource->info->pathname, perms))
        != APR_SUCCESS) {
                             HTTP_INTERNAL_SERVER_ERROR, 0, status,
    apr_status_t status;
    if ((status = apr_file_perms_set(resource->info->pathname, perms))
        != APR_SUCCESS) {
                             HTTP_INTERNAL_SERVER_ERROR, 0, status,
    err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, errcode, status, errstr);
                             HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN, 0,
                             DAV_ERR_LOCK_NO_DB, 0,
                             HTTP_INTERNAL_SERVER_ERROR, 0, 0,
                                 DAV_ERR_LOCK_CORRUPT_DB, 0,
                         DAV_ERR_LOCK_CORRUPT_DB, 0,
                             HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        ap_log_rerror(APLOG_MARK, level, errscan->aprerr, r, "%s  [%d, #%d]",
                      errscan->desc, errscan->status, errscan->error_id);
        return dav_new_error(r->pool, HTTP_NOT_FOUND, 0, 0,
                err = dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0, rc,
                    err = dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, rc,
                    return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, 0,
                    err = dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, 0,
                            return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, 0,
                    err424_set = dav_new_error(p, HTTP_FAILED_DEPENDENCY, 0, 0,
                    err424_delete = dav_new_error(p, HTTP_FAILED_DEPENDENCY, 0, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
        err = dav_new_error(ctx->w.pool, HTTP_CONFLICT, 0, 0,
        err = dav_new_error(ctx->w.pool, HTTP_CONFLICT, 0, 0,
            err = dav_new_error(r->pool, multi_status->status, 0, 0,
                                multi_status->desc);
            err = dav_new_error(r->pool, HTTP_MULTI_STATUS, 0, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
      err = dav_new_error(r->pool, HTTP_FORBIDDEN, 0, 0,
    apr_status_t aprerr;        /* APR error if any, or 0/APR_SUCCESS */
                                      int error_id, apr_status_t aprerr,
                                      const char *desc);
** namespace may be NULL, which means "DAV:".
                                          int error_id, apr_status_t aprerr,
                                          const char *desc,
        return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
                                     0,
                                 DAV_ERR_PROP_READONLY, 0,
                                 DAV_ERR_PROP_NO_DATABASE, 0,
DAV_DECLARE(dav_error*) dav_new_error(apr_pool_t *p, int status, int error_id,
                                      apr_status_t aprerr, const char *desc)
    err->aprerr = aprerr;
                                          int error_id, apr_status_t aprerr,
                                          const char *desc,
    dav_error *err = dav_new_error(p, status, error_id, aprerr, desc);
    apr_status_t rv;
                                     DAV_ERR_IF_TAGGED, 0,
            if ((rv = apr_uri_parse(r->pool, uri, &parsed_uri)) != APR_SUCCESS) {
                                     DAV_ERR_IF_TAGGED, rv,
                                     DAV_ERR_IF_UNCLOSED_PAREN, 0,
                                     DAV_ERR_IF_PARSE, 0,
                                             DAV_ERR_IF_PARSE, 0, NULL);
                                             DAV_ERR_IF_PARSE, 0, NULL);
                                                 DAV_ERR_IF_MULTIPLE_NOT, 0,
                                         DAV_ERR_IF_UNK_CHAR, 0,
                                 DAV_ERR_IF_UNK_CHAR, 0,
            return dav_new_error(p, HTTP_LOCKED, 0, 0,
                return dav_new_error(p, HTTP_LOCKED, 0, 0,
        return dav_new_error(p, HTTP_LOCKED, 0, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
                        return dav_new_error(p, HTTP_FORBIDDEN, 0, 0, errmsg);
            return dav_new_error(p, HTTP_LOCKED, 0 /* error_id */, 0,
            return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
            return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,
        return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
    return dav_new_error(p, HTTP_LOCKED, 1 /* error_id */, 0,
        return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        return dav_new_error(r->pool, result, 0, 0, NULL);
            err = dav_new_error(r->pool, HTTP_FORBIDDEN, 0, 0,
            return dav_new_error(r->pool, HTTP_FAILED_DEPENDENCY, 0, 0,
        return dav_new_error(r->pool, HTTP_MULTI_STATUS, 0, 0,
        return dav_new_error(r->pool, HTTP_BAD_REQUEST, DAV_ERR_IF_ABSENT, 0,
                return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
                err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
        return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,
            return dav_new_error(r->pool, HTTP_MULTI_STATUS, 0, 0,
            return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
    return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
            return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
 * created at config time in the parent are valid across children.  However,
 * this can't work effectively with non-forked architectures.  So while the
 * arrays in the scoreboard never change between the parent and forked
 * children, so they do not require shm storage, the contents of the shm
 * may contain no pointers.
    SB_NOT_SHARED = 1,
    SB_SHARED = 2,      /* PARENT */
    SB_SHARED_CHILD = 3
    char vhost[32];	        /* What virtual host is being accessed? */
/* Scoreboard is now in 'local' memory, since it isn't updated once created,
 * even in forked architectures.  Child created-processes (non-fork) will
 * set up these indicies into the (possibly relocated) shmem records.
 */
    global_score *global;
typedef struct ap_sb_handle_t ap_sb_handle_t;
AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sbh, request_rec *r);
void ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e t);
apr_status_t reopen_scoreboard(apr_pool_t *p, int detached);
void ap_init_scoreboard(void *shared_score);
AP_DECLARE(void) ap_create_sb_handle(ap_sb_handle_t **new_sbh, apr_pool_t *p,
AP_DECLARE(int) ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r);

AP_DECLARE(worker_score *) ap_get_scoreboard_worker(int x, int y);
AP_DECLARE(process_score *) ap_get_scoreboard_process(int x);
AP_DECLARE(global_score *) ap_get_scoreboard_global(void);
#include "apr_shm.h"
#include "apr_rmm.h"
#define APR_HAS_SHARED_MEMORY 1
static apr_shm_t      *client_shm =  NULL;
static apr_rmm_t      *client_rmm = NULL;
static unsigned long  *opaque_cntr;
    ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
    sts = apr_shm_create(&client_shm, shmem_size, tmpnam(NULL), ctx);
    client_list = apr_rmm_malloc(client_rmm, sizeof(*client_list) +
    opaque_cntr = apr_rmm_malloc(client_rmm, sizeof(*opaque_cntr));
    otn_counter = apr_rmm_malloc(client_rmm, sizeof(*otn_counter));
            apr_rmm_free(client_rmm, entry);
    entry = apr_rmm_malloc(client_rmm, sizeof(client_entry));
        entry = apr_rmm_malloc(client_rmm, sizeof(client_entry));
	    
			    ap_escape_html(r->pool, ws_record.vhost));
			     ap_escape_html(r->pool, ws_record.vhost),
                    n = ssl_rand_choosenum(0,ap_calc_scoreboard_size()-1024-1);

/*  A Bison parser, made from ssl_expr_parse.y
    by GNU Bison version 1.28  */

#define YYBISON 1  /* Identify Bison output.  */

#define	T_TRUE	257
#define	T_FALSE	258
#define	T_DIGIT	259
#define	T_ID	260
#define	T_STRING	261
#define	T_REGEX	262
#define	T_REGEX_I	263
#define	T_FUNC_FILE	264
#define	T_OP_EQ	265
#define	T_OP_NE	266
#define	T_OP_LT	267
#define	T_OP_LE	268
#define	T_OP_GT	269
#define	T_OP_GE	270
#define	T_OP_REG	271
#define	T_OP_NRE	272
#define	T_OP_IN	273
#define	T_OP_OR	274
#define	T_OP_AND	275
#define	T_OP_NOT	276

#line 68 "ssl_expr_parse.y"


#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		53
#define	YYFLAG		-32768
#define	YYNTBASE	29

#define YYTRANSLATE(x) ((unsigned)(x) <= 276 ? ssl_expr_yytranslate[x] : 36)

static const char ssl_expr_yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,    28,     2,     2,    23,
    24,     2,     2,    27,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,    25,     2,    26,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
    17,    18,    19,    20,    21,    22

#if YYDEBUG != 0
static const short ssl_expr_yyprhs[] = {     0,
     0,     2,     4,     6,     9,    13,    17,    19,    23,    27,
    31,    35,    39,    43,    47,    53,    57,    61,    63,    67,
    69,    71,    76,    78,    80,    82

static const short ssl_expr_yyrhs[] = {    30,
     0,     3,     0,     4,     0,    22,    30,     0,    30,    20,
    30,     0,    30,    21,    30,     0,    31,     0,    23,    30,
    24,     0,    33,    11,    33,     0,    33,    12,    33,     0,
    33,    13,    33,     0,    33,    14,    33,     0,    33,    15,
    33,     0,    33,    16,    33,     0,    33,    19,    25,    32,
    26,     0,    33,    17,    34,     0,    33,    18,    34,     0,
    33,     0,    32,    27,    33,     0,     5,     0,     7,     0,
    28,    25,     6,    26,     0,    35,     0,     8,     0,     9,
     0,    10,    23,     7,    24,     0

#endif

#if YYDEBUG != 0
static const short ssl_expr_yyrline[] = { 0,
   115,   118,   119,   120,   121,   122,   123,   124,   127,   128,
   129,   130,   131,   132,   133,   134,   135,   138,   139,   142,
   143,   144,   145,   148,   158,   170
#endif


#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)

static const char * const ssl_expr_yytname[] = {   "$","error","$undefined.","T_TRUE",
"T_FALSE","T_DIGIT","T_ID","T_STRING","T_REGEX","T_REGEX_I","T_FUNC_FILE","T_OP_EQ",
"T_OP_NE","T_OP_LT","T_OP_LE","T_OP_GT","T_OP_GE","T_OP_REG","T_OP_NRE","T_OP_IN",
"T_OP_OR","T_OP_AND","T_OP_NOT","'('","')'","'{'","'}'","','","'%'","root","expr",
"comparison","words","word","regex","funccall", NULL
};
#endif

static const short ssl_expr_yyr1[] = {     0,
    29,    30,    30,    30,    30,    30,    30,    30,    31,    31,
    31,    31,    31,    31,    31,    31,    31,    32,    32,    33,
    33,    33,    33,    34,    34,    35

static const short ssl_expr_yyr2[] = {     0,
     1,     1,     1,     2,     3,     3,     1,     3,     3,     3,
     3,     3,     3,     3,     5,     3,     3,     1,     3,     1,
     1,     4,     1,     1,     1,     4
};

static const short ssl_expr_yydefact[] = {     0,
     2,     3,    20,    21,     0,     0,     0,     0,     1,     7,
     0,    23,     0,     4,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     8,     0,
     5,     6,     9,    10,    11,    12,    13,    14,    24,    25,
    16,    17,     0,    26,    22,     0,    18,    15,     0,    19,
     0,     0,     0

static const short ssl_expr_yydefgoto[] = {    51,
     9,    10,    46,    11,    41,    12

static const short ssl_expr_yypact[] = {     3,
-32768,-32768,-32768,-32768,   -11,     3,     3,   -10,     0,-32768,
    22,-32768,    16,-32768,    -2,    23,     3,     3,     4,     4,
     4,     4,     4,     4,    34,    34,    21,    24,-32768,    25,
    26,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,     4,-32768,-32768,    18,-32768,-32768,     4,-32768,
    49,    50,-32768

static const short ssl_expr_yypgoto[] = {-32768,
    10,-32768,-32768,   -19,    27,-32768


#define	YYLAST		53


static const short ssl_expr_yytable[] = {    33,
    34,    35,    36,    37,    38,     1,     2,     3,     3,     4,
     4,    13,     5,     5,    16,    14,    15,    17,    18,    17,
    18,    29,    28,    47,     6,     7,    31,    32,    30,    50,
     8,     8,    19,    20,    21,    22,    23,    24,    25,    26,
    27,    39,    40,    48,    49,    43,    18,    44,    52,    53,
    45,     0,    42

static const short ssl_expr_yycheck[] = {    19,
    20,    21,    22,    23,    24,     3,     4,     5,     5,     7,
     7,    23,    10,    10,    25,     6,     7,    20,    21,    20,
    21,    24,     7,    43,    22,    23,    17,    18,     6,    49,
    28,    28,    11,    12,    13,    14,    15,    16,    17,    18,
    19,     8,     9,    26,    27,    25,    21,    24,     0,     0,
    26,    -1,    26
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/usr/local/share/bison.simple"
/* This file comes from bison-1.28.  */

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

#ifndef YYSTACK_USE_ALLOCA
#ifdef alloca
#define YYSTACK_USE_ALLOCA
#else /* alloca not defined */
#ifdef __GNUC__
#define YYSTACK_USE_ALLOCA
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
#define YYSTACK_USE_ALLOCA
#include <alloca.h>
#else /* not sparc */
/* We think this test detects Watcom and Microsoft C.  */
/* This used to test MSDOS, but that is a bad idea
   since that symbol is in the user namespace.  */
#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
#if 0 /* No need for malloc.h, which pollutes the namespace;
	 instead, just don't use alloca.  */
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
/* I don't know what this was needed for, but it pollutes the namespace.
   So I turned it off.   rms, 2 May 1997.  */
/* #include <malloc.h>  */
 #pragma alloca
#define YYSTACK_USE_ALLOCA
#else /* not MSDOS, or __TURBOC__, or _AIX */
#if 0
#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
		 and on HPUX 10.  Eventually we can turn this on.  */
#define YYSTACK_USE_ALLOCA
#define alloca __builtin_alloca
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc */
#endif /* not GNU C */
#endif /* alloca not defined */
#endif /* YYSTACK_USE_ALLOCA not defined */

#ifdef YYSTACK_USE_ALLOCA
#define YYSTACK_ALLOC alloca
#define YYSTACK_ALLOC malloc
#endif

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define ssl_expr_yyerrok		(ssl_expr_yyerrstatus = 0)
#define ssl_expr_yyclearin	(ssl_expr_yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	goto ssl_expr_yyacceptlab
#define YYABORT 	goto ssl_expr_yyabortlab
#define YYERROR		goto ssl_expr_yyerrlab1
/* Like YYERROR except do call ssl_expr_yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto ssl_expr_yyerrlab
#define YYRECOVERING()  (!!ssl_expr_yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (ssl_expr_yychar == YYEMPTY && ssl_expr_yylen == 1)				\
    { ssl_expr_yychar = (token), ssl_expr_yylval = (value);			\
      ssl_expr_yychar1 = YYTRANSLATE (ssl_expr_yychar);				\
      YYPOPSTACK;						\
      goto ssl_expr_yybackup;						\
    }								\
  else								\
    { ssl_expr_yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		ssl_expr_yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, &ssl_expr_yylloc, YYLEX_PARAM)
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, &ssl_expr_yylloc)
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, YYLEX_PARAM)
#else
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval)
#endif
#endif /* not YYLSP_NEEDED */
/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	ssl_expr_yychar;			/*  the lookahead symbol		*/
YYSTYPE	ssl_expr_yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE ssl_expr_yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int ssl_expr_yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int ssl_expr_yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Define __ssl_expr_yy_memcpy.  Note that the size argument
   should be passed with type unsigned int, because that is what the non-GCC
   definitions require.  With GCC, __builtin_memcpy takes an arg
   of type size_t, but it can handle unsigned int.  */

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __ssl_expr_yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__ssl_expr_yy_memcpy (to, from, count)
     char *to;
     char *from;
     unsigned int count;
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__ssl_expr_yy_memcpy (char *to, char *from, unsigned int count)
  register char *t = to;
  register char *f = from;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
#endif
#endif

#line 217 "/usr/local/share/bison.simple"

/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into ssl_expr_yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */
#ifdef YYPARSE_PARAM
#ifdef __cplusplus
#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
#else /* not __cplusplus */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#endif /* not __cplusplus */
#else /* not YYPARSE_PARAM */
#endif /* not YYPARSE_PARAM */

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
#ifdef YYPARSE_PARAM
int ssl_expr_yyparse (void *);
#else
int ssl_expr_yyparse (void);
#endif
ssl_expr_yyparse(YYPARSE_PARAM_ARG)
     YYPARSE_PARAM_DECL
  register int ssl_expr_yystate;
  register int ssl_expr_yyn;
  register short *ssl_expr_yyssp;
  register YYSTYPE *ssl_expr_yyvsp;
  int ssl_expr_yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int ssl_expr_yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	ssl_expr_yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE ssl_expr_yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *ssl_expr_yyss = ssl_expr_yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *ssl_expr_yyvs = ssl_expr_yyvsa;	/*  to allow ssl_expr_yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE ssl_expr_yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *ssl_expr_yyls = ssl_expr_yylsa;
  YYLTYPE *ssl_expr_yylsp;

#define YYPOPSTACK   (ssl_expr_yyvsp--, ssl_expr_yyssp--, ssl_expr_yylsp--)
#else
#define YYPOPSTACK   (ssl_expr_yyvsp--, ssl_expr_yyssp--)
#endif

  int ssl_expr_yystacksize = YYINITDEPTH;
  int ssl_expr_yyfree_stacks = 0;

#ifdef YYPURE
  int ssl_expr_yychar;
  YYSTYPE ssl_expr_yylval;
  int ssl_expr_yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE ssl_expr_yylloc;
#endif
#endif

  YYSTYPE ssl_expr_yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int ssl_expr_yylen;
#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  ssl_expr_yystate = 0;
  ssl_expr_yyerrstatus = 0;
  ssl_expr_yynerrs = 0;
  ssl_expr_yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  ssl_expr_yyssp = ssl_expr_yyss - 1;
  ssl_expr_yyvsp = ssl_expr_yyvs;
#ifdef YYLSP_NEEDED
  ssl_expr_yylsp = ssl_expr_yyls;
#endif

/* Push a new state, which is found in  ssl_expr_yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
ssl_expr_yynewstate:

  *++ssl_expr_yyssp = ssl_expr_yystate;

  if (ssl_expr_yyssp >= ssl_expr_yyss + ssl_expr_yystacksize - 1)
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *ssl_expr_yyvs1 = ssl_expr_yyvs;
      short *ssl_expr_yyss1 = ssl_expr_yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *ssl_expr_yyls1 = ssl_expr_yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = ssl_expr_yyssp - ssl_expr_yyss + 1;

#ifdef ssl_expr_yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if ssl_expr_yyoverflow is a macro.  */
      ssl_expr_yyoverflow("parser stack overflow",
		 &ssl_expr_yyss1, size * sizeof (*ssl_expr_yyssp),
		 &ssl_expr_yyvs1, size * sizeof (*ssl_expr_yyvsp),
		 &ssl_expr_yyls1, size * sizeof (*ssl_expr_yylsp),
		 &ssl_expr_yystacksize);
#else
      ssl_expr_yyoverflow("parser stack overflow",
		 &ssl_expr_yyss1, size * sizeof (*ssl_expr_yyssp),
		 &ssl_expr_yyvs1, size * sizeof (*ssl_expr_yyvsp),
		 &ssl_expr_yystacksize);
#endif

      ssl_expr_yyss = ssl_expr_yyss1; ssl_expr_yyvs = ssl_expr_yyvs1;
#ifdef YYLSP_NEEDED
      ssl_expr_yyls = ssl_expr_yyls1;
#endif
#else /* no ssl_expr_yyoverflow */
      /* Extend the stack our own way.  */
      if (ssl_expr_yystacksize >= YYMAXDEPTH)
	{
	  ssl_expr_yyerror("parser stack overflow");
	  if (ssl_expr_yyfree_stacks)
	    {
	      free (ssl_expr_yyss);
	      free (ssl_expr_yyvs);
#ifdef YYLSP_NEEDED
	      free (ssl_expr_yyls);
#endif
	    }
	  return 2;
	}
      ssl_expr_yystacksize *= 2;
      if (ssl_expr_yystacksize > YYMAXDEPTH)
	ssl_expr_yystacksize = YYMAXDEPTH;
#ifndef YYSTACK_USE_ALLOCA
      ssl_expr_yyfree_stacks = 1;
#endif
      ssl_expr_yyss = (short *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yyssp));
      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyss, (char *)ssl_expr_yyss1,
		   size * (unsigned int) sizeof (*ssl_expr_yyssp));
      ssl_expr_yyvs = (YYSTYPE *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yyvsp));
      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyvs, (char *)ssl_expr_yyvs1,
		   size * (unsigned int) sizeof (*ssl_expr_yyvsp));
#ifdef YYLSP_NEEDED
      ssl_expr_yyls = (YYLTYPE *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yylsp));
      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyls, (char *)ssl_expr_yyls1,
		   size * (unsigned int) sizeof (*ssl_expr_yylsp));
#endif
#endif /* no ssl_expr_yyoverflow */

      ssl_expr_yyssp = ssl_expr_yyss + size - 1;
      ssl_expr_yyvsp = ssl_expr_yyvs + size - 1;
#ifdef YYLSP_NEEDED
      ssl_expr_yylsp = ssl_expr_yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Stack size increased to %d\n", ssl_expr_yystacksize);
#endif

      if (ssl_expr_yyssp >= ssl_expr_yyss + ssl_expr_yystacksize - 1)
	YYABORT;

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Entering state %d\n", ssl_expr_yystate);
  goto ssl_expr_yybackup;
 ssl_expr_yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* ssl_expr_yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */
  ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];
  if (ssl_expr_yyn == YYFLAG)
    goto ssl_expr_yydefault;
  /* Not known => get a lookahead token if don't already have one.  */

  /* ssl_expr_yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (ssl_expr_yychar == YYEMPTY)
#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Reading a token: ");
      ssl_expr_yychar = YYLEX;

  /* Convert token to internal form (in ssl_expr_yychar1) for indexing tables with */

  if (ssl_expr_yychar <= 0)		/* This means end of input. */
      ssl_expr_yychar1 = 0;
      ssl_expr_yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
  else
      ssl_expr_yychar1 = YYTRANSLATE(ssl_expr_yychar);

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, ssl_expr_yychar, ssl_expr_yylval);
	  fprintf (stderr, ")\n");
	}

  ssl_expr_yyn += ssl_expr_yychar1;
  if (ssl_expr_yyn < 0 || ssl_expr_yyn > YYLAST || ssl_expr_yycheck[ssl_expr_yyn] != ssl_expr_yychar1)
    goto ssl_expr_yydefault;

  ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];

  /* ssl_expr_yyn is what to do for this token type in this state.
     Negative => reduce, -ssl_expr_yyn is rule number.
     Positive => shift, ssl_expr_yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (ssl_expr_yyn < 0)
      if (ssl_expr_yyn == YYFLAG)
	goto ssl_expr_yyerrlab;
      ssl_expr_yyn = -ssl_expr_yyn;
      goto ssl_expr_yyreduce;
  else if (ssl_expr_yyn == 0)
    goto ssl_expr_yyerrlab;

  if (ssl_expr_yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (ssl_expr_yychar != YYEOF)
    ssl_expr_yychar = YYEMPTY;

  *++ssl_expr_yyvsp = ssl_expr_yylval;
#ifdef YYLSP_NEEDED
  *++ssl_expr_yylsp = ssl_expr_yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (ssl_expr_yyerrstatus) ssl_expr_yyerrstatus--;

  ssl_expr_yystate = ssl_expr_yyn;
  goto ssl_expr_yynewstate;

/* Do the default action for the current state.  */
ssl_expr_yydefault:

  ssl_expr_yyn = ssl_expr_yydefact[ssl_expr_yystate];
  if (ssl_expr_yyn == 0)
    goto ssl_expr_yyerrlab;

/* Do a reduction.  ssl_expr_yyn is the number of a rule to reduce with.  */
  ssl_expr_yylen = ssl_expr_yyr2[ssl_expr_yyn];
  if (ssl_expr_yylen > 0)
    ssl_expr_yyval = ssl_expr_yyvsp[1-ssl_expr_yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       ssl_expr_yyn, ssl_expr_yyrline[ssl_expr_yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = ssl_expr_yyprhs[ssl_expr_yyn]; ssl_expr_yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", ssl_expr_yytname[ssl_expr_yyrhs[i]]);
      fprintf (stderr, " -> %s\n", ssl_expr_yytname[ssl_expr_yyr1[ssl_expr_yyn]]);
    }
#endif


  switch (ssl_expr_yyn) {

{ ssl_expr_info.expr = ssl_expr_yyvsp[0].exVal; ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_True,  NULL, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_False, NULL, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Not,   ssl_expr_yyvsp[0].exVal,   NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Or,    ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_And,   ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Comp,  ssl_expr_yyvsp[0].exVal,   NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[-1].exVal; ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_EQ,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_IN,  ssl_expr_yyvsp[-4].exVal, ssl_expr_yyvsp[-1].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_REG, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NRE, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, ssl_expr_yyvsp[-2].exVal);   ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Digit,  ssl_expr_yyvsp[0].cpVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_String, ssl_expr_yyvsp[0].cpVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Var,    ssl_expr_yyvsp[-1].cpVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[0].exVal; ;
    break;}
            ;
    break;}
            ;
    break;}
            ;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 543 "/usr/local/share/bison.simple"

  ssl_expr_yyvsp -= ssl_expr_yylen;
  ssl_expr_yyssp -= ssl_expr_yylen;
#ifdef YYLSP_NEEDED
  ssl_expr_yylsp -= ssl_expr_yylen;
#endif

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    {
      short *ssp1 = ssl_expr_yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != ssl_expr_yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++ssl_expr_yyvsp = ssl_expr_yyval;

#ifdef YYLSP_NEEDED
  ssl_expr_yylsp++;
  if (ssl_expr_yylen == 0)
    {
      ssl_expr_yylsp->first_line = ssl_expr_yylloc.first_line;
      ssl_expr_yylsp->first_column = ssl_expr_yylloc.first_column;
      ssl_expr_yylsp->last_line = (ssl_expr_yylsp-1)->last_line;
      ssl_expr_yylsp->last_column = (ssl_expr_yylsp-1)->last_column;
      ssl_expr_yylsp->text = 0;
    }
  else
    {
      ssl_expr_yylsp->last_line = (ssl_expr_yylsp+ssl_expr_yylen-1)->last_line;
      ssl_expr_yylsp->last_column = (ssl_expr_yylsp+ssl_expr_yylen-1)->last_column;
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  ssl_expr_yyn = ssl_expr_yyr1[ssl_expr_yyn];

  ssl_expr_yystate = ssl_expr_yypgoto[ssl_expr_yyn - YYNTBASE] + *ssl_expr_yyssp;
  if (ssl_expr_yystate >= 0 && ssl_expr_yystate <= YYLAST && ssl_expr_yycheck[ssl_expr_yystate] == *ssl_expr_yyssp)
    ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yystate];
  else
    ssl_expr_yystate = ssl_expr_yydefgoto[ssl_expr_yyn - YYNTBASE];

  goto ssl_expr_yynewstate;

ssl_expr_yyerrlab:   /* here on detecting error */

  if (! ssl_expr_yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++ssl_expr_yynerrs;

#ifdef YYERROR_VERBOSE
      ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];

      if (ssl_expr_yyn > YYFLAG && ssl_expr_yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -ssl_expr_yyn if nec to avoid negative indexes in ssl_expr_yycheck.  */
	  for (x = (ssl_expr_yyn < 0 ? -ssl_expr_yyn : 0);
	       x < (sizeof(ssl_expr_yytname) / sizeof(char *)); x++)
	    if (ssl_expr_yycheck[x + ssl_expr_yyn] == x)
	      size += strlen(ssl_expr_yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (ssl_expr_yyn < 0 ? -ssl_expr_yyn : 0);
		       x < (sizeof(ssl_expr_yytname) / sizeof(char *)); x++)
		    if (ssl_expr_yycheck[x + ssl_expr_yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, ssl_expr_yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      ssl_expr_yyerror(msg);
	      free(msg);
	    }
	  else
	    ssl_expr_yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	ssl_expr_yyerror("parse error");
    }

  goto ssl_expr_yyerrlab1;
ssl_expr_yyerrlab1:   /* here on error raised explicitly by an action */

  if (ssl_expr_yyerrstatus == 3)
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (ssl_expr_yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
#endif

      ssl_expr_yychar = YYEMPTY;

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  ssl_expr_yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto ssl_expr_yyerrhandle;

ssl_expr_yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  ssl_expr_yyn = ssl_expr_yydefact[ssl_expr_yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (ssl_expr_yyn) goto ssl_expr_yydefault;
#endif

ssl_expr_yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (ssl_expr_yyssp == ssl_expr_yyss) YYABORT;
  ssl_expr_yyvsp--;
  ssl_expr_yystate = *--ssl_expr_yyssp;
#ifdef YYLSP_NEEDED
  ssl_expr_yylsp--;
#endif

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
      short *ssp1 = ssl_expr_yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != ssl_expr_yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
#endif

ssl_expr_yyerrhandle:

  ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];
  if (ssl_expr_yyn == YYFLAG)
    goto ssl_expr_yyerrdefault;

  ssl_expr_yyn += YYTERROR;
  if (ssl_expr_yyn < 0 || ssl_expr_yyn > YYLAST || ssl_expr_yycheck[ssl_expr_yyn] != YYTERROR)
    goto ssl_expr_yyerrdefault;

  ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];
  if (ssl_expr_yyn < 0)
    {
      if (ssl_expr_yyn == YYFLAG)
	goto ssl_expr_yyerrpop;
      ssl_expr_yyn = -ssl_expr_yyn;
      goto ssl_expr_yyreduce;
    }
  else if (ssl_expr_yyn == 0)
    goto ssl_expr_yyerrpop;

  if (ssl_expr_yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++ssl_expr_yyvsp = ssl_expr_yylval;
#ifdef YYLSP_NEEDED
  *++ssl_expr_yylsp = ssl_expr_yylloc;
#endif

  ssl_expr_yystate = ssl_expr_yyn;
  goto ssl_expr_yynewstate;

 ssl_expr_yyacceptlab:
  /* YYACCEPT comes here.  */
  if (ssl_expr_yyfree_stacks)
    {
      free (ssl_expr_yyss);
      free (ssl_expr_yyvs);
#ifdef YYLSP_NEEDED
      free (ssl_expr_yyls);
#endif
    }
  return 0;

 ssl_expr_yyabortlab:
  /* YYABORT comes here.  */
  if (ssl_expr_yyfree_stacks)
    {
      free (ssl_expr_yyss);
      free (ssl_expr_yyvs);
#ifdef YYLSP_NEEDED
      free (ssl_expr_yyls);
#endif
    }
  return 1;
}
#line 176 "ssl_expr_parse.y"


int ssl_expr_yyerror(char *s)
{
    ssl_expr_error = s;
    return 2;

#define	T_TRUE	257
#define	T_FALSE	258
#define	T_DIGIT	259
#define	T_ID	260
#define	T_STRING	261
#define	T_REGEX	262
#define	T_REGEX_I	263
#define	T_FUNC_FILE	264
#define	T_OP_EQ	265
#define	T_OP_NE	266
#define	T_OP_LT	267
#define	T_OP_LE	268
#define	T_OP_GT	269
#define	T_OP_GE	270
#define	T_OP_REG	271
#define	T_OP_NRE	272
#define	T_OP_IN	273
#define	T_OP_OR	274
#define	T_OP_AND	275
#define	T_OP_NOT	276


 * $Header: /home/striker/cvs2svn/dumps/httpd-2.0/../../httpd-2.0/modules/ssl/ssl_expr_scan.c,v 1.7 2002/01/10 00:28:00 wrowe Exp $
#include <unistd.h>
    ap_sb_handle_t *sbh;
    ap_sb_handle_t *sbh;
        ap_scoreboard_image->global->running_generation = ap_my_generation;
        void *sb_mem;
        rc = DosAllocSharedMem((PPVOID)&sbmem, ap_scoreboard_fname,
        ap_init_scoreboard(sb_mem);
    } while (!shutdown_pending && ap_my_generation == ap_scoreboard_image->global->running_generation);
    ap_sb_handle_t *sbh;
    ap_sb_handle_t *sbh;
        ap_scoreboard_image->global->running_generation = ap_my_generation;
    ap_sb_handle_t *sbh;
    ap_sb_handle_t *sbh;
    reopen_scoreboard(pchild, 0);
    ap_scoreboard_image->global->running_generation = ap_my_generation;
	ap_scoreboard_image->global->running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
	ap_scoreboard_image->global->running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
    ap_sb_handle_t *sbh;
    thread_control[THREAD_GLOBAL(thread_num)].generation = ap_scoreboard_image->global->running_generation;
    ++ap_scoreboard_image->global->running_generation;
#define AP_MPM_WANT_SET_SCOREBOARD
    ap_sb_handle_t *sbh;
            /* Set up the scoreboard. */
            ap_run_pre_mpm(pconf, SB_NOT_SHARED);
            /* Set up the scoreboard. */
            ap_run_pre_mpm(pconf, SB_SHARED_CHILD);
        ap_scoreboard_image->parent[0].pid = parent_pid;
        ap_scoreboard_image->parent[0].quiescing = 0;
            
        /* Set up the scoreboard. */
        ap_run_pre_mpm(pconf, SB_SHARED);

    ap_sb_handle_t *sbh;
    reopen_scoreboard(pchild, 0);
    ap_scoreboard_image->global->running_generation = ap_my_generation;
const char * ap_mpm_set_scoreboard(cmd_parms *cmd, void *dummy,
                                   const char *arg)
const char *ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
                                const char *arg)
#include "apr_shm.h"
static apr_shm_t *scoreboard_shm = NULL;
struct ap_sb_handle_t {
};
    free(ap_scoreboard_image);
    scoreboard_size = sizeof(global_score);
void ap_init_scoreboard(void *shared_score)
    ap_scoreboard_image = 
        calloc(1, sizeof(scoreboard) + server_limit * sizeof(worker_score *));
    more_storage = shared_score;
    ap_scoreboard_image->global = (global_score *)more_storage;
    more_storage += sizeof(global_score);
    ap_scoreboard_image->servers = 
        (worker_score **)((char*)ap_scoreboard_image + sizeof(scoreboard));
    ap_assert(more_storage == (char*)shared_score + scoreboard_size);
static apr_status_t open_scoreboard(apr_pool_t *p)
    char *fname = NULL;
    if (ap_scoreboard_fname) {
        fname = ap_server_root_relative(p, ap_scoreboard_fname);
    }
    rv = apr_shm_create(&scoreboard_shm, scoreboard_size, fname, p);
/* If detach is non-zero, this is a seperate child process,
 * if zero, it is a forked child.
 */
apr_status_t reopen_scoreboard(apr_pool_t *p, int detached)
#if APR_HAS_SHARED_MEMORY
    apr_status_t rv;
    char *fname = NULL;

    if (!detached) {
        return APR_SUCCESS;
    }
    if (ap_scoreboard_fname) {
        fname = ap_server_root_relative(p, ap_scoreboard_fname);
    }
    rv = apr_shm_attach(&scoreboard_shm, fname, p);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                     "Fatal error: could not open(create) scoreboard");
        return rv;
    }
    if (apr_shm_size_get(scoreboard_shm) < scoreboard_size) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                     "Fatal error: shared scoreboard too small for child!");
        apr_shm_detach(scoreboard_shm);
        scoreboard_shm = NULL;
    }
    /* everything will be cleared shortly */
#endif
    return APR_SUCCESS;
    if (ap_scoreboard_image->global->sb_type == SB_SHARED) {
        free(ap_scoreboard_image->global);
/* Create or reinit an existing scoreboard. The MPM can control whether
void ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
	running_gen = ap_scoreboard_image->global->running_generation;
            void *sb_shared;
            rv = open_scoreboard(p);
            if (rv || !(sb_shared = apr_shm_baseaddr_get(scoreboard_shm))) {
            memset(sb_shared, 0, scoreboard_size);
            ap_init_scoreboard(sb_shared);
        }
        else if (sb_type == SB_SHARED_CHILD) {
            void *sb_shared;
            rv = reopen_scoreboard(p, 1);
            if (rv || !(sb_shared = apr_shm_baseaddr_get(scoreboard_shm))) {
                exit(APEXIT_INIT); /* XXX need to return an error from this function */
            }
            ap_init_scoreboard(sb_shared);
            void *sb_mem = calloc(1, scoreboard_size);
            if (sb_mem == NULL) {
            ap_init_scoreboard(sb_mem);
    /* can't just memset() */
    if (sb_type != SB_SHARED_CHILD) {
        ap_scoreboard_image->global->sb_type = sb_type;
        ap_scoreboard_image->global->running_generation = running_gen;
        ap_restart_time = apr_time_now();
        apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
    }
				           worker_score *new_score_rec)
    lseek(scoreboard_fd, sizeof(global_score) 
                       + (long) child_num * sizeof(worker_score), 0);
    lseek(scoreboard_fd, 0, 0);
AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)
AP_DECLARE(void) ap_create_sb_handle(ap_sb_handle_t **new_sbh, apr_pool_t *p,
    *new_sbh = (ap_sb_handle_t *)apr_palloc(p, sizeof(ap_sb_handle_t));
    (*new_sbh)->child_num = child_num;
    (*new_sbh)->thread_num = thread_num;
    int old_status;
        ps->generation = ap_my_generation;
	    apr_cpystrn(ws->vhost, r->server->server_hostname, sizeof(ws->vhost));
AP_DECLARE(int)ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r)
    return ap_update_child_status_from_indexes(sbh->child_num, sbh->thread_num,
AP_DECLARE(worker_score *) ap_get_scoreboard_worker(int x, int y)
AP_DECLARE(process_score *) ap_get_scoreboard_process(int x)
AP_DECLARE(global_score *) ap_get_scoreboard_global()
    return(ap_scoreboard_image->global);
        const char *escpath;
        escpath = ap_escape_html(p, path);
                "<base href=\"%s%s%s\">\n"
                site, basedir, escpath, site, basedir, escpath, site, str);
 * 20120211.23 (2.4.5-dev) Add ap_proxy_clear_connection()
#define MODULE_MAGIC_NUMBER_MINOR 23                   /* 0...n */
/**
 * Clear the headers referenced by the Connection header from the given
 * table, and remove the Connection header.
 * @param r request
 * @param headers table of headers to clear
 * @return 1 if "close" was present, 0 otherwise.
 */
APR_DECLARE_OPTIONAL_FN(int, ap_proxy_clear_connection,
        (request_rec *r, apr_table_t *headers));

static int (*ap_proxy_clear_connection_fn)(request_rec *r, apr_table_t *headers) =
        NULL;



            backend->close = ap_proxy_clear_connection_fn(r, r->headers_out);



/* post_config hook: */
static int proxy_http_post_config(apr_pool_t *pconf, apr_pool_t *plog,
        apr_pool_t *ptemp, server_rec *s)
{

    /* proxy_http_post_config() will be called twice during startup.  So, don't
     * set up the static data the 1st time through. */
    if (ap_state_query(AP_SQ_MAIN_STATE) == AP_SQ_MS_CREATE_PRE_CONFIG) {
        return OK;
    }

    if (!ap_proxy_clear_connection_fn) {
        ap_proxy_clear_connection_fn =
                APR_RETRIEVE_OPTIONAL_FN(ap_proxy_clear_connection);
        if (!ap_proxy_clear_connection_fn) {
            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(02477)
                         "mod_proxy must be loaded for mod_proxy_http");
            return !OK;
        }
    }

    return OK;
}

    ap_hook_post_config(proxy_http_post_config, NULL, NULL, APR_HOOK_MIDDLE);
typedef struct header_connection {
    apr_array_header_t *array;
    const char *first;
    unsigned int closed:1;
} header_connection;
static int find_conn_headers(void *data, const char *key, const char *val)
    header_connection *x = data;

    do {
        while (*val == ',') {
            val++;
        name = ap_get_token(x->pool, &val, 0);
        if (!strcasecmp(name, "close")) {
            x->closed = 1;
        if (!x->first) {
            x->first = name;
        }
        else {
            const char **elt;
            if (!x->array) {
                x->array = apr_array_make(x->pool, 4, sizeof(char *));
            }
            elt = apr_array_push(x->array);
            *elt = name;
        }
    } while (*val);

/**
 * Remove all headers referred to by the Connection header.
 */
static int ap_proxy_clear_connection(request_rec *r, apr_table_t *headers)
    const char **name;
    header_connection x;

    x.pool = r->pool;
    x.array = NULL;
    x.first = NULL;
    x.closed = 0;


    apr_table_do(find_conn_headers, &x, headers, "Connection", NULL);
    if (x.first) {
        /* fast path - no memory allocated for one header */
        apr_table_unset(headers, "Connection");
        apr_table_unset(headers, x.first);
    }
    if (x.array) {
        /* two or more headers */
        while ((name = apr_array_pop(x.array))) {
            apr_table_unset(headers, *name);
        }
    }

    return x.closed;
    ap_proxy_clear_connection(r, headers_in_copy);

void proxy_util_register_hooks(apr_pool_t *p)
{
    APR_REGISTER_OPTIONAL_FN(ap_proxy_retry_worker);
    APR_REGISTER_OPTIONAL_FN(ap_proxy_clear_connection);
}
static int read_request_line(request_rec *r, apr_bucket_brigade *bb)

#if 0
    conn_rec *conn = r->connection;
#endif
    int num_blank_lines = 0;
    int max_blank_lines = r->server->limit_req_fields;

    if (max_blank_lines <= 0) {
        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
    }

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    do {
        apr_status_t rv;

        /* insure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */
        r->the_request = NULL;
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                         &len, r, 0, bb);

        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }
            return 0;
        }
    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));

    /* we've probably got something to do, ignore graceful restart requests */
    ll = r->the_request;
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method",
                                r->method);
#endif

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

             && (minor < HTTP_VERSION(1, 0)) ) /* don't allow HTTP/0.1000 */
    else
    return 1;
    char *last_field = NULL;
    apr_size_t last_len = 0;
    apr_size_t alloc_len = 0;
    char *value;
    int fields_read = 0;
    char *tmp_field;
        int folded = 0;

        if (last_field != NULL) {
            if ((len > 0) && ((*field == '\t') || *field == ' ')) {
                /* This line is a continuation of the preceding line(s),
                 * so append it to the line that we've set aside.
                 * Note: this uses a power-of-two allocator to avoid
                 * doing O(n) allocs and using O(n^2) space for
                 * continuations that span many many lines.
                 */
                apr_size_t fold_len = last_len + len + 1; /* trailing null */

                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field "
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                if (fold_len > alloc_len) {
                    char *fold_buf;
                    alloc_len += alloc_len;
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
                    }
                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);
                    memcpy(fold_buf, last_field, last_len);
                    last_field = fold_buf;
                }
                memcpy(last_field + last_len, field, len +1); /* +1 for nul */
                last_len += len;
                folded = 1;
            }
            else /* not a continuation line */ {

                if (r->server->limit_req_fields
                    && (++fields_read > r->server->limit_req_fields)) {
                    r->status = HTTP_BAD_REQUEST;
                    apr_table_setn(r->notes, "error-notes",
                                   "The number of request header fields "
                                   "exceeds this server's limit.");
                    return;
                }

                if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                    r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Request header field is "
                                               "missing ':' separator.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool,
                                                              last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                tmp_field = value - 1; /* last character of field-name */

                *value++ = '\0'; /* NUL-terminate at colon */

                while (*value == ' ' || *value == '\t') {
                    ++value;            /* Skip to start of value   */
                }

                /* Strip LWS after field-name: */
                while (tmp_field > last_field
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                /* Strip LWS after field-value: */
                tmp_field = last_field + last_len - 1;
                while (tmp_field > value
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                apr_table_addn(r->headers_in, last_field, value);

                /* reset the alloc_len so that we'll allocate a new
                 * buffer if we have to do any more folding: we can't
                 * use the previous buffer because its contents are
                 * now part of r->headers_in
                 */
                alloc_len = 0;

            } /* end if current line is not a continuation starting with tab */

        /* Found a blank line, stop. */
        if (len == 0) {
            break;
        }

        /* Keep track of this line so that we can parse it on
         * the next loop iteration.  (In the folded case, last_field
         * has been updated already.)
         */
        if (!folded) {
            last_field = field;
            last_len = len;

    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
request_rec *ap_read_request(conn_rec *conn)
    const char *expect;
    int access_status;
    apr_bucket_brigade *tmp_bb;
    apr_socket_t *csd;
    apr_interval_time_t cur_timeout;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    /* Get the request... */
    if (!read_request_line(r, tmp_bb)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        apr_brigade_destroy(tmp_bb);
        return NULL;
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_get(csd, &cur_timeout);
    if (cur_timeout != conn->base_server->timeout) {
        apr_socket_timeout_set(csd, conn->base_server->timeout);
        cur_timeout = conn->base_server->timeout;
    }

    if (!r->assbackwards) {
        ap_get_mime_headers_core(r, tmp_bb);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        if (apr_table_get(r->headers_in, "Transfer-Encoding")
            && apr_table_get(r->headers_in, "Content-Length")) {
            /* 2616 section 4.4, point 3: "if both Transfer-Encoding
             * and Content-Length are received, the latter MUST be
             * ignored"; so unset it here to prevent any confusion
             * later. */
            apr_table_unset(r->headers_in, "Content-Length");
        }
    }
    else {
        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }
    }

    apr_brigade_destroy(tmp_bb);
    if (cur_timeout != r->server->timeout) {
        apr_socket_timeout_set(csd, r->server->timeout);
        cur_timeout = r->server->timeout;
    const char *p;
    const char *allowed = "~$-_.+!*'(),;:@&=/"; /* allowed+reserved from
                                                   ap_proxy_canonenc */
    /* In a reverse proxy, our URL has been processed, so canonicalise
     * In a forward proxy, we have and MUST NOT MANGLE the original,
     * so just check it for disallowed chars.
     */
    switch (r->proxyreq) {
    default: /* wtf are we doing here? */
    case PROXYREQ_REVERSE:
        path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path, 0, r->proxyreq);
        break;
    case PROXYREQ_PROXY:
        for (p = url; *p; ++p) {
            if (!apr_isalnum(*p) && !strchr(allowed, *p)) {
                if (*p == '%' && apr_isxdigit(p[1]) && apr_isxdigit(p[2])) {
                    p += 2; /* an encoded char */
                }
                else {
                    return HTTP_BAD_REQUEST; /* reject bad char in URL */
                }
            }
        }
        path = url;
        break;
    }

    imap_conf_rec *new = (imap_conf_rec *) apr_palloc(p, sizeof(imap_conf_rec));
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted") && *comment) {
    else if (!strcasecmp(menu, "unformatted") && *comment) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
        if (APR_SUCCESS != (status = apr_strtoff(&cl_val, old_cl_val, NULL,
                                                 0))) {
            return status;
        }
 * @param read The length of the line.
 * @return APR_SUCCESS, if successful
 *         APR_ENOSPC, if the line is too big to fit in the buffer
 *         Other errors where appropriate
AP_DECLARE(apr_status_t) ap_rgetline(char **s, apr_size_t n, apr_size_t *read,
                                     request_rec *r, int fold);
 * If s is NULL, ap_rgetline will allocate necessary memory from r->pool.
 *
 * Returns APR_SUCCESS if there are no problems and sets *read to be
 * the full length of s.
 *
 * APR_ENOSPC is returned if there is not enough buffer space.
 * Other errors may be returned on other errors.
 *
 * The LF is *not* returned in the buffer.  Therefore, a *read of 0
 * indicates that an empty line was read.
AP_DECLARE(apr_status_t) ap_rgetline(char **s, apr_size_t n, 
                                     apr_size_t *read, request_rec *r, 
                                     int fold)
    apr_status_t rv;
    apr_size_t bytes_handled = 0, current_alloc = 0;
    apr_off_t bytes_read;
    char *pos, *last_char = *s;
    int do_alloc = (*s == NULL), saw_eos = 0;

    b = apr_brigade_create(r->pool);
    rv = ap_get_brigade(r->input_filters, b, AP_MODE_GETLINE,
                        APR_BLOCK_READ, &bytes_read);

    if (rv != APR_SUCCESS) {
        return rv;
    }

    /* Something horribly wrong happened.  Someone didn't block! */
    if (APR_BRIGADE_EMPTY(b)) {
        return APR_EGENERAL; 
    }

    APR_BRIGADE_FOREACH(e, b) {
        const char *str;
        apr_size_t len;

        /* If we see an EOS, don't bother doing anything more. */
            saw_eos = 1; 
            break;
        }

        rv = apr_bucket_read(e, &str, &len, APR_BLOCK_READ);

        if (rv != APR_SUCCESS) {
            return rv;

        /* Would this overrun our buffer?  If so, we'll die. */
        if (n < bytes_handled + len) {
            apr_brigade_destroy(b); 
            return APR_ENOSPC;

        /* Do we have to handle the allocation ourselves? */
        if (do_alloc) {
            /* We'll assume the common case where one bucket is enough. */
            if (!*s) {
                current_alloc = len;
                *s = apr_palloc(r->pool, len);
            else if (bytes_handled + len > current_alloc) {
                /* We resize to the next power of 2. */
                apr_size_t new_size = current_alloc;
                char *new_buffer;
                do {
                    new_size *= 2;
                } while (bytes_handled + len > new_size);
                new_buffer = apr_palloc(r->pool, new_size);
                /* Copy what we already had. */
                memcpy(new_buffer, *s, bytes_handled);
                current_alloc = new_size;
                *s = new_buffer;
        /* Just copy the rest of the data to the end of the old buffer. */
        pos = *s + bytes_handled;
        memcpy(pos, str, len);
        last_char = pos + len - 1;
        /* We've now processed that new data - update accordingly. */
        bytes_handled += len;
    }

    /* We no longer need the returned brigade. */
    apr_brigade_destroy(b);

    /* We likely aborted early before reading anything or we read no 
     * data.  Technically, this might be success condition.  But,
     * probably means something is horribly wrong.  For now, we'll
     * treat this as APR_SUCCESS, but it may be worth re-examining.
     */
    if (bytes_handled == 0) {
        *read = 0;
        return APR_SUCCESS; 
    }

    /* If we didn't get a full line of input, try again. */
    if (*last_char != APR_ASCII_LF) {
        /* Do we have enough space? We may be full now. */
        if (bytes_handled < n) {
            apr_size_t next_size, next_len;
            char *tmp;
     
            /* If we're doing the allocations for them, we have to
             * give ourselves a NULL and copy it on return.
             */ 
                tmp = NULL;
            } else {
                /* We're not null terminated yet. */
                tmp = last_char + 1;
            }

            next_size = n - bytes_handled;

            rv = ap_rgetline(&tmp, next_size, &next_len, r, fold);

            if (rv != APR_SUCCESS) {
                return rv;
            }

            if (do_alloc && next_len > 0) {
                char *new_buffer;
                apr_size_t new_size = bytes_handled + next_len;
                /* Again we need to alloc an extra two bytes for LF, null */
                new_buffer = apr_palloc(r->pool, new_size);
                /* Copy what we already had. */
                memcpy(new_buffer, *s, bytes_handled);
                memcpy(new_buffer + bytes_handled, tmp, next_len);
                current_alloc = new_size;
                *s = new_buffer;

            bytes_handled += next_len;
            last_char = *s + bytes_handled - 1;
            return APR_ENOSPC;
        }
    }

    /* We now go backwards over any CR (if present) or white spaces.
     *
     * Trim any extra trailing spaces or tabs except for the first
     * space or tab at the beginning of a blank string.  This makes
     * it much easier to check field values for exact matches, and
     * saves memory as well.  Terminate string at end of line.
     */
    pos = last_char;
    if (pos > *s && *(pos - 1) == APR_ASCII_CR) {
        --pos;
    }

    /* Trim any extra trailing spaces or tabs except for the first
     * space or tab at the beginning of a blank string.  This makes
     * it much easier to check field values for exact matches, and
     * saves memory as well.
     */
    while (pos > ((*s) + 1) && 
           (*(pos - 1) == APR_ASCII_BLANK || *(pos - 1) == APR_ASCII_TAB)) {
        --pos;
    }
    /* Since we want to remove the LF from the line, we'll go ahead
     * and set this last character to be the term NULL and reset 
     * bytes_handled accordingly.
     */
    *pos = '\0';
    last_char = pos;
    bytes_handled = pos - *s;
   
    /* If we're folding, we have more work to do. 
     *
     * Note that if an EOS was seen, we know we can't have another line.
     */
    if (fold && bytes_handled && !saw_eos) {
        const char *str;
        apr_size_t len;
        /* We only care about the first byte. */
        bytes_read = 1;
        rv = ap_get_brigade(r->input_filters, b, AP_MODE_SPECULATIVE,
                            APR_BLOCK_READ, &bytes_read);

        if (rv != APR_SUCCESS) {
            return rv;
        e = APR_BRIGADE_FIRST(b);

        /* If we see an EOS, don't bother doing anything more. */
        if (APR_BUCKET_IS_EOS(e)) {
            *read = bytes_handled;
            return APR_SUCCESS;
        }

        rv = apr_bucket_read(e, &str, &len, APR_BLOCK_READ);

        if (rv != APR_SUCCESS) {
            return rv;
        }

        /* Found one, so call ourselves again to get the next line. 
         *
         * FIXME: If the folding line is completely blank, should we
         * stop folding?  Does that require also looking at the next
         * char?
         */
        if (*str == APR_ASCII_BLANK || *str == APR_ASCII_TAB) {
            /* Do we have enough space? We may be full now. */
            if (bytes_handled < n) {
                apr_size_t next_size, next_len;
                char *tmp;
       
                /* If we're doing the allocations for them, we have to
                 * give ourselves a NULL and copy it on return.
                 */ 
                if (do_alloc) {
                    tmp = NULL;           
                } else { 
                    /* We're null terminated. */
                    tmp = last_char;
                }

                next_size = n - bytes_handled;

                rv = ap_rgetline(&tmp, next_size, &next_len, r, fold);

                if (rv != APR_SUCCESS) {
                    return rv;
                }

                if (do_alloc && next_len > 0) {
                    char *new_buffer;
                    apr_size_t new_size = bytes_handled + next_len;
                    /* Again we need to alloc an extra two bytes for LF, null */
                    new_buffer = apr_palloc(r->pool, new_size);
                    /* Copy what we already had. */
                    memcpy(new_buffer, *s, bytes_handled);
                    memcpy(new_buffer + bytes_handled, tmp, next_len);
                    current_alloc = new_size;
                    *s = new_buffer;
                }

                *read = bytes_handled + next_len;
                return APR_SUCCESS;
                return APR_ENOSPC;

    /* FIXME: Can we optimize this at all by placing it a different layer? */
    ap_xlate_proto_from_ascii(*s, bytes_handled);
    *read = bytes_handled;
    return APR_SUCCESS;
    apr_status_t rv;
    apr_size_t len;

    rv = ap_rgetline(&tmp_s, n, &len, r, fold);

    /* Map the out-of-space condition to the old API. */
    if (rv == APR_ENOSPC) {
        return n;
    }

    /* Anything else is just bad. */
    if (rv != APR_SUCCESS) {
        return -1;
    }

    return (int)len;
    apr_size_t len;
    do {
        apr_status_t rv;

        rv = ap_rgetline(&(r->the_request), DEFAULT_LIMIT_REQUEST_LINE + 2,
                         &len, r, 0);

        if (rv != APR_SUCCESS) {
            /* Something went horribly wrong. */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "read_request_line() failed");
	        r->request_time = apr_time_now();
    } while (len <= 0);

    apr_size_t len;
    while(1) {
        apr_status_t rv;
        field = NULL;
        rv = ap_rgetline(&field, DEFAULT_LIMIT_REQUEST_FIELDSIZE + 2,
                         &len, r, 1);

        /* ap_rgetline returns APR_ENOSPC if it fills up the buffer before 
         * finding the end-of-line.  This is only going to happen if it 
         * exceeds the configured limit for a field size.
         */
        if (rv == APR_ENOSPC) {
                apr_pstrcat(r->pool,
                            "Size of a request header field "
                            "exceeds server limit.<br />\n"
                            "<pre>\n",
                            ap_escape_html(r->pool, field),
                            "</pre>\n", NULL));

        if (rv != APR_SUCCESS) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, "get_mime_headers() failed");
            return;
        }

        /* Found a blank line, stop. */
        if (len == 0) {
            break;
        }

        if (r->server->limit_req_fields &&
            (++fields_read > r->server->limit_req_fields)) {
			   "The number of request header fields exceeds "
			   "this server's limit.");
        }
        apr_table_addn(tmp_headers, field, value);
    apr_pool_t *pool = s->process->pool;
                          pool);
    mc = (SSLModConfigRec *)apr_palloc(pool, sizeof(*mc));
    mc->pPool = pool;
    mc->aRandSeed              = apr_array_make(pool, 4,
    mc->tVHostKeys             = apr_hash_make(pool);
    mc->tPrivateKey            = apr_hash_make(pool);
    mc->tPublicCert            = apr_hash_make(pool);
    mc->tTmpKeys               = apr_hash_make(pool);
                          pool);
    ssl_randseed_t *seed;
    seed = apr_array_push(mc->aRandSeed);
        seed->nCtx = SSL_RSCTX_STARTUP;
        seed->nCtx = SSL_RSCTX_CONNECT;
        seed->nSrc   = SSL_RSSRC_FILE;
        seed->cpPath = ap_server_root_relative(mc->pPool, arg2+5);
        seed->nSrc   = SSL_RSSRC_EXEC;
        seed->cpPath = ap_server_root_relative(mc->pPool, arg2+5);
        seed->nSrc   = SSL_RSSRC_EGD;
        seed->cpPath = ap_server_root_relative(mc->pPool, arg2+4);
        seed->nSrc   = SSL_RSSRC_BUILTIN;
        seed->cpPath = NULL;
        seed->nSrc   = SSL_RSSRC_FILE;
        seed->cpPath = ap_server_root_relative(mc->pPool, arg2);
    if (seed->nSrc != SSL_RSSRC_BUILTIN) {
        if (!ssl_util_path_check(SSL_PCM_EXISTS, seed->cpPath, cmd->pool)) {
                               seed->cpPath, "' does not exist", NULL);
        seed->nBytes = 0; /* read whole file */
        if (seed->nSrc == SSL_RSSRC_BUILTIN) {
        seed->nBytes = atoi(arg3);
        if (seed->nBytes < 0) {
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
            sc->szPublicCertFile[i] = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
            sc->szPrivateKeyFile[i] = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
    sc->szCertificateChain = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, path, cmd->pool)) {
                           path, "' does not exist", NULL);
        sc->szCACertificatePath = path;
        dc->szCACertificatePath = path;
    sc->szCACertificatePath = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
        sc->szCACertificateFile = path;
        dc->szCACertificateFile = path;
    sc->szCACertificateFile = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, path, cmd->pool)) {
                           path, "' does not exist", NULL);
    sc->szCARevocationPath = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
    sc->szCARevocationFile = path;
                               const char *arg)
    while (*arg) {
        w = ap_getword_conf(cmd->pool, &arg);
                               const char *arg)
    ssl_expr *expr;
    ssl_require_t *require;
    if (!(expr = ssl_expr_comp(cmd->pool, (char *)arg))) {
    require = apr_array_push(dc->aRequirement);
    require->cpExpr = apr_pstrdup(cmd->pool, arg);
    require->mpExpr = expr;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
    sc->szProxyCACertificateFile = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, path, cmd->pool)) {
                           path, "' does not exist", NULL);
    sc->szProxyCACertificatePath = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
    sc->szProxyClientCertificateFile = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, path, cmd->pool)) {
                           path, "' does not exist", NULL);
    sc->szProxyClientCertificatePath = path;
    unsigned char *ptr;
        ptr = ssl_asn1_table_set(mc->tTmpKeys, "RSA:512", length);
        (void)i2d_RSAPrivateKey(rsa, &ptr); /* 2nd arg increments */
        ptr = ssl_asn1_table_set(mc->tTmpKeys, "RSA:1024", length);
        (void)i2d_RSAPrivateKey(rsa, &ptr); /* 2nd arg increments */
        ptr = ssl_asn1_table_set(mc->tTmpKeys, "DH:512", length);
        (void)i2d_DHparams(dh, &ptr); /* 2nd arg increments */
        ptr = ssl_asn1_table_set(mc->tTmpKeys, "DH:1024", length);
        (void)i2d_DHparams(dh, &ptr); /* 2nd arg increments */
            ptr = asn1->cpData;
                  d2i_RSAPrivateKey(NULL, &ptr, asn1->nData)))
            ptr = asn1->cpData;
                  d2i_RSAPrivateKey(NULL, &ptr, asn1->nData)))
            ptr = asn1->cpData;
                  d2i_DHparams(NULL, &ptr, asn1->nData)))
            ptr = asn1->cpData;
                  d2i_DHparams(NULL, &ptr, asn1->nData)))
    int verify = SSL_VERIFY_NONE;
    char *cp, *vhost_id;
    EVP_PKEY *pkey;
    STACK_OF(X509_NAME) *ca_list;
    unsigned char *ptr;
    int is_ca, pathlen;
    sc->szVHostID = vhost_id = ssl_util_vhostid(p, s);
                vhost_id);
                "(theoretically shouldn't happen!)", vhost_id);
                vhost_id);
            vhost_id, cp);
        verify |= SSL_VERIFY_PEER_STRICT;
        verify |= SSL_VERIFY_PEER;
    SSL_CTX_set_verify(ctx, verify,  ssl_callback_SSLVerify);
                vhost_id, sc->szCipherSuite);
                    vhost_id);
                "Init: (%s) Configuring client authentication", vhost_id);
                    "for client authentication", vhost_id);
        ca_list = ssl_init_FindCAList(s, p,
                                      sc->szCACertificateFile,
                                      sc->szCACertificatePath);
        if (!ca_list) {
                    vhost_id);
        SSL_CTX_set_client_CA_list(sc->pSSLCtx, (STACK *)ca_list);
                vhost_id);
                    vhost_id);
        ca_list = (STACK_OF(X509_NAME) *)SSL_CTX_get_client_CA_list(ctx);
        if (sk_X509_NAME_num(ca_list) == 0) {
    cp = apr_psprintf(p, "%s:RSA", vhost_id);
                vhost_id);
        ptr = asn1->cpData;
              d2i_X509(NULL, &ptr, asn1->nData)))
                    vhost_id);
                    vhost_id);
    cp = apr_psprintf(p, "%s:DSA", vhost_id);
                vhost_id);
        ptr = asn1->cpData;
              d2i_X509(NULL, &ptr, asn1->nData)))
                    vhost_id);
                    vhost_id);
                vhost_id);
                vhost_id);
                        vhost_id, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
            if (SSL_X509_getBC(sc->pPublicCert[i], &is_ca, &pathlen)) {
                if (is_ca) {
                            vhost_id, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
                            vhost_id, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
                            vhost_id, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
                            vhost_id, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
    cp = apr_psprintf(p, "%s:RSA", vhost_id);
                vhost_id);
        ptr = asn1->cpData;
              d2i_PrivateKey(EVP_PKEY_RSA, NULL, &ptr, asn1->nData)))
                    vhost_id);
                    vhost_id);
    cp = apr_psprintf(p, "%s:DSA", vhost_id);
                vhost_id);
        ptr = asn1->cpData;
              d2i_PrivateKey(EVP_PKEY_DSA, NULL, &ptr, asn1->nData)))
                    vhost_id);
                    vhost_id);
                vhost_id);
        pkey = X509_get_pubkey(sc->pPublicCert[SSL_AIDX_DSA]);
        if (pkey && (EVP_PKEY_key_type(pkey) == EVP_PKEY_DSA) &&
            EVP_PKEY_missing_parameters(pkey))
            EVP_PKEY_copy_parameters(pkey,
        BOOL skip_first = FALSE;
                skip_first = TRUE;
                                          skip_first, NULL);
                    vhost_id);
                vhost_id, n, n == 1 ? "" : "s");
    server_rec *s, **ps;
    ssl_ds_table *table;
    apr_pool_t *subpool;
    BOOL conflict = FALSE;
    apr_pool_create(&subpool, p);
    table = ssl_ds_table_make(subpool, sizeof(server_rec *));
        key = apr_psprintf(subpool, "%pA:%u",
        if ((ps = ssl_ds_table_get(table, key))) {
            conflict = TRUE;
        ps = ssl_ds_table_push(table, key);
    ssl_ds_table_kill(table);
    apr_pool_destroy(subpool);
    if (conflict) {
static void ssl_init_PushCAList(STACK_OF(X509_NAME) *ca_list,
        if (sk_X509_NAME_find(ca_list, name) < 0) {
            /* this will be freed when ca_list is */
            sk_X509_NAME_push(ca_list, name);
                                         apr_pool_t *p,
                                         const char *ca_file,
                                         const char *ca_path)
    STACK_OF(X509_NAME) *ca_list;
    apr_pool_t *subpool;
    apr_pool_sub_make(&subpool, p, NULL);
    ca_list = sk_X509_NAME_new(ssl_init_FindCAList_X509NameCmp);
    if (ca_file) {
        ssl_init_PushCAList(ca_list, s, ca_file);
    if (ca_path) {
        if (apr_dir_open(&dir, ca_path, subpool) != APR_SUCCESS) {
                    ca_path);
            const char *file;
            file = apr_pstrcat(subpool, ca_path, "/", direntry.name, NULL);
            ssl_init_PushCAList(ca_list, s, file);
    sk_X509_NAME_set_cmp_func(ca_list, NULL);
    apr_pool_destroy(subpool);
    return ca_list;
    const char *type = "";
        type = "standard";
        type = "unclean";
        type = "accurate";
                conn->id, type,
    apr_array_header_t *requires;
    ssl_require_t *ssl_requires;
    STACK_OF(X509_NAME) *ca_list;
    char *ca_path, *ca_file;
    STACK_OF(X509) *cert_stack;
    X509_STORE *cert_store;
    X509_STORE_CTX cert_store_ctx;
    STACK_OF(SSL_CIPHER) *cipher_list_old, *cipher_list = NULL;
    SSL_CIPHER *cipher = NULL;
    int depth, verify_old, verify, n;
            cipher = SSL_get_current_cipher(ssl);
            cipher_list_old = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);
            if (cipher_list_old) {
                cipher_list_old = sk_SSL_CIPHER_dup(cipher_list_old);
            if (cipher_list_old) {
                sk_SSL_CIPHER_free(cipher_list_old);
        cipher_list = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);
            if ((!cipher && cipher_list) ||
                (cipher && !cipher_list))
            else if (cipher && cipher_list &&
                     (sk_SSL_CIPHER_find(cipher_list, cipher) < 0))
            if ((!cipher_list_old && cipher_list) ||
                (cipher_list_old && !cipher_list))
            else if (cipher_list_old && cipher_list) {
                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list));
                    SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list, n);
                    if (sk_SSL_CIPHER_find(cipher_list_old, value) < 0) {
                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list_old));
                    SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list_old, n);
                    if (sk_SSL_CIPHER_find(cipher_list, value) < 0) {
        if (cipher_list_old) {
            sk_SSL_CIPHER_free(cipher_list_old);
        verify_old = SSL_get_verify_mode(ssl);
        verify = SSL_VERIFY_NONE;
            verify |= SSL_VERIFY_PEER_STRICT;
            verify |= SSL_VERIFY_PEER;
        SSL_set_verify(ssl, verify, ssl_callback_SSLVerify);
        if (verify != verify_old) {
            if (((verify_old == SSL_VERIFY_NONE) &&
                 (verify     != SSL_VERIFY_NONE)) ||
                (!(verify_old & SSL_VERIFY_PEER) &&
                  (verify     & SSL_VERIFY_PEER)) ||
                (!(verify_old & SSL_VERIFY_PEER_STRICT) &&
                  (verify     & SSL_VERIFY_PEER_STRICT)))
                    (verify_old == SSL_VERIFY_NONE) &&
        ca_file = dc->szCACertificateFile ?
        ca_path = dc->szCACertificatePath ?
           if (!SSL_load_verify_locations(ssl, ca_file, ca_path)) {
        if (!SSL_CTX_load_verify_locations(ctx, ca_file, ca_path)) {
        if (!(ca_list = ssl_init_FindCAList(r->server, r->pool,
                                            ca_file, ca_path)))
        SSL_set_client_CA_list(ssl, ca_list);
            if (!(cert_store = SSL_CTX_get_cert_store(ctx))) {
            cert_stack = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl);
            if (!cert_stack || (sk_X509_num(cert_stack) == 0)) {
            cert = sk_X509_value(cert_stack, 0);
            X509_STORE_CTX_init(&cert_store_ctx, cert_store, cert, cert_stack);
                X509_STORE_CTX_set_depth(&cert_store_ctx, depth);
            X509_STORE_CTX_set_ex_data(&cert_store_ctx,
            if (!X509_verify_cert(&cert_store_ctx)) {
            SSL_set_verify_result(ssl, cert_store_ctx.error);
            X509_STORE_CTX_cleanup(&cert_store_ctx);
            BOOL do_verify = (dc->nVerifyClient == SSL_CVERIFY_REQUIRE);
            if (do_verify && (SSL_get_verify_result(ssl) != X509_V_OK)) {
            if (do_verify && !SSL_get_peer_certificate(ssl)) {
    requires = dc->aRequirement;
    ssl_requires = (ssl_require_t *)requires->elts;
    for (i = 0; i < requires->nelts; i++) {
        ssl_require_t *req = &ssl_requires[i];
        ok = ssl_expr_exec(r, req->mpExpr);
                    "Failed expression: %s", req->cpExpr);
    char buf1[MAX_STRING_LEN], buf2[MAX_STRING_LEN];
    const char *auth_line, *username, *password;
    if ((auth_line = apr_table_get(r->headers_in, "Authorization"))) {
        if (strcEQ(ap_getword(r->pool, &auth_line, ' '), "Basic")) {
            while ((*auth_line == ' ') || (*auth_line == '\t')) {
                auth_line++;
            auth_line = ap_pbase64decode(r->pool, auth_line);
            username = ap_getword_nulls(r->pool, &auth_line, ':');
            password = auth_line;
            if ((username[0] == '/') && strEQ(password, "password")) {
    apr_snprintf(buf1, sizeof(buf1), "%s:password", clientdn);
    ssl_util_uuencode(buf2, buf1, FALSE);
    apr_snprintf(buf1, sizeof(buf1), "Basic %s", buf2);
    apr_table_set(r->headers_in, "Authorization", buf1);
            "Faking HTTP Basic Auth header: \"Authorization: %s\"", buf1);
    apr_table_t *env = r->subprocess_env;
    STACK_OF(X509) *peer_certs;
    apr_table_setn(env, "HTTPS", "on"); 
                apr_table_setn(env, var, val);
        apr_table_setn(env, "SSL_SERVER_CERT", val);
        apr_table_setn(env, "SSL_CLIENT_CERT", val);
        if ((peer_certs = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl))) {
            for (i = 0; i < sk_X509_num(peer_certs); i++) {
                    apr_table_setn(env, var, val);
RSA *ssl_callback_TmpRSA(SSL *ssl, int export, int keylen)
    conn_rec *c = (conn_rec *)SSL_get_app_data(ssl);
    if (export) {
        if (keylen == 512) {
        else if (keylen == 1024) {
DH *ssl_callback_TmpDH(SSL *ssl, int export, int keylen)
    conn_rec *c = (conn_rec *)SSL_get_app_data(ssl);
    if (export) {
        if (keylen == 512) {
        else if (keylen == 1024) {
        X509 *cert  = X509_STORE_CTX_get_current_cert(ctx);
        char *sname = X509_NAME_oneline(X509_get_subject_name(cert), NULL, 0);
        char *iname = X509_NAME_oneline(X509_get_issuer_name(cert),  NULL, 0);
                sname ? sname : "-unknown-",
                iname ? iname : "-unknown-");
        if (sname) {
            free(sname);
        if (iname) {
            free(iname);
    X509 *cert;
    cert    = X509_STORE_CTX_get_current_cert(ctx);
    subject = X509_get_subject_name(cert);
    issuer  = X509_get_issuer_name(cert);
        if (X509_CRL_verify(crl, X509_get_pubkey(cert)) <= 0) {
            if (!ASN1_INTEGER_cmp(sn, X509_get_serialNumber(cert))) {
int ssl_callback_NewSessionCacheEntry(SSL *ssl, SSL_SESSION *session)
    SSL_set_timeout(session, timeout);
    session_id = SSL_SESSION_get_session_id(session);
    session_id_length = SSL_SESSION_get_session_id_length(session);
    timeout += SSL_get_time(session);
                          timeout, session);
     * return 0 which means to OpenSSL that the session is still
                                               int idlen, int *do_copy)
    SSL_SESSION *session;
    session = ssl_scache_retrieve(s, id, idlen);
    if (session) {
     * setting do_copy to 0) that the reference count on the
    *do_copy = 0;
    return session;
                                       SSL_SESSION *session)
    session_id = SSL_SESSION_get_session_id(session);
    session_id_length = SSL_SESSION_get_session_id_length(session);
            char *str = (where & SSL_CB_READ) ? "read" : "write";
    if (strcmp(r->unparsed_uri, "*") == 0) {
        /* Don't apply rewrite rules to "*". */
        return DECLINED;
    }

    /* Check that the URI is valid. */
    if (!r->uri || r->uri[0] != '/') {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "Invalid URI in request %s", r->the_request);
        return HTTP_BAD_REQUEST;
    }
    
    if (strcmp(r->unparsed_uri, "*") == 0) {
        /* "*" cannot be proxied. */
        return DECLINED;
    }

    /* Check that the URI is valid. */
    if (!r->uri || r->uri[0] != '/') {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "Invalid URI in request %s", r->the_request);
        return HTTP_BAD_REQUEST;
    }

    if (dav_get_provider(lookup.rnew) == NULL) {
        return dav_error_response(r, HTTP_METHOD_NOT_ALLOWED,
                                  "DAV not enabled for Destination URI.");
    }

#include "apr_support.h"
    apr_bucket_brigade *tmpbb;
static apr_status_t check_time_left(reqtimeout_con_cfg *ccfg,
                                    apr_time_t *time_left_p)
{
    *time_left_p = ccfg->timeout_at - apr_time_now();
    if (*time_left_p <= 0)
        return APR_TIMEUP;
    
    if (*time_left_p < apr_time_from_sec(1)) {
        *time_left_p = apr_time_from_sec(1);
    }
    return APR_SUCCESS;
}

static apr_status_t have_lf_or_eos(apr_bucket_brigade *bb)
{
    apr_bucket *b = APR_BRIGADE_LAST(bb);

    for ( ; b != APR_BRIGADE_SENTINEL(bb) ; b = APR_BUCKET_PREV(b) ) {
    	const char *str;
    	apr_size_t len;
    	apr_status_t rv;

        if (APR_BUCKET_IS_EOS(b))
            return APR_SUCCESS;

        if (APR_BUCKET_IS_METADATA(b))
            continue;

        rv = apr_bucket_read(b, &str, &len, APR_BLOCK_READ);
        if (rv != APR_SUCCESS)
            return rv;

        if (len == 0)
            continue;

        if (str[len-1] == APR_ASCII_LF)
            return APR_SUCCESS;
    }
    return APR_INCOMPLETE;
}


#define MIN(x,y) ((x) < (y) ? (x) : (y))
    rv = check_time_left(ccfg, &time_left);
    if (rv != APR_SUCCESS)
        goto out;
    rv = apr_socket_timeout_set(ccfg->socket, MIN(time_left, saved_sock_timeout));
    AP_DEBUG_ASSERT(rv == APR_SUCCESS);
    if (mode == AP_MODE_GETLINE) {
        /*
         * For a blocking AP_MODE_GETLINE read, apr_brigade_split_line()
         * would loop until a whole line has been read. As this would make it
         * impossible to enforce a total timeout, we only do non-blocking
         * reads.
         */
        apr_size_t remaining = HUGE_STRING_LEN;
        do {
            apr_off_t bblen;
            rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE, APR_NONBLOCK_READ, remaining);
            if (APR_STATUS_IS_EAGAIN(rv)) {
                rv = APR_SUCCESS;
            }
            else if (rv != APR_SUCCESS) {
                break;
            }

            if (!APR_BRIGADE_EMPTY(bb)) {
                rv = have_lf_or_eos(bb);
                if (rv != APR_INCOMPLETE) {
                    break;
                }

                if (ccfg->min_rate > 0) {
                    extend_timeout(ccfg, bb);
                }

                rv = apr_brigade_length(bb, 1, &bblen);
                if (rv != APR_SUCCESS) {
                    break;
                }
                remaining -= bblen;
                if (remaining <= 0) {
                    break;
                }

                /* Haven't got a whole line yet, save what we have ... */
                if (!ccfg->tmpbb) {
                    ccfg->tmpbb = apr_brigade_create(f->c->pool, f->c->bucket_alloc);
                }
                APR_BRIGADE_CONCAT(ccfg->tmpbb, bb);
            }

            /* ... and wait for more */
            rv = apr_wait_for_io_or_timeout(NULL, ccfg->socket, 1);
            if (rv != APR_SUCCESS)
                break;

            rv = check_time_left(ccfg, &time_left);
            if (rv != APR_SUCCESS)
                break;
            rv = apr_socket_timeout_set(ccfg->socket,
                                   MIN(time_left, saved_sock_timeout));
            AP_DEBUG_ASSERT(rv == APR_SUCCESS);

        } while (1);

        if (ccfg->tmpbb)
            APR_BRIGADE_PREPEND(bb, ccfg->tmpbb);

    }
    else {
        /* mode != AP_MODE_GETLINE */
        rv = ap_get_brigade(f->next, bb, mode, block, readbytes);
        if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {
            extend_timeout(ccfg, bb);
        }
    apr_socket_timeout_set(ccfg->socket, saved_sock_timeout);

out:
        /*
         * If we allow lingering close, the client may keep this
         * process/thread busy for another 30s (MAX_SECS_TO_LINGER).
         * Therefore we have to abort the connection. The downside is
         * that the client will most likely not receive the error
         * message.
         */
        f->c->aborted = 1;
 * 20051231.0 (2.3.0-dev) Added num_blank_lines, pending_header_line, and
 *                        pending_header_size to request_rec
#define MODULE_MAGIC_NUMBER_MAJOR 20051231
    /** Number of leading blank lines encountered before request header */
    int num_blank_lines;

    /** A buffered header line, used to support header folding while
     *  reading the request */
    char *pending_header_line;

    /** If nonzero, the number of bytes allocated to hold pending_header_line */
    apr_size_t pending_header_size;

static void set_the_request(request_rec *r, char *line)
    apr_socket_t *csd;
    ll = r->the_request = line;
             && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */
    }
    else {
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(r->connection->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->connection->base_server->timeout);

    return;
}

static apr_status_t set_mime_header(request_rec *r, char *line)
{
    char *value, *tmp_field;

    if (r->server->limit_req_fields) {
        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);
        if (mime_headers->nelts >= r->server->limit_req_fields) {
            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields "
                           "exceeds this server's limit.");
            r->status = HTTP_BAD_REQUEST;
            return APR_ENOSPC;
        }
    }
    
    if (!(value = strchr(line, ':'))) { /* Find ':' or    */
        r->status = HTTP_BAD_REQUEST;      /* abort bad request */
        apr_table_setn(r->notes, "error-notes",
                       apr_pstrcat(r->pool,
                                   "Request header field is "
                                   "missing ':' separator.<br />\n"
                                   "<pre>\n",
                                   ap_escape_html(r->pool, line),
                                   "</pre>\n", NULL));
        return APR_EGENERAL;
    }

    tmp_field = value - 1; /* last character of field-name */

    *value++ = '\0'; /* NUL-terminate at colon */

    while (*value == ' ' || *value == '\t') {
        ++value;            /* Skip to start of value   */
    }

    /* Strip LWS after field-name: */
    while (tmp_field > line
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }

    /* Strip LWS after field-value: */
    tmp_field = strchr(value, '\0') - 1;
    while (tmp_field > value
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }
    apr_table_addn(r->headers_in, line, value);
    return APR_SUCCESS;
}

static apr_status_t process_request_line(request_rec *r, char *line,
                                         int skip_first)
{
    if (!skip_first && (r->the_request == NULL)) {
        /* This is the first line of the request */
        if ((line == NULL) || (*line == '\0')) {
            /* We skip empty lines because browsers have to tack a CRLF on to the end
             * of POSTs to support old CERN webservers.
             */
            int max_blank_lines = r->server->limit_req_fields;
            if (max_blank_lines <= 0) {
                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
            }
            r->num_blank_lines++;
            if (r->num_blank_lines < max_blank_lines) {
                return APR_SUCCESS;
            }
        }
        set_the_request(r, line);
    }
    else {
        /* We've already read the first line of the request.  This is either
         * a header field or the blank line terminating the header
         */
        if ((line == NULL) || (*line == '\0')) {
            if (r->pending_header_line != NULL) {
                apr_status_t rv = set_mime_header(r, r->pending_header_line);
                if (rv != APR_SUCCESS) {
                    return rv;
                }
                r->pending_header_line = NULL;
            }
            if (r->status == HTTP_REQUEST_TIME_OUT) {
                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
                r->status = HTTP_OK;
            }
        }
        else {
            if ((*line == ' ') || (*line == '\t')) {
                /* This line is a continuation of the previous one */
                if (r->pending_header_line == NULL) {
                    r->pending_header_line = line;
                    r->pending_header_size = 0;
                }
                else {
                    apr_size_t pending_len = strlen(r->pending_header_line);
                    apr_size_t fold_len = strlen(line);
                    if (pending_len + fold_len >
                        r->server->limit_req_fieldsize) {
                        /* CVE-2004-0942 */
                        r->status = HTTP_BAD_REQUEST;
                        return APR_ENOSPC;
                    }
                    if (pending_len + fold_len + 1 > r->pending_header_size) {
                        /* Allocate a new buffer big enough to hold the
                         * concatenated lines
                         */
                        apr_size_t new_size = r->pending_header_size;
                        char *new_buf;
                        if (new_size == 0) {
                            new_size = pending_len + fold_len + 1;
                        }
                        else {
                            do {
                                new_size *= 2;
                            } while (new_size < pending_len + fold_len + 1);
                        }
                        new_buf = (char *)apr_palloc(r->pool, new_size);
                        memcpy(new_buf, r->pending_header_line, pending_len);
                        r->pending_header_line = new_buf;
                        r->pending_header_size = new_size;
                    }
                    memcpy(r->pending_header_line + pending_len, line,
                           fold_len + 1);
                }
            }
            else {
                /* Set aside this line in case the next line is a continuation
                 */
                if (r->pending_header_line != NULL) {
                    apr_status_t rv = set_mime_header(r, r->pending_header_line);
                    if (rv != APR_SUCCESS) {
                        return rv;
                    }
                }
                r->pending_header_line = line;
                r->pending_header_size = 0;
            }
        }
    }
    return APR_SUCCESS;
        rv = process_request_line(r, field, 1);
        if (rv != APR_SUCCESS) {
            return;
        if ((field == NULL) || (*field == '\0')) {
            return;
static request_rec *init_request(conn_rec *conn)
    
    return r;
}
static request_rec *request_post_read(request_rec *r, conn_rec *conn)
{
    apr_socket_t *csd;
    const char *expect;
    int access_status;
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->server->timeout);

    if (apr_table_get(r->headers_in, "Transfer-Encoding") &&
        apr_table_get(r->headers_in, "Content-Length")) {
        /* 2616 section 4.4, point 3: "if both Transfer-Encoding
         * and Content-Length are received, the latter MUST be
         * ignored"; so unset it here to prevent any confusion
         * later.
         */
        apr_table_unset(r->headers_in, "Content-Length");
static apr_status_t read_partial_request(request_rec *r) {
    apr_bucket_brigade *tmp_bb;
    apr_status_t rv = APR_SUCCESS;

    /* Read and process lines of the request until we
     * encounter a complete request header, an error, or EAGAIN
     */
    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    while (r->status == HTTP_REQUEST_TIME_OUT) {
        char *line = NULL;
        apr_size_t line_length;
        apr_size_t length_limit;
        int first_line = (r->the_request == NULL);
        if (first_line) {
            length_limit = r->server->limit_req_line;
        }
        else {
            if (r->assbackwards) {
                r->status = HTTP_OK;
                break;
            }
            length_limit = r->server->limit_req_fieldsize;
        }
        /* TODO: use a nonblocking call in place of ap_rgetline */
        rv = ap_rgetline(&line, length_limit + 2,
                         &line_length, r, 0, tmp_bb);
        if (rv == APR_SUCCESS) {
            rv = process_request_line(r, line, 0);
        }
        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();
            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                if (first_line) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: URI too long (longer than %d)",
                                  r->server->limit_req_line);
                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                    r->proto_num = HTTP_VERSION(1,0);
                    r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
                }
                else {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: header line too long "
                                  "(longer than %d)",
                                  r->server->limit_req_fieldsize);
                    r->status = HTTP_BAD_REQUEST;
                }
            }
            break;
        }
    }
    apr_brigade_destroy(tmp_bb);
    return rv;
}

request_rec *ap_read_request(conn_rec *conn)
{
    request_rec *r;
    apr_status_t rv;

    r = init_request(conn);

    rv = read_partial_request(r);
    /* TODO poll if EAGAIN */
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return NULL;
    }

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers! Have to dink things just to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "client sent invalid HTTP/0.9 request: HEAD %s",
                      r->uri);
        r->header_only = 0;
        r->status = HTTP_BAD_REQUEST;
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return r;
    }

    return request_post_read(r, conn);
}

static int ap_http_create_req(request_rec *r)
{
    if (!r->main)
    {
        ap_add_input_filter("HTTP_IN", NULL, r, r->connection);
    }
    return OK;
}

    ap_hook_create_request(ap_http_create_req, NULL, NULL, APR_HOOK_MIDDLE);
    int status;
    apr_size_t remaining;
    enum {
        BODY_NONE   /* must have value of zero */,
        BODY_LENGTH,
        BODY_CHUNK
    } state;
/* Hi, I'm the main input filter for HTTP requests. 
 * I handle chunked and content-length bodies. */
        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));
        ctx->status = f->r->status;
    /* Basically, we have to stay out of the way until server/protocol.c
     * says it is okay - which it does by setting r->status to OK. */
    if (f->r->status != ctx->status)
    {
        int old_status;
        /* Allow us to be reentrant! */
        old_status = ctx->status;
        ctx->status = f->r->status;

        if (old_status == HTTP_REQUEST_TIME_OUT && f->r->status == HTTP_OK)
        {
            const char *tenc, *lenp;
            tenc = apr_table_get(f->r->headers_in, "Transfer-Encoding");
            lenp = apr_table_get(f->r->headers_in, "Content-Length");

            if (tenc) {
                if (!strcasecmp(tenc, "chunked")) {
                    char line[30];
            
                    if ((rv = ap_getline(line, sizeof(line), f->r, 0)) < 0) {
                        return rv;
                    }
                    ctx->state = BODY_CHUNK;
                    ctx->remaining = get_chunk_size(line);
                }
            else if (lenp) {
                const char *pos = lenp;

                while (apr_isdigit(*pos) || apr_isspace(*pos))
                    ++pos;
                if (*pos == '\0') {
                    ctx->state = BODY_LENGTH;
                    ctx->remaining = atol(lenp);
    if (!ctx->remaining)
    {
        switch (ctx->state)
        {
        case BODY_NONE:
            break;
        case BODY_LENGTH:
            e = apr_bucket_eos_create();
            APR_BRIGADE_INSERT_TAIL(b, e);
            return APR_SUCCESS;
        case BODY_CHUNK:
            {
                char line[30];
        
                ctx->state = BODY_NONE;

                /* We need to read the CRLF after the chunk.  */
                if ((rv = ap_getline(line, sizeof(line), f->r, 0)) < 0) {
                    return rv;
                }
                /* Read the real chunk line. */
                if ((rv = ap_getline(line, sizeof(line), f->r, 0)) < 0) {
                    return rv;
                }
                ctx->state = BODY_CHUNK;
                ctx->remaining = get_chunk_size(line);

                if (!ctx->remaining)
                {
                    e = apr_bucket_eos_create();
                    APR_BRIGADE_INSERT_TAIL(b, e);
                    return APR_SUCCESS;
                }
            break;
    rv = ap_get_brigade(f->next, b, mode, readbytes);

    if (rv != APR_SUCCESS)
        return rv;

    if (ctx->state != BODY_NONE)
        ctx->remaining -= *readbytes;
typedef struct core_filter_ctx {
    apr_bucket_brigade *b;
} core_ctx_t;

    apr_status_t rv;
    core_ctx_t *ctx = f->ctx;
    char *buff, *pos;
    apr_size_t len;
    if (!ctx)
    {
        f->ctx = ctx = apr_pcalloc(f->c->pool, sizeof(*ctx));
        ctx->b = apr_brigade_create(f->c->pool);

        /* seed the brigade with the client socket. */
        APR_BRIGADE_INSERT_TAIL(ctx->b, e);
    }

    if (mode == AP_MODE_PEEK) {
        apr_bucket *e;
        const char *str, *c;
        apr_size_t length;

        /* The purpose of this loop is to ignore any CRLF (or LF) at the end
         * of a request.  Many browsers send extra lines at the end of POST
         * requests.  We use the PEEK method to determine if there is more
         * data on the socket, so that we know if we should delay sending the
         * end of one request until we have served the second request in a
         * pipelined situation.  We don't want to actually delay sending a
         * response if the server finds a CRLF (or LF), becuause that doesn't
         * mean that there is another request, just a blank line.
         */
        while (1) {

            if (APR_BRIGADE_EMPTY(ctx->b))
                return APR_EOF;

            e = APR_BRIGADE_FIRST(ctx->b);

            rv = apr_bucket_read(e, &str, &length, APR_NONBLOCK_READ);

            if (rv != APR_SUCCESS)
                return rv;

            c = str;
            while (c < str + length) {
                if (*c == APR_ASCII_LF)
                    c++;
                else if (*c == APR_ASCII_CR && *(c + 1) == APR_ASCII_LF)
                    c += 2;
                else 
                    return APR_SUCCESS;
            }
            /* If we reach here, we were a bucket just full of CRLFs, so
             * just toss the bucket. */
            /* FIXME: Is this the right thing to do in the core? */
            apr_bucket_delete(e);
        }
    }

    /* If readbytes is -1, we want to just read everything until the end
     * of the brigade, which in this case means the end of the socket.  To
     * do this, we loop through the entire brigade, until the socket is
     * exhausted, at which point, it will automagically remove itself from
     * the brigade.
     */
    if (*readbytes == -1) {
        apr_bucket *e;
        apr_off_t total;
        const char *str;
        apr_size_t len;
        APR_BRIGADE_FOREACH(e, ctx->b) {
            /* We don't care about these values.  We just want to force the
             * lower level to just read it. */
            apr_bucket_read(e, &str, &len, APR_BLOCK_READ);
        }
        APR_BRIGADE_CONCAT(b, ctx->b);

        /* Force a recompute of the length */
        apr_brigade_length(b, 1, &total);
        *readbytes = total;
        /* We have read until the brigade was empty, so we know that we 
         * must be EOS. */
        e = apr_bucket_eos_create();
    /* readbytes == 0 is "read a single line". otherwise, read a block. */
    if (*readbytes) {
        apr_off_t total;
        apr_bucket *e;
        apr_bucket_brigade *newbb;

        newbb = NULL;

        apr_brigade_partition(ctx->b, *readbytes, &e);
        /* Must do split before CONCAT */
        if (e != APR_BRIGADE_SENTINEL(ctx->b)) {
            newbb = apr_brigade_split(ctx->b, e);
        }
        APR_BRIGADE_CONCAT(b, ctx->b);

        /* FIXME: Is this really needed?  Due to pointer use in sentinels,
         * I think so. */
        if (newbb)
            APR_BRIGADE_CONCAT(ctx->b, newbb);

        apr_brigade_length(b, 1, &total);
        *readbytes = total;

        return APR_SUCCESS;
    }

    /* we are reading a single LF line, e.g. the HTTP headers */
    while (!APR_BRIGADE_EMPTY(ctx->b)) {
        e = APR_BRIGADE_FIRST(ctx->b);
        if ((rv = apr_bucket_read(e, (const char **)&buff, &len, 
                                  mode)) != APR_SUCCESS) {
            return rv;
        }

        pos = memchr(buff, APR_ASCII_LF, len);
        /* We found a match. */
        if (pos != NULL) {
            apr_bucket_split(e, pos - buff + 1);
            APR_BUCKET_REMOVE(e);
            APR_BRIGADE_INSERT_TAIL(b, e);
            return APR_SUCCESS;
        }
        APR_BUCKET_REMOVE(e);
        APR_BRIGADE_INSERT_TAIL(b, e);
        *readbytes += len;

    return APR_SUCCESS;
            if ((retval = ap_get_brigade(r->input_filters, b,
    /* Must be set before we run create request hook */
    r->output_filters  = conn->output_filters;
    r->input_filters   = conn->input_filters;
    if (strcmp(r->unparsed_uri, "*") == 0) {
        /* Don't apply rewrite rules to "*". */
        return DECLINED;
    }

    /* Check that the URI is valid. */
    if (!r->uri || r->uri[0] != '/') {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "Invalid URI in request %s", r->the_request);
        return HTTP_BAD_REQUEST;
    }
    
    if (strcmp(r->unparsed_uri, "*") == 0) {
        /* "*" cannot be proxied. */
        return DECLINED;
    }

    /* Check that the URI is valid. */
    if (!r->uri || r->uri[0] != '/') {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "Invalid URI in request %s", r->the_request);
        return HTTP_BAD_REQUEST;
    }

     * - white space between the tokens
                char *last;
                value += strspn(value, " \t");  /* Move past leading WS */
                last = value + strlen(value);
                while (last >= value && apr_isspace(*last)) {
                   *last = '\0';
                   --last;
                }

        return 0;
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            else if (r->method == NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                              "request failed: invalid characters in URI");
            }
        ap_rvputs(r, ap_get_server_name(r), " (via ", r->connection->local_ip,
                        if (one_process && shutdown_pending) {
                            return;
                        }
            if (APR_STATUS_IS_EINTR(status) && one_process && shutdown_pending) {
                return;
            }
	apr_signal(SIGHUP, sig_term);
	apr_signal(SIGINT, sig_term);
	apr_signal(SIGTERM, sig_term);
        return 0;
        make_child(ap_server_conf, 0);
    else {
    } /* one_process */
					  int propid, dav_prop_insert what,
    if (what == DAV_PROP_INSERT_VALUE) {
    else if (what == DAV_PROP_INSERT_NAME) {
    }
    else {
        /* assert: what == DAV_PROP_INSERT_SUPPORTED */
        s = apr_psprintf(p, "<supported-live-property name=\"%s\""
                            " namespace=\"%s\" xmlns=\"DAV:\"/>" DEBUG_CR,
                         info->name, dav_fs_namespace_uris[info->ns]);
    /* we inserted what was asked for */
    return what;
                                 dav_prop_insert what, ap_text_header *phdr)
			      what, phdr);
			      what, phdr);
			      what, phdr);
			      what, phdr);
			      what, phdr);
                                 dav_prop_insert what, ap_text_header *phdr);
/* generate DAV:supported-method-set OPTIONS response */
static dav_error *dav_gen_supported_methods(request_rec *r,
                                            const ap_xml_elem *elem,
                                            const apr_table_t *methods,
                                            ap_text_header *body)
{
    apr_array_header_t *arr;
    apr_table_entry_t *elts;
    ap_xml_elem *child;
    ap_xml_attr *attr;
    char *s;
    int i;

    ap_text_append(r->pool, body, "<D:supported-method-set>" DEBUG_CR);

    if (elem->first_child == NULL) {
        /* show all supported methods */
        arr = apr_table_elts(methods);
        elts = (apr_table_entry_t *) arr->elts;

        for (i = 0; i < arr->nelts; ++i) {
            if (elts[i].key == NULL)
                continue;
            s = apr_psprintf(r->pool,
                            "<D:supported-method D:name=\"%s\"/>" DEBUG_CR,
                            elts[i].key);
            ap_text_append(r->pool, body, s);
        }
    }
    else {
        /* check for support of specific methods */
        for (child = elem->first_child; child != NULL; child = child->next) {
            if (child->ns == AP_XML_NS_DAV_ID
                && strcmp(child->name, "supported-method") == 0) {
                const char *name = NULL;

                /* go through attributes to find method name */
                for (attr = child->attr; attr != NULL; attr = attr->next) {
                    if (attr->ns == AP_XML_NS_DAV_ID
                        && strcmp(attr->name, "name") == 0)
                            name = attr->value;
                }

                if (name == NULL) {
                    return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
                                         "A DAV:supported-method element "
                                         "does not have a \"name\" attribute");
                }

                /* see if method is supported */
                if (apr_table_get(methods, name) != NULL) {
                    s = apr_psprintf(r->pool,
                                    "<D:supported-method D:name=\"%s\"/>" DEBUG_CR,
                                    name);
                    ap_text_append(r->pool, body, s);
                }
            }
        }
    }

    ap_text_append(r->pool, body, "</D:supported-method-set>" DEBUG_CR);
    return NULL;
}

/* generate DAV:supported-live-property-set OPTIONS response */
static dav_error *dav_gen_supported_live_props(request_rec *r,
                                               const dav_resource *resource,
                                               const ap_xml_elem *elem,
                                               ap_text_header *body)
{
    dav_lockdb *lockdb;
    dav_propdb *propdb;
    ap_xml_elem *child;
    ap_xml_attr *attr;
    dav_error *err;

    /* open lock database, to report on supported lock properties */
    /* ### should open read-only */
    if ((err = dav_open_lockdb(r, 0, &lockdb)) != NULL) {
	return dav_push_error(r->pool, err->status, 0,
			      "The lock database could not be opened, "
			      "preventing report of supported lock properties.",
			      err);
    }

    /* open the property database (readonly) for the resource */
    if ((err = dav_open_propdb(r, lockdb,
			       (dav_resource *)resource, 1,
                               NULL, &propdb)) != NULL) {
        if (lockdb != NULL)
            (*lockdb->hooks->close_lockdb)(lockdb);

	return dav_push_error(r->pool, err->status, 0,
			      "The property database could not be opened, "
			      "preventing report of supported properties.",
			      err);
    }

    ap_text_append(r->pool, body, "<D:supported-live-property-set>" DEBUG_CR);

    if (elem->first_child == NULL) {
        /* show all supported live properties */
        dav_get_props_result props = dav_get_allprops(propdb, DAV_PROP_INSERT_SUPPORTED);
        body->last->next = props.propstats;
        while (body->last->next != NULL)
            body->last = body->last->next;
    }
    else {
        /* check for support of specific live property */
        for (child = elem->first_child; child != NULL; child = child->next) {
            if (child->ns == AP_XML_NS_DAV_ID
                && strcmp(child->name, "supported-live-property") == 0) {
                const char *name = NULL;
                const char *nmspace = NULL;

                /* go through attributes to find name and namespace */
                for (attr = child->attr; attr != NULL; attr = attr->next) {
                    if (attr->ns == AP_XML_NS_DAV_ID) {
                        if (strcmp(attr->name, "name") == 0)
                            name = attr->value;
                        else if (strcmp(attr->name, "namespace") == 0)
                            nmspace = attr->value;
                    }
                }

                if (name == NULL) {
                    err = dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
                                        "A DAV:supported-live-property element "
                                        "does not have a \"name\" attribute");
                    break;
                }

                /* default namespace to DAV: */
                if (nmspace == NULL)
                    nmspace = "DAV:";

                /* check for support of property */
                dav_get_liveprop_supported(propdb, nmspace, name, body);
            }
        }
    }

    ap_text_append(r->pool, body, "</D:supported-live-property-set>" DEBUG_CR);

    dav_close_propdb(propdb);

    if (lockdb != NULL)
        (*lockdb->hooks->close_lockdb)(lockdb);

    return err;
}

/* generate DAV:supported-report-set OPTIONS response */
static dav_error *dav_gen_supported_reports(request_rec *r,
                                            const dav_resource *resource,
                                            const ap_xml_elem *elem,
                                            const dav_hooks_vsn *vsn_hooks,
                                            ap_text_header *body)
{
    ap_xml_elem *child;
    ap_xml_attr *attr;
    dav_error *err;
    char *s;

    ap_text_append(r->pool, body, "<D:supported-report-set>" DEBUG_CR);

    if (vsn_hooks != NULL) {
        const dav_report_elem *reports;
        const dav_report_elem *rp;

        if ((err = (*vsn_hooks->avail_reports)(resource, &reports)) != NULL) {
	    return dav_push_error(r->pool, err->status, 0,
			         "DAV:supported-report-set could not be determined "
                                 "due to a problem fetching the available reports "
                                 "for this resource.",
			         err);
        }

        if (reports != NULL) {
            if (elem->first_child == NULL) {
                /* show all supported reports */
                for (rp = reports; rp->nmspace != NULL; ++rp) {
                    /* Note: we presume reports->namespace is properly XML/URL quoted */
                    s = apr_psprintf(r->pool,
                                    "<D:supported-report D:name=\"%s\" D:namespace=\"%s\"/>" DEBUG_CR,
                                    rp->name, rp->nmspace);
                    ap_text_append(r->pool, body, s);
                }
            }
            else {
                /* check for support of specific report */
                for (child = elem->first_child; child != NULL; child = child->next) {
                    if (child->ns == AP_XML_NS_DAV_ID
                        && strcmp(child->name, "supported-report") == 0) {
                        const char *name = NULL;
                        const char *nmspace = NULL;

                        /* go through attributes to find name and namespace */
                        for (attr = child->attr; attr != NULL; attr = attr->next) {
                            if (attr->ns == AP_XML_NS_DAV_ID) {
                                if (strcmp(attr->name, "name") == 0)
                                    name = attr->value;
                                else if (strcmp(attr->name, "namespace") == 0)
                                    nmspace = attr->value;
                            }
                        }

                        if (name == NULL) {
                            return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
                                                 "A DAV:supported-report element "
                                                 "does not have a \"name\" attribute");
                        }

                        /* default namespace to DAV: */
                        if (nmspace == NULL)
                            nmspace = "DAV:";

                        for (rp = reports; rp->nmspace != NULL; ++rp) {
                            if (strcmp(name, rp->name) == 0
                                && strcmp(nmspace, rp->nmspace) == 0) {
                                /* Note: we presume reports->nmspace is properly XML/URL quoted */
                                s = apr_psprintf(r->pool,
                                                "<D:supported-report D:name=\"%s\" D:namespace=\"%s\"/>" DEBUG_CR,
                                                rp->name, rp->nmspace);
                                ap_text_append(r->pool, body, s);
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    ap_text_append(r->pool, body, "</D:supported-report-set>" DEBUG_CR);
    return NULL;
}

    char *allow;
    char *s;
    apr_array_header_t *arr;
    apr_table_entry_t *elts;
    apr_table_t *methods = apr_make_table(r->pool, 12);
    ap_text_header vsn_options = { 0 };
    ap_text_header body = { 0 };
    ap_text *t;
    int text_size;
    int i;
    ap_xml_doc *doc;
    const ap_xml_elem *elem;
    /* parse any request body */
    if ((result = ap_xml_parse_input(r, &doc)) != OK) {
	return result;
    }
    /* note: doc == NULL if no request body */

    if (doc && !dav_validate_root(doc, "options")) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, 0, r,
		      "The \"options\" element was not found.");
	return HTTP_BAD_REQUEST;
    }

    if (binding_hooks != NULL)
	dav_level = apr_pstrcat(r->pool, dav_level, ",bindings", NULL);

    /* ###
    ** MSFT Web Folders chokes if length of DAV header value > 63 characters!
    ** To workaround that, we use separate DAV headers for versioning and
    ** live prop provider namespace URIs.
    ** ###
    */
    apr_table_setn(r->headers_out, "DAV", dav_level);

    /*
    ** If there is a versioning provider, generate DAV headers
    ** for versioning options.
    */
    if (vsn_hooks != NULL) {
        (*vsn_hooks->get_vsn_options)(r->pool, &vsn_options);

        for (t = vsn_options.first; t != NULL; t = t->next)
            apr_table_addn(r->headers_out, "DAV", t->text);
    /*
    ** Gather property set URIs from all the liveprop providers,
    ** and generate a separate DAV header for each URI, to avoid
    ** problems with long header lengths.
    */
    for (i = 0; i < uri_ary->nelts; ++i) {
        if (((char **)uri_ary->elts)[i] != NULL)
            apr_table_addn(r->headers_out, "DAV", ((char **)uri_ary->elts)[i]);
    ** Determine which methods are allowed on the resource.
    ** All cases support OPTIONS, and if there is a lock provider, LOCK.
    ** Lock-null supports PROPFIND and UNLOCK.
    apr_table_addn(methods, "OPTIONS", "");

        apr_table_addn(methods, "GET", "");
        apr_table_addn(methods, "HEAD", "");
        apr_table_addn(methods, "POST", "");
        apr_table_addn(methods, "DELETE", "");
        apr_table_addn(methods, "TRACE", "");
        apr_table_addn(methods, "PROPFIND", "");
        apr_table_addn(methods, "PROPPATCH", "");
        apr_table_addn(methods, "COPY", "");
        apr_table_addn(methods, "MOVE", "");

	if (!resource->collection)
            apr_table_addn(methods, "PUT", "");

        if (locks_hooks != NULL) {
            apr_table_addn(methods, "LOCK", "");
            apr_table_addn(methods, "UNLOCK", "");
        }

        break;
        apr_table_addn(methods, "MKCOL", "");
        apr_table_addn(methods, "PROPFIND", "");
        apr_table_addn(methods, "PUT", "");

        if (locks_hooks != NULL) {
            apr_table_addn(methods, "LOCK", "");
            apr_table_addn(methods, "UNLOCK", "");
        }

        break;
        apr_table_addn(methods, "MKCOL", "");
        apr_table_addn(methods, "PUT", "");

        if (locks_hooks != NULL)
            apr_table_addn(methods, "LOCK", "");

        break;
    /* If there is a versioning provider, add versioning methods */
            if ((*vsn_hooks->versionable)(resource))
                apr_table_addn(methods, "VERSION-CONTROL", "");
            if (vsn_hooks->can_be_workspace != NULL
                && (*vsn_hooks->can_be_workspace)(resource))
                apr_table_addn(methods, "MKWORKSPACE", "");
            if ((*vsn_hooks->versionable)(resource))
                apr_table_addn(methods, "VERSION-CONTROL", "");
        }
        else if (resource->working) {
            apr_table_addn(methods, "CHECKIN", "");
            apr_table_addn(methods, "UNCHECKOUT", "");
        }
        else if (vsn_hooks->add_label != NULL) {
            apr_table_addn(methods, "CHECKOUT", "");
            apr_table_addn(methods, "LABEL", "");
        }
        else {
            apr_table_addn(methods, "CHECKOUT", "");
    if (binding_hooks != NULL
        && (*binding_hooks->is_bindable)(resource)) {
        apr_table_addn(methods, "BIND", "");
    /* Generate the Allow header */
    arr = apr_table_elts(methods);
    elts = (apr_table_entry_t *) arr->elts;
    text_size = 0;

    /* first, compute total length */
    for (i = 0; i < arr->nelts; ++i) {
        if (elts[i].key == NULL)
            continue;

        /* add 1 for comma or null */
        text_size += strlen(elts[i].key) + 1;
    }

    s = allow = apr_palloc(r->pool, text_size);

    for (i = 0; i < arr->nelts; ++i) {
        if (elts[i].key == NULL)
            continue;
        if (s != allow)
            *s++ = ',';

        strcpy(s, elts[i].key);
        s += strlen(s);
    }

    apr_table_setn(r->headers_out, "Allow", allow);

    /* if there was no request body, then there is no response body */
    if (doc == NULL) {
        ap_set_content_length(r, 0);

        /* ### this will send a Content-Type. the default OPTIONS does not. */
        ap_send_http_header(r);

        /* ### the default (ap_send_http_options) returns OK, but I believe
         * ### that is because it is the default handler and nothing else
         * ### will run after the thing. */
        return DONE;
    }

    /* handle each options request */
    for (elem = doc->root->first_child; elem != NULL; elem = elem->next) {
        /* check for something we recognize first */
        int core_option = 0;
        dav_error *err = NULL;

        if (elem->ns == AP_XML_NS_DAV_ID) {
            if (strcmp(elem->name, "supported-method-set") == 0) {
                err = dav_gen_supported_methods(r, elem, methods, &body);
                core_option = 1;
            }
            else if (strcmp(elem->name, "supported-live-property-set") == 0) {
                err = dav_gen_supported_live_props(r, resource, elem, &body);
                core_option = 1;
            }
            else if (strcmp(elem->name, "supported-report-set") == 0) {
                err = dav_gen_supported_reports(r, resource, elem, vsn_hooks, &body);
                core_option = 1;
            }
        }

        if (err != NULL)
            return dav_handle_err(r, err, NULL);

        /* if unrecognized option, pass to versioning provider */
        if (!core_option) {
            if ((err = (*vsn_hooks->get_option)(resource, elem, &body))
                != NULL) {
                return dav_handle_err(r, err, NULL);
            }
        }
    }

    /* send the options response */
    r->status = HTTP_OK;
    r->content_type = DAV_XML_CONTENT_TYPE;

    /* send the headers */
    /* send the response body */
    ap_rputs(DAV_XML_HEADER DEBUG_CR
             "<D:options-response xmlns:D=\"DAV:\">" DEBUG_CR, r);

    for (t = body.first; t != NULL; t = t->next)
        ap_rputs(t->text, r);

    ap_rputs("</D:options-response>" DEBUG_CR, r);
        dav_prop_insert what = ctx->propfind_type == DAV_PROPFIND_IS_ALLPROP
                                 ? DAV_PROP_INSERT_VALUE
                                 : DAV_PROP_INSERT_NAME;
	propstats = dav_get_allprops(propdb, what);
                                  dav_prop_insert what, ap_text_header *phdr),
                                 (r, resource, what, phdr));
/* defines type of property info a provider is to return */
typedef enum {
    DAV_PROP_INSERT_NOTDEF,	/* property is defined by this provider,
				   but nothing was inserted because the
				   (live) property is not defined for this
				   resource (it may be present as a dead
				   property). */
    DAV_PROP_INSERT_NOTSUPP,    /* property is recognized by this provider,
                                 * but it is not supported, and cannot be
                                 * treated as a dead property */
    DAV_PROP_INSERT_NAME,	/* a property name (empty elem) was
				   inserted into the text block */
    DAV_PROP_INSERT_VALUE,	/* a property name/value pair was inserted
				   into the text block */
    DAV_PROP_INSERT_SUPPORTED   /* a supported live property was added to
                                   the text block as a
                                   <DAV:supported-live-property> element */
} dav_prop_insert;

                          dav_prop_insert what, ap_text_header *phdr))
    ** Insert property information into a text block. The property to
    ** insert is identified by the propid value. The information to insert
    ** is identified by the "what" argument, as follows:
    **   DAV_PROP_INSERT_NAME
    **      property name, as an empty XML element
    **   DAV_PROP_INSERT_VALUE
    **      property name/value, as an XML element
    **   DAV_PROP_INSERT_SUPPORTED
    **      if the property is defined on the resource, then
    **      a DAV:supported-live-property element, as defined
    **      by the DeltaV extensions to RFC2518.
    **                      
    ** Providers should return DAV_PROP_INSERT_NOTDEF if they do not define
    ** the specified propid, but allow the property to be handled as a
    ** dead property. If a provider recognizes, but does not support,
    ** a property, and does not want it handled as a dead property, it should
    ** return DAV_PROP_INSERT_NOTSUPP.
				   int propid, dav_prop_insert what,
                                   dav_prop_insert what, ap_text_header *phdr);
    dav_prop_insert what);

void dav_get_liveprop_supported(
    dav_propdb *propdb,
    const char *ns_uri,
    const char *propname,
    ap_text_header *body);
    /* Return supported versioning options.
     * Each dav_text item in the list will be returned as a separate
     * DAV header. Providers are advised to limit the length of an
     * individual text item to 63 characters, to conform to the limit
     * used by MS Web Folders.
     */
    void (*get_vsn_options)(apr_pool_t *p, ap_text_header *phdr);

    /* Get the value of a specific option for an OPTIONS request.
     * The option being requested is given by the parsed XML
     * element object "elem". The value of the option should be
     * appended to the "option" text object.
    dav_error * (*get_option)(const dav_resource *resource,
                              const ap_xml_elem *elem,
                              ap_text_header *option);
    ** body. The report response is generated into the ap_text_header
static int dav_find_liveprop_provider(dav_propdb *propdb,
                                      const char *ns_uri,
                                      const char *propname,
                                      const dav_hooks_liveprop **provider)
    *provider = NULL;

    if (ns_uri == NULL) {
	/* policy: liveprop providers cannot define no-namespace properties */
	return DAV_PROPID_CORE_UNKNOWN;
    }
    else if (strcmp(ns_uri, "DAV:") == 0) {
	    if (strcmp(propname, *p) == 0) {
		return propid;
    propid = dav_run_find_liveprop(propdb->resource, ns_uri, propname,
                                   provider);
        return propid;
    /* no provider for this property */
    return DAV_PROPID_CORE_UNKNOWN;
}

static void dav_find_liveprop(dav_propdb *propdb, ap_xml_elem *elem)
{
    const char *ns_uri;
    dav_elem_private *priv = elem->private;
    const dav_hooks_liveprop *hooks;


    if (elem->ns == AP_XML_NS_NONE)
        ns_uri = NULL;
    else if (elem->ns == AP_XML_NS_DAV_ID)
        ns_uri = "DAV:";
    else
        ns_uri = AP_XML_GET_URI_ITEM(propdb->ns_xlate, elem->ns);

    priv->propid = dav_find_liveprop_provider(propdb, ns_uri, elem->name,
                                              &hooks);
    if (priv->propid != DAV_PROPID_CORE_UNKNOWN) {
        priv->provider = hooks;
    }
				       dav_prop_insert what,
				       dav_prop_insert *inserted)
    *inserted = DAV_PROP_INSERT_NOTDEF;
        if (what == DAV_PROP_INSERT_SUPPORTED) {
	    /* use D: prefix to refer to the DAV: namespace URI,
             * and let the namespace attribute default to "DAV:"
             */
            s = apr_psprintf(propdb->p,
                            "<D:supported-live-property D:name=\"%s\"/>" DEBUG_CR,
                            name);
        }
	else if (what == DAV_PROP_INSERT_VALUE && *value != '\0') {
	*inserted = what;
				       dav_prop_insert what,
				       dav_prop_insert *inserted)
    *inserted = DAV_PROP_INSERT_NOTDEF;
				   what, phdr, inserted);
    *inserted = (*priv->provider->insert_prop)(propdb->resource, priv->propid,
					       what, phdr);
    /* always defer actual open, to avoid expense of accessing db
     * when only live properties are involved
     */
    propdb->deferred = 1;
dav_get_props_result dav_get_allprops(dav_propdb *propdb, dav_prop_insert what)
    dav_prop_insert unused_inserted;
    /* if not just getting supported live properties,
     * scan all properties in the dead prop database
     */
    if (what != DAV_PROP_INSERT_SUPPORTED) {
        if (propdb->deferred) {
            /* ### what to do with db open error? */
            (void) dav_really_open_db(propdb, 1 /*ro*/);
        }
        /* generate all the namespaces that are in the propdb */
        dav_get_propdb_xmlns(propdb, &hdr_ns);
        /* initialize the result with some start tags... */
        ap_text_append(propdb->p, &hdr,
		       "<D:propstat>" DEBUG_CR
		       "<D:prop>" DEBUG_CR);
        /* if there ARE properties, then scan them */
        if (propdb->db != NULL) {
	    dav_datum key;
	    int dav_id = dav_find_dav_id(propdb);
	    (void) (*db_hooks->firstkey)(propdb->db, &key);
	    while (key.dptr) {
	        dav_datum prevkey;
	        /* any keys with leading capital letters should be skipped
	           (real keys start with a number or a colon) */
	        if (*key.dptr >= 'A' && *key.dptr <= 'Z')
		    goto next_key;
	        /*
	        ** We also look for <DAV:getcontenttype> and
	        ** <DAV:getcontentlanguage>. If they are not stored as dead
	        ** properties, then we need to perform a subrequest to get
	        ** their values (if any).
	        */
	        if (dav_id != -1
		    && *key.dptr != ':'
		    && dav_id == atoi(key.dptr)) {

		    const char *colon;

		    /* find the colon */
		    if ( key.dptr[1] == ':' ) {
		        colon = key.dptr + 1;
		    else {
		        colon = strchr(key.dptr + 2, ':');
		    if (colon[1] == 'g') {
		        if (strcmp(colon + 1, "getcontenttype") == 0) {
			    found_contenttype = 1;
		        }
		        else if (strcmp(colon + 1, "getcontentlanguage") == 0) {
			    found_contentlang = 1;
		        }
		    }
	        }
	        if (what == DAV_PROP_INSERT_VALUE) {
		    dav_datum value;
		    (void) (*db_hooks->fetch)(propdb->db, key, &value);
		    if (value.dptr == NULL) {
		        /* ### anything better to do? */
		        /* ### probably should enter a 500 error */
		        goto next_key;
		    }
		    /* put the prop name and value into the result */
		    dav_append_prop(propdb, key.dptr, value.dptr, &hdr);

		    (*db_hooks->freedatum)(propdb->db, value);
	        }
	        else {
		    /* simple, empty element if a value isn't needed */
		    dav_append_prop(propdb, key.dptr, DAV_EMPTY_VALUE, &hdr);
	        }

	      next_key:
	        prevkey = key;
	        (void) (*db_hooks->nextkey)(propdb->db, &key);
	        (*db_hooks->freedatum)(propdb->db, prevkey);
        }
        /* add namespaces for all the liveprop providers */
        dav_add_all_liveprop_xmlns(propdb->p, &hdr_ns);
    dav_run_insert_all_liveprops(propdb->r, propdb->resource, what, &hdr);
			      what, &hdr, &unused_inserted);
			      what, &hdr, &unused_inserted);
				  what, &hdr, &unused_inserted);
				  what, &hdr, &unused_inserted);
    /* if not just reporting on supported live props,
     * terminate the result */
    if (what != DAV_PROP_INSERT_SUPPORTED) {
        ap_text_append(propdb->p, &hdr,
		       "</D:prop>" DEBUG_CR
		       "<D:status>HTTP/1.1 200 OK</D:status>" DEBUG_CR
		       "</D:propstat>" DEBUG_CR);
    }
    int propdb_xmlns_done = 0;
        dav_datum key = { 0 };
	dav_error *err;
	dav_prop_insert inserted;
        int is_liveprop = 0;
        /*
        ** First try live property providers; if they don't handle
        ** the property, then try looking it up in the propdb.
        */
	/* cache the propid; dav_get_props() could be called many times */
	if (priv->propid == 0)
	    dav_find_liveprop(propdb, elem);
        if (priv->propid != DAV_PROPID_CORE_UNKNOWN) {
            is_liveprop = 1;
	    if ((err = dav_insert_liveprop(propdb, elem, DAV_PROP_INSERT_VALUE,
                                           &hdr_good, &inserted)) != NULL) {
	    if (inserted == DAV_PROP_INSERT_VALUE) {
            else if (inserted == DAV_PROP_INSERT_NOTDEF) {
                /* allow property to be handled as a dead property */
                is_liveprop = 0;
            }
        }

	/*
	** If not handled as a live property, look in the dead property database
	*/
        if (!is_liveprop) {
            /* make sure propdb is really open */
            if (propdb->deferred) {
                /* ### what to do with db open error? */
                (void) dav_really_open_db(propdb, 1 /*ro*/);
            }

            /* if not done yet,
             * generate all the namespaces that are in the propdb
             */
            if (!propdb_xmlns_done) {
                dav_get_propdb_xmlns(propdb, &hdr_ns);
                propdb_xmlns_done = 1;
            }

	    /*
	    ** Note: the key may be NULL if we have no properties that are in
	    ** a namespace that matches the requested prop's namespace.
	    */
	    key = dav_gdbm_key(propdb, elem);

	    /* fetch IF we have a db and a key. otherwise, value is NULL */
	    if (propdb->db != NULL && key.dptr != NULL) {
	        (void) (*db_hooks->fetch)(propdb->db, key, &value);
	    }
        }
void dav_get_liveprop_supported(dav_propdb *propdb,
                                const char *ns_uri,
                                const char *propname,
                                ap_text_header *body)
{
    int propid;
    const dav_hooks_liveprop *hooks;

    propid = dav_find_liveprop_provider(propdb, ns_uri, propname, &hooks);

    if (propid != DAV_PROPID_CORE_UNKNOWN) {
        if (hooks == NULL) {
            /* this is a "core" property that we define */
            dav_prop_insert unused_inserted;
            dav_insert_coreprop(propdb, propid, propname,
                                DAV_PROP_INSERT_SUPPORTED, body, &unused_inserted);
        }
        else {
	    (*hooks->insert_prop)(propdb->resource, propid,
                                  DAV_PROP_INSERT_SUPPORTED, body);
        }
    }
}

                                            int propid, dav_prop_insert what,
    if (what == DAV_PROP_INSERT_SUPPORTED) {
        s = apr_psprintf(p, "<supported-live-property name=\"%s\""
                            " namespace=\"%s\" xmlns=\"DAV:\"/>" DEBUG_CR,
                         info->name, dav_core_namespace_uris[info->ns]);
    }
	else if (what == DAV_PROP_INSERT_VALUE && *value != '\0') {
    /* we inserted what was asked for */
    return what;
                                   dav_prop_insert what, ap_text_header *phdr)
                                what, phdr);
AP_DECLARE_HOOK(int,monitor,(apr_pool_t *p))

APR_HOOK_STRUCT(
#if AP_ENABLE_EXCEPTION_HOOK
    APR_HOOK_LINK(fatal_exception)
#endif
    APR_HOOK_LINK(monitor)
)

#if AP_ENABLE_EXCEPTION_HOOK
AP_IMPLEMENT_HOOK_RUN_ALL(int, fatal_exception,
                          (ap_exception_info_t *ei), (ei), OK, DECLINED)
#endif
AP_IMPLEMENT_HOOK_RUN_ALL(int, monitor,
                          (apr_pool_t *p), (p), OK, DECLINED)


        ap_run_monitor(p);
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }

                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
 * %...B:  bytes sent, excluding HTTP headers.
 * %...b:  bytes sent, excluding HTTP headers in CLF format, i.e. a '-'
 *         when no bytes where sent (rather than a '0'.
 * %...m:  the request method
 * %...h:  the request protocol
static const char *log_request_method(request_rec *r, char *a)
{
    return r->method;
}
static const char *log_request_protocol(request_rec *r, char *a)
{
    return r->protocol;
}
static const char *clf_log_bytes_sent(request_rec *r, char *a)
static const char *log_bytes_sent(request_rec *r, char *a)
{
    if (!r->sent_bodyct) {
        return "0";
    }
    else {
        long int bs;
        ap_bgetopt(r->connection->client, BO_BYTECT, &bs);
	return apr_psprintf(r->pool, "%ld", bs);
    }
}


        'b', clf_log_bytes_sent, 0
    },
    {
        'B', log_bytes_sent, 0
    {
        'H', log_request_protocol, 0
    },
    {
        'm', log_request_method, 0
    },
     * - white space between the tokens
                char *last;
                value += strspn(value, " \t");  /* Move past leading WS */
                last = value + strlen(value);
                while (last >= value && apr_isspace(*last)) {
                   *last = '\0';
                   --last;
                }

typedef struct
{
    const char *name;           /* matching module name */
    const char *info;           /* additional info */
typedef struct
{
static void *create_info_config(apr_pool_t * p, server_rec *s)
    info_svr_conf *conf =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t * p, void *basev, void *overridesv)
    info_svr_conf *new =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info =
        apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec *r, int nest, const char *thisfn,
                            int linenum)
    const char *prevfn =
        ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL)
        thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n",
                   thisfn);
    if (linenum > 0)
        sprintf(buf, "%d", linenum);
    else
        buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i)
        ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i)
        ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec *r, const ap_directive_t * dir,
                              int nest)
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec *r, const ap_directive_t * dir,
                               int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n",
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec *r, const ap_directive_t * dir,
    }
    else {
        ap_rprintf(r, "/%s</tt></dd>", ap_escape_html(r->pool, dirname));
    }

static int mod_info_has_cmd(const command_rec *cmds, ap_directive_t * dir)
    const command_rec *cmd;
    if (cmds == NULL)
        return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0)
            return 1;
    }
static void mod_info_show_parents(request_rec *r, ap_directive_t * node,
                                  int from, int to)
{
    if (from < to)
        mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec *r, const command_rec *cmds,
    ap_directive_t *dir;
    if (level == 0)
        ap_set_module_config(r->request_config, &info_module, NULL);
                                             shown, level + 1)) {
        }
        else if (mod_info_has_cmd(cmds, dir)) {
        }
typedef struct
{                               /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc) (void);       /* just to get the right size */
    const char *const *aszPredecessors;
    const char *const *aszSuccessors;
typedef apr_array_header_t *(
                                __stdcall
                                * hook_get_t)      (void);
typedef struct
{
static int module_find_hook(module *modp, hook_get_t hook_get)
    elts = (hook_struct_t *) hooks->elts;
    for (i = 0; i < hooks->nelts; i++) {
                               hook_lookup_t * lookup, int *comma)
    int i, comma = 0;
    for (i = 0; request_hooks[i].name; i++) {
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
        return DECLINED;
             "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n",
             r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ",
                     r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name,
                           modp->name);
            ap_rprintf(r,
                       "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                       ap_get_server_version());
            ap_rprintf(r,
                       "<dt><strong>Server Built:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                       ap_get_server_built());
            ap_rprintf(r,
                       "<dt><strong>API Version:</strong> "
                       "<tt>%d:%d</tt></dt>\n", MODULE_MAGIC_NUMBER_MAJOR,
                       MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r,
                       "<dt><strong>Hostname/port:</strong> "
                       "<tt>%s:%u</tt></dt>\n", ap_get_server_name(r),
                       ap_get_server_port(r));
            ap_rprintf(r,
                       "<dt><strong>Timeouts:</strong> "
                       "<tt>connection: %d &nbsp;&nbsp; "
                       "keep-alive: %d</tt></dt>",
                       (int) (apr_time_sec(serv->timeout)),
                       (int) (apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n",
                       ap_show_mpm());
            ap_rprintf(r,
                       "<dt><strong>MPM Information:</strong> "
                       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r,
                       "<dt><strong>Server Root:</strong> "
                       "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r,
                       "<dt><strong>Config File:</strong> "
                       "<tt>%s</tt></dt>\n", ap_conftree->filename);
            for (modp = ap_top_module; modp; modp = modp->next) {
                if (!r->args || !strcasecmp(modp->name, r->args)) {
                    ap_rprintf(r,
                               "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                               "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                               modp->name, modp->name);
                    ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                    hand = modp->handlers;
                    if (hand) {
                        while (hand) {
                            if (hand->content_type) {
                                ap_rprintf(r, " <tt>%s</tt>\n",
                                           hand->content_type);
                            }
                            else {
                                break;
                            }
                            hand++;
                            if (hand && hand->content_type) {
                                ap_rputs(",", r);
                            }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    if (module_find_hook(modp, ap_hook_get_handler)) {
                        ap_rputs("<tt> <em>yes</em></tt>", r);
                    }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    ap_rputs("</dt>", r);
                    ap_rputs
                        ("<dt><strong>Configuration Phase Participation:</strong>\n",
                         r);
                    if (modp->create_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Directory Config</tt>", r);
                        comma = 1;
                    if (modp->merge_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Directory Configs</tt>", r);
                        comma = 1;
                    if (modp->create_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Server Config</tt>", r);
                        comma = 1;
                    if (modp->merge_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Server Configs</tt>", r);
                        comma = 1;
                    if (!comma)
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    comma = 0;
                    ap_rputs("</dt>", r);

                    module_request_hook_participate(r, modp);

                    cmd = modp->cmds;
                    if (cmd) {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong></dt>",
                             r);
                        while (cmd) {
                            if (cmd->name) {
                                ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                           ap_escape_html(r->pool, cmd->name),
                                           cmd->name[0] == '<' ? "&gt;" : "");
                                if (cmd->errmsg) {
                                    ap_rputs(cmd->errmsg, r);
                                }
                                ap_rputs("</i></tt></dd>\n", r);
                            else {
                                break;
                            }
                            cmd++;
                        ap_rputs
                            ("<dt><strong>Current Configuration:</strong></dt>\n",
                             r);
                        mod_info_module_cmds(r, modp->cmds, ap_conftree, 0,
                                             0);
                    }
                    else {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>",
                             r);
                    }
                    more_info = find_more_info(serv, modp->name);
                    if (more_info) {
                        ap_rputs
                            ("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                             r);
                        ap_rputs(more_info, r);
                        ap_rputs("</dd>", r);
                    }
                    ap_rputs("</dl><hr />\n", r);
                    if (r->args) {
                        break;
            if (!modp && r->args && strcasecmp(r->args, "server")) {
                ap_rputs("<p><b>No such module</b></p>\n", r);
            }
    ap_rputs(ap_psignature("", r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy,
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
static const command_rec info_cmds[] = {
static void register_hooks(apr_pool_t * p)
module AP_MODULE_DECLARE_DATA info_module = {
typedef struct
{
    const char *name;           /* matching module name */
    const char *info;           /* additional info */
typedef struct
{
static void *create_info_config(apr_pool_t * p, server_rec *s)
    info_svr_conf *conf =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t * p, void *basev, void *overridesv)
    info_svr_conf *new =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info =
        apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec *r, int nest, const char *thisfn,
                            int linenum)
    const char *prevfn =
        ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL)
        thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n",
                   thisfn);
    if (linenum > 0)
        sprintf(buf, "%d", linenum);
    else
        buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i)
        ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i)
        ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec *r, const ap_directive_t * dir,
                              int nest)
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec *r, const ap_directive_t * dir,
                               int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n",
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec *r, const ap_directive_t * dir,
    }
    else {
        ap_rprintf(r, "/%s</tt></dd>", ap_escape_html(r->pool, dirname));
    }

static int mod_info_has_cmd(const command_rec *cmds, ap_directive_t * dir)
    const command_rec *cmd;
    if (cmds == NULL)
        return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0)
            return 1;
    }
static void mod_info_show_parents(request_rec *r, ap_directive_t * node,
                                  int from, int to)
{
    if (from < to)
        mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec *r, const command_rec *cmds,
    ap_directive_t *dir;
    if (level == 0)
        ap_set_module_config(r->request_config, &info_module, NULL);
                                             shown, level + 1)) {
        }
        else if (mod_info_has_cmd(cmds, dir)) {
        }
typedef struct
{                               /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc) (void);       /* just to get the right size */
    const char *const *aszPredecessors;
    const char *const *aszSuccessors;
typedef apr_array_header_t *(
                                __stdcall
                                * hook_get_t)      (void);
typedef struct
{
static int module_find_hook(module *modp, hook_get_t hook_get)
    elts = (hook_struct_t *) hooks->elts;
    for (i = 0; i < hooks->nelts; i++) {
                               hook_lookup_t * lookup, int *comma)
    int i, comma = 0;
    for (i = 0; request_hooks[i].name; i++) {
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
        return DECLINED;
             "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n",
             r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ",
                     r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name,
                           modp->name);
            ap_rprintf(r,
                       "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                       ap_get_server_version());
            ap_rprintf(r,
                       "<dt><strong>Server Built:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                       ap_get_server_built());
            ap_rprintf(r,
                       "<dt><strong>API Version:</strong> "
                       "<tt>%d:%d</tt></dt>\n", MODULE_MAGIC_NUMBER_MAJOR,
                       MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r,
                       "<dt><strong>Hostname/port:</strong> "
                       "<tt>%s:%u</tt></dt>\n", ap_get_server_name(r),
                       ap_get_server_port(r));
            ap_rprintf(r,
                       "<dt><strong>Timeouts:</strong> "
                       "<tt>connection: %d &nbsp;&nbsp; "
                       "keep-alive: %d</tt></dt>",
                       (int) (apr_time_sec(serv->timeout)),
                       (int) (apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n",
                       ap_show_mpm());
            ap_rprintf(r,
                       "<dt><strong>MPM Information:</strong> "
                       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r,
                       "<dt><strong>Server Root:</strong> "
                       "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r,
                       "<dt><strong>Config File:</strong> "
                       "<tt>%s</tt></dt>\n", ap_conftree->filename);
            for (modp = ap_top_module; modp; modp = modp->next) {
                if (!r->args || !strcasecmp(modp->name, r->args)) {
                    ap_rprintf(r,
                               "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                               "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                               modp->name, modp->name);
                    ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                    hand = modp->handlers;
                    if (hand) {
                        while (hand) {
                            if (hand->content_type) {
                                ap_rprintf(r, " <tt>%s</tt>\n",
                                           hand->content_type);
                            }
                            else {
                                break;
                            }
                            hand++;
                            if (hand && hand->content_type) {
                                ap_rputs(",", r);
                            }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    if (module_find_hook(modp, ap_hook_get_handler)) {
                        ap_rputs("<tt> <em>yes</em></tt>", r);
                    }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    ap_rputs("</dt>", r);
                    ap_rputs
                        ("<dt><strong>Configuration Phase Participation:</strong>\n",
                         r);
                    if (modp->create_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Directory Config</tt>", r);
                        comma = 1;
                    if (modp->merge_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Directory Configs</tt>", r);
                        comma = 1;
                    if (modp->create_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Server Config</tt>", r);
                        comma = 1;
                    if (modp->merge_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Server Configs</tt>", r);
                        comma = 1;
                    if (!comma)
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    comma = 0;
                    ap_rputs("</dt>", r);

                    module_request_hook_participate(r, modp);

                    cmd = modp->cmds;
                    if (cmd) {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong></dt>",
                             r);
                        while (cmd) {
                            if (cmd->name) {
                                ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                           ap_escape_html(r->pool, cmd->name),
                                           cmd->name[0] == '<' ? "&gt;" : "");
                                if (cmd->errmsg) {
                                    ap_rputs(cmd->errmsg, r);
                                }
                                ap_rputs("</i></tt></dd>\n", r);
                            else {
                                break;
                            }
                            cmd++;
                        ap_rputs
                            ("<dt><strong>Current Configuration:</strong></dt>\n",
                             r);
                        mod_info_module_cmds(r, modp->cmds, ap_conftree, 0,
                                             0);
                    }
                    else {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>",
                             r);
                    }
                    more_info = find_more_info(serv, modp->name);
                    if (more_info) {
                        ap_rputs
                            ("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                             r);
                        ap_rputs(more_info, r);
                        ap_rputs("</dd>", r);
                    }
                    ap_rputs("</dl><hr />\n", r);
                    if (r->args) {
                        break;
            if (!modp && r->args && strcasecmp(r->args, "server")) {
                ap_rputs("<p><b>No such module</b></p>\n", r);
            }
    ap_rputs(ap_psignature("", r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy,
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
static const command_rec info_cmds[] = {
static void register_hooks(apr_pool_t * p)
module AP_MODULE_DECLARE_DATA info_module = {
static char* process_tags(header_entry *hdr, request_rec *r, request_rec *rr)
            str = apr_pstrdup(rr->pool, s);
            str = apr_pstrcat(rr->pool, str, s, NULL);
    request_rec *rr;

    rr = r;
    while (rr->main != NULL) {
        rr = rr->main;
    }
            apr_table_addn(headers, hdr->header, process_tags(hdr, r, rr));
            apr_table_mergen(headers, hdr->header, process_tags(hdr, r, rr));
                apr_table_addn(headers, hdr->header, process_tags(hdr, r, rr));
                char *new_val = process_tags(hdr, r, rr);
                 ap_set_content_type(r, process_tags(hdr, r, rr));
            apr_table_setn(headers, hdr->header, process_tags(hdr, r, rr));
                ed.p = rr->pool;

                if ((fold_len - 1) > r->server->limit_req_fieldsize) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field " 
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

    cache_server_conf *conf =
      (cache_server_conf *)ap_get_module_config(r->server->module_config,
                                                &cache_module);
                     "Incoming request is asking for a uncached version of "
    if (!conf->ignorecachecontrol
        && cc_req && ap_cache_liststr(r->pool, cc_req, "max-age", &val)) {
    if (!conf->ignorecachecontrol
        && cc_req && ap_cache_liststr(r->pool, cc_req, "min-fresh", &val)) {
static int read_request_line(request_rec *r, apr_bucket_brigade *bb)

#if 0
    conn_rec *conn = r->connection;
#endif
    int num_blank_lines = 0;
    int max_blank_lines = r->server->limit_req_fields;

    if (max_blank_lines <= 0) {
        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
    }

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    do {
        apr_status_t rv;

        /* insure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */
        r->the_request = NULL;
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                         &len, r, 0, bb);

        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }
            return 0;
        }
    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));

    /* we've probably got something to do, ignore graceful restart requests */
    ll = r->the_request;
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method",
                                r->method);
#endif

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

             && (minor < HTTP_VERSION(1, 0)) ) /* don't allow HTTP/0.1000 */
    else
    return 1;
    char *last_field = NULL;
    apr_size_t last_len = 0;
    apr_size_t alloc_len = 0;
    char *value;
    int fields_read = 0;
    char *tmp_field;
        int folded = 0;

        if (last_field != NULL) {
            if ((len > 0) && ((*field == '\t') || *field == ' ')) {
                /* This line is a continuation of the preceding line(s),
                 * so append it to the line that we've set aside.
                 * Note: this uses a power-of-two allocator to avoid
                 * doing O(n) allocs and using O(n^2) space for
                 * continuations that span many many lines.
                 */
                apr_size_t fold_len = last_len + len + 1; /* trailing null */

                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field "
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                if (fold_len > alloc_len) {
                    char *fold_buf;
                    alloc_len += alloc_len;
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
                    }
                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);
                    memcpy(fold_buf, last_field, last_len);
                    last_field = fold_buf;
                }
                memcpy(last_field + last_len, field, len +1); /* +1 for nul */
                last_len += len;
                folded = 1;
            }
            else /* not a continuation line */ {

                if (r->server->limit_req_fields
                    && (++fields_read > r->server->limit_req_fields)) {
                    r->status = HTTP_BAD_REQUEST;
                    apr_table_setn(r->notes, "error-notes",
                                   "The number of request header fields "
                                   "exceeds this server's limit.");
                    return;
                }

                if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                    r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Request header field is "
                                               "missing ':' separator.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool,
                                                              last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                tmp_field = value - 1; /* last character of field-name */

                *value++ = '\0'; /* NUL-terminate at colon */

                while (*value == ' ' || *value == '\t') {
                    ++value;            /* Skip to start of value   */
                }

                /* Strip LWS after field-name: */
                while (tmp_field > last_field
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                /* Strip LWS after field-value: */
                tmp_field = last_field + last_len - 1;
                while (tmp_field > value
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                apr_table_addn(r->headers_in, last_field, value);

                /* reset the alloc_len so that we'll allocate a new
                 * buffer if we have to do any more folding: we can't
                 * use the previous buffer because its contents are
                 * now part of r->headers_in
                 */
                alloc_len = 0;

            } /* end if current line is not a continuation starting with tab */

        /* Found a blank line, stop. */
        if (len == 0) {
            break;
        }

        /* Keep track of this line so that we can parse it on
         * the next loop iteration.  (In the folded case, last_field
         * has been updated already.)
         */
        if (!folded) {
            last_field = field;
            last_len = len;

    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
request_rec *ap_read_request(conn_rec *conn)
    const char *expect;
    int access_status;
    apr_bucket_brigade *tmp_bb;
    apr_socket_t *csd;
    apr_interval_time_t cur_timeout;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    /* Get the request... */
    if (!read_request_line(r, tmp_bb)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        apr_brigade_destroy(tmp_bb);
        return NULL;
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_get(csd, &cur_timeout);
    if (cur_timeout != conn->base_server->timeout) {
        apr_socket_timeout_set(csd, conn->base_server->timeout);
        cur_timeout = conn->base_server->timeout;
    }

    if (!r->assbackwards) {
        ap_get_mime_headers_core(r, tmp_bb);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        if (apr_table_get(r->headers_in, "Transfer-Encoding")
            && apr_table_get(r->headers_in, "Content-Length")) {
            /* 2616 section 4.4, point 3: "if both Transfer-Encoding
             * and Content-Length are received, the latter MUST be
             * ignored"; so unset it here to prevent any confusion
             * later. */
            apr_table_unset(r->headers_in, "Content-Length");
        }
    }
    else {
        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }
    }

    apr_brigade_destroy(tmp_bb);
    if (cur_timeout != r->server->timeout) {
        apr_socket_timeout_set(csd, r->server->timeout);
        cur_timeout = r->server->timeout;
static const char ssl_io_buffer[] = "SSL/TLS Buffer";
/* 128K maximum buffer size by default. */
#ifndef SSL_MAX_IO_BUFFER
#define SSL_MAX_IO_BUFFER (128 * 1024)
#endif

struct modssl_buffer_ctx {
    apr_bucket_brigade *bb;
    apr_pool_t *pool;
};

int ssl_io_buffer_fill(request_rec *r)
{
    conn_rec *c = r->connection;
    struct modssl_buffer_ctx *ctx;
    apr_bucket_brigade *tempb;
    apr_off_t total = 0; /* total length buffered */
    int eos = 0; /* non-zero once EOS is seen */
    
    /* Create the context which will be passed to the input filter;
     * containing a setaside pool and a brigade which constrain the
     * lifetime of the buffered data. */
    ctx = apr_palloc(r->pool, sizeof *ctx);
    apr_pool_create(&ctx->pool, r->pool);
    ctx->bb = apr_brigade_create(ctx->pool, c->bucket_alloc);

    /* ... and a temporary brigade. */
    tempb = apr_brigade_create(r->pool, c->bucket_alloc);

    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, "filling buffer");

    do {
        apr_status_t rv;
        apr_bucket *e, *next;

        /* The request body is read from the protocol-level input
         * filters; the buffering filter will reinject it from that
         * level, allowing content/resource filters to run later, if
         * necessary. */

        rv = ap_get_brigade(r->proto_input_filters, tempb, AP_MODE_READBYTES,
                            APR_BLOCK_READ, 8192);
        if (rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                          "could not read request body for SSL buffer");
            return HTTP_INTERNAL_SERVER_ERROR;
        }
        
        /* Iterate through the returned brigade: setaside each bucket
         * into the context's pool and move it into the brigade. */
        for (e = APR_BRIGADE_FIRST(tempb); 
             e != APR_BRIGADE_SENTINEL(tempb) && !eos; e = next) {
            const char *data;
            apr_size_t len;

            next = APR_BUCKET_NEXT(e);

            if (APR_BUCKET_IS_EOS(e)) {
                eos = 1;
            } else if (!APR_BUCKET_IS_METADATA(e)) {
                rv = apr_bucket_read(e, &data, &len, APR_BLOCK_READ);
                if (rv != APR_SUCCESS) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                                  "could not read bucket for SSL buffer");
                    return HTTP_INTERNAL_SERVER_ERROR;
                }
                total += len;
            }
                
            rv = apr_bucket_setaside(e, ctx->pool);
            if (rv != APR_SUCCESS) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                              "could not setaside bucket for SSL buffer");
                return HTTP_INTERNAL_SERVER_ERROR;
            }
            
            APR_BUCKET_REMOVE(e);
            APR_BRIGADE_INSERT_TAIL(ctx->bb, e);
        }

        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, 
                      "total of %" APR_OFF_T_FMT " bytes in buffer, eos=%d",
                      total, eos);

        /* Fail if this exceeds the maximum buffer size. */
        if (total > SSL_MAX_IO_BUFFER) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request body exceeds maximum size for SSL buffer");
            return HTTP_REQUEST_ENTITY_TOO_LARGE;
        }

    } while (!eos);

    apr_brigade_destroy(tempb);

    /* Insert the filter which will supply the buffered data. */
    ap_add_input_filter(ssl_io_buffer, ctx, r, c);

    return 0;
}

/* This input filter supplies the buffered request body to the caller
 * from the brigade stored in f->ctx. */
static apr_status_t ssl_io_filter_buffer(ap_filter_t *f,
                                         apr_bucket_brigade *bb,
                                         ap_input_mode_t mode,
                                         apr_read_type_e block,
                                         apr_off_t bytes)
{
    struct modssl_buffer_ctx *ctx = f->ctx;
    apr_status_t rv;

    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, f->c,
                  "read from buffered SSL brigade, mode %d, "
                  "%" APR_OFF_T_FMT " bytes",
                  mode, bytes);

    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {
        return APR_ENOTIMPL;
    }

    if (mode == AP_MODE_READBYTES) {
        apr_bucket *e;

        /* Partition the buffered brigade. */
        rv = apr_brigade_partition(ctx->bb, bytes, &e);
        if (rv && rv != APR_INCOMPLETE) {
            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, f->c,
                          "could not partition buffered SSL brigade");
            ap_remove_input_filter(f);
            return rv;
        }

        /* If the buffered brigade contains less then the requested
         * length, just pass it all back. */
        if (rv == APR_INCOMPLETE) {
            APR_BRIGADE_CONCAT(bb, ctx->bb);
        } else {
            apr_bucket *d = APR_BRIGADE_FIRST(ctx->bb);

            e = APR_BUCKET_PREV(e);
            
            /* Unsplice the partitioned segment and move it into the
             * passed-in brigade; no convenient way to do this with
             * the APR_BRIGADE_* macros. */
            APR_RING_UNSPLICE(d, e, link);
            APR_RING_SPLICE_HEAD(&bb->list, d, e, apr_bucket, link);

            APR_BRIGADE_CHECK_CONSISTENCY(bb);
            APR_BRIGADE_CHECK_CONSISTENCY(ctx->bb);
        }
    }
    else {
        /* Split a line into the passed-in brigade. */
        rv = apr_brigade_split_line(bb, ctx->bb, mode, bytes);

        if (rv) {
            ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, f->c,
                          "could not split line from buffered SSL brigade");
            ap_remove_input_filter(f);
            return rv;
        }
    }

    if (APR_BRIGADE_EMPTY(ctx->bb)) {
        apr_bucket *e = APR_BRIGADE_LAST(bb);
        
        /* Ensure that the brigade is terminated by an EOS if the
         * buffered request body has been entirely consumed. */
        if (e == APR_BRIGADE_SENTINEL(bb) || !APR_BUCKET_IS_EOS(e)) {
            e = apr_bucket_eos_create(f->c->bucket_alloc);
            APR_BRIGADE_INSERT_TAIL(bb, e);
        }

        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, f->c,
                      "buffered SSL brigade now exhausted; removing filter");
        ap_remove_input_filter(f);
    }

    return APR_SUCCESS;
}

    
    ap_register_input_filter  (ssl_io_buffer, ssl_io_filter_buffer, NULL, AP_FTYPE_PROTOCOL - 1);

    /* If a renegotiation is now required for this location, and the
     * request includes a message body (and the client has not
     * requested a "100 Continue" response), then the client will be
     * streaming the request body over the wire already.  In that
     * case, it is not possible to stop and perform a new SSL
     * handshake immediately; once the SSL library moves to the
     * "accept" state, it will reject the SSL packets which the client
     * is sending for the request body.
     * 
     * To allow authentication to complete in this auth hook, the
     * solution used here is to fill a (bounded) buffer with the
     * request body, and then to reinject that request body later.
    if (renegotiate && !renegotiate_quick
        && (apr_table_get(r->headers_in, "transfer-encoding")
            || (apr_table_get(r->headers_in, "content-length")
                && strcmp(apr_table_get(r->headers_in, "content-length"), "0")))
        && !r->expecting_100) {
        int rv;

        /* Fill the I/O buffer with the request body if possible. */
        rv = ssl_io_buffer_fill(r);

        if (rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "could not buffer message body to allow "
                          "SSL renegotiation to proceed");
            return rv;
        }
/* ssl_io_buffer_fill fills the setaside buffering of the HTTP request
 * to allow an SSL renegotiation to take place. */
int          ssl_io_buffer_fill(request_rec *r);

    int connect = 0, use_port = 0;
		 "proxy: FTP: connecting %s to %s:%d", url, connectname, connectport);
                      "proxy: FTP: error creating socket");
		     "proxy: FTP: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
		 "proxy: FTP: socket has been created");
			     "proxy: FTP: attempt to connect to %pI (%s) failed", connect_addr, connectname);
		     "proxy: FTP: an error occurred creating a new connection to %pI (%s)", connect_addr, connectname);
		 "proxy: FTP: control connection complete");
    apr_table_set(r->notes, "Directory-README", buffer);
     * Try EPSV, if that fails...
     * try PASV, if that fails...
     * try PORT.
/* this temporarily switches off EPSV/PASV */
    /* set up data connection - EPSV */
    {
	apr_sockaddr_t *remote_addr;
	char *remote_ip;
	apr_port_t remote_port;

	/* The EPSV command replaces PASV where both IPV4 and IPV6 is supported. Only
	 * the port is returned, the IP address is always the same as that on the
	 * control connection. Example:
	 *   Entering Extended Passive Mode (|||6446|)
	 */
	buf = apr_pstrcat(p, "EPSV", CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                     "proxy: FTP: EPSV");
	/* possible results: 227, 421, 500, 501, 502, 530 */
	/*   227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   502 Command not implemented. */
	/*   530 Not logged in. */
	i = ftp_getrc_msg(origin, cbb, buffer, sizeof(buffer));
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: FTP: %d %s", i, buffer);
	if (i == -1) {
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				 "Error reading from remote server");
	}
	if (i != 229 && i != 500 && i != 501 && i != 502) {
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
	}
	else if (i == 229) {
	    char *pstr;

	    pstr = apr_pstrdup(p, buffer);
	    pstr = strtok(pstr, " ");	/* separate result code */
	    if (pstr != NULL) {
		if (*(pstr + strlen(pstr) + 1) == '=') {
		    pstr += strlen(pstr) + 2;
		}
		else {
		    pstr = strtok(NULL, "(");  /* separate address & port params */
		    if (pstr != NULL)
			pstr = strtok(NULL, ")");
		}
	    }
	    if (pstr) {
		apr_sockaddr_t *epsv_addr;
		remote_port = atoi(pstr+3);

        	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                             "proxy: FTP: EPSV contacting remote host on port %d",
                             remote_port);
		if ((rv = apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
			          "proxy: FTP: error creating EPSV socket");
		    return HTTP_INTERNAL_SERVER_ERROR;
		}

#if !defined (TPF) && !defined(BEOS)
		if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
		    conf->recv_buffer_size))) {
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
				  "proxy: FTP: setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
		}
#endif

		/* make the connection */
		apr_socket_addr_get(&remote_addr, APR_REMOTE, sock);
		apr_sockaddr_ip_get(&remote_ip, remote_addr);
		apr_sockaddr_info_get(&epsv_addr, remote_ip, APR_INET, remote_port, 0, p);
		rv = apr_connect(remote_sock, epsv_addr);
		if (rv != APR_SUCCESS) {
		    ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
				 "proxy: FTP: EPSV attempt to connect to %pI failed - Firewall/NAT?", epsv_addr);
		    return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_psprintf(r->pool,
				         "EPSV attempt to connect to %pI failed - firewall/NAT?", epsv_addr));
		}
		else {
		    connect = 1;
		}
		/* and try the regular way */
		apr_socket_close(remote_sock);
    }

    /* set up data connection - PASV */
    if (!connect) {
	buf = apr_pstrcat(p, "PASV", CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                     "proxy: FTP: PASV");
	/* possible results: 227, 421, 500, 501, 502, 530 */
	/*   227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   502 Command not implemented. */
	/*   530 Not logged in. */
	i = ftp_getrc_msg(origin, cbb, buffer, sizeof(buffer));
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: FTP: %d %s", i, buffer);
	if (i == -1) {
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				 "Error reading from remote server");
	}
	if (i != 227 && i != 502) {
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
	}
	else if (i == 227) {
	    unsigned int h0, h1, h2, h3, p0, p1;
	    char *pstr;

/* FIXME: Check PASV against RFC1123 */

	    pstr = apr_pstrdup(p, buffer);
	    pstr = strtok(pstr, " ");	/* separate result code */
	    if (pstr != NULL) {
		if (*(pstr + strlen(pstr) + 1) == '=') {
		    pstr += strlen(pstr) + 2;
		}
		else {
		    pstr = strtok(NULL, "(");  /* separate address & port params */
		    if (pstr != NULL)
			pstr = strtok(NULL, ")");
		}
	    }
	    if (pstr != NULL && (sscanf(pstr,
		"%d,%d,%d,%d,%d,%d", &h3, &h2, &h1, &h0, &p1, &p0) == 6)) {
		apr_sockaddr_t *pasv_addr;
		int pasvport = (p1 << 8) + p0;
        	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                             "proxy: FTP: PASV contacting host %d.%d.%d.%d:%d",
                             h3, h2, h1, h0, pasvport);
		if ((rv = apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
			          "proxy: error creating PASV socket");
		    return HTTP_INTERNAL_SERVER_ERROR;
		}
		if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
		    conf->recv_buffer_size))) {
				  "proxy: FTP: setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
		}
		/* make the connection */
		apr_sockaddr_info_get(&pasv_addr, apr_psprintf(p, "%d.%d.%d.%d", h3, h2, h1, h0), APR_INET, pasvport, 0, p);
		rv = apr_connect(remote_sock, pasv_addr);
		if (rv != APR_SUCCESS) {
		    ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
				 "proxy: FTP: PASV attempt to connect to %pI failed - Firewall/NAT?", pasv_addr);
		    return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_psprintf(r->pool,
				         "PASV attempt to connect to %pI failed - firewall/NAT?", pasv_addr));
		}
		else {
		    connect = 1;
		}
	    }
		/* and try the regular way */
		apr_socket_close(remote_sock);
    /* set up data connection - PORT */
    if (!connect) {

	    /* signal that we must use the EPRT/PORT loop */
	    use_port = 1;
	    return ap_proxyerror(r, HTTP_NOT_IMPLEMENTED, "Connect to IPV6 ftp server using EPRT not supported. Enable EPSV.");
    if (use_port) {
	    /* RFC2616 tells us to forward this.
	     *
	     * OTOH, an interim response here may mean the backend
	     * is playing sillybuggers.  The Client didn't ask for
	     * it within the defined HTTP/1.1 mechanisms, and if
	     * it's an extension, it may also be unsupported by us.
	     *
	     * There's also the possibility that changing existing
	     * behaviour here might break something.
	     *
	     * So let's make it configurable.
	     */
            const char *policy = apr_table_get(r->subprocess_env,
			                       "proxy-interim-response");
	    if (!policy || !strcasecmp(policy, "RFC")) {
                ap_send_interim_response(r);
	    }
	    /* FIXME: refine this to be able to specify per-response-status
	     * policies and maybe also add option to bail out with 502
	     */
	    else if (strcasecmp(policy, "Suppress")) {
                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,
                             "undefined proxy interim response policy");
	    }
        if (ap_open(&s->error_log, fname, APR_APPEND | 
    char errstr[MAX_STRING_LEN + 1];    /* + 1 to have room for '\n' */
	len = ap_snprintf(errstr, MAX_STRING_LEN, "[%s] ", ap_get_time());
    len += ap_snprintf(errstr + len, MAX_STRING_LEN - len,
	len += ap_snprintf(errstr + len, MAX_STRING_LEN - len,
	len += ap_snprintf(errstr + len, MAX_STRING_LEN - len,
	len += ap_snprintf(errstr + len, MAX_STRING_LEN - len,
	len += ap_snprintf(errstr + len, MAX_STRING_LEN - len,
	    MAX_STRING_LEN - len,
	    len += ap_snprintf(errstr + len, MAX_STRING_LEN - len,
    len += ap_vsnprintf(errstr + len, MAX_STRING_LEN - len, fmt, args);
        /* We know that we have one more character of space available because
         * the array is sized that way */
        /* ap_assert(len < MAX_STRING_LEN) */
        errstr[len++] = '\n';
        errstr[len] = '\0';
    if(ap_open(&pid_file, fname, APR_WRITE | APR_CREATE, APR_OS_DEFAULT, p) != APR_SUCCESS) {
            ap_rvputs(r, "value=\"", wsel->s->route, NULL);
            ap_rvputs(r, "value=\"", wsel->s->redirect, NULL);
    if (strcmp(r->unparsed_uri, "*") == 0) {
        /* Don't apply rewrite rules to "*". */
        return DECLINED;
    }

    /* Check that the URI is valid. */
    if (!r->uri || r->uri[0] != '/') {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "Invalid URI in request %s", r->the_request);
        return HTTP_BAD_REQUEST;
    }
    
    if (strcmp(r->unparsed_uri, "*") == 0) {
        /* "*" cannot be proxied. */
        return DECLINED;
    }

    /* Check that the URI is valid. */
    if (!r->uri || r->uri[0] != '/') {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "Invalid URI in request %s", r->the_request);
        return HTTP_BAD_REQUEST;
    }

static void recalc_factors(proxy_balancer *balancer,
                           proxy_runtime_worker *fixed)
{
    int i;
    double median, ffactor = 0.0;
    proxy_runtime_worker *workers;    


    /* Recalculate lbfactors */
    workers = (proxy_runtime_worker *)balancer->workers->elts;
    /* Special case if there is only one worker it's
     * load factor will always be 100
     */
    if (balancer->workers->nelts == 1) {
        workers->s->lbstatus = workers->s->lbfactor = 100.0;
        return;
    }
    for (i = 0; i < balancer->workers->nelts; i++) {
        if (workers[i].s->lbfactor > 100.0)
            workers[i].s->lbfactor = 100.0;
        ffactor += workers[i].s->lbfactor;
    }
    if (ffactor < 100.0) {
        median = (100.0 - ffactor) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (&(workers[i]) != fixed)
                workers[i].s->lbfactor += median;
        }
    }
    else if (fixed->s->lbfactor < 100.0) {
        median = (ffactor - 100.0) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (workers[i].s->lbfactor > median &&
                &(workers[i]) != fixed)
                workers[i].s->lbfactor -= median;
        }
    } 
    else {
        median = (ffactor - 100.0) / balancer->workers->nelts;
        for (i = 0; i < balancer->workers->nelts; i++) {
            workers[i].s->lbfactor -= median;
        }
    } 
    for (i = 0; i < balancer->workers->nelts; i++) {
        /* Update the status entires */
        workers[i].s->lbstatus = workers[i].s->lbfactor;
    }
}

/* Invoke handler */
static int balancer_handler(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *conf = (proxy_server_conf *)
        ap_get_module_config(sconf, &proxy_module);
    apr_array_header_t *proxies = conf->proxies;
    struct proxy_remote *ents = (struct proxy_remote *)proxies->elts;
    proxy_balancer *balancer, *bsel = NULL;
    proxy_runtime_worker *worker, *wsel = NULL;
    apr_table_t *params = apr_table_make(r->pool, 10);
    int access_status;
    int i, n;
    const char *name;

    /* is this for us? */
    if (strcmp(r->handler, "balancer-manager"))
        return DECLINED;
    r->allowed = (AP_METHOD_BIT << M_GET);
    if (r->method_number != M_GET)
        return DECLINED;

    if (r->args) {
        char *args = apr_pstrdup(r->pool, r->args);
        char *tok, *val;
        while (args && *args) {
            if ((val = ap_strchr_c(args, '='))) {
                *val++ = '\0';
                if ((tok = ap_strchr_c(val, '&')))
                    *tok++ = '\0';
                if ((access_status = ap_unescape_url(val)) != OK)
                    return access_status;
                apr_table_setn(params, args, val);
                args = tok;
            }
            else
                return HTTP_BAD_REQUEST;
        }
    }
    if ((name = apr_table_get(params, "b")))
        bsel = ap_proxy_get_balancer(r->pool, conf,
            apr_pstrcat(r->pool, "balancer://", name, NULL));
    if ((name = apr_table_get(params, "w"))) {
        const char *sc = apr_table_get(params, "s");
        char *asname = NULL;
        proxy_worker *ws = NULL;
        if (sc) {
            asname = apr_pstrcat(r->pool, sc, "://", name, NULL);
            ws = ap_proxy_get_worker(r->pool, conf, asname);
        }
        if (ws) {
            worker = (proxy_runtime_worker *)bsel->workers->elts;
            for (n = 0; n < bsel->workers->nelts; n++) {
                if (strcasecmp(worker->w->name, ws->name) == 0) {
                    wsel = worker;
                    break;
                }
                ++worker;
            }
        }
    }
    /* First set the params */
    if (bsel) {
        const char *val;
        if ((val = apr_table_get(params, "ss"))) {
            if (strlen(val))
                bsel->sticky = apr_pstrdup(conf->pool, val);
            else
                bsel->sticky = NULL;
        }
        if ((val = apr_table_get(params, "tm"))) {
            int ival = atoi(val);
            if (ival >= 0)
                bsel->timeout = apr_time_from_sec(ival);
        }
    }
    if (wsel) {
        const char *val;
        if ((val = apr_table_get(params, "lf"))) {
            char *ep;
            double dval = strtod(val, &ep);
            if (dval > 1) {
                wsel->s->lbfactor = dval;
                if (bsel)
                    recalc_factors(bsel, wsel);
            }
        }
        if ((val = apr_table_get(params, "wr"))) {
            if (strlen(val))
                wsel->w->route = apr_pstrdup(conf->pool, val);
            else
                wsel->w->route = NULL;
        }
        if ((val = apr_table_get(params, "rr"))) {
            if (strlen(val))
                wsel->w->redirect = apr_pstrdup(conf->pool, val);
            else
                wsel->w->redirect = NULL;
        }
        if ((val = apr_table_get(params, "dw")))
            wsel->w->status |= PROXY_WORKER_DISABLED;
        else
            wsel->w->status &= ~PROXY_WORKER_DISABLED;

    }
    if (apr_table_get(params, "xml")) {
        ap_set_content_type(r, "text/xml");
        ap_rputs("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n", r);
        ap_rputs("<httpd:manager xmlns:httpd=\"http://httpd.apache.org\">\n", r);
        ap_rputs("  <httpd:balancers>\n", r);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("    <httpd:balancer>\n", r);
            ap_rvputs(r, "      <httpd:name>", balancer->name, "</httpd:name>\n", NULL);
            ap_rputs("      <httpd:workers>\n", r);
            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {
                ap_rputs("        <httpd:worker>\n", r);
                ap_rvputs(r, "          <httpd:scheme>", worker->w->scheme,
                          "</httpd:scheme>\n", NULL);                
                ap_rvputs(r, "          <httpd:hostname>", worker->w->hostname,
                          "</httpd:hostname>\n", NULL);                
               ap_rprintf(r, "          <httpd:loadfactor>%.2f</httpd:loadfactor>\n",
                          worker->s->lbfactor);
                ap_rputs("        </httpd:worker>\n", r);
                ++worker;
            }
            ap_rputs("      </httpd:workers>\n", r);
            ap_rputs("    </httpd:balancer>\n", r);
            ++balancer;
        }
        ap_rputs("  </httpd:balancers>\n", r);
        ap_rputs("</httpd:manager>", r);         
    }
    else {
        ap_set_content_type(r, "text/html");
        ap_rputs(DOCTYPE_HTML_3_2
                 "<html><head><title>Balancer Manager</title></head>\n", r);
        ap_rputs("<body><h1>Load Balancer Manager for ", r);
        ap_rvputs(r, ap_get_server_name(r), "</h1>\n\n", NULL);
        ap_rvputs(r, "<dl><dt>Server Version: ",
                  ap_get_server_version(), "</dt>\n", NULL);
        ap_rvputs(r, "<dt>Server Built: ",
                  ap_get_server_built(), "\n</dt></dl>\n", NULL);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("<hr />\n<h3>LoadBalancer Status for ", r);
            ap_rvputs(r, "<a href=\"", r->uri, "?b=",
                      balancer->name + sizeof("balancer://") - 1,
                      "\">", NULL); 
            ap_rvputs(r, balancer->name, "</a></h3>\n\n", NULL);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>StickySesion</th><th>Timeout</th>"
                "</tr>\n<tr>", r);                
            ap_rvputs(r, "<td>", balancer->sticky, NULL);
            ap_rprintf(r, "</td><td>%" APR_TIME_T_FMT "</td>\n",
                apr_time_sec(balancer->timeout));
            ap_rputs("</table>\n", r);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>Scheme</th><th>Host</th>"
                "<th>Route</th><th>RouteRedir</th>"
                "<th>Factor</th><th>Status</th>"
                "</tr>\n", r);

            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {

                ap_rvputs(r, "<tr>\n<td>", worker->w->scheme, "</td><td>", NULL);
                ap_rvputs(r, "<a href=\"", r->uri, "?b=", 
                          balancer->name + sizeof("balancer://") - 1,
                          "&s=", worker->w->scheme, "&w=", worker->w->hostname,
                          "\">", NULL); 
                ap_rvputs(r, worker->w->hostname, "</a></td>", NULL);
                ap_rvputs(r, "<td>", worker->w->route, NULL);
                ap_rvputs(r, "</td><td>", worker->w->redirect, NULL);
                ap_rprintf(r, "</td><td>%.2f</td><td>", worker->s->lbfactor);
                if (worker->w->status & PROXY_WORKER_DISABLED)
                    ap_rputs("Dis", r);
                else if (worker->w->status & PROXY_WORKER_IN_ERROR)
                    ap_rputs("Err", r);
                else if (worker->w->status & PROXY_WORKER_INITIALIZED)
                    ap_rputs("Ok", r);
                else
                    ap_rputs("-", r);
                ap_rputs("</td></tr>\n", r);

                ++worker;
            }
            ap_rputs("</table>\n", r);
            ++balancer;
        }
        ap_rputs("<hr />\n", r);
        if (wsel && bsel) {
            ap_rputs("<h3>Edit worker settings for ", r);
            ap_rvputs(r, wsel->w->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>Load factor:</td><td><input name=\"lf\" type=text ", r);
            ap_rprintf(r, "value=\"%.2f\"></td><tr>\n", wsel->s->lbfactor);            
            ap_rputs("<tr><td>Route:</td><td><input name=\"wr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->route, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Route Redirect:</td><td><input name=\"rr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->redirect, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Disabled:</td><td><input name=\"dw\" type=checkbox", r);
            if (wsel->w->status & PROXY_WORKER_DISABLED)
                ap_rputs(" checked", r);
            ap_rputs("></td><tr>\n", r);            
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"s\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->scheme, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"w\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->hostname, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        else if (bsel) {
            ap_rputs("<h3>Edit balancer settings for ", r);
            ap_rvputs(r, bsel->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>StickySession Identifier:</td><td><input name=\"ss\" type=text ", r);
            if (bsel->sticky)
                ap_rvputs(r, "value=\"", bsel->sticky, "\"", NULL);
            ap_rputs("></td><tr>\n<tr><td>Timeout:</td><td><input name=\"tm\" type=text ", r);
            ap_rprintf(r, "value=\"%" APR_TIME_T_FMT "\"></td></tr>\n",
                       apr_time_sec(bsel->timeout));
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        ap_rputs(ap_psignature("",r), r);
        ap_rputs("</body></html>\n", r);
    }
    return OK;
}

    /* manager handler */
    ap_hook_handler(balancer_handler, NULL, NULL, APR_HOOK_FIRST);
 * %...{FOOBAR}C:  The contents of the HTTP cookie FOOBAR
static const char *log_cookie(request_rec *r, char *a)
{
    const char *cookies;
    const char *start_cookie;

    if ((cookies = apr_table_get(r->headers_in, "Cookie"))) {
        if ((start_cookie = ap_strstr_c(cookies,a))) {
            char *cookie, *end_cookie;
            start_cookie += strlen(a) + 1; /* cookie_name + '=' */
            cookie = apr_pstrdup(r->pool, start_cookie);
            /* kill everything in cookie after ';' */
            end_cookie = strchr(cookie, ';'); 
            if (end_cookie) {
                *end_cookie = '\0';
            }
            return cookie;
        }
    }
    return NULL;
}

    {
        'C', log_cookie, 0
    },
module AP_MODULE_DECLARE_DATA imagemap_module;
    icr = ap_get_module_config(r->per_dir_config, &imagemap_module);
module AP_MODULE_DECLARE_DATA imagemap_module =
 * created at config time in the parent are valid across children.  However,
 * this can't work effectively with non-forked architectures.  So while the
 * arrays in the scoreboard never change between the parent and forked
 * children, so they do not require shm storage, the contents of the shm
 * may contain no pointers.
    SB_NOT_SHARED = 1,
    SB_SHARED = 2,      /* PARENT */
    SB_SHARED_CHILD = 3
    char vhost[32];	        /* What virtual host is being accessed? */
/* Scoreboard is now in 'local' memory, since it isn't updated once created,
 * even in forked architectures.  Child created-processes (non-fork) will
 * set up these indicies into the (possibly relocated) shmem records.
 */
    global_score *global;
typedef struct ap_sb_handle_t ap_sb_handle_t;
AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sbh, request_rec *r);
void ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e t);
apr_status_t reopen_scoreboard(apr_pool_t *p, int detached);
void ap_init_scoreboard(void *shared_score);
AP_DECLARE(void) ap_create_sb_handle(ap_sb_handle_t **new_sbh, apr_pool_t *p,
AP_DECLARE(int) ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r);

AP_DECLARE(worker_score *) ap_get_scoreboard_worker(int x, int y);
AP_DECLARE(process_score *) ap_get_scoreboard_process(int x);
AP_DECLARE(global_score *) ap_get_scoreboard_global(void);
#include "apr_shm.h"
#include "apr_rmm.h"
#define APR_HAS_SHARED_MEMORY 1
static apr_shm_t      *client_shm =  NULL;
static apr_rmm_t      *client_rmm = NULL;
static unsigned long  *opaque_cntr;
    ap_log_error(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
    sts = apr_shm_create(&client_shm, shmem_size, tmpnam(NULL), ctx);
    client_list = apr_rmm_malloc(client_rmm, sizeof(*client_list) +
    opaque_cntr = apr_rmm_malloc(client_rmm, sizeof(*opaque_cntr));
    otn_counter = apr_rmm_malloc(client_rmm, sizeof(*otn_counter));
            apr_rmm_free(client_rmm, entry);
    entry = apr_rmm_malloc(client_rmm, sizeof(client_entry));
        entry = apr_rmm_malloc(client_rmm, sizeof(client_entry));
	    
			    ap_escape_html(r->pool, ws_record.vhost));
			     ap_escape_html(r->pool, ws_record.vhost),
                    n = ssl_rand_choosenum(0,ap_calc_scoreboard_size()-1024-1);

/*  A Bison parser, made from ssl_expr_parse.y
    by GNU Bison version 1.28  */

#define YYBISON 1  /* Identify Bison output.  */

#define	T_TRUE	257
#define	T_FALSE	258
#define	T_DIGIT	259
#define	T_ID	260
#define	T_STRING	261
#define	T_REGEX	262
#define	T_REGEX_I	263
#define	T_FUNC_FILE	264
#define	T_OP_EQ	265
#define	T_OP_NE	266
#define	T_OP_LT	267
#define	T_OP_LE	268
#define	T_OP_GT	269
#define	T_OP_GE	270
#define	T_OP_REG	271
#define	T_OP_NRE	272
#define	T_OP_IN	273
#define	T_OP_OR	274
#define	T_OP_AND	275
#define	T_OP_NOT	276

#line 68 "ssl_expr_parse.y"


#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		53
#define	YYFLAG		-32768
#define	YYNTBASE	29

#define YYTRANSLATE(x) ((unsigned)(x) <= 276 ? ssl_expr_yytranslate[x] : 36)

static const char ssl_expr_yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,    28,     2,     2,    23,
    24,     2,     2,    27,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,    25,     2,    26,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
    17,    18,    19,    20,    21,    22

#if YYDEBUG != 0
static const short ssl_expr_yyprhs[] = {     0,
     0,     2,     4,     6,     9,    13,    17,    19,    23,    27,
    31,    35,    39,    43,    47,    53,    57,    61,    63,    67,
    69,    71,    76,    78,    80,    82

static const short ssl_expr_yyrhs[] = {    30,
     0,     3,     0,     4,     0,    22,    30,     0,    30,    20,
    30,     0,    30,    21,    30,     0,    31,     0,    23,    30,
    24,     0,    33,    11,    33,     0,    33,    12,    33,     0,
    33,    13,    33,     0,    33,    14,    33,     0,    33,    15,
    33,     0,    33,    16,    33,     0,    33,    19,    25,    32,
    26,     0,    33,    17,    34,     0,    33,    18,    34,     0,
    33,     0,    32,    27,    33,     0,     5,     0,     7,     0,
    28,    25,     6,    26,     0,    35,     0,     8,     0,     9,
     0,    10,    23,     7,    24,     0

#endif

#if YYDEBUG != 0
static const short ssl_expr_yyrline[] = { 0,
   115,   118,   119,   120,   121,   122,   123,   124,   127,   128,
   129,   130,   131,   132,   133,   134,   135,   138,   139,   142,
   143,   144,   145,   148,   158,   170
#endif


#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)

static const char * const ssl_expr_yytname[] = {   "$","error","$undefined.","T_TRUE",
"T_FALSE","T_DIGIT","T_ID","T_STRING","T_REGEX","T_REGEX_I","T_FUNC_FILE","T_OP_EQ",
"T_OP_NE","T_OP_LT","T_OP_LE","T_OP_GT","T_OP_GE","T_OP_REG","T_OP_NRE","T_OP_IN",
"T_OP_OR","T_OP_AND","T_OP_NOT","'('","')'","'{'","'}'","','","'%'","root","expr",
"comparison","words","word","regex","funccall", NULL
};
#endif

static const short ssl_expr_yyr1[] = {     0,
    29,    30,    30,    30,    30,    30,    30,    30,    31,    31,
    31,    31,    31,    31,    31,    31,    31,    32,    32,    33,
    33,    33,    33,    34,    34,    35

static const short ssl_expr_yyr2[] = {     0,
     1,     1,     1,     2,     3,     3,     1,     3,     3,     3,
     3,     3,     3,     3,     5,     3,     3,     1,     3,     1,
     1,     4,     1,     1,     1,     4
};

static const short ssl_expr_yydefact[] = {     0,
     2,     3,    20,    21,     0,     0,     0,     0,     1,     7,
     0,    23,     0,     4,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     8,     0,
     5,     6,     9,    10,    11,    12,    13,    14,    24,    25,
    16,    17,     0,    26,    22,     0,    18,    15,     0,    19,
     0,     0,     0

static const short ssl_expr_yydefgoto[] = {    51,
     9,    10,    46,    11,    41,    12

static const short ssl_expr_yypact[] = {     3,
-32768,-32768,-32768,-32768,   -11,     3,     3,   -10,     0,-32768,
    22,-32768,    16,-32768,    -2,    23,     3,     3,     4,     4,
     4,     4,     4,     4,    34,    34,    21,    24,-32768,    25,
    26,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,     4,-32768,-32768,    18,-32768,-32768,     4,-32768,
    49,    50,-32768

static const short ssl_expr_yypgoto[] = {-32768,
    10,-32768,-32768,   -19,    27,-32768


#define	YYLAST		53


static const short ssl_expr_yytable[] = {    33,
    34,    35,    36,    37,    38,     1,     2,     3,     3,     4,
     4,    13,     5,     5,    16,    14,    15,    17,    18,    17,
    18,    29,    28,    47,     6,     7,    31,    32,    30,    50,
     8,     8,    19,    20,    21,    22,    23,    24,    25,    26,
    27,    39,    40,    48,    49,    43,    18,    44,    52,    53,
    45,     0,    42

static const short ssl_expr_yycheck[] = {    19,
    20,    21,    22,    23,    24,     3,     4,     5,     5,     7,
     7,    23,    10,    10,    25,     6,     7,    20,    21,    20,
    21,    24,     7,    43,    22,    23,    17,    18,     6,    49,
    28,    28,    11,    12,    13,    14,    15,    16,    17,    18,
    19,     8,     9,    26,    27,    25,    21,    24,     0,     0,
    26,    -1,    26
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/usr/local/share/bison.simple"
/* This file comes from bison-1.28.  */

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

#ifndef YYSTACK_USE_ALLOCA
#ifdef alloca
#define YYSTACK_USE_ALLOCA
#else /* alloca not defined */
#ifdef __GNUC__
#define YYSTACK_USE_ALLOCA
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
#define YYSTACK_USE_ALLOCA
#include <alloca.h>
#else /* not sparc */
/* We think this test detects Watcom and Microsoft C.  */
/* This used to test MSDOS, but that is a bad idea
   since that symbol is in the user namespace.  */
#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
#if 0 /* No need for malloc.h, which pollutes the namespace;
	 instead, just don't use alloca.  */
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
/* I don't know what this was needed for, but it pollutes the namespace.
   So I turned it off.   rms, 2 May 1997.  */
/* #include <malloc.h>  */
 #pragma alloca
#define YYSTACK_USE_ALLOCA
#else /* not MSDOS, or __TURBOC__, or _AIX */
#if 0
#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
		 and on HPUX 10.  Eventually we can turn this on.  */
#define YYSTACK_USE_ALLOCA
#define alloca __builtin_alloca
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc */
#endif /* not GNU C */
#endif /* alloca not defined */
#endif /* YYSTACK_USE_ALLOCA not defined */

#ifdef YYSTACK_USE_ALLOCA
#define YYSTACK_ALLOC alloca
#define YYSTACK_ALLOC malloc
#endif

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define ssl_expr_yyerrok		(ssl_expr_yyerrstatus = 0)
#define ssl_expr_yyclearin	(ssl_expr_yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	goto ssl_expr_yyacceptlab
#define YYABORT 	goto ssl_expr_yyabortlab
#define YYERROR		goto ssl_expr_yyerrlab1
/* Like YYERROR except do call ssl_expr_yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto ssl_expr_yyerrlab
#define YYRECOVERING()  (!!ssl_expr_yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (ssl_expr_yychar == YYEMPTY && ssl_expr_yylen == 1)				\
    { ssl_expr_yychar = (token), ssl_expr_yylval = (value);			\
      ssl_expr_yychar1 = YYTRANSLATE (ssl_expr_yychar);				\
      YYPOPSTACK;						\
      goto ssl_expr_yybackup;						\
    }								\
  else								\
    { ssl_expr_yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		ssl_expr_yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, &ssl_expr_yylloc, YYLEX_PARAM)
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, &ssl_expr_yylloc)
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval, YYLEX_PARAM)
#else
#define YYLEX		ssl_expr_yylex(&ssl_expr_yylval)
#endif
#endif /* not YYLSP_NEEDED */
/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	ssl_expr_yychar;			/*  the lookahead symbol		*/
YYSTYPE	ssl_expr_yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE ssl_expr_yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int ssl_expr_yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int ssl_expr_yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Define __ssl_expr_yy_memcpy.  Note that the size argument
   should be passed with type unsigned int, because that is what the non-GCC
   definitions require.  With GCC, __builtin_memcpy takes an arg
   of type size_t, but it can handle unsigned int.  */

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __ssl_expr_yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__ssl_expr_yy_memcpy (to, from, count)
     char *to;
     char *from;
     unsigned int count;
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__ssl_expr_yy_memcpy (char *to, char *from, unsigned int count)
  register char *t = to;
  register char *f = from;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
#endif
#endif

#line 217 "/usr/local/share/bison.simple"

/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into ssl_expr_yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */
#ifdef YYPARSE_PARAM
#ifdef __cplusplus
#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
#else /* not __cplusplus */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#endif /* not __cplusplus */
#else /* not YYPARSE_PARAM */
#endif /* not YYPARSE_PARAM */

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
#ifdef YYPARSE_PARAM
int ssl_expr_yyparse (void *);
#else
int ssl_expr_yyparse (void);
#endif
ssl_expr_yyparse(YYPARSE_PARAM_ARG)
     YYPARSE_PARAM_DECL
  register int ssl_expr_yystate;
  register int ssl_expr_yyn;
  register short *ssl_expr_yyssp;
  register YYSTYPE *ssl_expr_yyvsp;
  int ssl_expr_yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int ssl_expr_yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	ssl_expr_yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE ssl_expr_yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *ssl_expr_yyss = ssl_expr_yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *ssl_expr_yyvs = ssl_expr_yyvsa;	/*  to allow ssl_expr_yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE ssl_expr_yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *ssl_expr_yyls = ssl_expr_yylsa;
  YYLTYPE *ssl_expr_yylsp;

#define YYPOPSTACK   (ssl_expr_yyvsp--, ssl_expr_yyssp--, ssl_expr_yylsp--)
#else
#define YYPOPSTACK   (ssl_expr_yyvsp--, ssl_expr_yyssp--)
#endif

  int ssl_expr_yystacksize = YYINITDEPTH;
  int ssl_expr_yyfree_stacks = 0;

#ifdef YYPURE
  int ssl_expr_yychar;
  YYSTYPE ssl_expr_yylval;
  int ssl_expr_yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE ssl_expr_yylloc;
#endif
#endif

  YYSTYPE ssl_expr_yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int ssl_expr_yylen;
#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  ssl_expr_yystate = 0;
  ssl_expr_yyerrstatus = 0;
  ssl_expr_yynerrs = 0;
  ssl_expr_yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  ssl_expr_yyssp = ssl_expr_yyss - 1;
  ssl_expr_yyvsp = ssl_expr_yyvs;
#ifdef YYLSP_NEEDED
  ssl_expr_yylsp = ssl_expr_yyls;
#endif

/* Push a new state, which is found in  ssl_expr_yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
ssl_expr_yynewstate:

  *++ssl_expr_yyssp = ssl_expr_yystate;

  if (ssl_expr_yyssp >= ssl_expr_yyss + ssl_expr_yystacksize - 1)
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *ssl_expr_yyvs1 = ssl_expr_yyvs;
      short *ssl_expr_yyss1 = ssl_expr_yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *ssl_expr_yyls1 = ssl_expr_yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = ssl_expr_yyssp - ssl_expr_yyss + 1;

#ifdef ssl_expr_yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if ssl_expr_yyoverflow is a macro.  */
      ssl_expr_yyoverflow("parser stack overflow",
		 &ssl_expr_yyss1, size * sizeof (*ssl_expr_yyssp),
		 &ssl_expr_yyvs1, size * sizeof (*ssl_expr_yyvsp),
		 &ssl_expr_yyls1, size * sizeof (*ssl_expr_yylsp),
		 &ssl_expr_yystacksize);
#else
      ssl_expr_yyoverflow("parser stack overflow",
		 &ssl_expr_yyss1, size * sizeof (*ssl_expr_yyssp),
		 &ssl_expr_yyvs1, size * sizeof (*ssl_expr_yyvsp),
		 &ssl_expr_yystacksize);
#endif

      ssl_expr_yyss = ssl_expr_yyss1; ssl_expr_yyvs = ssl_expr_yyvs1;
#ifdef YYLSP_NEEDED
      ssl_expr_yyls = ssl_expr_yyls1;
#endif
#else /* no ssl_expr_yyoverflow */
      /* Extend the stack our own way.  */
      if (ssl_expr_yystacksize >= YYMAXDEPTH)
	{
	  ssl_expr_yyerror("parser stack overflow");
	  if (ssl_expr_yyfree_stacks)
	    {
	      free (ssl_expr_yyss);
	      free (ssl_expr_yyvs);
#ifdef YYLSP_NEEDED
	      free (ssl_expr_yyls);
#endif
	    }
	  return 2;
	}
      ssl_expr_yystacksize *= 2;
      if (ssl_expr_yystacksize > YYMAXDEPTH)
	ssl_expr_yystacksize = YYMAXDEPTH;
#ifndef YYSTACK_USE_ALLOCA
      ssl_expr_yyfree_stacks = 1;
#endif
      ssl_expr_yyss = (short *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yyssp));
      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyss, (char *)ssl_expr_yyss1,
		   size * (unsigned int) sizeof (*ssl_expr_yyssp));
      ssl_expr_yyvs = (YYSTYPE *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yyvsp));
      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyvs, (char *)ssl_expr_yyvs1,
		   size * (unsigned int) sizeof (*ssl_expr_yyvsp));
#ifdef YYLSP_NEEDED
      ssl_expr_yyls = (YYLTYPE *) YYSTACK_ALLOC (ssl_expr_yystacksize * sizeof (*ssl_expr_yylsp));
      __ssl_expr_yy_memcpy ((char *)ssl_expr_yyls, (char *)ssl_expr_yyls1,
		   size * (unsigned int) sizeof (*ssl_expr_yylsp));
#endif
#endif /* no ssl_expr_yyoverflow */

      ssl_expr_yyssp = ssl_expr_yyss + size - 1;
      ssl_expr_yyvsp = ssl_expr_yyvs + size - 1;
#ifdef YYLSP_NEEDED
      ssl_expr_yylsp = ssl_expr_yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Stack size increased to %d\n", ssl_expr_yystacksize);
#endif

      if (ssl_expr_yyssp >= ssl_expr_yyss + ssl_expr_yystacksize - 1)
	YYABORT;

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Entering state %d\n", ssl_expr_yystate);
  goto ssl_expr_yybackup;
 ssl_expr_yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* ssl_expr_yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */
  ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];
  if (ssl_expr_yyn == YYFLAG)
    goto ssl_expr_yydefault;
  /* Not known => get a lookahead token if don't already have one.  */

  /* ssl_expr_yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (ssl_expr_yychar == YYEMPTY)
#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Reading a token: ");
      ssl_expr_yychar = YYLEX;

  /* Convert token to internal form (in ssl_expr_yychar1) for indexing tables with */

  if (ssl_expr_yychar <= 0)		/* This means end of input. */
      ssl_expr_yychar1 = 0;
      ssl_expr_yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
  else
      ssl_expr_yychar1 = YYTRANSLATE(ssl_expr_yychar);

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, ssl_expr_yychar, ssl_expr_yylval);
	  fprintf (stderr, ")\n");
	}

  ssl_expr_yyn += ssl_expr_yychar1;
  if (ssl_expr_yyn < 0 || ssl_expr_yyn > YYLAST || ssl_expr_yycheck[ssl_expr_yyn] != ssl_expr_yychar1)
    goto ssl_expr_yydefault;

  ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];

  /* ssl_expr_yyn is what to do for this token type in this state.
     Negative => reduce, -ssl_expr_yyn is rule number.
     Positive => shift, ssl_expr_yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (ssl_expr_yyn < 0)
      if (ssl_expr_yyn == YYFLAG)
	goto ssl_expr_yyerrlab;
      ssl_expr_yyn = -ssl_expr_yyn;
      goto ssl_expr_yyreduce;
  else if (ssl_expr_yyn == 0)
    goto ssl_expr_yyerrlab;

  if (ssl_expr_yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (ssl_expr_yychar != YYEOF)
    ssl_expr_yychar = YYEMPTY;

  *++ssl_expr_yyvsp = ssl_expr_yylval;
#ifdef YYLSP_NEEDED
  *++ssl_expr_yylsp = ssl_expr_yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (ssl_expr_yyerrstatus) ssl_expr_yyerrstatus--;

  ssl_expr_yystate = ssl_expr_yyn;
  goto ssl_expr_yynewstate;

/* Do the default action for the current state.  */
ssl_expr_yydefault:

  ssl_expr_yyn = ssl_expr_yydefact[ssl_expr_yystate];
  if (ssl_expr_yyn == 0)
    goto ssl_expr_yyerrlab;

/* Do a reduction.  ssl_expr_yyn is the number of a rule to reduce with.  */
  ssl_expr_yylen = ssl_expr_yyr2[ssl_expr_yyn];
  if (ssl_expr_yylen > 0)
    ssl_expr_yyval = ssl_expr_yyvsp[1-ssl_expr_yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       ssl_expr_yyn, ssl_expr_yyrline[ssl_expr_yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = ssl_expr_yyprhs[ssl_expr_yyn]; ssl_expr_yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", ssl_expr_yytname[ssl_expr_yyrhs[i]]);
      fprintf (stderr, " -> %s\n", ssl_expr_yytname[ssl_expr_yyr1[ssl_expr_yyn]]);
    }
#endif


  switch (ssl_expr_yyn) {

{ ssl_expr_info.expr = ssl_expr_yyvsp[0].exVal; ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_True,  NULL, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_False, NULL, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Not,   ssl_expr_yyvsp[0].exVal,   NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Or,    ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_And,   ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Comp,  ssl_expr_yyvsp[0].exVal,   NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[-1].exVal; ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_EQ,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_IN,  ssl_expr_yyvsp[-4].exVal, ssl_expr_yyvsp[-1].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_REG, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NRE, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, ssl_expr_yyvsp[-2].exVal);   ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Digit,  ssl_expr_yyvsp[0].cpVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_String, ssl_expr_yyvsp[0].cpVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Var,    ssl_expr_yyvsp[-1].cpVal, NULL); ;
    break;}
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[0].exVal; ;
    break;}
            ;
    break;}
            ;
    break;}
            ;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 543 "/usr/local/share/bison.simple"

  ssl_expr_yyvsp -= ssl_expr_yylen;
  ssl_expr_yyssp -= ssl_expr_yylen;
#ifdef YYLSP_NEEDED
  ssl_expr_yylsp -= ssl_expr_yylen;
#endif

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    {
      short *ssp1 = ssl_expr_yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != ssl_expr_yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++ssl_expr_yyvsp = ssl_expr_yyval;

#ifdef YYLSP_NEEDED
  ssl_expr_yylsp++;
  if (ssl_expr_yylen == 0)
    {
      ssl_expr_yylsp->first_line = ssl_expr_yylloc.first_line;
      ssl_expr_yylsp->first_column = ssl_expr_yylloc.first_column;
      ssl_expr_yylsp->last_line = (ssl_expr_yylsp-1)->last_line;
      ssl_expr_yylsp->last_column = (ssl_expr_yylsp-1)->last_column;
      ssl_expr_yylsp->text = 0;
    }
  else
    {
      ssl_expr_yylsp->last_line = (ssl_expr_yylsp+ssl_expr_yylen-1)->last_line;
      ssl_expr_yylsp->last_column = (ssl_expr_yylsp+ssl_expr_yylen-1)->last_column;
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  ssl_expr_yyn = ssl_expr_yyr1[ssl_expr_yyn];

  ssl_expr_yystate = ssl_expr_yypgoto[ssl_expr_yyn - YYNTBASE] + *ssl_expr_yyssp;
  if (ssl_expr_yystate >= 0 && ssl_expr_yystate <= YYLAST && ssl_expr_yycheck[ssl_expr_yystate] == *ssl_expr_yyssp)
    ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yystate];
  else
    ssl_expr_yystate = ssl_expr_yydefgoto[ssl_expr_yyn - YYNTBASE];

  goto ssl_expr_yynewstate;

ssl_expr_yyerrlab:   /* here on detecting error */

  if (! ssl_expr_yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++ssl_expr_yynerrs;

#ifdef YYERROR_VERBOSE
      ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];

      if (ssl_expr_yyn > YYFLAG && ssl_expr_yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -ssl_expr_yyn if nec to avoid negative indexes in ssl_expr_yycheck.  */
	  for (x = (ssl_expr_yyn < 0 ? -ssl_expr_yyn : 0);
	       x < (sizeof(ssl_expr_yytname) / sizeof(char *)); x++)
	    if (ssl_expr_yycheck[x + ssl_expr_yyn] == x)
	      size += strlen(ssl_expr_yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (ssl_expr_yyn < 0 ? -ssl_expr_yyn : 0);
		       x < (sizeof(ssl_expr_yytname) / sizeof(char *)); x++)
		    if (ssl_expr_yycheck[x + ssl_expr_yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, ssl_expr_yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      ssl_expr_yyerror(msg);
	      free(msg);
	    }
	  else
	    ssl_expr_yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	ssl_expr_yyerror("parse error");
    }

  goto ssl_expr_yyerrlab1;
ssl_expr_yyerrlab1:   /* here on error raised explicitly by an action */

  if (ssl_expr_yyerrstatus == 3)
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (ssl_expr_yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (ssl_expr_yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", ssl_expr_yychar, ssl_expr_yytname[ssl_expr_yychar1]);
#endif

      ssl_expr_yychar = YYEMPTY;

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  ssl_expr_yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto ssl_expr_yyerrhandle;

ssl_expr_yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  ssl_expr_yyn = ssl_expr_yydefact[ssl_expr_yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (ssl_expr_yyn) goto ssl_expr_yydefault;
#endif

ssl_expr_yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (ssl_expr_yyssp == ssl_expr_yyss) YYABORT;
  ssl_expr_yyvsp--;
  ssl_expr_yystate = *--ssl_expr_yyssp;
#ifdef YYLSP_NEEDED
  ssl_expr_yylsp--;
#endif

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
      short *ssp1 = ssl_expr_yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != ssl_expr_yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
#endif

ssl_expr_yyerrhandle:

  ssl_expr_yyn = ssl_expr_yypact[ssl_expr_yystate];
  if (ssl_expr_yyn == YYFLAG)
    goto ssl_expr_yyerrdefault;

  ssl_expr_yyn += YYTERROR;
  if (ssl_expr_yyn < 0 || ssl_expr_yyn > YYLAST || ssl_expr_yycheck[ssl_expr_yyn] != YYTERROR)
    goto ssl_expr_yyerrdefault;

  ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];
  if (ssl_expr_yyn < 0)
    {
      if (ssl_expr_yyn == YYFLAG)
	goto ssl_expr_yyerrpop;
      ssl_expr_yyn = -ssl_expr_yyn;
      goto ssl_expr_yyreduce;
    }
  else if (ssl_expr_yyn == 0)
    goto ssl_expr_yyerrpop;

  if (ssl_expr_yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (ssl_expr_yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++ssl_expr_yyvsp = ssl_expr_yylval;
#ifdef YYLSP_NEEDED
  *++ssl_expr_yylsp = ssl_expr_yylloc;
#endif

  ssl_expr_yystate = ssl_expr_yyn;
  goto ssl_expr_yynewstate;

 ssl_expr_yyacceptlab:
  /* YYACCEPT comes here.  */
  if (ssl_expr_yyfree_stacks)
    {
      free (ssl_expr_yyss);
      free (ssl_expr_yyvs);
#ifdef YYLSP_NEEDED
      free (ssl_expr_yyls);
#endif
    }
  return 0;

 ssl_expr_yyabortlab:
  /* YYABORT comes here.  */
  if (ssl_expr_yyfree_stacks)
    {
      free (ssl_expr_yyss);
      free (ssl_expr_yyvs);
#ifdef YYLSP_NEEDED
      free (ssl_expr_yyls);
#endif
    }
  return 1;
}
#line 176 "ssl_expr_parse.y"


int ssl_expr_yyerror(char *s)
{
    ssl_expr_error = s;
    return 2;

#define	T_TRUE	257
#define	T_FALSE	258
#define	T_DIGIT	259
#define	T_ID	260
#define	T_STRING	261
#define	T_REGEX	262
#define	T_REGEX_I	263
#define	T_FUNC_FILE	264
#define	T_OP_EQ	265
#define	T_OP_NE	266
#define	T_OP_LT	267
#define	T_OP_LE	268
#define	T_OP_GT	269
#define	T_OP_GE	270
#define	T_OP_REG	271
#define	T_OP_NRE	272
#define	T_OP_IN	273
#define	T_OP_OR	274
#define	T_OP_AND	275
#define	T_OP_NOT	276


 * $Header: /home/striker/cvs2svn/dumps/httpd-2.0/../../httpd-2.0/modules/ssl/ssl_expr_scan.c,v 1.7 2002/01/10 00:28:00 wrowe Exp $
#include <unistd.h>
    ap_sb_handle_t *sbh;
    ap_sb_handle_t *sbh;
        ap_scoreboard_image->global->running_generation = ap_my_generation;
        void *sb_mem;
        rc = DosAllocSharedMem((PPVOID)&sbmem, ap_scoreboard_fname,
        ap_init_scoreboard(sb_mem);
    } while (!shutdown_pending && ap_my_generation == ap_scoreboard_image->global->running_generation);
    ap_sb_handle_t *sbh;
    ap_sb_handle_t *sbh;
        ap_scoreboard_image->global->running_generation = ap_my_generation;
    ap_sb_handle_t *sbh;
    ap_sb_handle_t *sbh;
    reopen_scoreboard(pchild, 0);
    ap_scoreboard_image->global->running_generation = ap_my_generation;
	ap_scoreboard_image->global->running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
	ap_scoreboard_image->global->running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
    ap_sb_handle_t *sbh;
    thread_control[THREAD_GLOBAL(thread_num)].generation = ap_scoreboard_image->global->running_generation;
    ++ap_scoreboard_image->global->running_generation;
#define AP_MPM_WANT_SET_SCOREBOARD
    ap_sb_handle_t *sbh;
            /* Set up the scoreboard. */
            ap_run_pre_mpm(pconf, SB_NOT_SHARED);
            /* Set up the scoreboard. */
            ap_run_pre_mpm(pconf, SB_SHARED_CHILD);
        ap_scoreboard_image->parent[0].pid = parent_pid;
        ap_scoreboard_image->parent[0].quiescing = 0;
            
        /* Set up the scoreboard. */
        ap_run_pre_mpm(pconf, SB_SHARED);

    ap_sb_handle_t *sbh;
    reopen_scoreboard(pchild, 0);
    ap_scoreboard_image->global->running_generation = ap_my_generation;
const char * ap_mpm_set_scoreboard(cmd_parms *cmd, void *dummy,
                                   const char *arg)
const char *ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
                                const char *arg)
#include "apr_shm.h"
static apr_shm_t *scoreboard_shm = NULL;
struct ap_sb_handle_t {
};
    free(ap_scoreboard_image);
    scoreboard_size = sizeof(global_score);
void ap_init_scoreboard(void *shared_score)
    ap_scoreboard_image = 
        calloc(1, sizeof(scoreboard) + server_limit * sizeof(worker_score *));
    more_storage = shared_score;
    ap_scoreboard_image->global = (global_score *)more_storage;
    more_storage += sizeof(global_score);
    ap_scoreboard_image->servers = 
        (worker_score **)((char*)ap_scoreboard_image + sizeof(scoreboard));
    ap_assert(more_storage == (char*)shared_score + scoreboard_size);
static apr_status_t open_scoreboard(apr_pool_t *p)
    char *fname = NULL;
    if (ap_scoreboard_fname) {
        fname = ap_server_root_relative(p, ap_scoreboard_fname);
    }
    rv = apr_shm_create(&scoreboard_shm, scoreboard_size, fname, p);
/* If detach is non-zero, this is a seperate child process,
 * if zero, it is a forked child.
 */
apr_status_t reopen_scoreboard(apr_pool_t *p, int detached)
#if APR_HAS_SHARED_MEMORY
    apr_status_t rv;
    char *fname = NULL;

    if (!detached) {
        return APR_SUCCESS;
    }
    if (ap_scoreboard_fname) {
        fname = ap_server_root_relative(p, ap_scoreboard_fname);
    }
    rv = apr_shm_attach(&scoreboard_shm, fname, p);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                     "Fatal error: could not open(create) scoreboard");
        return rv;
    }
    if (apr_shm_size_get(scoreboard_shm) < scoreboard_size) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
                     "Fatal error: shared scoreboard too small for child!");
        apr_shm_detach(scoreboard_shm);
        scoreboard_shm = NULL;
    }
    /* everything will be cleared shortly */
#endif
    return APR_SUCCESS;
    if (ap_scoreboard_image->global->sb_type == SB_SHARED) {
        free(ap_scoreboard_image->global);
/* Create or reinit an existing scoreboard. The MPM can control whether
void ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
	running_gen = ap_scoreboard_image->global->running_generation;
            void *sb_shared;
            rv = open_scoreboard(p);
            if (rv || !(sb_shared = apr_shm_baseaddr_get(scoreboard_shm))) {
            memset(sb_shared, 0, scoreboard_size);
            ap_init_scoreboard(sb_shared);
        }
        else if (sb_type == SB_SHARED_CHILD) {
            void *sb_shared;
            rv = reopen_scoreboard(p, 1);
            if (rv || !(sb_shared = apr_shm_baseaddr_get(scoreboard_shm))) {
                exit(APEXIT_INIT); /* XXX need to return an error from this function */
            }
            ap_init_scoreboard(sb_shared);
            void *sb_mem = calloc(1, scoreboard_size);
            if (sb_mem == NULL) {
            ap_init_scoreboard(sb_mem);
    /* can't just memset() */
    if (sb_type != SB_SHARED_CHILD) {
        ap_scoreboard_image->global->sb_type = sb_type;
        ap_scoreboard_image->global->running_generation = running_gen;
        ap_restart_time = apr_time_now();
        apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
    }
				           worker_score *new_score_rec)
    lseek(scoreboard_fd, sizeof(global_score) 
                       + (long) child_num * sizeof(worker_score), 0);
    lseek(scoreboard_fd, 0, 0);
AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)
AP_DECLARE(void) ap_create_sb_handle(ap_sb_handle_t **new_sbh, apr_pool_t *p,
    *new_sbh = (ap_sb_handle_t *)apr_palloc(p, sizeof(ap_sb_handle_t));
    (*new_sbh)->child_num = child_num;
    (*new_sbh)->thread_num = thread_num;
    int old_status;
        ps->generation = ap_my_generation;
	    apr_cpystrn(ws->vhost, r->server->server_hostname, sizeof(ws->vhost));
AP_DECLARE(int)ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r)
    return ap_update_child_status_from_indexes(sbh->child_num, sbh->thread_num,
AP_DECLARE(worker_score *) ap_get_scoreboard_worker(int x, int y)
AP_DECLARE(process_score *) ap_get_scoreboard_process(int x)
AP_DECLARE(global_score *) ap_get_scoreboard_global()
    return(ap_scoreboard_image->global);
    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, "text/xml");
    ap_set_content_type(r, apr_pstrdup(r->pool, info->content_type));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html;charset=utf-8");
    ap_set_content_type(r, "text/html");
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html");
                    ap_set_content_type(r, "text/plain");
    ap_set_content_type(r, "message/http");
AP_DECLARE(void) ap_set_content_type(request_rec *r, const char *ct)
        ap_set_content_type(r, "text/html; charset=iso-8859-1");
            ap_set_content_type(r, apr_pstrcat(r->pool, "multipart",
                                               use_range_x(r) ? "/x-" : "/",
                                               "byteranges; boundary=",
                                               r->boundary, NULL));
    ap_set_content_type(r, rr->content_type);
        ap_set_content_type(new, r->content_type);
        ap_set_content_type(r, DIR_MAGIC_TYPE);
                ap_set_content_type(r, (char*) type);
                ap_set_content_type(r, exinfo->forced_type);
	    ap_set_content_type(r, apr_pstrcat(r->pool, ctp->type, "/",
                                               ctp->subtype, NULL));
			ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                           "; charset=", charset,
                                                           NULL));
		    ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                       "; ", pp->attr,
                                                       "=", pp->val,
                                                       NULL));
		ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                   "; charset=", charset,
                                                   NULL));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(sub_req, CGI_MAGIC_TYPE);
        ap_set_content_type(r, t);
                ap_set_content_type(r, p->forced_mimetype);
	    ap_set_content_type(r, tmp);
	ap_set_content_type(r, tmp);
	ap_set_content_type(r, apr_pstrdup(r->pool, sub->content_type));
        ap_set_content_type(r, "text/html");
            ap_set_content_type(r, ap_default_type(r));
                    ap_set_content_type(r, apr_pstrdup(p, buf));
    apr_status_t status = APR_EINIT;
	    status = apr_accept(&csd, sd, ptrans);
   	    if (status == APR_SUCCESS || !APR_STATUS_IS_EINTR(status))
	    if (status == APR_SUCCESS)
                switch (status) {
		    ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
		    ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
			"select/accept error (%d)", status);
		    ap_log_error(APLOG_MARK, APLOG_ERR, status, ap_server_conf,
                apr_size_t fold_len = last_len + len + 1; /* trailing null */
                if (fold_len > alloc_len) {
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
    imap_conf_rec *new = (imap_conf_rec *) apr_palloc(p, sizeof(imap_conf_rec));
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted") && *comment) {
    else if (!strcasecmp(menu, "unformatted") && *comment) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    /* Note: Memory pool allocation.
     * A downstream keepalive connection is always connected to the existence
     * (or not) of an upstream keepalive connection. If this is not done then
     * load balancing against multiple backend servers breaks (one backend
     * server ends up taking 100% of the load), and the risk is run of
     * downstream keepalive connections being kept open unnecessarily. This
     * keeps webservers busy and ties up resources.
     *
     * As a result, we allocate all sockets out of the upstream connection
     * pool, and when we want to reuse a socket, we check first whether the
     * connection ID of the current upstream connection is the same as that
     * of the connection when the socket was opened.
     */
    apr_pool_t *p = r->pool;
    conn_rec *c = r->connection;
    apr_bucket *e;
    apr_bucket_brigade *bb = apr_brigade_create(p);

    /* see memory note above */
    err = apr_sockaddr_info_get(&uri_addr, uri.hostname, APR_UNSPEC, uri.port, 0, c->pool);
	/* see memory note above */
        err = apr_sockaddr_info_get(&connect_addr, proxyname, APR_UNSPEC, proxyport, 0, c->pool);
    /* see memory note above */
	if ((conf->id == c->id) &&
    if ((conf->id == c->id) && (conf->client_socket)) {
	conf->client_socket = NULL;

	/* see memory note above */
	if ((apr_socket_create(&sock, APR_INET, SOCK_STREAM, c->pool)) != APR_SUCCESS) {
    /* the socket is now open, create a new downstream connection */
/* XXX FIXME: Only sends downstream when request is fully loaded */
	     "proxy: error reading status line from remote server %s",
	/* no chunked / no length therefore read till EOF and cancel keepalive */
	    close += 1;
    /** Did we use HTTP Keep-Alive? */
    unsigned keptalive:1;
    /** How many times have we used it? */
    int keepalives;
	    || (r->server->keep_alive_max > r->connection->keepalives))
        int left = r->server->keep_alive_max - r->connection->keepalives;
        r->connection->keepalives++;
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;

#if 0
    conn_rec *conn = r->connection;
#endif
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
	    /* this is a hack to make sure that request time is set,
	     * it's not perfect, but it's better than nothing 
	     */
	    r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */

    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk

#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */

    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);

#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week 
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method); 
#endif
    uri = ap_getword_white(r->pool, &ll);

    /* Provide quick information about the request method as soon as known */

    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }

    ap_parse_uri(r, uri);

    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }

    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
 	r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))	/* don't allow HTTP/0.1000 */
	r->proto_num = HTTP_VERSION(major, minor);
    else
	r->proto_num = HTTP_VERSION(1,0);

    return 1;
}

    conn->keptalive    = conn->keepalive == 1;
    conn->keepalive    = 0;

    ap_run_create_request(r);
    r->the_request     = NULL;
    apr_setsocketopt(conn->client_socket, APR_SO_TIMEOUT, 
                     (int)(conn->keptalive
                     ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                     : r->server->timeout * APR_USEC_PER_SEC));
                     
    /* Get the request... */
    if (!read_request_line(r)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
			  "request failed: URI too long");
            ap_send_error_response(r, 0);
            ap_run_log_transaction(r);
            return r;
        }
        return NULL;
    }
    if (r->connection->keptalive) {
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(r->server->timeout * APR_USEC_PER_SEC));
    }
    conn->keptalive = 0;        /* We now have a request to play with */

/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define CORE_PRIVATE

#include "mod_session.h"
#include "apr_lib.h"
#include "apr_strings.h"
#include "http_log.h"
#include "util_cookies.h"
#include "apr_dbd.h"
#include "mod_dbd.h"
#include "mpm_common.h"

#define LOG_PREFIX "mod_session_dbd: "
#define MOD_SESSION_DBD "mod_session_dbd"

module AP_MODULE_DECLARE_DATA session_dbd_module;

/**
 * Structure to carry the per-dir session config.
 */
typedef struct {
    const char *name;
    int name_set;
    const char *name_attrs;
    const char *name2;
    int name2_set;
    const char *name2_attrs;
    int peruser;
    int peruser_set;
    int remove;
    int remove_set;
    const char *selectlabel;
    const char *insertlabel;
    const char *updatelabel;
    const char *deletelabel;
} session_dbd_dir_conf;

/* optional function - look it up once in post_config */
static ap_dbd_t *(*session_dbd_acquire_fn) (request_rec *) = NULL;
static void (*session_dbd_prepare_fn) (server_rec *, const char *, const char *) = NULL;

/**
 * Initialise the database.
 * 
 * If the mod_dbd module is missing, this method will return APR_EGENERAL.
 */
static apr_status_t dbd_init(request_rec *r, const char *query, ap_dbd_t **dbdp,
                             apr_dbd_prepared_t **statementp)
{
    ap_dbd_t *dbd;
    apr_dbd_prepared_t *statement;

    if (!session_dbd_prepare_fn || !session_dbd_acquire_fn) {
        session_dbd_prepare_fn = APR_RETRIEVE_OPTIONAL_FN(ap_dbd_prepare);
        session_dbd_acquire_fn = APR_RETRIEVE_OPTIONAL_FN(ap_dbd_acquire);
        if (!session_dbd_prepare_fn || !session_dbd_acquire_fn) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                          "You must load mod_dbd to enable AuthDBD functions");
            return APR_EGENERAL;
        }
    }

    dbd = session_dbd_acquire_fn(r);
    if (!dbd) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "failed to acquire database connection");
        return APR_EGENERAL;
    }

    statement = apr_hash_get(dbd->prepared, query, APR_HASH_KEY_STRING);
    if (!statement) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "failed to find the prepared statement called '%s'", query);
        return APR_EGENERAL;
    }
    
    *dbdp = dbd;
    *statementp = statement;

    return APR_SUCCESS;
}

/**
 * Load the session by the key specified.
 */
static apr_status_t dbd_load(request_rec * r, const char *key, const char **val)
{

    apr_status_t rv;
    ap_dbd_t *dbd = NULL;
    apr_dbd_prepared_t *statement = NULL;
    apr_dbd_results_t *res = NULL;
    apr_dbd_row_t *row = NULL;
    apr_int64_t expiry = (apr_int64_t) apr_time_now();

    session_dbd_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_dbd_module);

    if (conf->selectlabel == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "no SessionDBDselectlabel has been specified");
        return APR_EGENERAL;
    }

    rv = dbd_init(r, conf->selectlabel, &dbd, &statement);
    if (rv) {
        return rv;
    }
    rv = apr_dbd_pvbselect(dbd->driver, r->pool, dbd->handle, &res, statement,
                          0, key, &expiry, NULL);
    if (rv) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "query execution error saving session '%s' "
                      "in database using query '%s': %s", key, conf->selectlabel,
                      apr_dbd_error(dbd->driver, dbd->handle, rv));
        return APR_EGENERAL;
    }
    for (rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1);
         rv != -1;
         rv = apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1)) {
        if (rv != 0) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, LOG_PREFIX
                          "error retrieving results while saving '%s' "
                          "in database using query '%s': %s", key, conf->selectlabel,
                           apr_dbd_error(dbd->driver, dbd->handle, rv));
            return APR_EGENERAL;
        }
        if (*val == NULL) {
            *val = apr_dbd_get_entry(dbd->driver, row, 0);
        }
        /* we can't break out here or row won't get cleaned up */
    }

    return APR_SUCCESS;

}

/**
 * Load the session by firing off a dbd query.
 *
 * If the session is anonymous, the session key will be extracted from
 * the cookie specified. Failing that, the session key will be extracted
 * from the GET parameters.
 *
 * If the session is keyed by the username, the session will be extracted
 * by that.
 *
 * If no session is found, an empty session will be created.
 *
 * On success, this returns OK.
 */
AP_DECLARE(int) ap_session_dbd_load(request_rec * r, session_rec ** z)
{

    session_dbd_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_dbd_module);

    apr_status_t ret = APR_SUCCESS;
    session_rec *zz = NULL;
    const char *name = NULL;
    const char *note = NULL;
    const char *val = NULL;
    const char *key = NULL;
    request_rec *m = r->main ? r->main : r;

    /* is our session in a cookie? */
    if (conf->name2_set) {
        name = conf->name2;
    }
    else if (conf->name_set) {
        name = conf->name;
    }
    else if (conf->peruser_set && r->user) {
        name = r->user;
    }
    else {
        return DECLINED;
    }

    /* first look in the notes */
    note = apr_pstrcat(r->pool, MOD_SESSION_DBD, name, NULL);
    zz = (session_rec *)apr_table_get(m->notes, note);
    if (zz) {
        *z = zz;
        return OK;
    }

    /* load anonymous sessions */
    if (conf->name_set || conf->name2_set) {

        /* load RFC2109 compliant cookie */
        if (conf->name_set) {
            ap_cookie_read(r, conf->name, &key, conf->remove);
        }

        /* load RFC2965 compliant cookie */
        if (!key && conf->name2_set) {
            ap_cookie_read(r, conf->name2, &key, conf->remove);
        }

        if (key) {
            ret = dbd_load(r, key, &val);
            if (ret != APR_SUCCESS) {
                return ret;
            }
        }

    }

    /* load named session */
    else if (conf->peruser) {
        if (r->user) {
            ret = dbd_load(r, r->user, &val);
            if (ret != APR_SUCCESS) {
                return ret;
            }
        }
    }

    /* otherwise not for us */
    else {
        return DECLINED;
    }

    /* create a new session and return it */
    zz = (session_rec *) apr_pcalloc(r->pool, sizeof(session_rec));
    zz->pool = r->pool;
    zz->entries = apr_table_make(zz->pool, 10);
    zz->uuid = (apr_uuid_t *) apr_pcalloc(zz->pool, sizeof(apr_uuid_t));
    if (key) {
        apr_uuid_parse(zz->uuid, key);
    }
    else {
        apr_uuid_get(zz->uuid);
    }
    zz->encoded = val;
    *z = zz;

    /* put the session in the notes so we don't have to parse it again */
    apr_table_setn(m->notes, note, (char *)zz);

    return OK;

}

/**
 * Save the session by the key specified.
 */
static apr_status_t dbd_save(request_rec * r, const char *key, const char *val, apr_int64_t expiry)
{

    apr_status_t rv;
    ap_dbd_t *dbd = NULL;
    apr_dbd_prepared_t *statement;
    int rows = 0;

    session_dbd_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_dbd_module);

    if (conf->updatelabel == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "no SessionDBDupdatelabel has been specified");
        return APR_EGENERAL;
    }

    rv = dbd_init(r, conf->updatelabel, &dbd, &statement);
    if (rv) {
        return rv;
    }
    rv = apr_dbd_pvbquery(dbd->driver, r->pool, dbd->handle, &rows, statement,
                          val, &expiry, key, NULL);
    if (rv) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "query execution error updating session '%s' "
                      "using database query '%s': %s", key, conf->updatelabel,
                      apr_dbd_error(dbd->driver, dbd->handle, rv));
        return APR_EGENERAL;
    }

    /*
     * if some rows were updated it means a session existed and was updated,
     * so we are done.
     */
    if (rows != 0) {
        return APR_SUCCESS;
    }

    if (conf->insertlabel == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "no SessionDBDinsertlabel has been specified");
        return APR_EGENERAL;
    }

    rv = dbd_init(r, conf->insertlabel, &dbd, &statement);
    if (rv) {
        return rv;
    }
    rv = apr_dbd_pvbquery(dbd->driver, r->pool, dbd->handle, &rows, statement,
                          val, &expiry, key, NULL);
    if (rv) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, LOG_PREFIX
                      "query execution error inserting session '%s' "
                      "in database with '%s': %s", key, conf->insertlabel,
                      apr_dbd_error(dbd->driver, dbd->handle, rv));
        return APR_EGENERAL;
    }

    /*
     * if some rows were inserted it means a session was inserted, so we are
     * done.
     */
    if (rows != 0) {
        return APR_SUCCESS;
    }

    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                  "the session insert query did not cause any rows to be added "
                  "to the database for session '%s', session not inserted", key);

    return APR_EGENERAL;

}

/**
 * Remove the session by the key specified.
 */
static apr_status_t dbd_remove(request_rec * r, const char *key)
{

    apr_status_t rv;
    apr_dbd_prepared_t *statement;
    int rows = 0;

    session_dbd_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_dbd_module);
    ap_dbd_t *dbd = session_dbd_acquire_fn(r);
    if (dbd == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "failed to acquire database connection to remove "
                      "session with key '%s'", key);
        return APR_EGENERAL;
    }

    if (conf->deletelabel == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "no SessionDBDdeletelabel has been specified");
        return APR_EGENERAL;
    }

    statement = apr_hash_get(dbd->prepared, conf->deletelabel, APR_HASH_KEY_STRING);
    if (statement == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
                      "prepared statement could not be found for "
                      "SessionDBDdeletelabel with the label '%s'", conf->deletelabel);
        return APR_EGENERAL;
    }
    rv = apr_dbd_pvbquery(dbd->driver, r->pool, dbd->handle, &rows, statement,
                          key, NULL);
    if (rv != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, LOG_PREFIX
                      "query execution error removing session '%s' "
                      "from database", key);
        return rv;
    }

    return APR_SUCCESS;

}

/**
 * Clean out expired sessions.
 * 
 * TODO: We need to figure out a way to clean out expired sessions from the database.
 * The monitor hook doesn't help us that much, as we have no handle into the
 * server, and so we need to come up with a way to do this safely.
 */
static apr_status_t dbd_clean(apr_pool_t *p)
{

    return APR_ENOTIMPL;

}

/**
 * Save the session by firing off a dbd query.
 *
 * If the session is anonymous, save the session and write a cookie
 * containing the uuid.
 *
 * If the session is keyed to the username, save the session using
 * the username as a key.
 *
 * On success, this method will return APR_SUCCESS.
 *
 * @param r The request pointer.
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_dbd_save(request_rec * r, session_rec * z)
{

    apr_status_t ret = APR_SUCCESS;
    session_dbd_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_dbd_module);

    /* support anonymous sessions */
    if (conf->name_set || conf->name2_set) {

        /* don't cache pages with a session */
        apr_table_addn(r->headers_out, "Cache-Control", "no-cache");

        /* must we create a uuid? */
        char *buffer = apr_pcalloc(r->pool, APR_UUID_FORMATTED_LENGTH + 1);
        apr_uuid_format(buffer, z->uuid);

        /* save the session with the uuid as key */
        if (z->encoded && z->encoded[0]) {
            ret = dbd_save(r, buffer, z->encoded, z->expiry);
        }
        else {
            ret = dbd_remove(r, buffer);
        }
        if (ret != APR_SUCCESS) {
            return ret;
        }

        /* create RFC2109 compliant cookie */
        if (conf->name_set) {
            ap_cookie_write(r, conf->name, buffer, conf->name_attrs, z->maxage);
        }

        /* create RFC2965 compliant cookie */
        if (conf->name2_set) {
            ap_cookie_write2(r, conf->name2, buffer, conf->name2_attrs, z->maxage);
        }

        return OK;

    }

    /* save named session */
    else if (conf->peruser) {

        /* don't cache pages with a session */
        apr_table_addn(r->headers_out, "Cache-Control", "no-cache");

        if (r->user) {
            ret = dbd_save(r, r->user, z->encoded, z->expiry);
            if (ret != APR_SUCCESS) {
                return ret;
            }
            return OK;
        }
        else {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, LOG_PREFIX
               "peruser sessions can only be saved if a user is logged in, "
                          "session not saved: %s", r->uri);
        }
    }

    return DECLINED;

}

/**
 * This function performs housekeeping on the database, deleting expired
 * sessions.
 */
AP_DECLARE(int) ap_session_dbd_monitor(apr_pool_t *p)
{
    /* TODO handle housekeeping */
    dbd_clean(p);
    return OK;
}


static void *create_session_dbd_dir_config(apr_pool_t * p, char *dummy)
{
    session_dbd_dir_conf *new =
    (session_dbd_dir_conf *) apr_pcalloc(p, sizeof(session_dbd_dir_conf));

    new->remove = 1;
    new->remove_set = 1;
    
    new->selectlabel = "selectsession";
    new->insertlabel = "insertsession";
    new->updatelabel = "updatesession";
    new->deletelabel = "deletesession";

    return (void *) new;
}

static void *merge_session_dbd_dir_config(apr_pool_t * p, void *basev, void *addv)
{
    session_dbd_dir_conf *new = (session_dbd_dir_conf *) apr_pcalloc(p, sizeof(session_dbd_dir_conf));
    session_dbd_dir_conf *add = (session_dbd_dir_conf *) addv;
    session_dbd_dir_conf *base = (session_dbd_dir_conf *) basev;

    new->name = (add->name_set == 0) ? base->name : add->name;
    new->name_attrs = (add->name_set == 0) ? base->name_attrs : add->name_attrs;
    new->name_set = add->name_set || base->name_set;
    new->name2 = (add->name2_set == 0) ? base->name2 : add->name2;
    new->name2_attrs = (add->name2_set == 0) ? base->name2_attrs : add->name2_attrs;
    new->name2_set = add->name2_set || base->name2_set;
    new->peruser = (add->peruser_set == 0) ? base->peruser : add->peruser;
    new->peruser_set = add->peruser_set || base->peruser_set;
    new->remove = (add->remove_set == 0) ? base->remove : add->remove;
    new->remove_set = add->remove_set || base->remove_set;
    new->selectlabel = (!add->selectlabel) ? base->selectlabel : add->selectlabel;
    new->updatelabel = (!add->updatelabel) ? base->updatelabel : add->updatelabel;
    new->insertlabel = (!add->insertlabel) ? base->insertlabel : add->insertlabel;
    new->deletelabel = (!add->deletelabel) ? base->deletelabel : add->deletelabel;

    return new;
}

/**
 * Sanity check a given string that it exists, is not empty,
 * and does not contain special characters.
 */
static const char *check_string(cmd_parms * cmd, const char *string)
{
    if (APR_SUCCESS != ap_cookie_check_string(string)) {
        return apr_pstrcat(cmd->pool, cmd->directive->directive,
                           " cannot be empty, or contain '=', ';' or '&'.",
                           NULL);
    }
    return NULL;
}

static const char *
     set_dbd_peruser(cmd_parms * parms, void *dconf, int flag)
{
    session_dbd_dir_conf *conf = dconf;

    conf->peruser = flag;
    conf->peruser_set = 1;

    return NULL;
}

static const char *
     set_dbd_cookie_remove(cmd_parms * parms, void *dconf, int flag)
{
    session_dbd_dir_conf *conf = dconf;

    conf->remove = flag;
    conf->remove_set = 1;

    return NULL;
}

static const char *set_cookie_name(cmd_parms * cmd, void *config, const char *args)
{
    char *last;
    char *line = apr_pstrdup(cmd->pool, args);
    session_dbd_dir_conf *conf = (session_dbd_dir_conf *) config;
    char *cookie = apr_strtok(line, " \t", &last);
    conf->name = cookie;
    conf->name_set = 1;
    while (apr_isspace(*last)) {
        last++;
    }
    conf->name_attrs = last;
    return check_string(cmd, cookie);
}

static const char *set_cookie_name2(cmd_parms * cmd, void *config, const char *args)
{
    char *last;
    char *line = apr_pstrdup(cmd->pool, args);
    session_dbd_dir_conf *conf = (session_dbd_dir_conf *) config;
    char *cookie = apr_strtok(line, " \t", &last);
    conf->name2 = cookie;
    conf->name2_set = 1;
    while (apr_isspace(*last)) {
        last++;
    }
    conf->name2_attrs = last;
    return check_string(cmd, cookie);
}

static const command_rec session_dbd_cmds[] =
{
    AP_INIT_TAKE1("SessionDBDSelectLabel", ap_set_string_slot,
      (void *) APR_OFFSETOF(session_dbd_dir_conf, selectlabel), OR_AUTHCFG,
                  "Query label used to select a new session"),
    AP_INIT_TAKE1("SessionDBDInsertLabel", ap_set_string_slot,
      (void *) APR_OFFSETOF(session_dbd_dir_conf, insertlabel), OR_AUTHCFG,
                  "Query label used to insert a new session"),
    AP_INIT_TAKE1("SessionDBDUpdateLabel", ap_set_string_slot,
      (void *) APR_OFFSETOF(session_dbd_dir_conf, updatelabel), OR_AUTHCFG,
                  "Query label used to update an existing session"),
    AP_INIT_TAKE1("SessionDBDDeleteLabel", ap_set_string_slot,
      (void *) APR_OFFSETOF(session_dbd_dir_conf, deletelabel), OR_AUTHCFG,
                  "Query label used to delete an existing session"),
    AP_INIT_FLAG("SessionDBDPerUser", set_dbd_peruser, NULL, OR_AUTHCFG,
                 "Save the session per user"),
    AP_INIT_FLAG("SessionDBDCookieRemove", set_dbd_cookie_remove, NULL, RSRC_CONF|OR_AUTHCFG,
                 "Remove the session cookie after session load. On by default."),
    AP_INIT_RAW_ARGS("SessionDBDCookieName", set_cookie_name, NULL, OR_AUTHCFG,
                 "The name of the RFC2109 cookie carrying the session key"),
    AP_INIT_RAW_ARGS("SessionDBDCookieName2", set_cookie_name2, NULL, OR_AUTHCFG,
                 "The name of the RFC2965 cookie carrying the session key"),
    {NULL}
};

static void register_hooks(apr_pool_t * p)
{
    ap_hook_session_load(ap_session_dbd_load, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_session_save(ap_session_dbd_save, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_monitor(ap_session_dbd_monitor, NULL, NULL, APR_HOOK_MIDDLE);
}

module AP_MODULE_DECLARE_DATA session_dbd_module =
{
    STANDARD20_MODULE_STUFF,
    create_session_dbd_dir_config, /* dir config creater */
    merge_session_dbd_dir_config,  /* dir merger --- default is to
                                    * override */
    NULL,                          /* server config */
    NULL,                          /* merge server config */
    session_dbd_cmds,              /* command apr_table_t */
    register_hooks                 /* register hooks */
};
    /* RFC 2616:
     *   Request-URI    = "*" | absoluteURI | abs_path | authority
     *
     * authority is a special case for CONNECT.  If the request is not
     * using CONNECT, and the parsed URI does not have scheme, and
     * it does not begin with '/', and it is not '*', then, fail
     * and give a 400 response. */
    if (r->method_number != M_CONNECT 
        && !r->parsed_uri.scheme 
        && uri[0] != '/'
        && !(uri[0] == '*' && uri[1] == '\0')) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "invalid request-URI %s", uri);
        r->args = NULL;
        r->hostname = NULL;
        r->status = HTTP_BAD_REQUEST;
        r->uri = apr_pstrdup(r->pool, uri);
    }

    int interim_response; /* non-zero whilst interim 1xx responses
                           * are being read. */
    do {
        interim_response = ap_is_HTTP_INFO(r->status);
        if (interim_response) {
                         "proxy: HTTP: received interim %d response",
                         r->status);
            !interim_response &&                   /* not any 1xx response */
    } while (interim_response);
            if ((status != HTTP_NO_CONTENT) && /* not 204 */
        ap_rvputs(r, ap_get_server_name(r), " (via ", r->connection->local_ip,
        else if (is_absolute_uri(r->filename)) {
        else if (is_absolute_uri(r->filename)) {
	do_expand_env(r, p->env, briRR, briRC);
    do_expand(r, output, newuri, sizeof(newuri), briRR, briRC);
    do_expand_env(r, p->env, briRR, briRC);
    if (prefixstrip && r->filename[0] != '/'
	&& !is_absolute_uri(r->filename)) {
    if (is_absolute_uri(r->filename)) {
    do_expand(r, p->input, input, sizeof(input), briRR, briRC);
        if (strlen(input) > 0 && subreq_ok(r)) {
        if (strlen(input) > 0 && subreq_ok(r)) {

/*
**
**  perform all the expansions on the input string
**  leaving the result in the supplied buffer
**
*/

static void do_expand(request_rec *r, char *input, char *buffer, int nbuf,
		       backrefinfo *briRR, backrefinfo *briRC)
{
    char *inp, *outp;
    size_t span, space;

    /*
     * for security reasons this expansion must be perfomed in a
     * single pass, otherwise an attacker can arrange for the result
     * of an earlier expansion to include expansion specifiers that
     * are interpreted by a later expansion, producing results that
     * were not intended by the administrator.
     */

    inp = input;
    outp = buffer;
    space = nbuf - 1; /* room for '\0' */

    for (;;) {
	span = strcspn(inp, "$%");
	if (span > space) {
	    span = space;
	}
	memcpy(outp, inp, span);
	inp += span;
	outp += span;
	space -= span;
	if (space == 0 || *inp == '\0') {
	    break;
	}
	/* now we have a '$' or a '%' */
	if (inp[1] == '{') {
	    char *endp;
	    endp = strchr(inp, '}');
	    if (endp == NULL) {
		goto skip;
	    }
	    *endp = '\0';
	    if (inp[0] == '$') {
		/* ${...} map lookup expansion */
		char *key, *dflt, *result;
		key = strchr(inp, ':');
		if (key == NULL) {
		    goto skip;
		}
		*key++ = '\0';
		dflt = strchr(key, '|');
		if (dflt) {
		    *dflt++ = '\0';
		}
		result = lookup_map(r, inp+2, key);
		if (result == NULL) {
		    result = dflt ? dflt : "";
		}
		span = apr_cpystrn(outp, result, space) - outp;
		key[-1] = ':';
		if (dflt) {
		    dflt[-1] = '|';
		}
	    }
	    else if (inp[0] == '%') {
		/* %{...} variable lookup expansion */
		span = apr_cpystrn(outp, lookup_variable(r, inp+2), space) - outp;
	    }
	    else {
		span = 0;
	    }
	    *endp = '}';
	    inp = endp+1;
	    outp += span;
	    space -= span;
	    continue;
	}
	else if (apr_isdigit(inp[1])) {
	    int n = inp[1] - '0';
	    backrefinfo *bri = NULL;
	    if (inp[0] == '$') {
		/* $N RewriteRule regexp backref expansion */
		bri = briRR;
	    }
	    else if (inp[0] == '%') {
		/* %N RewriteCond regexp backref expansion */
		bri = briRC;
	    }
	    /* see ap_pregsub() in src/main/util.c */
            if (bri && n <= bri->nsub &&
		bri->regmatch[n].rm_eo > bri->regmatch[n].rm_so) {
		span = bri->regmatch[n].rm_eo - bri->regmatch[n].rm_so;
		if (span > space) {
		    span = space;
		}
		memcpy(outp, bri->source + bri->regmatch[n].rm_so, span);
		outp += span;
		space -= span;
	    }
	    inp += 2;
	    continue;
	}
    skip:
	*outp++ = *inp++;
	space--;
    }
    *outp++ = '\0';
}


/*
**
**  perform all the expansions on the environment variables
**
*/

static void do_expand_env(request_rec *r, char *env[],
			  backrefinfo *briRR, backrefinfo *briRC)
{
    int i;
    char buf[MAX_STRING_LEN];

    for (i = 0; env[i] != NULL; i++) {
	do_expand(r, env[i], buf, sizeof(buf), briRR, briRC);
	add_env_variable(r, buf);
    }
}


    if (!is_absolute_uri(r->filename)) {
**  return non-zero if the URI is absolute (includes a scheme etc.)
static int is_absolute_uri(char *uri)
    int i = strlen(uri);
    if (   (i > 7 && strncasecmp(uri, "http://",   7) == 0)
        || (i > 8 && strncasecmp(uri, "https://",  8) == 0)
        || (i > 9 && strncasecmp(uri, "gopher://", 9) == 0)
        || (i > 6 && strncasecmp(uri, "ftp://",    6) == 0)
        || (i > 5 && strncasecmp(uri, "ldap:",     5) == 0)
        || (i > 5 && strncasecmp(uri, "news:",     5) == 0)
        || (i > 7 && strncasecmp(uri, "mailto:",   7) == 0) ) {
	return 1;
    else {
	return 0;
/*
**
**  check that a subrequest won't cause infinite recursion
**
*/

static int subreq_ok(request_rec *r)
{
    /*
     * either not in a subrequest, or in a subrequest
     * and URIs aren't NULL and sub/main URIs differ
     */
    return (r->main == NULL ||
	    (r->main->uri != NULL && r->uri != NULL &&
	     strcmp(r->main->uri, r->uri) != 0));
}

static void do_expand(request_rec *r, char *input, char *buffer, int nbuf,
		      backrefinfo *briRR, backrefinfo *briRC);
static void do_expand_env(request_rec *r, char *env[],
			  backrefinfo *briRR, backrefinfo *briRC);

static int   is_absolute_uri(char *uri);
static int    subreq_ok(request_rec *r);
/**
 * Unescape a string
 * @param url The string to unescape
 * @return 0 on success, non-zero otherwise
 */
AP_DECLARE(int) ap_unescape_all(char *url);

/**
 * Escape a path segment, as defined in RFC 1808, to a preallocated buffer.
 * @param c The preallocated buffer to write to
 * @param s The path to convert
 * @return The converted URL (c)
 */
AP_DECLARE(char *) ap_escape_path_segment_b(char *c, const char *s);

/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define CORE_PRIVATE

#include "mod_session.h"
#include "apr_lib.h"
#include "apr_strings.h"
#include "util_filter.h"
#include "http_log.h"
#include "http_request.h"
#include "http_protocol.h"

#define SESSION_PREFIX "mod_session: "
#define SESSION_EXPIRY "expiry"
#define HTTP_SESSION "HTTP_SESSION"

APR_HOOK_STRUCT(
                APR_HOOK_LINK(session_load)
                APR_HOOK_LINK(session_save)
                APR_HOOK_LINK(session_encode)
                APR_HOOK_LINK(session_decode)
)
AP_IMPLEMENT_HOOK_RUN_FIRST(int, session_load,
                      (request_rec * r, session_rec ** z), (r, z), DECLINED)
AP_IMPLEMENT_HOOK_RUN_FIRST(int, session_save,
                       (request_rec * r, session_rec * z), (r, z), DECLINED)
AP_IMPLEMENT_HOOK_RUN_ALL(int, session_encode,
                   (request_rec * r, session_rec * z), (r, z), OK, DECLINED)
AP_IMPLEMENT_HOOK_RUN_ALL(int, session_decode,
                   (request_rec * r, session_rec * z), (r, z), OK, DECLINED)
/**
 * Should the session be included within this URL.
 *
 * This function tests whether a session is valid for this URL. It uses the
 * include and exclude arrays to determine whether they should be included.
 */
    static int session_included(request_rec * r, session_dir_conf * conf)
{

    const char **includes = (const char **) conf->includes->elts;
    const char **excludes = (const char **) conf->excludes->elts;
    int included = 1;                /* defaults to included */
    int i;

    if (conf->includes->nelts) {
        included = 0;
        for (i = 0; !included && i < conf->includes->nelts; i++) {
            const char *include = includes[i];
            if (strncmp(r->parsed_uri.path, include, strlen(include))) {
                included = 1;
            }
        }
    }

    if (conf->excludes->nelts) {
        for (i = 0; included && i < conf->includes->nelts; i++) {
            const char *exclude = excludes[i];
            if (strncmp(r->parsed_uri.path, exclude, strlen(exclude))) {
                included = 0;
            }
        }
    }

    return included;
}

/**
 * Get a particular value from the session.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to get.
 * @param value The buffer to write the value to.
 */
AP_DECLARE(void) ap_session_get(request_rec * r, session_rec * z, const char *key, const char **value)
{
    if (!z) {
        ap_session_load(r, &z);
    }
    *value = apr_table_get(z->entries, key);
}

/**
 * Set a particular value to the session.
 *
 * Using this method ensures that the dirty flag is set correctly, so that
 * the session can be saved efficiently.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to set. The existing key value will be replaced.
 * @param value The value to set.
 */
AP_DECLARE(void) ap_session_set(request_rec * r, session_rec * z,
                                const char *key, const char *value)
{
    if (!z) {
        ap_session_load(r, &z);
    }
    if (value) {
        apr_table_set(z->entries, key, value);
    }
    else {
        apr_table_unset(z->entries, key);
    }
    z->dirty = 1;
}

/**
 * Load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_load(request_rec * r, session_rec ** z)
{

    session_dir_conf *dconf = ap_get_module_config(r->per_dir_config,
                                                   &session_module);
    apr_time_t now;
    session_rec *zz = NULL;

    /* is the session enabled? */
    if (!dconf->enabled) {
        return APR_SUCCESS;
    }

    /* should the session be loaded at all? */
    if (!session_included(r, dconf)) {
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, SESSION_PREFIX
                      "excluded by configuration for: %s", r->uri);
        return APR_SUCCESS;
    }

    /* load the session from the session hook */
    int rv = ap_run_session_load(r, &zz);
    if (DECLINED == rv) {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                      "session is enabled but no session modules have been configured, "
                      "session not loaded: %s", r->uri);
        return APR_EGENERAL;
    }
    else if (OK != rv) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                      "error while loading the session, "
                      "session not loaded: %s", r->uri);
        return rv;
    }

    /* found a session that hasn't expired? */
    now = apr_time_now();
    if (!zz || (zz->expiry && zz->expiry < now)) {

        /* no luck, create a blank session */
        zz = (session_rec *) apr_pcalloc(r->pool, sizeof(session_rec));
        zz->pool = r->pool;
        zz->entries = apr_table_make(zz->pool, 10);
        zz->uuid = (apr_uuid_t *) apr_pcalloc(zz->pool, sizeof(apr_uuid_t));
        apr_uuid_get(zz->uuid);

    }
    else {
        rv = ap_run_session_decode(r, zz);
        if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while decoding the session, "
                          "session not loaded: %s", r->uri);
            return rv;
        }
    }

    /* make sure the expiry is set, if present */
    if (!zz->expiry && dconf->maxage) {
        zz->expiry = now + dconf->maxage * APR_USEC_PER_SEC;
        zz->maxage = dconf->maxage;
    }

    *z = zz;

    return APR_SUCCESS;

}

/**
 * Save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_save(request_rec * r, session_rec * z)
{
    if (z) {
        apr_time_t now = apr_time_now();
        int rv = 0;

        /* sanity checks, should we try save at all? */
        if (z->written) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, SESSION_PREFIX
                          "attempt made to save the session twice, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }
        if (z->expiry && z->expiry < now) {
            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                          "attempt made to save a session when the session had already expired, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }

        /* encode the session */
        rv = ap_run_session_encode(r, z);
        if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while encoding the session, "
                          "session not saved: %s", r->uri);
            return rv;
        }

        /* try the save */
        rv = ap_run_session_save(r, z);
        if (DECLINED == rv) {
            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                          "session is enabled but no session modules have been configured, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }
        else if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while saving the session, "
                          "session not saved: %s", r->uri);
            return rv;
        }
        else {
            z->written = 1;
        }
    }

    return APR_SUCCESS;

}

static int identity_count(int *count, const char *key, const char *val)
{
    *count += strlen(key) * 3 + strlen(val) * 3 + 1;
    return 1;
}

static int identity_concat(char *buffer, const char *key, const char *val)
{
    char *slider = buffer;
    int length = strlen(slider);
    slider += length;
    if (length) {
        *slider = '&';
        slider++;
    }
    ap_escape_path_segment_b(slider, key);
    slider += strlen(slider);
    *slider = '=';
    slider++;
    ap_escape_path_segment_b(slider, val);
    return 1;
}

/**
 * Default identity encoding for the session.
 *
 * By default, the name value pairs in the session are URLEncoded, separated
 * by equals, and then in turn separated by ampersand, in the format of an
 * html form.
 *
 * This was chosen to make it easy for external code to unpack a session,
 * should there be a need to do so.
 *
 * @param r The request pointer.
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_identity_encode(request_rec * r, session_rec * z)
{

    char *buffer = NULL;
    int length = 0;
    if (z->expiry) {
        char *expiry = apr_psprintf(r->pool, "%" APR_INT64_T_FMT, z->expiry);
        apr_table_set(z->entries, SESSION_EXPIRY, expiry);
    }
    apr_table_do((int (*) (void *, const char *, const char *))
                 identity_count, &length, z->entries, NULL);;
    buffer = apr_pcalloc(r->pool, length + 1);
    apr_table_do((int (*) (void *, const char *, const char *))
                 identity_concat, buffer, z->entries, NULL);
    z->encoded = buffer;
    return OK;

}

/**
 * Default identity decoding for the session.
 *
 * By default, the name value pairs in the session are URLEncoded, separated
 * by equals, and then in turn separated by ampersand, in the format of an
 * html form.
 *
 * This was chosen to make it easy for external code to unpack a session,
 * should there be a need to do so.
 *
 * This function reverses that process, and populates the session table.
 *
 * Name / value pairs that are not encoded properly are ignored.
 *
 * @param r The request pointer.
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_identity_decode(request_rec * r, session_rec * z)
{

    char *last = NULL;
    char *encoded, *pair;
    const char *sep = "&";

    /* sanity check - anything to decode? */
    if (!z->encoded) {
        return OK;
    }

    /* decode what we have */
    encoded = apr_pstrcat(r->pool, z->encoded, NULL);
    pair = apr_strtok(encoded, sep, &last);
    while (pair && pair[0]) {
        char *plast = NULL;
        const char *psep = "=";
        char *key = apr_strtok(pair, psep, &plast);
        char *val = apr_strtok(NULL, psep, &plast);
        if (key && *key) {
            if (!val || !*val) {
                apr_table_unset(z->entries, key);
            }
            if (!ap_unescape_all(key) && !ap_unescape_all(val)) {
                if (!strcmp(SESSION_EXPIRY, key)) {
                    z->expiry = (apr_time_t) apr_atoi64(val);
                }
                else {
                    apr_table_set(z->entries, key, val);
                }
            }
        }
        pair = apr_strtok(NULL, sep, &last);
    }
    z->encoded = NULL;
    return OK;

}

/**
 * Ensure any changes to the session are committed.
 *
 * This is done in an output filter so that our options for where to
 * store the session can include storing the session within a cookie:
 * As an HTTP header, the cookie must be set before the output is
 * written, but after the handler is run.
 *
 * NOTE: It is possible for internal redirects to cause more than one
 * request to be present, and each request might have a session
 * defined. We need to go through each session in turn, and save each
 * one.
 * 
 * The same session might appear in more than one request. The first
 * attempt to save the session will be called
 */
static apr_status_t ap_session_output_filter(ap_filter_t * f,
                                                    apr_bucket_brigade * in)
{

    /* save all the sessions in all the requests */
    request_rec *r = f->r->main;
    if (!r) {
        r = f->r;
    }
    while (r) {
        session_rec *z = NULL;
        session_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_module);

        /* load the session, or create one if necessary */
        ap_session_load(r, &z);
        if (!z || z->written) {
            r = r->next;
            continue;
        }

        /* if a header was specified, insert the new values from the header */
        if (conf->header_set) {
            const char *override = apr_table_get(r->err_headers_out, conf->header);
            if (!override) {
                override = apr_table_get(r->headers_out, conf->header);
            }
            if (override) {
                z->encoded = override;
                ap_session_identity_decode(r, z);
            }
        }

        /* save away the session, and we're done */
        ap_session_save(r, z);

        r = r->next;
    }

    /* remove ourselves from the filter chain */
    ap_remove_output_filter(f);

    /* send the data up the stack */
    return ap_pass_brigade(f->next, in);

}

/**
 * Insert the output filter.
 */
static void ap_session_insert_output_filter(request_rec * r)
{
    ap_add_output_filter("MOD_SESSION_OUT", NULL, r, r->connection);
}

/**
 * Fixups hook.
 *
 * Load the session within a fixup - this ensures that the session is
 * properly loaded prior to the handler being called.
 * 
 * The fixup is also responsible for injecting the session into the CGI
 * environment, should the admin have configured it so.
 * 
 * @param r The request
 */
AP_DECLARE(int) ap_session_fixups(request_rec * r)
{
    session_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                  &session_module);

    session_rec *z = NULL;
    ap_session_load(r, &z);

    if (conf->env) {
        ap_session_identity_encode(r, z);
        if (z->encoded) {
            apr_table_set(r->subprocess_env, HTTP_SESSION, z->encoded);
            z->encoded = NULL;
        }
    }

    return OK;

}


static void *create_session_dir_config(apr_pool_t * p, char *dummy)
{
    session_dir_conf *new =
    (session_dir_conf *) apr_pcalloc(p, sizeof(session_dir_conf));

    new->includes = apr_array_make(p, 10, sizeof(const char **));
    new->excludes = apr_array_make(p, 10, sizeof(const char **));

    return (void *) new;
}

static void *merge_session_dir_config(apr_pool_t * p, void *basev, void *addv)
{
    session_dir_conf *new = (session_dir_conf *) apr_pcalloc(p, sizeof(session_dir_conf));
    session_dir_conf *add = (session_dir_conf *) addv;
    session_dir_conf *base = (session_dir_conf *) basev;

    new->enabled = (add->enabled_set == 0) ? base->enabled : add->enabled;
    new->enabled_set = add->enabled_set || base->enabled_set;
    new->maxage = (add->maxage_set == 0) ? base->maxage : add->maxage;
    new->maxage_set = add->maxage_set || base->maxage_set;
    new->header = (add->header_set == 0) ? base->header : add->header;
    new->header_set = add->header_set || base->header_set;
    new->env = (add->env_set == 0) ? base->env : add->env;
    new->env_set = add->env_set || base->env_set;
    new->includes = apr_array_append(p, base->includes, add->includes);
    new->excludes = apr_array_append(p, base->excludes, add->excludes);

    return new;
}


static const char *
     set_session_enable(cmd_parms * parms, void *dconf, int flag)
{
    session_dir_conf *conf = dconf;

    conf->enabled = flag;
    conf->enabled_set = 1;

    return NULL;
}

static const char *
     set_session_maxage(cmd_parms * parms, void *dconf, const char *arg)
{
    session_dir_conf *conf = dconf;

    conf->maxage = atol(arg);
    conf->maxage_set = 1;

    return NULL;
}

static const char *
     set_session_header(cmd_parms * parms, void *dconf, const char *arg)
{
    session_dir_conf *conf = dconf;

    conf->header = arg;
    conf->header_set = 1;

    return NULL;
}

static const char *
     set_session_env(cmd_parms * parms, void *dconf, int flag)
{
    session_dir_conf *conf = dconf;

    conf->env = flag;
    conf->env_set = 1;

    return NULL;
}

static const char *add_session_include(cmd_parms * cmd, void *dconf, const char *f)
{
    session_dir_conf *conf = dconf;

    const char **new = apr_array_push(conf->includes);
    *new = f;

    return NULL;
}

static const char *add_session_exclude(cmd_parms * cmd, void *dconf, const char *f)
{
    session_dir_conf *conf = dconf;

    const char **new = apr_array_push(conf->excludes);
    *new = f;

    return NULL;
}


static const command_rec session_cmds[] =
{
    AP_INIT_FLAG("Session", set_session_enable, NULL, OR_AUTHCFG,
                 "on if a session should be maintained for these URLs"),
    AP_INIT_TAKE1("SessionMaxAge", set_session_maxage, NULL, OR_AUTHCFG,
                  "length of time for which a session should be valid. Zero to disable"),
    AP_INIT_TAKE1("SessionHeader", set_session_header, NULL, OR_AUTHCFG,
                  "output header, if present, whose contents will be injected into the session."),
    AP_INIT_FLAG("SessionEnv", set_session_env, NULL, OR_AUTHCFG,
                 "on if a session should be written to the CGI environment. Defaults to off"),
    AP_INIT_TAKE1("SessionInclude", add_session_include, NULL, OR_AUTHCFG,
                  "URL prefixes to include in the session. Defaults to all URLs"),
    AP_INIT_TAKE1("SessionExclude", add_session_exclude, NULL, OR_AUTHCFG,
                  "URL prefixes to exclude from the session. Defaults to no URLs"),
    {NULL}
};

static void register_hooks(apr_pool_t * p)
{
    ap_register_output_filter("MOD_SESSION_OUT", ap_session_output_filter,
                              NULL, AP_FTYPE_CONTENT_SET);
    ap_hook_insert_filter(ap_session_insert_output_filter, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_insert_error_filter(ap_session_insert_output_filter,
                                NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_fixups(ap_session_fixups, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_session_encode(ap_session_identity_encode, NULL, NULL, APR_HOOK_REALLY_FIRST);
    ap_hook_session_decode(ap_session_identity_decode, NULL, NULL, APR_HOOK_REALLY_LAST);
    APR_REGISTER_OPTIONAL_FN(ap_session_get);
    APR_REGISTER_OPTIONAL_FN(ap_session_set);
    APR_REGISTER_OPTIONAL_FN(ap_session_load);
    APR_REGISTER_OPTIONAL_FN(ap_session_save);
}

module AP_MODULE_DECLARE_DATA session_module =
{
    STANDARD20_MODULE_STUFF,
    create_session_dir_config,   /* dir config creater */
    merge_session_dir_config,    /* dir merger --- default is to override */
    NULL,                        /* server config */
    NULL,                        /* merge server config */
    session_cmds,                /* command apr_table_t */
    register_hooks               /* register hooks */
};
/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef MOD_SESSION_H
#define MOD_SESSION_H

/**
 * @file  mod_session.h
 * @brief Session Module for Apache
 *
 * @defgroup MOD_SESSION mod_session
 * @ingroup  APACHE_MODS
 * @{
 */

#define CORE_PRIVATE

#include "apr_hooks.h"
#include "apr_optional.h"
#include "apr_tables.h"
#include "apr_uuid.h"
#include "apr_pools.h"
#include "apr_time.h"

#include "httpd.h"
#include "http_config.h"
#include "ap_config.h"

#define MOD_SESSION_NOTES_KEY "mod_session_key"

/**
 * Define the name of a username stored in the session, so that modules interested
 * in the username can find it in a standard place.
 */
#define MOD_SESSION_USER "user"

/**
 * Define the name of a password stored in the session, so that modules interested
 * in the password can find it in a standard place.
 */
#define MOD_SESSION_PW "pw"

/**
 * A session structure.
 *
 * At the core of the session is a set of name value pairs making up the
 * session.
 *
 * The session might be uniquely identified by an anonymous uuid, or
 * a remote_user value, or both.
 */
typedef struct {
    apr_pool_t *pool;             /* pool to be used for this session */
    apr_uuid_t *uuid;             /* anonymous uuid of this particular session */
    const char *remote_user;      /* user who owns this particular session */
    apr_table_t *entries;         /* key value pairs */
    const char *encoded;          /* the encoded version of the key value pairs */
    apr_time_t expiry;            /* if > 0, the time of expiry of this session */
    long maxage;                  /* if > 0, the maxage of the session, from
                                   * which expiry is calculated */
    int dirty;                    /* dirty flag */
    int cached;                   /* true if this session was loaded from a
                                   * cache of some kind */
    int written;                  /* true if this session has already been
                                   * written */
} session_rec;

/**
 * Structure to carry the per-dir session config.
 */
typedef struct {
    int enabled;                  /* whether the session has been enabled for
                                   * this directory */
    int enabled_set;
    long maxage;                  /* seconds until session expiry */
    int maxage_set;
    const char *header;           /* header to inject session */
    int header_set;
    int env;                      /* whether the session has been enabled for
                                   * this directory */
    int env_set;
    apr_array_header_t *includes; /* URL prefixes to be included. All
                                   * URLs included if empty */
    apr_array_header_t *excludes; /* URL prefixes to be excluded. No
                                   * URLs excluded if empty */
} session_dir_conf;

/**
 * Get a particular value from the session.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to get.
 * @param value The buffer to write the value to.
 */
AP_DECLARE(void) ap_session_get(request_rec * r, session_rec * z, const char *key, const char **value);

/**
 * Set a particular value to the session.
 *
 * Using this method ensures that the dirty flag is set correctly, so that
 * the session can be saved efficiently.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to set. The existing key value will be replaced.
 * @param value The value to set.
 */
AP_DECLARE(void) ap_session_set(request_rec * r, session_rec * z,
                                const char *key, const char *value);

/**
 * Load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_load(request_rec * r, session_rec ** z);

/**
 * Hook to load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_load, (request_rec * r, session_rec ** z))

/**
 * Save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_save(request_rec * r, session_rec * z);

/**
 * Hook to save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_save, (request_rec * r, session_rec * z))

/**
 * Hook to encode the session.
 *
 * In the default implementation, the key value pairs are encoded using
 * key value pairs separated by equals, in turn separated by ampersand,
 * like a web form.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_encode, (request_rec * r, session_rec * z))

/**
 * Hook to decode the session.
 *
 * In the default implementation, the key value pairs are encoded using
 * key value pairs separated by equals, in turn separated by ampersand,
 * like a web form.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_decode, (request_rec * r, session_rec * z))

APR_DECLARE_OPTIONAL_FN(void, ap_session_get, (request_rec * r, session_rec * z,
                                               const char *key, const char **value));
APR_DECLARE_OPTIONAL_FN(void, ap_session_set, (request_rec * r, session_rec * z,
                                               const char *key, const char *value));
APR_DECLARE_OPTIONAL_FN(int, ap_session_load, (request_rec *, session_rec **));
APR_DECLARE_OPTIONAL_FN(int, ap_session_save, (request_rec *, session_rec *));

/**
 * The name of the module.
 */
extern module AP_MODULE_DECLARE_DATA session_module;

#endif /* MOD_SESSION_H */
/** @} */
AP_DECLARE(int) ap_unescape_all(char *url)
{
    return unescape_url(url, NULL, NULL);
}

AP_DECLARE(char *) ap_escape_path_segment_b(char *copy, const char *segment)
AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char *segment)
{
    return ap_escape_path_segment_b(apr_palloc(p, 3 * strlen(segment) + 1), segment);
}

	    if ((rv = apr_socket_create(&sock, connect_addr->family, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
		ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
			      "proxy: FTP: error creating socket");
		continue;
	    }

#if !defined(TPF) && !defined(BEOS)
	    if (conf->recv_buffer_size > 0
		&& (rv = apr_socket_opt_set(sock, APR_SO_RCVBUF,
                                            conf->recv_buffer_size))) {
		ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
			      "apr_socket_opt_set(APR_SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
	    }
#endif

	    if (APR_SUCCESS != (rv = apr_socket_opt_set(sock, APR_SO_REUSEADDR, one))) {
		apr_socket_close(sock);
#ifndef _OSD_POSIX              /* BS2000 has this option "always on" */
		ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
			      "proxy: FTP: error setting reuseaddr option: apr_socket_opt_set(APR_SO_REUSEADDR)");
		continue;
#endif                          /* _OSD_POSIX */
	    }

	    /* Set a timeout on the socket */
	    if (conf->timeout_set == 1) {
		apr_socket_timeout_set(sock, conf->timeout);
	    }
	    else {
		apr_socket_timeout_set(sock, r->server->timeout);
	    }

                         "proxy: FTP: fam %d socket created, trying to connect to %pI (%s)...", 
                         connect_addr->family, connect_addr, connectname);
		apr_socket_close(sock);
                if ((rv = apr_socket_create(&data_sock, connect_addr->family, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                apr_sockaddr_info_get(&epsv_addr, data_ip, connect_addr->family, data_port, 0, p);
                if ((rv = apr_socket_create(&data_sock, connect_addr->family, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                apr_sockaddr_info_get(&pasv_addr, apr_psprintf(p, "%d.%d.%d.%d", h3, h2, h1, h0), connect_addr->family, pasvport, 0, p);
        if ((rv = apr_socket_create(&local_sock, connect_addr->family, SOCK_STREAM, r->pool)) != APR_SUCCESS) {

    /** Which allow-override-opts bits are set */
    int override_opts;
                                       int override_opts,
    allow_options_t override_opts;
    /** the override options allowed for the .htaccess file */
    int override_opts;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
				       int override_opts,
    parms.override_opts = override_opts;
    new->override_opts = override_opts;
    conf->override_opts = OPT_UNSET | OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER
   			 | OPT_MULTI;
    if (!(new->override_opts & OPT_UNSET)) {
	conf->override_opts = new->override_opts;
    }

static const char *set_allow_opts(cmd_parms *cmd, allow_options_t *opts,
                                  const char *l)
{
    allow_options_t opt;
    int first = 1;

    char *p = (char *) l;

    while (p && *p) {
        char *w = strsep(&p, ",");

        if (first) {
            *opts = OPT_NONE;
            first = 0;
        }

	if (!w)
	    continue;

        if (!strcasecmp(w, "Indexes")) {
            opt = OPT_INDEXES;
        }
        else if (!strcasecmp(w, "Includes")) {
            opt = OPT_INCLUDES;
        }
        else if (!strcasecmp(w, "IncludesNOEXEC")) {
            opt = (OPT_INCLUDES | OPT_INCNOEXEC);
        }
        else if (!strcasecmp(w, "FollowSymLinks")) {
            opt = OPT_SYM_LINKS;
        }
        else if (!strcasecmp(w, "SymLinksIfOwnerMatch")) {
            opt = OPT_SYM_OWNER;
        }
        else if (!strcasecmp(w, "ExecCGI")) {
            opt = OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "MultiViews")) {
            opt = OPT_MULTI;
        }
        else if (!strcasecmp(w, "RunScripts")) { /* AI backcompat. Yuck */
            opt = OPT_MULTI|OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "None")) {
            opt = OPT_NONE;
        }
        else if (!strcasecmp(w, "All")) {
            opt = OPT_ALL;
        }
        else {
            return apr_pstrcat(cmd->pool, "Illegal option ", w, NULL);
        }

        *opts |= opt;
    }

    (*opts) &= (~OPT_UNSET);

    return NULL;
}

    char *k, *v;

	k = w;
	v = strchr(k, '=');
	if (v) {
		*v++ = '\0';
	}

        else if (!strcasecmp(k, "Options")) {
	    if (v) 
                set_allow_opts(cmd, &(d->override_opts), v);
	    else
	        d->override_opts = OPT_ALL;
        else if (!strcasecmp(w, "ExecCGI")) {
	if (!(cmd->override_opts & opt) && opt != OPT_NONE) {
	    return apr_pstrcat(cmd->pool, "Option ", w, " not allowed here", NULL);
        }
        else if (action == '-') {
            /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        overrides_t override_opts;
    if (!(this_dir->override_opts & OR_UNSET)) {
        opts->override_opts = this_dir->override_opts;
    }
					opts.override_opts,
    note = apr_pstrcat(m->pool, MOD_SESSION_COOKIE, name, NULL);
    zz = (session_rec *) apr_pcalloc(m->pool, sizeof(session_rec));
    zz->pool = m->pool;
    zz->entries = apr_table_make(m->pool, 10);
    zz->uuid = (apr_uuid_t *) apr_pcalloc(m->pool, sizeof(apr_uuid_t));
 * by Alexei Kosut <akosut@apache.org>, significant overhauls and
 * redesign by William Rowe <wrowe@covalent.net>, and hints from many
 * other developer/users who have hit on specific flaws.
 * This module implements the ISAPI Handler architecture, allowing 
 * Apache to load Internet Server Applications (ISAPI extensions),
 * similar to the support in IIS, Zope, O'Reilly's WebSite and others.
 * It is a complete implementation of the ISAPI 2.0 specification, 
 * except for "Microsoft extensions" to the API which provide 
 * asynchronous I/O.  It is further extended to include additional
 * "Microsoft extentions" through IIS 5.0, with some deficiencies
 * where one-to-one mappings don't exist.
 *
 * Refer to /manual/mod/mod_isapi.html for additional details on
 * configuration and use, but check this source for specific support
 * of the API, 
#include "apr_strings.h"
#include "apr_portable.h"
#include "apr_buckets.h"
#include "apr_thread_mutex.h"
#include "apr_thread_rwlock.h"
#include "apr_hash.h"
#include "mod_isapi.h"
/* Retry frequency for a failed-to-load isapi .dll */
#define ISAPI_RETRY ( 30 * APR_USEC_PER_SEC )
apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r, 
                          const char *fpath, isapi_loaded** isa);
    isapi_loaded *isa;

    /* ### Just an observation ... it would be terribly cool to be
     * able to use this per-dir, relative to the directory block being
     * defined.  The hash result remains global, but shorthand of
     * <Directory "c:/webapps/isapi">
     *     ISAPICacheFile myapp.dll anotherapp.dll thirdapp.dll
     * </Directory>
     * would be very convienent.
     */
	             "ISAPI: invalid module path, skipping %s", filename);
	    "ISAPI: unable to stat, skipping %s", fspec);
	    "ISAPI: not a regular file, skipping %s", fspec);
    /* Load the extention as cached (with null request_rec) */
    rv = isapi_lookup(cmd->pool, cmd->server, NULL, fspec, &isa); 
                     "ISAPI: unable to cache, skipping %s", fspec);
/* Our isapi global config values */
static struct isapi_global_conf {
    apr_pool_t         *pool;
    apr_thread_mutex_t *lock;
    apr_hash_t         *hash;
} loaded;

    const char          *filename;
    apr_thread_rwlock_t *in_progress;
    apr_status_t         last_load_rv;
    apr_time_t           last_load_time;
    apr_dso_handle_t    *handle;
    HSE_VERSION_INFO    *isapi_version;
    apr_uint32_t         report_version;
#ifdef FAKE_ASYNC
    int                  fakeasync;
    apr_uint32_t         timeout;
#endif
static apr_status_t isapi_unload(isapi_loaded *isa, int force)
     * If optionally cached, and we weren't asked to force the unload,
     * pass HSE_TERM_ADVISORY_UNLOAD, and if it returns 1, unload, 
     * otherwise, leave it alone (it didn't choose to cooperate.)
    if (!isa->handle) {
    }
        if (force) {
        }
        else if (!(*isa->TerminateExtension)(HSE_TERM_ADVISORY_UNLOAD)) {
        }
static apr_status_t cleanup_isapi(void *isa_)
    isapi_loaded* isa = (isapi_loaded*) isa_;

    /* We must force the module to unload, we are about 
     * to lose the isapi structure's allocation entirely.
     */
    return isapi_unload(isa, 1);
static apr_status_t isapi_load(apr_pool_t *p, server_rec *s, request_rec *r, isapi_loaded *isa)
    isa->isapi_version = apr_pcalloc(p, sizeof(HSE_VERSION_INFO));

    /* TODO: These aught to become overrideable, so that we
     * assure a given isapi can be fooled into behaving well.
     *
     * The tricky bit, they aren't really a per-dir sort of
     * config, they will always be constant across every 
     * reference to the .dll no matter what context (vhost,
     * location, etc) they apply to.
     */
    isa->report_version = MAKELONG(0, 5); /* Revision 5.0 */
#ifdef FAKE_ASYNC
    isa->timeout = INFINITE; /* microsecs */
    isa->fakeasync = 1;
#endif
    rv = apr_dso_load(&isa->handle, isa->filename, p);
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                     "ISAPI: failed to load %s", isa->filename);
        isa->handle = NULL;
    rv = apr_dso_sym((void**)&isa->GetExtensionVersion, isa->handle,
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                     "ISAPI: missing GetExtensionVersion() in %s",
                     isa->filename);
        apr_dso_unload(isa->handle);
        isa->handle = NULL;
    rv = apr_dso_sym((void**)&isa->HttpExtensionProc, isa->handle,
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                     "ISAPI: missing HttpExtensionProc() in %s",
                     isa->filename);
        apr_dso_unload(isa->handle);
        isa->handle = NULL;
    rv = apr_dso_sym((void**)&isa->TerminateExtension, isa->handle,
    if (!(isa->GetExtensionVersion)(isa->isapi_version)) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                     "ISAPI: failed call to GetExtensionVersion() in %s", 
                     isa->filename);
        apr_dso_unload(isa->handle);
        isa->handle = NULL;
    apr_pool_cleanup_register(p, isa, cleanup_isapi, 
                              apr_pool_cleanup_null);
apr_status_t isapi_lookup(apr_pool_t *p, server_rec *s, request_rec *r, 
                          const char *fpath, isapi_loaded** isa)
{
    apr_status_t rv;
    const char *key;

    if ((rv = apr_thread_mutex_lock(loaded.lock)) != APR_SUCCESS) {
        return rv;
    }

    *isa = apr_hash_get(loaded.hash, fpath, APR_HASH_KEY_STRING);

    if (*isa) {

        /* If we find this lock exists, use a set-aside copy of gainlock
         * to avoid race conditions on NULLing the in_progress variable 
         * when the load has completed.  Release the global isapi hash
         * lock so other requests can proceed, then rdlock for completion
         * of loading our desired dll or wrlock if we would like to retry
         * loading the dll (because last_load_rv failed and retry is up.)
         */
        apr_thread_rwlock_t *gainlock = (*isa)->in_progress;

        /* gainlock is NULLed after the module loads successfully.
         * This free-threaded module can be used without any locking.
         */
        if (!gainlock) {
            rv = (*isa)->last_load_rv;
            apr_thread_mutex_unlock(loaded.lock);
            return rv;
        }

            
        if ((*isa)->last_load_rv == APR_SUCCESS) {
            apr_thread_mutex_unlock(loaded.lock);
            if ((rv = apr_thread_rwlock_rdlock(gainlock)) 
                    != APR_SUCCESS) {
                return rv;
            }
            rv = (*isa)->last_load_rv;
            apr_thread_rwlock_unlock(gainlock);
            return rv;
        }

        if (apr_time_now() > (*isa)->last_load_time + ISAPI_RETRY) {
        
            /* Remember last_load_time before releasing the global
             * hash lock to avoid colliding with another thread
             * that hit this exception at the same time as our
             * retry attempt, since we unlock the global mutex
             * before attempting a write lock for this module.
             */
            apr_time_t check_time = (*isa)->last_load_time;
            apr_thread_mutex_unlock(loaded.lock);

            if ((rv = apr_thread_rwlock_wrlock(gainlock)) 
                    != APR_SUCCESS) {
                return rv;
            }

            /* If last_load_time is unchanged, we still own this
             * retry, otherwise presume another thread provided 
             * our retry (for good or ill).  Relock the global
             * hash for updating last_load_ vars, so their update
             * is always atomic to the global lock.
             */
            if (check_time == (*isa)->last_load_time) {

                rv = isapi_load(loaded.pool, r->server, r, *isa);

                apr_thread_mutex_lock(loaded.lock);
                (*isa)->last_load_rv = rv;
                (*isa)->last_load_time = apr_time_now();
                apr_thread_mutex_unlock(loaded.lock);
            }
            else {
                rv = (*isa)->last_load_rv;
            }
            apr_thread_rwlock_unlock(gainlock);

            return rv;
        }

        /* We haven't hit timeup on retry, let's grab the last_rv
         * within the hash mutex before unlocking.
         */
        rv = (*isa)->last_load_rv;
        apr_thread_mutex_unlock(loaded.lock);

        return rv;
    }

    /* If the module was not found, it's time to create a hash key entry
     * before releasing the hash lock to avoid multiple threads from 
     * loading the same module.
     */
    key = apr_pstrdup(loaded.pool, fpath);
    *isa = apr_pcalloc(loaded.pool, sizeof(isapi_loaded));
    (*isa)->filename = key;
    if (r) {
        /* A mutex that exists only long enough to attempt to
         * load this isapi dll, the release this module to all
         * other takers that came along during the one-time
         * load process.  Short lifetime for this lock would
         * be great, however, using r->pool is nasty if those
         * blocked on the lock haven't all unlocked before we
         * attempt to destroy.  A nastier race condition than
         * I want to deal with at this moment...
         */
        apr_thread_rwlock_create(&(*isa)->in_progress, loaded.pool);
        apr_thread_rwlock_wrlock((*isa)->in_progress);
    }

    apr_hash_set(loaded.hash, key, APR_HASH_KEY_STRING, *isa);
    
    /* Now attempt to load the isapi on our own time, 
     * allow other isapi processing to resume.
     */
    apr_thread_mutex_unlock(loaded.lock);

    rv = isapi_load(loaded.pool, r->server, r, *isa);
    (*isa)->last_load_time = apr_time_now();
    (*isa)->last_load_rv = rv;

    if (r && (rv == APR_SUCCESS)) {
        /* Let others who are blocked on this particular
         * module resume their requests, for better or worse.
         */
        apr_thread_rwlock_t *unlock = (*isa)->in_progress;
        (*isa)->in_progress = NULL;
        apr_thread_rwlock_unlock(unlock);
    }
    else if (!r && (rv != APR_SUCCESS)) {
        /* We must leave a rwlock around for requests to retry
         * loading this dll after timeup... since we were in 
         * the setup code we had avoided creating this lock.
         */
        apr_thread_rwlock_create(&(*isa)->in_progress, loaded.pool);
    }

    return (*isa)->last_load_rv;
}

    EXTENSION_CONTROL_BLOCK *ecb;
#ifdef FAKE_ASYNC
#endif
int APR_THREAD_FUNC GetServerVariable (isapi_cid *cid, 
                                       char *lpszVariableName,
                                       void *lpvBuffer, 
                                       apr_uint32_t *lpdwSizeofBuffer)
    request_rec *r = cid->r;
    apr_uint32_t len;
            return 0;
        return 1;
            return 0;
        return 1;
            return 0;
        return 1;
    return 0;
int APR_THREAD_FUNC WriteClient(isapi_cid *ConnID, 
                                void *Buffer, 
                                apr_uint32_t *lpdwBytes, 
                                apr_uint32_t dwReserved)
    return 1;
int APR_THREAD_FUNC ReadClient(isapi_cid *ConnID, 
                               void *lpvBuffer, 
                               apr_uint32_t *lpdwSize)
    apr_uint32_t read = 0;
    return 1;
/* Common code invoked for both HSE_REQ_SEND_RESPONSE_HEADER and 
 * the newer HSE_REQ_SEND_RESPONSE_HEADER_EX ServerSupportFunction(s)
 */
static apr_ssize_t send_response_header(isapi_cid *cid, 
                                        const char *stat,
                                        const char *head, 
                                        apr_size_t statlen,
    /* Seems IIS does not enforce the requirement for \r\n termination 
     * on HSE_REQ_SEND_RESPONSE_HEADER, but we won't panic... 
     * ap_scan_script_header_err_strs handles this aspect for us.
     *
     * Parse them out, or die trying 
     */
int APR_THREAD_FUNC ServerSupportFunction(isapi_cid   *cid, 
                                          apr_uint32_t dwHSERequest,
                                          void        *lpvBuffer, 
                                          apr_uint32_t *lpdwSize,
                                          apr_uint32_t *lpdwDataType)
        return 1;
    case HSE_REQ_SEND_URL:
        return 1;
    case HSE_REQ_SEND_RESPONSE_HEADER:
            return 0;
        return 1;
    case HSE_REQ_DONE_WITH_SESSION:
#ifdef FAKE_ASYNC
            SetEvent(cid->complete);
#endif
        return 1;
    case HSE_REQ_MAP_URL_TO_PATH:
        apr_uint32_t len;
        return 1;
    case HSE_REQ_GET_SSPI_INFO:
        return 0;
    case HSE_APPEND_LOG_PARAMETER:
        return 1;
    case HSE_REQ_IO_COMPLETION:
#ifdef FAKE_ASYNC
        if (cid->isa->fakeasync) {
            cid->completion = (PFN_HSE_IO_COMPLETION) lpvBuffer;
            cid->completion_arg = (PVOID) lpdwDataType;
            return 1;
#endif
        if (cid->dconf.log_unsupported)
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
                      "ISAPI: ServerSupportFunction HSE_REQ_IO_COMPLETION "
                      "is not supported: %s", r->filename);
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    case HSE_REQ_TRANSMIT_FILE:
#ifdef FAKE_ASYNC
        if ((tf->dwFlags & HSE_IO_ASYNC) && cid->isa->fakeasync) {
            /* TBD */
        }
        else /* if (!cid->isa->fakeasync && ... */
#endif
        if (tf->dwFlags & HSE_IO_ASYNC)
        {
            return 0;
            return 0;
                return 0;
#ifdef FAKE_ASYNC
#endif
        return 1;
    case HSE_REQ_REFRESH_ISAPI_ACL:
        return 0;
    case HSE_REQ_IS_KEEP_CONN:
        *((int *)lpvBuffer) = (r->connection->keepalive == 1);
        return 1;
    case HSE_REQ_ASYNC_READ_CLIENT:
#ifdef FAKE_ASYNC
        /* TBD: Fake it */
#else
        return 0;
#endif
    case HSE_REQ_GET_IMPERSONATION_TOKEN:  /* Added in ISAPI 4.0 */
        return 0;
    case HSE_REQ_MAP_URL_TO_PATH_EX:
        HSE_URL_MAPEX_INFO *info = (HSE_URL_MAPEX_INFO*)lpdwDataType;
                                      sizeof(info->lpszPath)) - info->lpszPath;
        return 1;
    case HSE_REQ_ABORTIVE_CLOSE:
        return 0;
    case HSE_REQ_GET_CERT_INFO_EX:  /* Added in ISAPI 4.0 */
        return 0;
    case HSE_REQ_SEND_RESPONSE_HEADER_EX:  /* Added in ISAPI 4.0 */
        HSE_SEND_HEADER_EX_INFO *shi = (HSE_SEND_HEADER_EX_INFO*)lpvBuffer;

    /*  XXX: ignore shi->fKeepConn?  We shouldn't need the advise
     *  r->connection->keepalive = shi->fKeepConn; 
     */
            return 0;
        return 1;
    case HSE_REQ_CLOSE_CONNECTION:  /* Added after ISAPI 4.0 */
        return 0;
    case HSE_REQ_IS_CONNECTED:  /* Added after ISAPI 4.0 */
        *((int *)lpvBuffer) = (r->connection->aborted == 0);
        return 1;
    case HSE_REQ_EXTENSION_TRIGGER:  /* Added after ISAPI 4.0 */
        return 0;
        return 0;
    apr_uint32_t read;
    if(strcmp(r->handler, "isapi-isa") 
        && strcmp(r->handler, "isapi-handler")) {
        /* Hang on to the isapi-isa for compatibility with older docs
         * (wtf did '-isa' mean in the first place?) but introduce
         * a newer and clearer "isapi-handler" name.
         */
    }
    if (!(ap_allow_options(r) & OPT_EXECCGI)) {
    }
    if (r->finfo.filetype == APR_NOFILE) {
    }
    if (r->finfo.filetype != APR_REG) {
    }
        r->path_info && *r->path_info) {
    if (isapi_lookup(r->pool, r->server, r, r->filename, &isa) 
           != APR_SUCCESS) {
    }
    
    cid->ecb = apr_pcalloc(r->pool, sizeof(EXTENSION_CONTROL_BLOCK));
    cid->ecb->ConnID = cid;
#ifdef FAKE_ASYNC
#endif
        isapi_unload(isa, 0);
            if (cid->ecb->cbTotalBytes > (apr_uint32_t)cid->dconf.read_ahead_buflen)
            isapi_unload(isa, 0);
             * the ISAPI Handler's "advice".
        case HSE_STATUS_PENDING:
#ifdef FAKE_ASYNC
             *
             * This request completes upon a notification through
             * ServerSupportFunction(HSE_REQ_DONE_WITH_SESSION)
            if (isa->fakeasync) 
            {
                cid->complete = CreateEvent(NULL, 0, 0, NULL);
                break;
            }
#endif
            if (cid->dconf.log_unsupported)
            {
                 ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
                               "ISAPI: asynch I/O result HSE_STATUS_PENDING "
                               "from HttpExtensionProc() is not supported: %s",
                               r->filename);
                 cid->r->status = HTTP_INTERNAL_SERVER_ERROR;
    apr_status_t rv;

    loaded.hash = apr_hash_make(loaded.pool);
    if (!loaded.hash) {
        ap_log_error(APLOG_MARK, APLOG_NOERRNO, 0, NULL,
                     "ISAPI: Failed to create module cache");
    rv = apr_thread_mutex_create(&loaded.lock, APR_THREAD_MUTEX_DEFAULT, 
                                 loaded.pool);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, rv, 0, NULL,
                     "ISAPI: Failed to create module cache lock");
        return rv;
    }
static void recalc_factors(proxy_balancer *balancer,
                           proxy_runtime_worker *fixed)
{
    int i;
    double median, ffactor = 0.0;
    proxy_runtime_worker *workers;    


    /* Recalculate lbfactors */
    workers = (proxy_runtime_worker *)balancer->workers->elts;
    /* Special case if there is only one worker it's
     * load factor will always be 100
     */
    if (balancer->workers->nelts == 1) {
        workers->s->lbstatus = workers->s->lbfactor = 100.0;
        return;
    }
    for (i = 0; i < balancer->workers->nelts; i++) {
        if (workers[i].s->lbfactor > 100.0)
            workers[i].s->lbfactor = 100.0;
        ffactor += workers[i].s->lbfactor;
    }
    if (ffactor < 100.0) {
        median = (100.0 - ffactor) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (&(workers[i]) != fixed)
                workers[i].s->lbfactor += median;
        }
    }
    else if (fixed->s->lbfactor < 100.0) {
        median = (ffactor - 100.0) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (workers[i].s->lbfactor > median &&
                &(workers[i]) != fixed)
                workers[i].s->lbfactor -= median;
        }
    } 
    else {
        median = (ffactor - 100.0) / balancer->workers->nelts;
        for (i = 0; i < balancer->workers->nelts; i++) {
            workers[i].s->lbfactor -= median;
        }
    } 
    for (i = 0; i < balancer->workers->nelts; i++) {
        /* Update the status entires */
        workers[i].s->lbstatus = workers[i].s->lbfactor;
    }
}

/* Invoke handler */
static int balancer_handler(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *conf = (proxy_server_conf *)
        ap_get_module_config(sconf, &proxy_module);
    apr_array_header_t *proxies = conf->proxies;
    struct proxy_remote *ents = (struct proxy_remote *)proxies->elts;
    proxy_balancer *balancer, *bsel = NULL;
    proxy_runtime_worker *worker, *wsel = NULL;
    apr_table_t *params = apr_table_make(r->pool, 10);
    int access_status;
    int i, n;
    const char *name;

    /* is this for us? */
    if (strcmp(r->handler, "balancer-manager"))
        return DECLINED;
    r->allowed = (AP_METHOD_BIT << M_GET);
    if (r->method_number != M_GET)
        return DECLINED;

    if (r->args) {
        char *args = apr_pstrdup(r->pool, r->args);
        char *tok, *val;
        while (args && *args) {
            if ((val = ap_strchr_c(args, '='))) {
                *val++ = '\0';
                if ((tok = ap_strchr_c(val, '&')))
                    *tok++ = '\0';
                if ((access_status = ap_unescape_url(val)) != OK)
                    return access_status;
                apr_table_setn(params, args, val);
                args = tok;
            }
            else
                return HTTP_BAD_REQUEST;
        }
    }
    if ((name = apr_table_get(params, "b")))
        bsel = ap_proxy_get_balancer(r->pool, conf,
            apr_pstrcat(r->pool, "balancer://", name, NULL));
    if ((name = apr_table_get(params, "w"))) {
        const char *sc = apr_table_get(params, "s");
        char *asname = NULL;
        proxy_worker *ws = NULL;
        if (sc) {
            asname = apr_pstrcat(r->pool, sc, "://", name, NULL);
            ws = ap_proxy_get_worker(r->pool, conf, asname);
        }
        if (ws) {
            worker = (proxy_runtime_worker *)bsel->workers->elts;
            for (n = 0; n < bsel->workers->nelts; n++) {
                if (strcasecmp(worker->w->name, ws->name) == 0) {
                    wsel = worker;
                    break;
                }
                ++worker;
            }
        }
    }
    /* First set the params */
    if (bsel) {
        const char *val;
        if ((val = apr_table_get(params, "ss"))) {
            if (strlen(val))
                bsel->sticky = apr_pstrdup(conf->pool, val);
            else
                bsel->sticky = NULL;
        }
        if ((val = apr_table_get(params, "tm"))) {
            int ival = atoi(val);
            if (ival >= 0)
                bsel->timeout = apr_time_from_sec(ival);
        }
    }
    if (wsel) {
        const char *val;
        if ((val = apr_table_get(params, "lf"))) {
            char *ep;
            double dval = strtod(val, &ep);
            if (dval > 1) {
                wsel->s->lbfactor = dval;
                if (bsel)
                    recalc_factors(bsel, wsel);
            }
        }
        if ((val = apr_table_get(params, "wr"))) {
            if (strlen(val))
                wsel->w->route = apr_pstrdup(conf->pool, val);
            else
                wsel->w->route = NULL;
        }
        if ((val = apr_table_get(params, "rr"))) {
            if (strlen(val))
                wsel->w->redirect = apr_pstrdup(conf->pool, val);
            else
                wsel->w->redirect = NULL;
        }
        if ((val = apr_table_get(params, "dw")))
            wsel->w->status |= PROXY_WORKER_DISABLED;
        else
            wsel->w->status &= ~PROXY_WORKER_DISABLED;

    }
    if (apr_table_get(params, "xml")) {
        ap_set_content_type(r, "text/xml");
        ap_rputs("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n", r);
        ap_rputs("<httpd:manager xmlns:httpd=\"http://httpd.apache.org\">\n", r);
        ap_rputs("  <httpd:balancers>\n", r);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("    <httpd:balancer>\n", r);
            ap_rvputs(r, "      <httpd:name>", balancer->name, "</httpd:name>\n", NULL);
            ap_rputs("      <httpd:workers>\n", r);
            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {
                ap_rputs("        <httpd:worker>\n", r);
                ap_rvputs(r, "          <httpd:scheme>", worker->w->scheme,
                          "</httpd:scheme>\n", NULL);                
                ap_rvputs(r, "          <httpd:hostname>", worker->w->hostname,
                          "</httpd:hostname>\n", NULL);                
               ap_rprintf(r, "          <httpd:loadfactor>%.2f</httpd:loadfactor>\n",
                          worker->s->lbfactor);
                ap_rputs("        </httpd:worker>\n", r);
                ++worker;
            }
            ap_rputs("      </httpd:workers>\n", r);
            ap_rputs("    </httpd:balancer>\n", r);
            ++balancer;
        }
        ap_rputs("  </httpd:balancers>\n", r);
        ap_rputs("</httpd:manager>", r);         
    }
    else {
        ap_set_content_type(r, "text/html");
        ap_rputs(DOCTYPE_HTML_3_2
                 "<html><head><title>Balancer Manager</title></head>\n", r);
        ap_rputs("<body><h1>Load Balancer Manager for ", r);
        ap_rvputs(r, ap_get_server_name(r), "</h1>\n\n", NULL);
        ap_rvputs(r, "<dl><dt>Server Version: ",
                  ap_get_server_version(), "</dt>\n", NULL);
        ap_rvputs(r, "<dt>Server Built: ",
                  ap_get_server_built(), "\n</dt></dl>\n", NULL);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("<hr />\n<h3>LoadBalancer Status for ", r);
            ap_rvputs(r, "<a href=\"", r->uri, "?b=",
                      balancer->name + sizeof("balancer://") - 1,
                      "\">", NULL); 
            ap_rvputs(r, balancer->name, "</a></h3>\n\n", NULL);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>StickySesion</th><th>Timeout</th>"
                "</tr>\n<tr>", r);                
            ap_rvputs(r, "<td>", balancer->sticky, NULL);
            ap_rprintf(r, "</td><td>%" APR_TIME_T_FMT "</td>\n",
                apr_time_sec(balancer->timeout));
            ap_rputs("</table>\n", r);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>Scheme</th><th>Host</th>"
                "<th>Route</th><th>RouteRedir</th>"
                "<th>Factor</th><th>Status</th>"
                "</tr>\n", r);

            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {

                ap_rvputs(r, "<tr>\n<td>", worker->w->scheme, "</td><td>", NULL);
                ap_rvputs(r, "<a href=\"", r->uri, "?b=", 
                          balancer->name + sizeof("balancer://") - 1,
                          "&s=", worker->w->scheme, "&w=", worker->w->hostname,
                          "\">", NULL); 
                ap_rvputs(r, worker->w->hostname, "</a></td>", NULL);
                ap_rvputs(r, "<td>", worker->w->route, NULL);
                ap_rvputs(r, "</td><td>", worker->w->redirect, NULL);
                ap_rprintf(r, "</td><td>%.2f</td><td>", worker->s->lbfactor);
                if (worker->w->status & PROXY_WORKER_DISABLED)
                    ap_rputs("Dis", r);
                else if (worker->w->status & PROXY_WORKER_IN_ERROR)
                    ap_rputs("Err", r);
                else if (worker->w->status & PROXY_WORKER_INITIALIZED)
                    ap_rputs("Ok", r);
                else
                    ap_rputs("-", r);
                ap_rputs("</td></tr>\n", r);

                ++worker;
            }
            ap_rputs("</table>\n", r);
            ++balancer;
        }
        ap_rputs("<hr />\n", r);
        if (wsel && bsel) {
            ap_rputs("<h3>Edit worker settings for ", r);
            ap_rvputs(r, wsel->w->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>Load factor:</td><td><input name=\"lf\" type=text ", r);
            ap_rprintf(r, "value=\"%.2f\"></td><tr>\n", wsel->s->lbfactor);            
            ap_rputs("<tr><td>Route:</td><td><input name=\"wr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->route, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Route Redirect:</td><td><input name=\"rr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->redirect, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Disabled:</td><td><input name=\"dw\" type=checkbox", r);
            if (wsel->w->status & PROXY_WORKER_DISABLED)
                ap_rputs(" checked", r);
            ap_rputs("></td><tr>\n", r);            
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"s\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->scheme, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"w\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->hostname, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        else if (bsel) {
            ap_rputs("<h3>Edit balancer settings for ", r);
            ap_rvputs(r, bsel->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>StickySession Identifier:</td><td><input name=\"ss\" type=text ", r);
            if (bsel->sticky)
                ap_rvputs(r, "value=\"", bsel->sticky, "\"", NULL);
            ap_rputs("></td><tr>\n<tr><td>Timeout:</td><td><input name=\"tm\" type=text ", r);
            ap_rprintf(r, "value=\"%" APR_TIME_T_FMT "\"></td></tr>\n",
                       apr_time_sec(bsel->timeout));
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        ap_rputs(ap_psignature("",r), r);
        ap_rputs("</body></html>\n", r);
    }
    return OK;
}

    /* manager handler */
    ap_hook_handler(balancer_handler, NULL, NULL, APR_HOOK_FIRST);
        ap_rvputs(r, ap_get_server_name(r), " (via ", r->connection->local_ip,
    const char *key;

    key = cache_create_key(r);
        cache_run_remove_url(type, key);
    const char *key;
    cache_request_rec *cache = (cache_request_rec *) 
                         ap_get_module_config(r->request_config, &cache_module);
    key = cache_create_key(r);
        switch (rv = cache_run_create_entity(h, type, key, size)) {
    const char *key;
    cache_request_rec *cache = (cache_request_rec *) 
                         ap_get_module_config(r->request_config, &cache_module);
    key = cache_create_key(r);
        switch ((rv = cache_run_open_entity(cache->handle, type, key))) {
apr_status_t cache_write_entity_headers(cache_handle_t *h, 
                                        request_rec *r, 
                                        cache_info *info)
    h->write_headers(h, r, info);
apr_status_t cache_read_entity_headers(cache_handle_t *h, request_rec *r)
    h->read_headers(h, r);
    r->filename = apr_pstrdup(r->pool, info->filename );
const char* cache_create_key( request_rec *r ) 
{
    return r->uri;
}
                                      const char *urlkey, apr_size_t len),
                                      (h,type,urlkey,len),DECLINED)
                                      const char *urlkey),(h,type,urlkey),
                                      DECLINED)
                                    (const char *type, const char *urlkey),
                                    (type,urlkey),OK,DECLINED)
        return 1;
const char *ap_cache_get_cachetype(request_rec *r, 
                                   cache_server_conf *conf, 
                                   const char *url)
        struct cache_enable *ent = 
                                (struct cache_enable *)conf->cacheenable->elts;
        const char *thisurl = ent[i].url;
        const char *thistype = ent[i].type;
        if ((thisurl) && !strncasecmp(thisurl, url, strlen(thisurl))) {
            if (!type) {
                type = thistype;
            }
            else {
                type = apr_pstrcat(r->pool, type, ",", thistype, NULL);
            }
        }
        struct cache_disable *ent = 
                               (struct cache_disable *)conf->cachedisable->elts;
        const char *thisurl = ent[i].url;
        if ((thisurl) && !strncasecmp(thisurl, url, strlen(thisurl))) {
            type = NULL;
        }
        p = strchr((char *) list, ',');
        if (p != NULL) {
            i = p - list;
            do
            p++;
            while (ap_isspace(*p));
        }
        else
            i = strlen(list);

        while (i > 0 && ap_isspace(list[i - 1]))
            i--;
        if (i == len && strncasecmp(list, key, len) == 0) {
            if (val) {
            p = strchr((char *) list, ',');
            while (ap_isspace(*list)) {
                list++;
            }
            if ('=' == list[0])
                list++;
            while (ap_isspace(*list)) {
                list++;
            }
            strncpy(valbuf, list, MIN(p-list, sizeof(valbuf)-1));
            *val = valbuf;
            }
            return 1;
        }
        list = p;
        i = s - list;
        do
            s++;
        while (apr_isspace(*s))
            ; /* noop */
        i = strlen(list);
        i--;
        return apr_pstrndup(p, list, i);
        return NULL;
    cache_server_conf *conf = 
        (cache_server_conf *) ap_get_module_config(r->server->module_config, 
                                                   &cache_module);
    cache = (cache_request_rec *) ap_get_module_config(r->request_config, 
                                                       &cache_module);
                         "cache: fresh cache - add cache_out filter and "
                         "handle request");
                             "cache: error returned while trying to return %s "
                             "cached data", 
                             cache->type);
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
                             r->server,
                             "cache: conditional - add cache_in filter and "
                             "DECLINE");
                    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
                                 r->server,
                                 "cache: nonconditional - fudge conditional "
                                 "by etag");
                    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
                                 r->server,
                                 "cache: nonconditional - fudge conditional "
                                 "by lastmod");
                    apr_table_set(r->headers_in, 
                                  "If-Modified-Since", 
                                  info->lastmods);
                    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
                                 r->server,
                                 "cache: nonconditional - no cached "
                                 "etag/lastmods - add cache_in and DECLINE");
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
                             r->server,
                             "cache: nonconditional - add cache_conditional and"
                             " DECLINE");
                ap_add_output_filter("CACHE_CONDITIONAL", 
                                     NULL, 
                                     r, 
                                     r->connection);
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, 
                     r->server,
                     "cache: error returned while checking for cached file by "
                     "%s cache", 
                     cache->type);
    cache_request_rec *cache = 
        (cache_request_rec *) ap_get_module_config(r->request_config, 
                                                   &cache_module);
            "cache: running CACHE_OUT filter");
    cache_read_entity_headers(cache->handle, r);    
    /* have we already run the cachability check and set up the cached file 
     * handle? 
     */
         r->status != HTTP_MOVED_PERMANENTLY && 
         r->status != HTTP_NOT_MODIFIED) ||
    /* 200 OK response from HTTP/1.0 and up without a Last-Modified header/Etag 
     */
    /* XXX mod-include clears last_modified/expires/etags - this is why we have
     * a optional function for a key-gen ;-) 
     */
        (r->status == HTTP_OK && lastmods == NULL && etag == NULL 
            && (conf->no_last_mod_ignore ==0)) ||
        else {

            /* if we don't get the content-length, see if we have all the 
             * buckets and use their length to calculate the size 
             */
            apr_bucket *e;
            int all_buckets_here=0;
            size=0;
            APR_BRIGADE_FOREACH(e, in) {
                if (APR_BUCKET_IS_EOS(e)) {
                    all_buckets_here=1;
                    break;
                }
                if (APR_BUCKET_IS_FLUSH(e)) {
                    continue;
                }
                size += e->length;
            }

            if (!all_buckets_here) {
                size = -1;
            }
        }
    if (info->date == APR_DATE_BAD) {  /* No, or bad date */
        /* add one; N.B. use the time _now_ rather than when we were checking
         * the cache 
         */
        /* if its in the future, then replace by date */
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, 
                     r->server,
                     "cache: Last modified is in the future, "
                     "replacing with now");
    info->filename = apr_pstrdup(r->pool, r->filename );
    cache_write_entity_headers(cache->handle, r, info);
    ps->no_last_mod_ignore_set = 0;
    ps->no_last_mod_ignore = 0;
    ps->cacheon = 
        (overrides->cacheon_set == 0) ? base->cacheon : overrides->cacheon;
    ps->cachedisable = ap_append_arrays(p, 
                                        base->cachedisable, 
                                        overrides->cachedisable);
    ps->cacheenable = ap_append_arrays(p, 
                                       base->cacheenable, 
                                       overrides->cacheenable);
    ps->complete =
        (overrides->complete_set == 0) ? base->complete : overrides->complete;
    ps->no_last_mod_ignore =
        (overrides->no_last_mod_ignore_set) ? 
                    base->no_last_mod_ignore : 
                    overrides->no_last_mod_ignore;
static const char
*set_cache_ignore_no_last_mod( cmd_parms *parms, void *dummy, int flag)
{
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                   &cache_module);
    conf->no_last_mod_ignore = 1;
    conf->no_last_mod_ignore_set = 1;
    return NULL;

}
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config,
                                                   &cache_module);
*add_cache_enable(cmd_parms *parms, 
                  void *dummy, 
                  const char *type, 
                  const char *url)
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config,
                                                   &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                   &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config,
                                                   &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config,
                                                   &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                   &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                   &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                   &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, 
                                                   &cache_module);
     AP_INIT_TAKE1("CacheIgnoreNoLastMod", set_cache_ignore_no_last_mod, NULL, 
             RSRC_CONF, 
             "Ignore Responses where there is no Last Modified Header"),
     * XXX ianhH:they should run AFTER all the other content filters.
    ap_register_output_filter("CACHE_IN", 
                              ap_cache_in_filter, 
                              AP_FTYPE_CONTENT+1);
    ap_register_output_filter("CACHE_OUT", 
                              ap_cache_out_filter, 
                              AP_FTYPE_CONTENT+1);
    ap_register_output_filter("CACHE_CONDITIONAL", 
                              ap_cache_conditional_filter, 
                              AP_FTYPE_CONTENT+1);
    NULL,                   /* create per-directory config structure */
    NULL,                   /* merge per-directory config structures */
    create_cache_config,    /* create per-server config structure */
    merge_cache_config,     /* merge per-server config structures */
    cache_cmds,             /* command apr_table_t */
    apr_time_t defex;           /* default time to keep cached file in msecs */
    double factor;              /* factor for estimating expires date */
    int complete;               /* Force cache completion after this point */
    /* ignore the last-modified header when deciding to cache this request */
    int no_last_mod_ignore_set;
    int no_last_mod_ignore; 
    const char *lastmods;     /* last modified of cache entity */
    const char *filename;   
    int (*write_headers)(cache_handle_t *h, request_rec *r, cache_info *i);
    int (*read_headers) (cache_handle_t *h, request_rec *r);
/**
 * create a key for the cache based on the request record
 * this is the 'default' version, which can be overridden by a default function
 */
const char* cache_create_key( request_rec*r );
apr_status_t cache_write_entity_headers(cache_handle_t *h, request_rec *r, cache_info *info);
apr_status_t cache_read_entity_headers(cache_handle_t *h, request_rec *r);
                           const char *urlkey, apr_size_t len))
                           const char *urlkey))
                          (const char *type, const char *urlkey))
static apr_size_t max_cache_entry_size = 5000;
    apr_ssize_t num_header_out;
    apr_ssize_t num_subprocess_env;
    apr_ssize_t num_notes;
    cache_header_tbl_t *header_out;
    cache_header_tbl_t *subprocess_env;
    cache_header_tbl_t *notes;
static int write_headers(cache_handle_t *h, request_rec *r, cache_info *i);
static int read_headers(cache_handle_t *h, request_rec *r);
    /* XXX should freeing of the info be done here or in cache_storage ? 
    if (obj->info.content_type ) {
        free((char*)obj->info.content_type );
        obj->info.content_type =NULL;
    }
    if (obj->info.filename ) {
        free( (char*)obj->info.filename );
        obj->info.filename= NULL;
    }
    */
    if (mobj->num_header_out) {
static int create_entity(cache_handle_t *h, 
                         const char *type, 
                         const char *key, 
                         apr_size_t len) 
    if (len < 0 || len > max_cache_entry_size) {
    obj->vobj = mobj;    /* Reference the mem_cache_object_t out of 
                          * cache_object_t 
                          */
    tmp_obj = (cache_object_t *) apr_hash_get(sconf->cacheht, 
                                              key, 
                                              APR_HASH_KEY_STRING);
static int open_entity(cache_handle_t *h, const char *type, const char *key) 
    obj = (cache_object_t *) apr_hash_get(sconf->cacheht, 
                                          key, 
                                          APR_HASH_KEY_STRING);
static int serialize_table( cache_header_tbl_t **obj, 
                            int*nelts, 
                            apr_table_t *table) 
{
   apr_table_entry_t *elts = (apr_table_entry_t *) table->a.elts;
   apr_ssize_t i;
   apr_size_t len = 0;
   apr_size_t idx = 0;
   char *buf;
   
   *nelts = table->a.nelts;
   if (*nelts ==0 ) {
       *obj=NULL;
       return OK;
   }
    *obj = malloc(sizeof(cache_header_tbl_t) * table->a.nelts);
    if (NULL == *obj) {
        /* cleanup_cache_obj(h->cache_obj); */
        return DECLINED;
    }
    for (i = 0; i < table->a.nelts; ++i) {
        len += strlen(elts[i].key);
        len += strlen(elts[i].val);
        len += 2;  /* Extra space for NULL string terminator for key and val */
    }

    /* Transfer the headers into a contiguous memory block */
    buf = malloc(len);
    if (!buf) {
        free(obj);
        *obj = NULL;
        /* cleanup_cache_obj(h->cache_obj); */
        return DECLINED;
    }

    for (i = 0; i < *nelts; ++i) {
        (*obj)[i].hdr = &buf[idx];
        len = strlen(elts[i].key) + 1;              /* Include NULL terminator */
        strncpy(&buf[idx], elts[i].key, len);
        idx+=len;

        (*obj)[i].val = &buf[idx];
        len = strlen(elts[i].val) + 1;
        strncpy(&buf[idx], elts[i].val, len);
        idx+=len;
    }
    return OK;
 
}
static int unserialize_table( cache_header_tbl_t *ctbl, 
                              int num_headers, 
                              apr_table_t *t )
{
    int i;
    for (i = 0; i < num_headers; ++i) {
        apr_table_setn(t, ctbl[i].hdr, ctbl[i].val);
    } 

    return OK;
}
static int remove_url(const char *type, const char *key) 
    obj = (cache_object_t *) apr_hash_get(sconf->cacheht, 
                                          key, 
                                          APR_HASH_KEY_STRING);
static int read_headers(cache_handle_t *h, request_rec *r) 
    int rc;
    r->headers_out = apr_table_make(r->pool,mobj->num_header_out);
    r->subprocess_env = apr_table_make(r->pool, mobj->num_subprocess_env);
    r->notes = apr_table_make(r->pool, mobj->num_notes);
    rc = unserialize_table( mobj->header_out,
                            mobj->num_header_out, 
                            r->headers_out);
    rc = unserialize_table( mobj->subprocess_env, 
                            mobj->num_subprocess_env, 
                            r->subprocess_env);
    rc = unserialize_table( mobj->notes,
                            mobj->num_notes,
                            r->notes);
    return rc;

static int write_headers(cache_handle_t *h, request_rec *r, cache_info *info)
    int rc;
    rc = serialize_table(&mobj->header_out, 
                         &mobj->num_header_out, 
                         r->headers_out);   
    if (rc != OK ) {
        return rc;
    rc = serialize_table(&mobj->subprocess_env,
                         &mobj->num_subprocess_env, 
                         r->subprocess_env );
    if (rc != OK ) {
        return rc;
    rc = serialize_table(&mobj->notes, &mobj->num_notes, r->notes);
    if (rc != OK ) {
        return rc;
 
    if ( info->filename) {
        obj->info.filename = (char*) malloc(strlen(info->filename )+1);
        if (!obj->info.filename ) {
            free( (char*)obj->info.content_type );
            obj->info.content_type =NULL;
            return DECLINED;
        }
        strcpy((char*) obj->info.filename, info->filename );
    }
static const char 
*set_cache_entry_size(cmd_parms *parms, void *in_struct_ptr, const char *arg)
    int val;
    if (sscanf(arg, "%d", &val) != 1) {
        return "CacheSize value must be an integer (bytes)";
    }
    max_cache_entry_size = val;
    AP_INIT_TAKE1("CacheMemSize", set_cache_size, NULL, RSRC_CONF,
     "The maximum space used by the cache in Kb"),
    AP_INIT_TAKE1("CacheMemEntrySize", set_cache_entry_size, NULL, RSRC_CONF,
     "The maximum size (in bytes) that a entry can take"),
        unsigned skip;
        else if ((skip = is_absolute_uri(r->filename)) > 0) {
            if (rulestatus != ACTION_NOESCAPE) {
                rewritelog(r, 1, "escaping %s for redirect", r->filename);
                r->filename = escape_absolute_uri(r->pool, r->filename, skip);
            if (r->args) {
                                          (rulestatus == ACTION_NOESCAPE)
                                            ? r->args
                                            : ap_escape_uri(r->pool, r->args),
                                          NULL);
        unsigned skip;
        else if ((skip = is_absolute_uri(r->filename)) > 0) {
                /* skip 'scheme://' */
                cp = r->filename + skip;

            if (rulestatus != ACTION_NOESCAPE) {
                rewritelog(r, 1, "[per-dir %s] escaping %s for redirect",
                           dconf->directory, r->filename);
                r->filename = escape_absolute_uri(r->pool, r->filename, skip);
            if (r->args) {
                                          (rulestatus == ACTION_NOESCAPE)
                                            ? r->args
                                            : ap_escape_uri(r->pool, r->args),
                                          NULL);
    /* don't touch, unless it's an http or mailto URL.
     * See RFC 1738 and RFC 2368.
     */
    if (   is_absolute_uri(r->filename)
        && strncasecmp(r->filename, "http", 4)
        && strncasecmp(r->filename, "mailto", 6)) {
        r->args = NULL; /* forget the query that's still flying around */
        return;
    }


/* return number of chars of the scheme (incl. '://')
 * if the URI is absolute (includes a scheme etc.)
 * otherwise 0.
 *
 * NOTE: If you add new schemes here, please have a
 *       look at escape_absolute_uri and splitout_queryargs.
 *       Not every scheme takes query strings and some schemes
 *       may be handled in a special way.
 *
 * XXX: we should consider a scheme registry, perhaps with
 *      appropriate escape callbacks to allow other modules
 *      to extend mod_rewrite at runtime.
 */
static unsigned is_absolute_uri(char *uri)
{
    /* fast exit */
    if (*uri == '/' || strlen(uri) <= 5) {
        return 0;
    }

    switch (*uri++) {
    case 'f':
    case 'F':
        if (!strncasecmp(uri, "tp://", 5)) {        /* ftp://    */
            return 6;
        }
        break;
    case 'g':
    case 'G':
        if (!strncasecmp(uri, "opher://", 8)) {     /* gopher:// */
            return 9;
        }
        break;

    case 'h':
    case 'H':
        if (!strncasecmp(uri, "ttp://", 6)) {       /* http://   */
            return 7;
        }
        else if (!strncasecmp(uri, "ttps://", 7)) { /* https://  */
            return 8;
        }
        break;

    case 'l':
    case 'L':
        if (!strncasecmp(uri, "dap://", 6)) {       /* ldap://   */
            return 7;
        }
        break;

    case 'm':
    case 'M':
        if (!strncasecmp(uri, "ailto:", 6)) {       /* mailto:   */
            return 7;
        }
        break;

    case 'n':
    case 'N':
        if (!strncasecmp(uri, "ews:", 4)) {         /* news:     */
            return 5;
        }
        else if (!strncasecmp(uri, "ntp://", 6)) {  /* nntp://   */
            return 7;
        }
        break;
    }

    return 0;
}


/* escape absolute uri, which may or may not be path oriented.
 * So let's handle them differently.
 */
static char *escape_absolute_uri(apr_pool_t *p, char *uri, unsigned scheme)
    char *cp;

    /* be safe.
     * NULL should indicate elsewhere, that something's wrong
     */
    if (!scheme || strlen(uri) < scheme) {
        return NULL;

    cp = uri + scheme;

    /* scheme with authority part? */
    if (cp[-1] == '/') {
        /* skip host part */
        while (*cp && *cp != '/') {
            ++cp;
        }

        /* nothing after the hostpart. ready! */
        if (!*cp || !*++cp) {
            return apr_pstrdup(p, uri);
        }

        /* remember the hostname stuff */
        scheme = cp - uri;

        /* special thing for ldap.
         * The parts are separated by question marks. From RFC 2255:
         *     ldapurl = scheme "://" [hostport] ["/"
         *               [dn ["?" [attributes] ["?" [scope]
         *               ["?" [filter] ["?" extensions]]]]]]
         */
        if (!strncasecmp(uri, "ldap", 4)) {
            char *token[5];
            int c = 0;

            token[0] = cp = apr_pstrdup(p, cp);
            while (*cp && c < 5) {
                if (*cp == '?') {
                    token[++c] = cp + 1;
                    *cp = '\0';
                }
                ++cp;
            }

            return apr_pstrcat(p, apr_pstrndup(p, uri, scheme),
                                          ap_escape_uri(p, token[0]),
                               (c >= 1) ? "?" : NULL,
                               (c >= 1) ? ap_escape_uri(p, token[1]) : NULL,
                               (c >= 2) ? "?" : NULL,
                               (c >= 2) ? ap_escape_uri(p, token[2]) : NULL,
                               (c >= 3) ? "?" : NULL,
                               (c >= 3) ? ap_escape_uri(p, token[3]) : NULL,
                               (c >= 4) ? "?" : NULL,
                               (c >= 4) ? ap_escape_uri(p, token[4]) : NULL,
                               NULL);
        }

    /* Nothing special here. Apply normal escaping. */
    return apr_pstrcat(p, apr_pstrndup(p, uri, scheme),
                       ap_escape_uri(p, cp), NULL);
static unsigned is_absolute_uri(char *uri);
static char *escape_absolute_uri(apr_pool_t *p, char *uri, unsigned scheme);
typedef struct
{
    const char *name;           /* matching module name */
    const char *info;           /* additional info */
typedef struct
{
static void *create_info_config(apr_pool_t * p, server_rec *s)
    info_svr_conf *conf =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t * p, void *basev, void *overridesv)
    info_svr_conf *new =
        (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info =
        apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec *r, int nest, const char *thisfn,
                            int linenum)
    const char *prevfn =
        ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL)
        thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n",
                   thisfn);
    if (linenum > 0)
        sprintf(buf, "%d", linenum);
    else
        buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i)
        ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i)
        ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec *r, const ap_directive_t * dir,
                              int nest)
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec *r, const ap_directive_t * dir,
                               int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n",
               ap_escape_html(r->pool, dir->directive),
               ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec *r, const ap_directive_t * dir,
    }
    else {
        ap_rprintf(r, "/%s</tt></dd>", ap_escape_html(r->pool, dirname));
    }

static int mod_info_has_cmd(const command_rec *cmds, ap_directive_t * dir)
    const command_rec *cmd;
    if (cmds == NULL)
        return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0)
            return 1;
    }
static void mod_info_show_parents(request_rec *r, ap_directive_t * node,
                                  int from, int to)
{
    if (from < to)
        mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec *r, const command_rec *cmds,
    ap_directive_t *dir;
    if (level == 0)
        ap_set_module_config(r->request_config, &info_module, NULL);
                                             shown, level + 1)) {
        }
        else if (mod_info_has_cmd(cmds, dir)) {
        }
typedef struct
{                               /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc) (void);       /* just to get the right size */
    const char *const *aszPredecessors;
    const char *const *aszSuccessors;
typedef apr_array_header_t *(
                                __stdcall
                                * hook_get_t)      (void);
typedef struct
{
static int module_find_hook(module *modp, hook_get_t hook_get)
    elts = (hook_struct_t *) hooks->elts;
    for (i = 0; i < hooks->nelts; i++) {
                               hook_lookup_t * lookup, int *comma)
    int i, comma = 0;
    for (i = 0; request_hooks[i].name; i++) {
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
        return DECLINED;
             "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n",
             r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ",
                     r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name,
                           modp->name);
            ap_rprintf(r,
                       "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                       ap_get_server_version());
            ap_rprintf(r,
                       "<dt><strong>Server Built:</strong> "
                       "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                       ap_get_server_built());
            ap_rprintf(r,
                       "<dt><strong>API Version:</strong> "
                       "<tt>%d:%d</tt></dt>\n", MODULE_MAGIC_NUMBER_MAJOR,
                       MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r,
                       "<dt><strong>Hostname/port:</strong> "
                       "<tt>%s:%u</tt></dt>\n", ap_get_server_name(r),
                       ap_get_server_port(r));
            ap_rprintf(r,
                       "<dt><strong>Timeouts:</strong> "
                       "<tt>connection: %d &nbsp;&nbsp; "
                       "keep-alive: %d</tt></dt>",
                       (int) (apr_time_sec(serv->timeout)),
                       (int) (apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n",
                       ap_show_mpm());
            ap_rprintf(r,
                       "<dt><strong>MPM Information:</strong> "
                       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r,
                       "<dt><strong>Server Root:</strong> "
                       "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r,
                       "<dt><strong>Config File:</strong> "
                       "<tt>%s</tt></dt>\n", ap_conftree->filename);
            for (modp = ap_top_module; modp; modp = modp->next) {
                if (!r->args || !strcasecmp(modp->name, r->args)) {
                    ap_rprintf(r,
                               "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                               "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                               modp->name, modp->name);
                    ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                    hand = modp->handlers;
                    if (hand) {
                        while (hand) {
                            if (hand->content_type) {
                                ap_rprintf(r, " <tt>%s</tt>\n",
                                           hand->content_type);
                            }
                            else {
                                break;
                            }
                            hand++;
                            if (hand && hand->content_type) {
                                ap_rputs(",", r);
                            }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    if (module_find_hook(modp, ap_hook_get_handler)) {
                        ap_rputs("<tt> <em>yes</em></tt>", r);
                    }
                    else {
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    }
                    ap_rputs("</dt>", r);
                    ap_rputs
                        ("<dt><strong>Configuration Phase Participation:</strong>\n",
                         r);
                    if (modp->create_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Directory Config</tt>", r);
                        comma = 1;
                    if (modp->merge_dir_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Directory Configs</tt>", r);
                        comma = 1;
                    if (modp->create_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Create Server Config</tt>", r);
                        comma = 1;
                    if (modp->merge_server_config) {
                        if (comma) {
                            ap_rputs(", ", r);
                        }
                        ap_rputs("<tt>Merge Server Configs</tt>", r);
                        comma = 1;
                    if (!comma)
                        ap_rputs("<tt> <em>none</em></tt>", r);
                    comma = 0;
                    ap_rputs("</dt>", r);

                    module_request_hook_participate(r, modp);

                    cmd = modp->cmds;
                    if (cmd) {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong></dt>",
                             r);
                        while (cmd) {
                            if (cmd->name) {
                                ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                           ap_escape_html(r->pool, cmd->name),
                                           cmd->name[0] == '<' ? "&gt;" : "");
                                if (cmd->errmsg) {
                                    ap_rputs(cmd->errmsg, r);
                                }
                                ap_rputs("</i></tt></dd>\n", r);
                            else {
                                break;
                            }
                            cmd++;
                        ap_rputs
                            ("<dt><strong>Current Configuration:</strong></dt>\n",
                             r);
                        mod_info_module_cmds(r, modp->cmds, ap_conftree, 0,
                                             0);
                    }
                    else {
                        ap_rputs
                            ("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>",
                             r);
                    }
                    more_info = find_more_info(serv, modp->name);
                    if (more_info) {
                        ap_rputs
                            ("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                             r);
                        ap_rputs(more_info, r);
                        ap_rputs("</dd>", r);
                    }
                    ap_rputs("</dl><hr />\n", r);
                    if (r->args) {
                        break;
            if (!modp && r->args && strcasecmp(r->args, "server")) {
                ap_rputs("<p><b>No such module</b></p>\n", r);
            }
    ap_rputs(ap_psignature("", r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy,
    info_svr_conf *conf =
        (info_svr_conf *) ap_get_module_config(s->module_config,
                                               &info_module);
static const command_rec info_cmds[] = {
static void register_hooks(apr_pool_t * p)
module AP_MODULE_DECLARE_DATA info_module = {
        if (sc->server) {
            sc->server->sc = sc;
        }

                                  modssl_ctx_t *mctx)
    if (!mctx->pks->cert_files[0]) {
    if (mctx->pks->certs[SSL_AIDX_RSA] ||
        mctx->pks->certs[SSL_AIDX_DSA])
static void ssl_init_ctx(server_rec *s,
                         apr_pool_t *p,
                         apr_pool_t *ptemp,
                         modssl_ctx_t *mctx)
    int protocol = mctx->protocol;
    mctx->ssl_ctx = ctx;
                                       modssl_ctx_t *mctx)
    SSL_CTX *ctx = mctx->ssl_ctx;
                                   modssl_ctx_t *mctx)
    SSL_CTX *ctx = mctx->ssl_ctx;
    if (mctx->sc->log_level >= SSL_LOG_INFO) {
                                modssl_ctx_t *mctx)
    SSL_CTX *ctx = mctx->ssl_ctx;
    if (mctx->auth.verify_mode == SSL_CVERIFY_UNSET) {
        mctx->auth.verify_mode = SSL_CVERIFY_NONE;
    if (mctx->auth.verify_depth == UNSET) {
        mctx->auth.verify_depth = 1;
    if (mctx->auth.verify_mode == SSL_CVERIFY_REQUIRE) {
    if ((mctx->auth.verify_mode == SSL_CVERIFY_OPTIONAL) ||
        (mctx->auth.verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA))
    if (mctx->auth.ca_cert_file || mctx->auth.ca_cert_path) {
                                           mctx->auth.ca_cert_file,
                                           mctx->auth.ca_cert_path))
                                      mctx->auth.ca_cert_file,
                                      mctx->auth.ca_cert_path);
    if (mctx->auth.verify_mode == SSL_CVERIFY_REQUIRE) {
                                      modssl_ctx_t *mctx)
    SSL_CTX *ctx = mctx->ssl_ctx;
    const char *suite = mctx->auth.cipher_suite;
                             modssl_ctx_t *mctx)
    if (!(mctx->crl_file || mctx->crl_path)) {
    mctx->crl =
        SSL_X509_STORE_create((char *)mctx->crl_file,
                              (char *)mctx->crl_path);
    if (!mctx->crl) {
                                    modssl_ctx_t *mctx)
    const char *chain = mctx->cert_chain;
    for (i = 0; (i < SSL_AIDX_MAX) && mctx->pks->cert_files[i]; i++) {
        if (strEQ(mctx->pks->cert_files[i], chain)) {
    n = SSL_CTX_use_certificate_chain(mctx->ssl_ctx,
                                  modssl_ctx_t *mctx,
    if (SSL_CTX_use_certificate(mctx->ssl_ctx, cert) <= 0) {
    mctx->pks->certs[idx] = cert;
                                 modssl_ctx_t *mctx,
    if (SSL_CTX_use_PrivateKey(mctx->ssl_ctx, pkey) <= 0) {
    if ((pkey_type == EVP_PKEY_DSA) && mctx->pks->certs[idx]) {
        EVP_PKEY *pubkey = X509_get_pubkey(mctx->pks->certs[idx]);
    mctx->pks->keys[idx] = pkey;
                                  modssl_ctx_t *mctx)
    const char *vhost_id = mctx->sc->vhost_id;
    have_rsa = ssl_server_import_cert(s, mctx, rsa_id, SSL_AIDX_RSA);
    have_dsa = ssl_server_import_cert(s, mctx, dsa_id, SSL_AIDX_DSA);
        ssl_check_public_cert(s, ptemp, mctx->pks->certs[i], i);
    have_rsa = ssl_server_import_key(s, mctx, rsa_id, SSL_AIDX_RSA);
    have_dsa = ssl_server_import_key(s, mctx, dsa_id, SSL_AIDX_DSA);
    ssl_init_server_check(s, p, ptemp, sc->server);
    ssl_init_ctx(s, p, ptemp, sc->server);
    ssl_init_ctx_session_cache(s, p, ptemp, sc->server);
    ssl_init_ctx_callbacks(s, p, ptemp, sc->server);
    ssl_init_ctx_verify(s, p, ptemp, sc->server);
    ssl_init_ctx_cipher_suite(s, p, ptemp, sc->server);
    ssl_init_ctx_crl(s, p, ptemp, sc->server);
    ssl_init_ctx_cert_chain(s, p, ptemp, sc->server);
    ssl_init_server_certs(s, p, ptemp, sc->server);
static void recalc_factors(proxy_balancer *balancer,
                           proxy_runtime_worker *fixed)
{
    int i;
    double median, ffactor = 0.0;
    proxy_runtime_worker *workers;    


    /* Recalculate lbfactors */
    workers = (proxy_runtime_worker *)balancer->workers->elts;
    /* Special case if there is only one worker it's
     * load factor will always be 100
     */
    if (balancer->workers->nelts == 1) {
        workers->s->lbstatus = workers->s->lbfactor = 100.0;
        return;
    }
    for (i = 0; i < balancer->workers->nelts; i++) {
        if (workers[i].s->lbfactor > 100.0)
            workers[i].s->lbfactor = 100.0;
        ffactor += workers[i].s->lbfactor;
    }
    if (ffactor < 100.0) {
        median = (100.0 - ffactor) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (&(workers[i]) != fixed)
                workers[i].s->lbfactor += median;
        }
    }
    else if (fixed->s->lbfactor < 100.0) {
        median = (ffactor - 100.0) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (workers[i].s->lbfactor > median &&
                &(workers[i]) != fixed)
                workers[i].s->lbfactor -= median;
        }
    } 
    else {
        median = (ffactor - 100.0) / balancer->workers->nelts;
        for (i = 0; i < balancer->workers->nelts; i++) {
            workers[i].s->lbfactor -= median;
        }
    } 
    for (i = 0; i < balancer->workers->nelts; i++) {
        /* Update the status entires */
        workers[i].s->lbstatus = workers[i].s->lbfactor;
    }
}

/* Invoke handler */
static int balancer_handler(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *conf = (proxy_server_conf *)
        ap_get_module_config(sconf, &proxy_module);
    apr_array_header_t *proxies = conf->proxies;
    struct proxy_remote *ents = (struct proxy_remote *)proxies->elts;
    proxy_balancer *balancer, *bsel = NULL;
    proxy_runtime_worker *worker, *wsel = NULL;
    apr_table_t *params = apr_table_make(r->pool, 10);
    int access_status;
    int i, n;
    const char *name;

    /* is this for us? */
    if (strcmp(r->handler, "balancer-manager"))
        return DECLINED;
    r->allowed = (AP_METHOD_BIT << M_GET);
    if (r->method_number != M_GET)
        return DECLINED;

    if (r->args) {
        char *args = apr_pstrdup(r->pool, r->args);
        char *tok, *val;
        while (args && *args) {
            if ((val = ap_strchr_c(args, '='))) {
                *val++ = '\0';
                if ((tok = ap_strchr_c(val, '&')))
                    *tok++ = '\0';
                if ((access_status = ap_unescape_url(val)) != OK)
                    return access_status;
                apr_table_setn(params, args, val);
                args = tok;
            }
            else
                return HTTP_BAD_REQUEST;
        }
    }
    if ((name = apr_table_get(params, "b")))
        bsel = ap_proxy_get_balancer(r->pool, conf,
            apr_pstrcat(r->pool, "balancer://", name, NULL));
    if ((name = apr_table_get(params, "w"))) {
        const char *sc = apr_table_get(params, "s");
        char *asname = NULL;
        proxy_worker *ws = NULL;
        if (sc) {
            asname = apr_pstrcat(r->pool, sc, "://", name, NULL);
            ws = ap_proxy_get_worker(r->pool, conf, asname);
        }
        if (ws) {
            worker = (proxy_runtime_worker *)bsel->workers->elts;
            for (n = 0; n < bsel->workers->nelts; n++) {
                if (strcasecmp(worker->w->name, ws->name) == 0) {
                    wsel = worker;
                    break;
                }
                ++worker;
            }
        }
    }
    /* First set the params */
    if (bsel) {
        const char *val;
        if ((val = apr_table_get(params, "ss"))) {
            if (strlen(val))
                bsel->sticky = apr_pstrdup(conf->pool, val);
            else
                bsel->sticky = NULL;
        }
        if ((val = apr_table_get(params, "tm"))) {
            int ival = atoi(val);
            if (ival >= 0)
                bsel->timeout = apr_time_from_sec(ival);
        }
    }
    if (wsel) {
        const char *val;
        if ((val = apr_table_get(params, "lf"))) {
            char *ep;
            double dval = strtod(val, &ep);
            if (dval > 1) {
                wsel->s->lbfactor = dval;
                if (bsel)
                    recalc_factors(bsel, wsel);
            }
        }
        if ((val = apr_table_get(params, "wr"))) {
            if (strlen(val))
                wsel->w->route = apr_pstrdup(conf->pool, val);
            else
                wsel->w->route = NULL;
        }
        if ((val = apr_table_get(params, "rr"))) {
            if (strlen(val))
                wsel->w->redirect = apr_pstrdup(conf->pool, val);
            else
                wsel->w->redirect = NULL;
        }
        if ((val = apr_table_get(params, "dw")))
            wsel->w->status |= PROXY_WORKER_DISABLED;
        else
            wsel->w->status &= ~PROXY_WORKER_DISABLED;

    }
    if (apr_table_get(params, "xml")) {
        ap_set_content_type(r, "text/xml");
        ap_rputs("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n", r);
        ap_rputs("<httpd:manager xmlns:httpd=\"http://httpd.apache.org\">\n", r);
        ap_rputs("  <httpd:balancers>\n", r);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("    <httpd:balancer>\n", r);
            ap_rvputs(r, "      <httpd:name>", balancer->name, "</httpd:name>\n", NULL);
            ap_rputs("      <httpd:workers>\n", r);
            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {
                ap_rputs("        <httpd:worker>\n", r);
                ap_rvputs(r, "          <httpd:scheme>", worker->w->scheme,
                          "</httpd:scheme>\n", NULL);                
                ap_rvputs(r, "          <httpd:hostname>", worker->w->hostname,
                          "</httpd:hostname>\n", NULL);                
               ap_rprintf(r, "          <httpd:loadfactor>%.2f</httpd:loadfactor>\n",
                          worker->s->lbfactor);
                ap_rputs("        </httpd:worker>\n", r);
                ++worker;
            }
            ap_rputs("      </httpd:workers>\n", r);
            ap_rputs("    </httpd:balancer>\n", r);
            ++balancer;
        }
        ap_rputs("  </httpd:balancers>\n", r);
        ap_rputs("</httpd:manager>", r);         
    }
    else {
        ap_set_content_type(r, "text/html");
        ap_rputs(DOCTYPE_HTML_3_2
                 "<html><head><title>Balancer Manager</title></head>\n", r);
        ap_rputs("<body><h1>Load Balancer Manager for ", r);
        ap_rvputs(r, ap_get_server_name(r), "</h1>\n\n", NULL);
        ap_rvputs(r, "<dl><dt>Server Version: ",
                  ap_get_server_version(), "</dt>\n", NULL);
        ap_rvputs(r, "<dt>Server Built: ",
                  ap_get_server_built(), "\n</dt></dl>\n", NULL);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("<hr />\n<h3>LoadBalancer Status for ", r);
            ap_rvputs(r, "<a href=\"", r->uri, "?b=",
                      balancer->name + sizeof("balancer://") - 1,
                      "\">", NULL); 
            ap_rvputs(r, balancer->name, "</a></h3>\n\n", NULL);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>StickySesion</th><th>Timeout</th>"
                "</tr>\n<tr>", r);                
            ap_rvputs(r, "<td>", balancer->sticky, NULL);
            ap_rprintf(r, "</td><td>%" APR_TIME_T_FMT "</td>\n",
                apr_time_sec(balancer->timeout));
            ap_rputs("</table>\n", r);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>Scheme</th><th>Host</th>"
                "<th>Route</th><th>RouteRedir</th>"
                "<th>Factor</th><th>Status</th>"
                "</tr>\n", r);

            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {

                ap_rvputs(r, "<tr>\n<td>", worker->w->scheme, "</td><td>", NULL);
                ap_rvputs(r, "<a href=\"", r->uri, "?b=", 
                          balancer->name + sizeof("balancer://") - 1,
                          "&s=", worker->w->scheme, "&w=", worker->w->hostname,
                          "\">", NULL); 
                ap_rvputs(r, worker->w->hostname, "</a></td>", NULL);
                ap_rvputs(r, "<td>", worker->w->route, NULL);
                ap_rvputs(r, "</td><td>", worker->w->redirect, NULL);
                ap_rprintf(r, "</td><td>%.2f</td><td>", worker->s->lbfactor);
                if (worker->w->status & PROXY_WORKER_DISABLED)
                    ap_rputs("Dis", r);
                else if (worker->w->status & PROXY_WORKER_IN_ERROR)
                    ap_rputs("Err", r);
                else if (worker->w->status & PROXY_WORKER_INITIALIZED)
                    ap_rputs("Ok", r);
                else
                    ap_rputs("-", r);
                ap_rputs("</td></tr>\n", r);

                ++worker;
            }
            ap_rputs("</table>\n", r);
            ++balancer;
        }
        ap_rputs("<hr />\n", r);
        if (wsel && bsel) {
            ap_rputs("<h3>Edit worker settings for ", r);
            ap_rvputs(r, wsel->w->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>Load factor:</td><td><input name=\"lf\" type=text ", r);
            ap_rprintf(r, "value=\"%.2f\"></td><tr>\n", wsel->s->lbfactor);            
            ap_rputs("<tr><td>Route:</td><td><input name=\"wr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->route, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Route Redirect:</td><td><input name=\"rr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->redirect, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Disabled:</td><td><input name=\"dw\" type=checkbox", r);
            if (wsel->w->status & PROXY_WORKER_DISABLED)
                ap_rputs(" checked", r);
            ap_rputs("></td><tr>\n", r);            
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"s\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->scheme, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"w\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->hostname, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        else if (bsel) {
            ap_rputs("<h3>Edit balancer settings for ", r);
            ap_rvputs(r, bsel->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>StickySession Identifier:</td><td><input name=\"ss\" type=text ", r);
            if (bsel->sticky)
                ap_rvputs(r, "value=\"", bsel->sticky, "\"", NULL);
            ap_rputs("></td><tr>\n<tr><td>Timeout:</td><td><input name=\"tm\" type=text ", r);
            ap_rprintf(r, "value=\"%" APR_TIME_T_FMT "\"></td></tr>\n",
                       apr_time_sec(bsel->timeout));
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        ap_rputs(ap_psignature("",r), r);
        ap_rputs("</body></html>\n", r);
    }
    return OK;
}

    /* manager handler */
    ap_hook_handler(balancer_handler, NULL, NULL, APR_HOOK_FIRST);
static void recalc_factors(proxy_balancer *balancer,
                           proxy_runtime_worker *fixed)
{
    int i;
    double median, ffactor = 0.0;
    proxy_runtime_worker *workers;    


    /* Recalculate lbfactors */
    workers = (proxy_runtime_worker *)balancer->workers->elts;
    /* Special case if there is only one worker it's
     * load factor will always be 100
     */
    if (balancer->workers->nelts == 1) {
        workers->s->lbstatus = workers->s->lbfactor = 100.0;
        return;
    }
    for (i = 0; i < balancer->workers->nelts; i++) {
        if (workers[i].s->lbfactor > 100.0)
            workers[i].s->lbfactor = 100.0;
        ffactor += workers[i].s->lbfactor;
    }
    if (ffactor < 100.0) {
        median = (100.0 - ffactor) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (&(workers[i]) != fixed)
                workers[i].s->lbfactor += median;
        }
    }
    else if (fixed->s->lbfactor < 100.0) {
        median = (ffactor - 100.0) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (workers[i].s->lbfactor > median &&
                &(workers[i]) != fixed)
                workers[i].s->lbfactor -= median;
        }
    } 
    else {
        median = (ffactor - 100.0) / balancer->workers->nelts;
        for (i = 0; i < balancer->workers->nelts; i++) {
            workers[i].s->lbfactor -= median;
        }
    } 
    for (i = 0; i < balancer->workers->nelts; i++) {
        /* Update the status entires */
        workers[i].s->lbstatus = workers[i].s->lbfactor;
    }
}

/* Invoke handler */
static int balancer_handler(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *conf = (proxy_server_conf *)
        ap_get_module_config(sconf, &proxy_module);
    apr_array_header_t *proxies = conf->proxies;
    struct proxy_remote *ents = (struct proxy_remote *)proxies->elts;
    proxy_balancer *balancer, *bsel = NULL;
    proxy_runtime_worker *worker, *wsel = NULL;
    apr_table_t *params = apr_table_make(r->pool, 10);
    int access_status;
    int i, n;
    const char *name;

    /* is this for us? */
    if (strcmp(r->handler, "balancer-manager"))
        return DECLINED;
    r->allowed = (AP_METHOD_BIT << M_GET);
    if (r->method_number != M_GET)
        return DECLINED;

    if (r->args) {
        char *args = apr_pstrdup(r->pool, r->args);
        char *tok, *val;
        while (args && *args) {
            if ((val = ap_strchr_c(args, '='))) {
                *val++ = '\0';
                if ((tok = ap_strchr_c(val, '&')))
                    *tok++ = '\0';
                if ((access_status = ap_unescape_url(val)) != OK)
                    return access_status;
                apr_table_setn(params, args, val);
                args = tok;
            }
            else
                return HTTP_BAD_REQUEST;
        }
    }
    if ((name = apr_table_get(params, "b")))
        bsel = ap_proxy_get_balancer(r->pool, conf,
            apr_pstrcat(r->pool, "balancer://", name, NULL));
    if ((name = apr_table_get(params, "w"))) {
        const char *sc = apr_table_get(params, "s");
        char *asname = NULL;
        proxy_worker *ws = NULL;
        if (sc) {
            asname = apr_pstrcat(r->pool, sc, "://", name, NULL);
            ws = ap_proxy_get_worker(r->pool, conf, asname);
        }
        if (ws) {
            worker = (proxy_runtime_worker *)bsel->workers->elts;
            for (n = 0; n < bsel->workers->nelts; n++) {
                if (strcasecmp(worker->w->name, ws->name) == 0) {
                    wsel = worker;
                    break;
                }
                ++worker;
            }
        }
    }
    /* First set the params */
    if (bsel) {
        const char *val;
        if ((val = apr_table_get(params, "ss"))) {
            if (strlen(val))
                bsel->sticky = apr_pstrdup(conf->pool, val);
            else
                bsel->sticky = NULL;
        }
        if ((val = apr_table_get(params, "tm"))) {
            int ival = atoi(val);
            if (ival >= 0)
                bsel->timeout = apr_time_from_sec(ival);
        }
    }
    if (wsel) {
        const char *val;
        if ((val = apr_table_get(params, "lf"))) {
            char *ep;
            double dval = strtod(val, &ep);
            if (dval > 1) {
                wsel->s->lbfactor = dval;
                if (bsel)
                    recalc_factors(bsel, wsel);
            }
        }
        if ((val = apr_table_get(params, "wr"))) {
            if (strlen(val))
                wsel->w->route = apr_pstrdup(conf->pool, val);
            else
                wsel->w->route = NULL;
        }
        if ((val = apr_table_get(params, "rr"))) {
            if (strlen(val))
                wsel->w->redirect = apr_pstrdup(conf->pool, val);
            else
                wsel->w->redirect = NULL;
        }
        if ((val = apr_table_get(params, "dw")))
            wsel->w->status |= PROXY_WORKER_DISABLED;
        else
            wsel->w->status &= ~PROXY_WORKER_DISABLED;

    }
    if (apr_table_get(params, "xml")) {
        ap_set_content_type(r, "text/xml");
        ap_rputs("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n", r);
        ap_rputs("<httpd:manager xmlns:httpd=\"http://httpd.apache.org\">\n", r);
        ap_rputs("  <httpd:balancers>\n", r);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("    <httpd:balancer>\n", r);
            ap_rvputs(r, "      <httpd:name>", balancer->name, "</httpd:name>\n", NULL);
            ap_rputs("      <httpd:workers>\n", r);
            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {
                ap_rputs("        <httpd:worker>\n", r);
                ap_rvputs(r, "          <httpd:scheme>", worker->w->scheme,
                          "</httpd:scheme>\n", NULL);                
                ap_rvputs(r, "          <httpd:hostname>", worker->w->hostname,
                          "</httpd:hostname>\n", NULL);                
               ap_rprintf(r, "          <httpd:loadfactor>%.2f</httpd:loadfactor>\n",
                          worker->s->lbfactor);
                ap_rputs("        </httpd:worker>\n", r);
                ++worker;
            }
            ap_rputs("      </httpd:workers>\n", r);
            ap_rputs("    </httpd:balancer>\n", r);
            ++balancer;
        }
        ap_rputs("  </httpd:balancers>\n", r);
        ap_rputs("</httpd:manager>", r);         
    }
    else {
        ap_set_content_type(r, "text/html");
        ap_rputs(DOCTYPE_HTML_3_2
                 "<html><head><title>Balancer Manager</title></head>\n", r);
        ap_rputs("<body><h1>Load Balancer Manager for ", r);
        ap_rvputs(r, ap_get_server_name(r), "</h1>\n\n", NULL);
        ap_rvputs(r, "<dl><dt>Server Version: ",
                  ap_get_server_version(), "</dt>\n", NULL);
        ap_rvputs(r, "<dt>Server Built: ",
                  ap_get_server_built(), "\n</dt></dl>\n", NULL);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("<hr />\n<h3>LoadBalancer Status for ", r);
            ap_rvputs(r, "<a href=\"", r->uri, "?b=",
                      balancer->name + sizeof("balancer://") - 1,
                      "\">", NULL); 
            ap_rvputs(r, balancer->name, "</a></h3>\n\n", NULL);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>StickySesion</th><th>Timeout</th>"
                "</tr>\n<tr>", r);                
            ap_rvputs(r, "<td>", balancer->sticky, NULL);
            ap_rprintf(r, "</td><td>%" APR_TIME_T_FMT "</td>\n",
                apr_time_sec(balancer->timeout));
            ap_rputs("</table>\n", r);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>Scheme</th><th>Host</th>"
                "<th>Route</th><th>RouteRedir</th>"
                "<th>Factor</th><th>Status</th>"
                "</tr>\n", r);

            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {

                ap_rvputs(r, "<tr>\n<td>", worker->w->scheme, "</td><td>", NULL);
                ap_rvputs(r, "<a href=\"", r->uri, "?b=", 
                          balancer->name + sizeof("balancer://") - 1,
                          "&s=", worker->w->scheme, "&w=", worker->w->hostname,
                          "\">", NULL); 
                ap_rvputs(r, worker->w->hostname, "</a></td>", NULL);
                ap_rvputs(r, "<td>", worker->w->route, NULL);
                ap_rvputs(r, "</td><td>", worker->w->redirect, NULL);
                ap_rprintf(r, "</td><td>%.2f</td><td>", worker->s->lbfactor);
                if (worker->w->status & PROXY_WORKER_DISABLED)
                    ap_rputs("Dis", r);
                else if (worker->w->status & PROXY_WORKER_IN_ERROR)
                    ap_rputs("Err", r);
                else if (worker->w->status & PROXY_WORKER_INITIALIZED)
                    ap_rputs("Ok", r);
                else
                    ap_rputs("-", r);
                ap_rputs("</td></tr>\n", r);

                ++worker;
            }
            ap_rputs("</table>\n", r);
            ++balancer;
        }
        ap_rputs("<hr />\n", r);
        if (wsel && bsel) {
            ap_rputs("<h3>Edit worker settings for ", r);
            ap_rvputs(r, wsel->w->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>Load factor:</td><td><input name=\"lf\" type=text ", r);
            ap_rprintf(r, "value=\"%.2f\"></td><tr>\n", wsel->s->lbfactor);            
            ap_rputs("<tr><td>Route:</td><td><input name=\"wr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->route, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Route Redirect:</td><td><input name=\"rr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->redirect, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Disabled:</td><td><input name=\"dw\" type=checkbox", r);
            if (wsel->w->status & PROXY_WORKER_DISABLED)
                ap_rputs(" checked", r);
            ap_rputs("></td><tr>\n", r);            
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"s\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->scheme, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"w\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->hostname, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        else if (bsel) {
            ap_rputs("<h3>Edit balancer settings for ", r);
            ap_rvputs(r, bsel->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>StickySession Identifier:</td><td><input name=\"ss\" type=text ", r);
            if (bsel->sticky)
                ap_rvputs(r, "value=\"", bsel->sticky, "\"", NULL);
            ap_rputs("></td><tr>\n<tr><td>Timeout:</td><td><input name=\"tm\" type=text ", r);
            ap_rprintf(r, "value=\"%" APR_TIME_T_FMT "\"></td></tr>\n",
                       apr_time_sec(bsel->timeout));
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        ap_rputs(ap_psignature("",r), r);
        ap_rputs("</body></html>\n", r);
    }
    return OK;
}

    /* manager handler */
    ap_hook_handler(balancer_handler, NULL, NULL, APR_HOOK_FIRST);
#define CORE_PRIVATE

#include "apr_strings.h"
#include "apr_buckets.h"
#include "util_filter.h"
#include "ap_config.h"
#include "http_main.h"
#include "http_connection.h"
#include "util_date.h"
int ap_proxy_ftp_canon(request_rec *r, char *url);
int ap_proxy_ftp_handler(request_rec *r, char *url);
static int ftp_getrc_msg(conn_rec *c, char *msgbuf, int msglen)
    char *response;
    char buff[5];
    apr_bucket *e;
    apr_bucket_brigade *bb = apr_brigade_create(c->pool);

    bb = apr_brigade_create(c->pool);
    /* Tell http_filter to grab the data one line at a time. */
    c->remain = 0;

    ap_get_brigade(c->input_filters, bb, AP_MODE_BLOCKING);
    e = APR_BRIGADE_FIRST(bb);
    apr_bucket_read(e, (const char **)&response, &len, APR_BLOCK_READ);
    if (len == -1) {
    }
    if (len < 5 || !apr_isdigit(response[0]) || !apr_isdigit(response[1]) ||
	!apr_isdigit(response[2]) || (response[3] != ' ' && response[3] != '-'))
	status = 100 * response[0] + 10 * response[1] + response[2] - 111 * '0';
    mb = apr_cpystrn(mb, response+4, me - mb);
/* FIXME: If the line was too long, read till LF */
    if (response[3] == '-') {
	memcpy(buff, response, 3);
	    apr_bucket_read(e, (const char **)&response, &len, APR_BLOCK_READ);

/* FIXME: If the line was too long, read till LF */

	    mb = apr_cpystrn(mb, response+4, me - mb);
	} while (memcmp(response, buff, 4) != 0);

    APR_BUCKET_REMOVE(e);
    apr_bucket_destroy(e);

/* this piece needs some serious overhauling */
#if 0
#endif
 * Filters by [Graham Leggett <minfrin@sharp.fm>]
int ap_proxy_ftp_handler(request_rec *r, char *url)
    apr_pool_t *p = r->pool;
    apr_socket_t *sock, *local_sock, *remote_sock;
    apr_sockaddr_t *uri_addr, *connect_addr;
    conn_rec *origin, *remote;
    int err;
    apr_bucket *e;
    apr_bucket_brigade *bb = apr_brigade_create(p);
    char *buf, *pasv, *connectname;
    apr_port_t connectport;
    char buffer[MAX_STRING_LEN];

    char *path, *strp, *parms;
    int i, j, len, rc;
    char *size = NULL;

    /* stuff for PASV mode */
    int pasvmode = 0;
    char dates[AP_RFC822_DATE_LEN];
    /*
     * I: Who Do I Connect To?
     * -----------------------
     *
     * Break up the URL to determine the host to connect to
     */
    /* we only support GET and HEAD */
    /* We break the URL into host, port, path-search */
    connectname = r->parsed_uri.hostname;
    connectport = (r->parsed_uri.port != 0)
	           ? r->parsed_uri.port
	           : ap_default_port_for_request(r);
    parms = strchr(path, ';');
    if (parms != NULL)
	*(parms++) = '\0';

    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: FTP connecting %s to %s:%d", url, connectname, connectport);

    /* do a DNS lookup for the destination host */
    err = apr_sockaddr_info_get(&uri_addr, connectname, APR_UNSPEC, connectport, 0, p);

    /* check if ProxyBlock directive on this host */
    if (OK != ap_proxy_checkproxyblock(r, conf, uri_addr)) {
	return ap_proxyerror(r, HTTP_FORBIDDEN,
			     "Connect to remote machine blocked");
    /*
     * II: Make the Connection
     * -----------------------
     *
     * We have determined who to connect to. Now make the connection.
     */

    /* get all the possible IP addresses for the destname and loop through them
     * until we get a successful connection
     */
    if (APR_SUCCESS != err) {
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_pstrcat(p,
                             "DNS lookup failure for: ",
                             connectname, NULL));
    }
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: socket has been created");


    /*
     * At this point we have a list of one or more IP addresses of
     * the machine to connect to. If configured, reorder this
     * list so that the "best candidate" is first try. "best
     * candidate" could mean the least loaded server, the fastest
     * responding server, whatever.
     *
     * For now we do nothing, ie we get DNS round robin.
     * XXX FIXME
     */


    /* try each IP address until we connect successfully */
    {
	int failed = 1;
	while (connect_addr) {

	    /* make the connection out of the socket */
	    err = apr_connect(sock, connect_addr);

	    /* if an error occurred, loop round and try again */
            if (err != APR_SUCCESS) {
		ap_log_error(APLOG_MARK, APLOG_ERR, err, r->server,
			     "proxy: attempt to connect to %pI (%s) failed", connect_addr, connectname);
		connect_addr = connect_addr->next;
		continue;
            }

	    /* if we get here, all is well */
	    failed = 0;
	    break;
	}

	/* handle a permanent error from the above loop */
	if (failed) {
	    apr_socket_close(sock);
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_pstrcat(r->pool,
				 "Could not connect to remote machine: ",
				 r->parsed_uri.hostname, NULL));
	}
    }

    /* the socket is now open, create a new connection */
    origin = ap_new_connection(p, r->server, sock, r->connection->id);
    if (!origin) {
	/* the peer reset the connection already; ap_new_connection() 
	 * closed the socket */
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: an error occurred creating a new connection to %pI (%s)", connect_addr, connectname);
	return HTTP_INTERNAL_SERVER_ERROR;
    conf->id = r->connection->id;
    /* allocate this out of the connection pool - the check on r->connection->id makes
     * sure that this string does not live past the connection lifetime */
    conf->connectname = apr_pstrdup(r->connection->pool, connectname);
    conf->connectport = connectport;

    /* if a keepalive connection is floating around, close it first! */
    if (conf->client_socket) {
	apr_socket_close(conf->client_socket);
    }
    conf->client_socket = sock;
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: connection complete");
    /*
     * III: Send Control Request
     * -------------------------
     *
     * Log into the ftp server, send the username & password, change to the correct
     * directory...
     */

    /* set up the connection filters */
    ap_proxy_pre_http_connection(origin);

    /* possible results: */
    /*   120 Service ready in nnn minutes. */
    /*   220 Service ready for new user. */
    /*   421 Service not available, closing control connection. */
    i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
				 "FTP: initial connect returned status %d", i);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
    buf = apr_pstrcat(p, "USER ", user, CRLF, NULL);
    bb = apr_brigade_create(p);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    apr_brigade_destroy(bb);
    /* possible results; 230, 331, 332, 421, 500, 501, 530 */
    /* states: 1 - error, 2 - success; 3 - send password, 4,5 fail */
    /*   230 User logged in, proceed. */
    /*   331 User name okay, need password. */
    /*   332 Need account for login. */
    /*   421 Service not available, closing control connection. */
    /*   500 Syntax error, command unrecognized. */
    /*       (This may include errors such as command line too long.) */
    /*   501 Syntax error in parameters or arguments. */
    /*   530 Not logged in. */
    i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
/* FIXME: Insert clean disconnect */
/* FIXME: Insert clean disconnect */
	buf = apr_pstrcat(p, "PASS ", password, CRLF, NULL);
	bb = apr_brigade_create(p);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,

	/* possible results 202, 230, 332, 421, 500, 501, 503, 530 */
	/*   230 User logged in, proceed. */
	/*   332 Need account for login. */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   503 Bad sequence of commands. */
	/*   530 Not logged in. */
	i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
				 apr_pstrcat(p, "Need account for login: ", buffer, NULL));
/* FIXME: Insert clean disconnect */
    /* set the directory (walk directory component by component):
     * this is what we must do if we don't know the OS type of the remote
     * machine
     */
	buf = apr_pstrcat(p, "CWD ", path, CRLF, NULL);
	bb = apr_brigade_create(p);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
	/* responses: 250, 421, 500, 501, 502, 530, 550 */
	/*   250 Requested file action okay, completed. */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   502 Command not implemented. */
	/*   530 Not logged in. */
	/*   550 Requested action not taken. */
	i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	    return ap_proxyerror(r, HTTP_NOT_FOUND, buffer);
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
	buf = apr_pstrcat(p, "TYPE I", CRLF, NULL);
	bb = apr_brigade_create(p);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	/* responses: 200, 421, 500, 501, 504, 530 */
	/*   200 Command okay. */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   504 Command not implemented for that parameter. */
	/*   530 Not logged in. */
	i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
	/* Allow not implemented */

    /*
     * IV: Make Data Connection?
     * -------------------------
     *
     * Try PASV, if that fails try normally.
     */

    /* try to set up PASV data connection first */
    if ((apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
    if (conf->recv_buffer_size > 0 && apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
    bb = apr_brigade_create(p);
    buf = apr_pstrcat(p, "PASV", CRLF, NULL);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    apr_brigade_destroy(bb);
    /* possible results: 227, 421, 500, 501, 502, 530 */
    /*   227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
    /*   421 Service not available, closing control connection. */
    /*   500 Syntax error, command unrecognized. */
    /*   501 Syntax error in parameters or arguments. */
    /*   502 Command not implemented. */
    /*   530 Not logged in. */
    bb = apr_brigade_create(p);
    origin->remain = 0;
    ap_get_brigade(origin->input_filters, bb, AP_MODE_BLOCKING);
    e = APR_BRIGADE_FIRST(bb);
    apr_bucket_read(e, (const char **)&buf, &len, APR_BLOCK_READ);
    if (len < 5) {
	apr_socket_close(remote_sock);
	return HTTP_BAD_GATEWAY;
	unsigned int presult, h0, h1, h2, h3, p0, p1;
	char *pstr;

	pasv = apr_pstrdup(p, buf);
	pasv[len - 1] = '\0';
                     "FTP: PASV returned status %d", presult);

/* FIXME: Only supports IPV4 */

	    apr_sockaddr_t *pasv_addr;
	    int pasvport = (p1 << 8) + p0;
                         "FTP: PASV contacting host %d.%d.%d.%d:%d",
                         h3, h2, h1, h0, pasvport);

	    /* make the connection */
	    apr_sockaddr_info_get(&pasv_addr, apr_psprintf(p, "%d.%d.%d.%d", h3, h2, h1, h0), APR_UNSPEC, pasvport, 0, p);
	    err = apr_connect(sock, pasv_addr);
            if (err != APR_SUCCESS) {
		return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_psprintf(r->pool,
				     "PASV attempt to connect to %pI failed - firewall/NAT?", pasv_addr));
            }
	    /* and try the regular way */
	    apr_socket_close(remote_sock);
    APR_BUCKET_REMOVE(e);
    apr_bucket_destroy(e);
    /* set up data connection */
    if (!pasvmode) {
	apr_sockaddr_t *local_addr;
	char *local_ip;
	apr_port_t local_port;

	if ((apr_socket_create(&local_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
        apr_socket_addr_get(&local_addr, APR_LOCAL, sock);
        apr_sockaddr_port_get(&local_port, local_addr);
        apr_sockaddr_ip_get(&local_ip, local_addr);
	if (apr_setsocketopt(local_sock, APR_SO_REUSEADDR, one) != APR_SUCCESS) {
	    apr_socket_close(local_sock);
        if (apr_sockaddr_info_get(&local_addr, local_ip, APR_INET,
				  local_port, 0, r->pool) != APR_SUCCESS) {
	if (apr_bind(local_sock, local_addr) != APR_SUCCESS) {
	    apr_snprintf(buff, sizeof(buff), "%s:%d", local_ip, local_port);
	    apr_socket_close(remote_sock);

	/* only need a short queue */
	apr_listen(local_sock, 2);

    /*
     * V: Set The Headers
     * -------------------
     *
     * Get the size of the request, set up the environment for HTTP.
     */

    /* set request; "path" holds last path component */
	bb = apr_brigade_create(p);
	buf = apr_pstrcat(p, "SIZE ", path, CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	i = ftp_getrc_msg(origin, buffer, sizeof buffer);
                     "FTP: returned status %d with response %s", i, buffer);
		bb = apr_brigade_create(p);
		buf = apr_pstrcat(p, "CWD ", path, CRLF, NULL);
		e = apr_bucket_pool_create(buf, strlen(buf), p);
		APR_BRIGADE_INSERT_TAIL(bb, e);
		e = apr_bucket_flush_create();
		APR_BRIGADE_INSERT_TAIL(bb, e);
		ap_pass_brigade(origin->output_filters, bb);
		apr_brigade_destroy(bb);
		i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
		    return ap_proxyerror(r, HTTP_NOT_FOUND, buffer);
		    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
		for (j = 0; j < sizeof(buffer) && apr_isdigit(buffer[j]); j++);
		buffer[j] = '\0';
		if (buffer[0] != '\0')
		    size = apr_pstrdup(p, buffer);
    bb = apr_brigade_create(p);
    buf = apr_pstrcat(p, "PWD", CRLF, NULL);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    apr_brigade_destroy(bb);
    /* responses: 257, 500, 501, 502, 421, 550 */
    /*   257 "<directory-name>" <commentary> */
    /*   421 Service not available, closing control connection. */
    /*   500 Syntax error, command unrecognized. */
    /*   501 Syntax error in parameters or arguments. */
    /*   502 Command not implemented. */
    /*   550 Requested action not taken. */
    i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	return ap_proxyerror(r, HTTP_NOT_FOUND, buffer);
	const char *dirp = buffer;
		    buf = apr_pstrcat(p, "LIST ", path, CRLF, NULL);
		    buf = apr_pstrcat(p, "LIST -lag", CRLF, NULL);
					 "FTP: LIST %s", (len == 0 ? "-lag" : path));
		buf = apr_pstrcat(p, "RETR ", path, CRLF, NULL);
    bb = apr_brigade_create(p);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    apr_brigade_destroy(bb);
    /* RETR: 110, 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 530, 550
     * NLST: 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 502, 530 */
    /*   110 Restart marker reply. */
    /*   125 Data connection already open; transfer starting. */
    /*   150 File status okay; about to open data connection. */
    /*   226 Closing data connection. */
    /*   250 Requested file action okay, completed. */
    /*   421 Service not available, closing control connection. */
    /*   425 Can't open data connection. */
    /*   426 Connection closed; transfer aborted. */
    /*   450 Requested file action not taken. */
    /*   451 Requested action aborted. Local error in processing. */
    /*   500 Syntax error, command unrecognized. */
    /*   501 Syntax error in parameters or arguments. */
    /*   530 Not logged in. */
    /*   550 Requested action not taken. */
    rc = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	bb = apr_brigade_create(p);
	buf = apr_pstrcat(p, "CWD ", path, CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	rc = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	    return ap_proxyerror(r, HTTP_NOT_FOUND, buffer);
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
	bb = apr_brigade_create(p);
	buf = apr_pstrcat(p, "PWD ", CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	    return ap_proxyerror(r, HTTP_NOT_FOUND, buffer);
	    const char *dirp = buffer;
	bb = apr_brigade_create(p);
	buf = apr_pstrcat(p, "LIST -lag", CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	rc = ftp_getrc_msg(origin, buffer, sizeof(buffer));
    if (rc != 125 && rc != 150 && rc != 226 && rc != 250) {
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
    }

    apr_table_setn(r->headers_out, "Date", dates);
    apr_table_setn(r->headers_out, "Server", ap_get_server_version());
		apr_table_setn(r->headers_out, "Content-Type", "text/html");
	    apr_table_setn(r->headers_out, "Content-Type", r->content_type);
	    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
			 "FTP: Content-Type set to %s", r->content_type);
	    apr_table_setn(r->headers_out, "Content-Type", ap_default_type(r));
	    apr_table_setn(r->headers_out, "Content-Length", size);
	apr_table_setn(r->headers_out, "Content-Encoding", r->content_encoding);
    /* wait for connection */
    if (!pasvmode) {
            switch(apr_accept(&remote_sock, local_sock, r->pool))
                apr_socket_close(local_sock);
    /* the transfer socket is now open, create a new connection */
    remote = ap_new_connection(p, r->server, remote_sock, r->connection->id);
    if (!remote) {
	/* the peer reset the connection already; ap_new_connection() 
	 * closed the socket */
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: an error occurred creating a new connection");
	apr_socket_close(remote_sock);
	apr_socket_close(local_sock);
	return HTTP_INTERNAL_SERVER_ERROR;
    /* set up the connection filters */
    ap_proxy_pre_http_connection(remote);

    /*
     * VI: Receive the Response
     * ------------------------
     *
     * Get response from the remote ftp socket, and pass it up the
     * filter chain.
     */

    /* send response */

   if (parms[0] == 'd') {
	/* insert directory filter */
/*	send_dir(data, r, c, cwd); */
   }


    /* send body */

	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: FTP start body send");

	/* read the body, pass it to the output filters */
	bb = apr_brigade_create(p);
	while (ap_get_brigade(remote->input_filters, bb, AP_MODE_BLOCKING) == APR_SUCCESS) {
	    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
		ap_pass_brigade(r->output_filters, bb);
		break;
	    }
	    ap_pass_brigade(r->output_filters, bb);
	    apr_brigade_destroy(bb);
	    bb = apr_brigade_create(p);
	}
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: FTP end body send");



	/* abort the transfer */
	bb = apr_brigade_create(p);
	buf = apr_pstrcat(p, "ABOR", CRLF, NULL);
	e = apr_bucket_pool_create(buf, strlen(buf), p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(bb, e);
	ap_pass_brigade(origin->output_filters, bb);
	apr_brigade_destroy(bb);
	/* responses: 225, 226, 421, 500, 501, 502 */
	/*   225 Data connection open; no transfer in progress. */
	/*   226 Closing data connection. */
	/*   421 Service not available, closing control connection. */
	/*   500 Syntax error, command unrecognized. */
	/*   501 Syntax error in parameters or arguments. */
	/*   502 Command not implemented. */
	i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
		     "FTP: returned status %d", i);

    /*
     * VII: Clean Up
     * -------------
     *
     * If there are no KeepAlives, or if the connection has been signalled
     * to close, close the socket and clean up
     */

    /* finish */
    bb = apr_brigade_create(p);
    buf = apr_pstrcat(p, "QUIT", CRLF, NULL);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    apr_brigade_destroy(bb);
    /* responses: 221, 500 */
    /*   221 Service closing control connection. */
    /*   500 Syntax error, command unrecognized. */
    i = ftp_getrc_msg(origin, buffer, sizeof(buffer));
module AP_MODULE_DECLARE_DATA imagemap_module;
    icr = ap_get_module_config(r->per_dir_config, &imagemap_module);
module AP_MODULE_DECLARE_DATA imagemap_module =
        if (APR_SUCCESS != (status = apr_strtoff(&cl_val, old_cl_val, NULL,
                                                 0))) {
            return status;
        }
	    /* RFC2616 tells us to forward this.
	     *
	     * OTOH, an interim response here may mean the backend
	     * is playing sillybuggers.  The Client didn't ask for
	     * it within the defined HTTP/1.1 mechanisms, and if
	     * it's an extension, it may also be unsupported by us.
	     *
	     * There's also the possibility that changing existing
	     * behaviour here might break something.
	     *
	     * So let's make it configurable.
	     */
            const char *policy = apr_table_get(r->subprocess_env,
			                       "proxy-interim-response");
	    if (!policy || !strcasecmp(policy, "RFC")) {
                ap_send_interim_response(r);
	    }
	    /* FIXME: refine this to be able to specify per-response-status
	     * policies and maybe also add option to bail out with 502
	     */
	    else if (strcasecmp(policy, "Suppress")) {
                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,
                             "undefined proxy interim response policy");
	    }
static int read_request_line(request_rec *r, apr_bucket_brigade *bb)

#if 0
    conn_rec *conn = r->connection;
#endif
    int num_blank_lines = 0;
    int max_blank_lines = r->server->limit_req_fields;

    if (max_blank_lines <= 0) {
        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
    }

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    do {
        apr_status_t rv;

        /* insure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */
        r->the_request = NULL;
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                         &len, r, 0, bb);

        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }
            return 0;
        }
    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));

    /* we've probably got something to do, ignore graceful restart requests */
    ll = r->the_request;
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method",
                                r->method);
#endif

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

             && (minor < HTTP_VERSION(1, 0)) ) /* don't allow HTTP/0.1000 */
    else
    return 1;
    char *last_field = NULL;
    apr_size_t last_len = 0;
    apr_size_t alloc_len = 0;
    char *value;
    int fields_read = 0;
    char *tmp_field;
        int folded = 0;

        if (last_field != NULL) {
            if ((len > 0) && ((*field == '\t') || *field == ' ')) {
                /* This line is a continuation of the preceding line(s),
                 * so append it to the line that we've set aside.
                 * Note: this uses a power-of-two allocator to avoid
                 * doing O(n) allocs and using O(n^2) space for
                 * continuations that span many many lines.
                 */
                apr_size_t fold_len = last_len + len + 1; /* trailing null */

                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field "
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                if (fold_len > alloc_len) {
                    char *fold_buf;
                    alloc_len += alloc_len;
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
                    }
                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);
                    memcpy(fold_buf, last_field, last_len);
                    last_field = fold_buf;
                }
                memcpy(last_field + last_len, field, len +1); /* +1 for nul */
                last_len += len;
                folded = 1;
            }
            else /* not a continuation line */ {

                if (r->server->limit_req_fields
                    && (++fields_read > r->server->limit_req_fields)) {
                    r->status = HTTP_BAD_REQUEST;
                    apr_table_setn(r->notes, "error-notes",
                                   "The number of request header fields "
                                   "exceeds this server's limit.");
                    return;
                }

                if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                    r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Request header field is "
                                               "missing ':' separator.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool,
                                                              last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                tmp_field = value - 1; /* last character of field-name */

                *value++ = '\0'; /* NUL-terminate at colon */

                while (*value == ' ' || *value == '\t') {
                    ++value;            /* Skip to start of value   */
                }

                /* Strip LWS after field-name: */
                while (tmp_field > last_field
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                /* Strip LWS after field-value: */
                tmp_field = last_field + last_len - 1;
                while (tmp_field > value
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                apr_table_addn(r->headers_in, last_field, value);

                /* reset the alloc_len so that we'll allocate a new
                 * buffer if we have to do any more folding: we can't
                 * use the previous buffer because its contents are
                 * now part of r->headers_in
                 */
                alloc_len = 0;

            } /* end if current line is not a continuation starting with tab */

        /* Found a blank line, stop. */
        if (len == 0) {
            break;
        }

        /* Keep track of this line so that we can parse it on
         * the next loop iteration.  (In the folded case, last_field
         * has been updated already.)
         */
        if (!folded) {
            last_field = field;
            last_len = len;

    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
request_rec *ap_read_request(conn_rec *conn)
    const char *expect;
    int access_status;
    apr_bucket_brigade *tmp_bb;
    apr_socket_t *csd;
    apr_interval_time_t cur_timeout;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    /* Get the request... */
    if (!read_request_line(r, tmp_bb)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        apr_brigade_destroy(tmp_bb);
        return NULL;
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_get(csd, &cur_timeout);
    if (cur_timeout != conn->base_server->timeout) {
        apr_socket_timeout_set(csd, conn->base_server->timeout);
        cur_timeout = conn->base_server->timeout;
    }

    if (!r->assbackwards) {
        ap_get_mime_headers_core(r, tmp_bb);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        if (apr_table_get(r->headers_in, "Transfer-Encoding")
            && apr_table_get(r->headers_in, "Content-Length")) {
            /* 2616 section 4.4, point 3: "if both Transfer-Encoding
             * and Content-Length are received, the latter MUST be
             * ignored"; so unset it here to prevent any confusion
             * later. */
            apr_table_unset(r->headers_in, "Content-Length");
        }
    }
    else {
        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }
    }

    apr_brigade_destroy(tmp_bb);
    if (cur_timeout != r->server->timeout) {
        apr_socket_timeout_set(csd, r->server->timeout);
        cur_timeout = r->server->timeout;

    /** Which allow-override-opts bits are set */
    int override_opts;
                                       int override_opts,
    allow_options_t override_opts;
    /** the override options allowed for the .htaccess file */
    int override_opts;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
				       int override_opts,
    parms.override_opts = override_opts;
    new->override_opts = override_opts;
    conf->override_opts = OPT_UNSET | OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER
   			 | OPT_MULTI;
    if (!(new->override_opts & OPT_UNSET)) {
	conf->override_opts = new->override_opts;
    }

static const char *set_allow_opts(cmd_parms *cmd, allow_options_t *opts,
                                  const char *l)
{
    allow_options_t opt;
    int first = 1;

    char *p = (char *) l;

    while (p && *p) {
        char *w = strsep(&p, ",");

        if (first) {
            *opts = OPT_NONE;
            first = 0;
        }

	if (!w)
	    continue;

        if (!strcasecmp(w, "Indexes")) {
            opt = OPT_INDEXES;
        }
        else if (!strcasecmp(w, "Includes")) {
            opt = OPT_INCLUDES;
        }
        else if (!strcasecmp(w, "IncludesNOEXEC")) {
            opt = (OPT_INCLUDES | OPT_INCNOEXEC);
        }
        else if (!strcasecmp(w, "FollowSymLinks")) {
            opt = OPT_SYM_LINKS;
        }
        else if (!strcasecmp(w, "SymLinksIfOwnerMatch")) {
            opt = OPT_SYM_OWNER;
        }
        else if (!strcasecmp(w, "ExecCGI")) {
            opt = OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "MultiViews")) {
            opt = OPT_MULTI;
        }
        else if (!strcasecmp(w, "RunScripts")) { /* AI backcompat. Yuck */
            opt = OPT_MULTI|OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "None")) {
            opt = OPT_NONE;
        }
        else if (!strcasecmp(w, "All")) {
            opt = OPT_ALL;
        }
        else {
            return apr_pstrcat(cmd->pool, "Illegal option ", w, NULL);
        }

        *opts |= opt;
    }

    (*opts) &= (~OPT_UNSET);

    return NULL;
}

    char *k, *v;

	k = w;
	v = strchr(k, '=');
	if (v) {
		*v++ = '\0';
	}

        else if (!strcasecmp(k, "Options")) {
	    if (v) 
                set_allow_opts(cmd, &(d->override_opts), v);
	    else
	        d->override_opts = OPT_ALL;
        else if (!strcasecmp(w, "ExecCGI")) {
	if (!(cmd->override_opts & opt) && opt != OPT_NONE) {
	    return apr_pstrcat(cmd->pool, "Option ", w, " not allowed here", NULL);
        }
        else if (action == '-') {
            /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        overrides_t override_opts;
    if (!(this_dir->override_opts & OR_UNSET)) {
        opts->override_opts = this_dir->override_opts;
    }
					opts.override_opts,
    bracket = apr_pstrcat(temp_pool, orig_directive + 1, ">", NULL);
        cmd_name = ap_getword_conf(cmd->temp_pool, &args);
    char *dir = apr_pstrdup(parms->temp_pool, cmd_line);
    conf->gprof_dir = arg;
    limited_methods = apr_pstrndup(cmd->temp_pool, arg, endp - arg);
        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);
            methnum = ap_method_register(cmd->pool,
                                         apr_pstrdup(cmd->pool, method));
    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);
        || !ap_is_directory(cmd->temp_pool, ap_server_root)) {

    /** Which allow-override-opts bits are set */
    int override_opts;
                                       int override_opts,
    allow_options_t override_opts;
    /** the override options allowed for the .htaccess file */
    int override_opts;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
				       int override_opts,
    parms.override_opts = override_opts;
    new->override_opts = override_opts;
    conf->override_opts = OPT_UNSET | OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER
   			 | OPT_MULTI;
    if (!(new->override_opts & OPT_UNSET)) {
	conf->override_opts = new->override_opts;
    }

static const char *set_allow_opts(cmd_parms *cmd, allow_options_t *opts,
                                  const char *l)
{
    allow_options_t opt;
    int first = 1;

    char *p = (char *) l;

    while (p && *p) {
        char *w = strsep(&p, ",");

        if (first) {
            *opts = OPT_NONE;
            first = 0;
        }

	if (!w)
	    continue;

        if (!strcasecmp(w, "Indexes")) {
            opt = OPT_INDEXES;
        }
        else if (!strcasecmp(w, "Includes")) {
            opt = OPT_INCLUDES;
        }
        else if (!strcasecmp(w, "IncludesNOEXEC")) {
            opt = (OPT_INCLUDES | OPT_INCNOEXEC);
        }
        else if (!strcasecmp(w, "FollowSymLinks")) {
            opt = OPT_SYM_LINKS;
        }
        else if (!strcasecmp(w, "SymLinksIfOwnerMatch")) {
            opt = OPT_SYM_OWNER;
        }
        else if (!strcasecmp(w, "ExecCGI")) {
            opt = OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "MultiViews")) {
            opt = OPT_MULTI;
        }
        else if (!strcasecmp(w, "RunScripts")) { /* AI backcompat. Yuck */
            opt = OPT_MULTI|OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "None")) {
            opt = OPT_NONE;
        }
        else if (!strcasecmp(w, "All")) {
            opt = OPT_ALL;
        }
        else {
            return apr_pstrcat(cmd->pool, "Illegal option ", w, NULL);
        }

        *opts |= opt;
    }

    (*opts) &= (~OPT_UNSET);

    return NULL;
}

    char *k, *v;

	k = w;
	v = strchr(k, '=');
	if (v) {
		*v++ = '\0';
	}

        else if (!strcasecmp(k, "Options")) {
	    if (v) 
                set_allow_opts(cmd, &(d->override_opts), v);
	    else
	        d->override_opts = OPT_ALL;
        else if (!strcasecmp(w, "ExecCGI")) {
	if (!(cmd->override_opts & opt) && opt != OPT_NONE) {
	    return apr_pstrcat(cmd->pool, "Option ", w, " not allowed here", NULL);
        }
        else if (action == '-') {
            /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        overrides_t override_opts;
    if (!(this_dir->override_opts & OR_UNSET)) {
        opts->override_opts = this_dir->override_opts;
    }
					opts.override_opts,
    ap_register_output_filter("PROXY_SEND_DIR", ap_proxy_send_dir_filter, AP_FTYPE_CONTENT);
apr_status_t ap_proxy_send_dir_filter(ap_filter_t *f,
				      apr_bucket_brigade *bb);
apr_status_t ap_proxy_string_read(conn_rec *c, apr_bucket_brigade *bb, char *buff, size_t bufflen, int *eos);
    int eos;
    if (APR_SUCCESS != (rv = ap_proxy_string_read(c, bb, response, sizeof(response), &eos))) {
	    if (APR_SUCCESS != (rv = ap_proxy_string_read(c, bb, response, sizeof(response), &eos))) {
typedef struct {
    apr_bucket_brigade *in;
    char buffer[MAX_STRING_LEN];
    enum {HEADER, BODY, FOOTER} state;
} proxy_dir_ctx_t;

apr_status_t ap_proxy_send_dir_filter(ap_filter_t *f, apr_bucket_brigade *in)
    request_rec *r = f->r;
    apr_pool_t *p = r->pool;
    apr_bucket_brigade *out = apr_brigade_create(p);
    apr_status_t rv;
    char *dir, *path, *reldir, *site, *str;
    const char *pwd = apr_table_get(r->notes, "Directory-PWD");
    const char *readme = apr_table_get(r->notes, "Directory-README");
    proxy_dir_ctx_t *ctx = f->ctx;
    if (!ctx) {
	f->ctx = ctx = apr_pcalloc(p, sizeof(*ctx));
	ctx->in = apr_brigade_create(p);
	ctx->buffer[0] = 0;
	ctx->state = HEADER;
    }
    /* combine the stored and the new */
    APR_BRIGADE_CONCAT(ctx->in, in);

    if (HEADER == ctx->state) {

	/* Save "scheme://site" prefix without password */
	site = ap_unparse_uri_components(p, &f->r->parsed_uri, UNP_OMITPASSWORD|UNP_OMITPATHINFO);
	/* ... and path without query args */
	path = ap_unparse_uri_components(p, &f->r->parsed_uri, UNP_OMITSITEPART|UNP_OMITQUERY);
	(void)decodeenc(path);

	/* Copy path, strip (all except the last) trailing slashes */
	path = dir = apr_pstrcat(p, path, "/", NULL);
	while ((n = strlen(path)) > 1 && path[n-1] == '/' && path[n-2] == '/')
	    path[n-1] = '\0';

	/* print "ftp://host/" */
	str = apr_psprintf(p, DOCTYPE_HTML_3_2
			"\n\n<HTML>\n<HEAD>\n<TITLE>%s%s</TITLE>\n"
			"<BASE HREF=\"%s%s\">\n</HEAD>\n\n"
			"<BODY>\n\n<H2>Directory of "
			"<A HREF=\"/\">%s</A>/",
			site, path, site, path, site);

	e = apr_bucket_pool_create(str, strlen(str), p);
	APR_BRIGADE_INSERT_TAIL(out, e);

	while ((dir = strchr(dir+1, '/')) != NULL)
	{
	    *dir = '\0';
	    if ((reldir = strrchr(path+1, '/'))==NULL)
		reldir = path+1;
	    else
		++reldir;
	    /* print "path/" component */
	    str = apr_psprintf(p, "<A HREF=\"/%s/\">%s</A>/", path+1, reldir);
	    e = apr_bucket_pool_create(str, strlen(str), p);
	    APR_BRIGADE_INSERT_TAIL(out, e);
	    *dir = '/';
	}
	/* If the caller has determined the current directory, and it differs */
	/* from what the client requested, then show the real name */
	if (pwd == NULL || strncmp (pwd, path, strlen(pwd)) == 0) {
	    str = apr_psprintf(p, "</H2>\n\n<HR></HR>\n\n<PRE>");
	} else {
	    str = apr_psprintf(p, "</H2>\n\n(%s)\n\n<HR></HR>\n\n<PRE>", pwd);
	}
	e = apr_bucket_pool_create(str, strlen(str), p);
	APR_BRIGADE_INSERT_TAIL(out, e);
	/* print README */
	if (readme) {
	    str = apr_psprintf(p, "%s\n</PRE>\n\n<HR></HR>\n\n<PRE>\n",
			     readme);
	    e = apr_bucket_pool_create(str, strlen(str), p);
	    APR_BRIGADE_INSERT_TAIL(out, e);
	}
	/* make sure page intro gets sent out */
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(out, e);
	if (APR_SUCCESS != (rv = ap_pass_brigade(f->next, out))) {
	    return rv;
	}
	apr_brigade_cleanup(out);
	ctx->state = BODY;
    /* loop through each line of directory */
    while (BODY == ctx->state) {
	char *filename;
	int found = 0;
	int eos = 0;
	ctx->buffer[0] = 0;

	/* get a complete line */
	while (!found && !APR_BRIGADE_EMPTY(ctx->in)) {
	    char *pos, *response;
	    apr_size_t len, max;
	    e = APR_BRIGADE_FIRST(ctx->in);
	    if (APR_BUCKET_IS_EOS(e)) {
		eos = 1;
		break;
	    }
	    if (APR_SUCCESS != (rv = apr_bucket_read(e, (const char **)&response, &len, APR_BLOCK_READ))) {
		return rv;
	    }
	    pos = memchr(response, APR_ASCII_LF, len);
	    if (pos != NULL) {
		if ((pos - response + 1) != len) {
		    apr_bucket_split(e, pos - response + 1);
		}
		found = 1;
	    }
	    max = sizeof(ctx->buffer)-strlen(ctx->buffer)-1;
	    if (len > max) {
		len = max;
	    }
	    apr_cpystrn(ctx->buffer+strlen(ctx->buffer), response, len);
	    APR_BUCKET_REMOVE(e);
	    apr_bucket_destroy(e);
	}
	/* EOS? jump to footer */
	if (eos) {
	    ctx->state = FOOTER;

	/* not complete? leave and try get some more */
	if (!found) {
	    return APR_SUCCESS;

ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "proxy: directory line: [%s]", ctx->buffer);


	/* a symlink? */
	if (ctx->buffer[0] == 'l' && (filename=strstr(ctx->buffer, " -> ")) != NULL) {
	    str = apr_psprintf(p, "%s <A HREF=\"%s\">%s %s</A>\n", ctx->buffer, filename, filename, link_ptr);

	/* a directory/file? */
	else if (ctx->buffer[0] == 'd' || ctx->buffer[0] == '-' || ctx->buffer[0] == 'l' || apr_isdigit(ctx->buffer[0])) {
	    int searchidx = 0;
	    char *searchptr = NULL;
	    int firstfile = 1;
	    if (apr_isdigit(ctx->buffer[0])) {	/* handle DOS dir */
		searchptr = strchr(ctx->buffer, '<');
		searchptr = strchr(ctx->buffer, '>');
	    filename = strrchr(ctx->buffer, ' ');
		searchidx = filename - ctx->buffer;
	    else if (searchidx != 0 && ctx->buffer[searchidx] != 0) {
		ctx->buffer[searchidx - 1] = 0;
		filename = &ctx->buffer[searchidx];
	    if (!strcmp(filename, ".") || !strcmp(filename, "..") || ctx->buffer[0] == 'd') {
		str = apr_psprintf(p, "%s <A HREF=\"%s/\">%s</A>\n",
		    ctx->buffer, filename, filename);
		str = apr_psprintf(p, "%s <A HREF=\"%s\">%s</A>\n",
		    ctx->buffer, filename, filename);
	e = apr_bucket_pool_create(str, strlen(str), p);
	APR_BRIGADE_INSERT_TAIL(out, e);
	APR_BRIGADE_INSERT_TAIL(out, e);
	if (APR_SUCCESS != (rv = ap_pass_brigade(f->next, out))) {
	    return rv;
	}
	apr_brigade_cleanup(out);
    if (FOOTER == ctx->state) {
	str = apr_psprintf(p, "</PRE>\n\n<HR></HR>\n\n%s\n\n</BODY>\n</HTML>\n", ap_psignature("", r));
	e = apr_bucket_pool_create(str, strlen(str), p);
	APR_BRIGADE_INSERT_TAIL(out, e);
	e = apr_bucket_flush_create();
	APR_BRIGADE_INSERT_TAIL(out, e);
	e = apr_bucket_eos_create();
	APR_BRIGADE_INSERT_TAIL(out, e);

	if (APR_SUCCESS != (rv = ap_pass_brigade(f->next, out))) {
	    return rv;
	}
	apr_brigade_destroy(out);
    }
    conn_rec *c = r->connection;
    proxy_conn_rec *backend =
    (proxy_conn_rec *) ap_get_module_config(c->conn_config, &proxy_module);
    if (!backend) {
	backend = ap_pcalloc(c->pool, sizeof(proxy_conn_rec));
	backend->connection = NULL;
	backend->hostname = NULL;
	backend->port = 0;
	ap_set_module_config(c->conn_config, &proxy_module, backend);
    }

    if (backend->connection) {
	apr_socket_close(backend->connection->client_socket);
	backend->connection = NULL;
		 "proxy: FTP: %d %s", i, buffer);
		 "proxy: FTP: %d %s", i, buffer);
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: FTP: %d %s", i, buffer);
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: FTP: %d %s", i, buffer);
    apr_table_set(r->notes, "Directory-README", buffer);
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: FTP: %d %s", i, buffer);
/* this temporarily switches off PASV */
/* IPV6 FIXME:
 * The EPSV command replaces PASV where both IPV4 and IPV6 is supported. Only
 * the port is returned, the IP address is always the same as that on the
 * control connection. Example:
 *   Entering Extended Passive Mode (|||6446|)
 */
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: FTP: %d %s", i, buffer);
/* FIXME: Check PASV against RFC1123 */

/* FIXME: Only supports IPV4 - fix in RFC2428 */
	unsigned int h0, h1, h2, h3, p0, p1;
        apr_socket_addr_get(&local_addr, APR_LOCAL, sock);
        if (apr_sockaddr_info_get(&local_addr, local_ip, APR_UNSPEC,

/* FIXME: Sent PORT here */

	if (local_ip && (sscanf(local_ip,
		 "%d.%d.%d.%d", &h3, &h2, &h1, &h0) == 4)) {
	    p1 = (local_port >> 8);
	    p0 = (local_port & 0xFF);

	    buf = apr_psprintf(p, "PORT %d,%d,%d,%d,%d,%d" CRLF, h3, h2, h1, h0, p1, p0);
	    e = apr_bucket_pool_create(buf, strlen(buf), p);
	    APR_BRIGADE_INSERT_TAIL(bb, e);
	    e = apr_bucket_flush_create();
	    APR_BRIGADE_INSERT_TAIL(bb, e);
	    ap_pass_brigade(origin->output_filters, bb);
            ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                         "proxy: FTP: PORT %d,%d,%d,%d,%d,%d", h3, h2, h1, h0, p1, p0);
	    /* possible results: 200, 421, 500, 501, 502, 530 */
	    /*   200 Command okay. */
	    /*   421 Service not available, closing control connection. */
	    /*   500 Syntax error, command unrecognized. */
	    /*   501 Syntax error in parameters or arguments. */
	    /*   502 Command not implemented. */
	    /*   530 Not logged in. */
	    rc = ftp_getrc_msg(origin, cbb, buffer, sizeof(buffer));
	    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: FTP: %d %s", rc, buffer);
	    if (rc == -1) {
		return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				     "Error reading from remote server");
	    }
	    if (rc != 200) {
		return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
	    }
	}
	else {
/* IPV6 FIXME:
 * The EPRT command replaces PORT where both IPV4 and IPV6 is supported. The first
 * number (1,2) indicates the protocol type. Examples:
 *   EPRT |1|132.235.1.2|6275|
 *   EPRT |2|1080::8:800:200C:417A|5282|
 */
	    return ap_proxyerror(r, HTTP_NOT_IMPLEMENTED, "Connect to IPV6 ftp server not supported");
	}
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
			     "proxy: FTP: %d %s", i, buffer);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
				 "proxy: FTP: %d %s", i, buffer);
	apr_table_set(r->notes, "Directory-PWD", ap_getword_conf(r->pool, &dirp));
/* FIXME: Handle range requests - send REST */
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: FTP: %d %s", rc, buffer);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
				 "proxy: FTP: %d %s", rc, buffer);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
				 "proxy: FTP: %d %s", i, buffer);
	    apr_table_set(r->notes, "Directory-PWD", ap_getword_conf(r->pool, &dirp));
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
				 "proxy: FTP: %d %s", rc, buffer);
    if (parms[0] == 'd') {
	r->content_type = "text/html";
	apr_table_setn(r->headers_out, "Content-Type", r->content_type);
    }
ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
			 "proxy: FTP: Content-Type set to %s", r->content_type);
		ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
			     "proxy: FTP: Content-Encoding set to %s", r->content_encoding);
/* FIXME: this does not return, despite the incoming connection being accepted */
    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                  "proxy: FTP: ready to suck data");

    /* read till EOF */
    c->remain = -1;

    if (parms[0] == 'd') {
    }
		e = apr_bucket_flush_create();
		APR_BRIGADE_INSERT_TAIL(bb, e);
		     "proxy: FTP: end body send");
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		     "proxy: FTP: %d %s", i, buffer);
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                 "proxy: FTP: %d %s", i, buffer);
    int i, len, backasswards, eos, close=0, failed=0, new=0;
    if (APR_SUCCESS != (rv = ap_proxy_string_read(origin, bb, buffer, sizeof(buffer), &eos))) {
		e = apr_bucket_flush_create();
		APR_BRIGADE_INSERT_TAIL(bb, e);
apr_status_t ap_proxy_string_read(conn_rec *c, apr_bucket_brigade *bb,
				  char *buff, size_t bufflen, int *eos)
    *eos = 0;
	    if (APR_BUCKET_IS_EOS(e)) {
		*eos = 1;
	    }
        ap_rvputs(r, ap_get_server_name(r), " (via ", r->connection->local_ip,
        const char *escpath;
        escpath = ap_escape_html(p, path);
                "<base href=\"%s%s%s\">\n"
                site, basedir, escpath, site, basedir, escpath, site, str);
    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, "text/xml");
    ap_set_content_type(r, apr_pstrdup(r->pool, info->content_type));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html;charset=utf-8");
    ap_set_content_type(r, "text/html");
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html");
                    ap_set_content_type(r, "text/plain");
    ap_set_content_type(r, "message/http");
AP_DECLARE(void) ap_set_content_type(request_rec *r, const char *ct)
        ap_set_content_type(r, "text/html; charset=iso-8859-1");
            ap_set_content_type(r, apr_pstrcat(r->pool, "multipart",
                                               use_range_x(r) ? "/x-" : "/",
                                               "byteranges; boundary=",
                                               r->boundary, NULL));
    ap_set_content_type(r, rr->content_type);
        ap_set_content_type(new, r->content_type);
        ap_set_content_type(r, DIR_MAGIC_TYPE);
                ap_set_content_type(r, (char*) type);
                ap_set_content_type(r, exinfo->forced_type);
	    ap_set_content_type(r, apr_pstrcat(r->pool, ctp->type, "/",
                                               ctp->subtype, NULL));
			ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                           "; charset=", charset,
                                                           NULL));
		    ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                       "; ", pp->attr,
                                                       "=", pp->val,
                                                       NULL));
		ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                   "; charset=", charset,
                                                   NULL));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(sub_req, CGI_MAGIC_TYPE);
        ap_set_content_type(r, t);
                ap_set_content_type(r, p->forced_mimetype);
	    ap_set_content_type(r, tmp);
	ap_set_content_type(r, tmp);
	ap_set_content_type(r, apr_pstrdup(r->pool, sub->content_type));
        ap_set_content_type(r, "text/html");
            ap_set_content_type(r, ap_default_type(r));
                    ap_set_content_type(r, apr_pstrdup(p, buf));
    /* RFC 2616:
     *   Request-URI    = "*" | absoluteURI | abs_path | authority
     *
     * authority is a special case for CONNECT.  If the request is not
     * using CONNECT, and the parsed URI does not have scheme, and
     * it does not begin with '/', and it is not '*', then, fail
     * and give a 400 response. */
    if (r->method_number != M_CONNECT 
        && !r->parsed_uri.scheme 
        && uri[0] != '/'
        && !(uri[0] == '*' && uri[1] == '\0')) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "invalid request-URI %s", uri);
        r->args = NULL;
        r->hostname = NULL;
        r->status = HTTP_BAD_REQUEST;
        r->uri = apr_pstrdup(r->pool, uri);
    }

 * 20051231.0 (2.3.0-dev) Added num_blank_lines, pending_header_line, and
 *                        pending_header_size to request_rec
#define MODULE_MAGIC_NUMBER_MAJOR 20051231
    /** Number of leading blank lines encountered before request header */
    int num_blank_lines;

    /** A buffered header line, used to support header folding while
     *  reading the request */
    char *pending_header_line;

    /** If nonzero, the number of bytes allocated to hold pending_header_line */
    apr_size_t pending_header_size;

static void set_the_request(request_rec *r, char *line)
    apr_socket_t *csd;
    ll = r->the_request = line;
             && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */
    }
    else {
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(r->connection->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->connection->base_server->timeout);

    return;
}

static apr_status_t set_mime_header(request_rec *r, char *line)
{
    char *value, *tmp_field;

    if (r->server->limit_req_fields) {
        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);
        if (mime_headers->nelts >= r->server->limit_req_fields) {
            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields "
                           "exceeds this server's limit.");
            r->status = HTTP_BAD_REQUEST;
            return APR_ENOSPC;
        }
    }
    
    if (!(value = strchr(line, ':'))) { /* Find ':' or    */
        r->status = HTTP_BAD_REQUEST;      /* abort bad request */
        apr_table_setn(r->notes, "error-notes",
                       apr_pstrcat(r->pool,
                                   "Request header field is "
                                   "missing ':' separator.<br />\n"
                                   "<pre>\n",
                                   ap_escape_html(r->pool, line),
                                   "</pre>\n", NULL));
        return APR_EGENERAL;
    }

    tmp_field = value - 1; /* last character of field-name */

    *value++ = '\0'; /* NUL-terminate at colon */

    while (*value == ' ' || *value == '\t') {
        ++value;            /* Skip to start of value   */
    }

    /* Strip LWS after field-name: */
    while (tmp_field > line
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }

    /* Strip LWS after field-value: */
    tmp_field = strchr(value, '\0') - 1;
    while (tmp_field > value
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }
    apr_table_addn(r->headers_in, line, value);
    return APR_SUCCESS;
}

static apr_status_t process_request_line(request_rec *r, char *line,
                                         int skip_first)
{
    if (!skip_first && (r->the_request == NULL)) {
        /* This is the first line of the request */
        if ((line == NULL) || (*line == '\0')) {
            /* We skip empty lines because browsers have to tack a CRLF on to the end
             * of POSTs to support old CERN webservers.
             */
            int max_blank_lines = r->server->limit_req_fields;
            if (max_blank_lines <= 0) {
                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
            }
            r->num_blank_lines++;
            if (r->num_blank_lines < max_blank_lines) {
                return APR_SUCCESS;
            }
        }
        set_the_request(r, line);
    }
    else {
        /* We've already read the first line of the request.  This is either
         * a header field or the blank line terminating the header
         */
        if ((line == NULL) || (*line == '\0')) {
            if (r->pending_header_line != NULL) {
                apr_status_t rv = set_mime_header(r, r->pending_header_line);
                if (rv != APR_SUCCESS) {
                    return rv;
                }
                r->pending_header_line = NULL;
            }
            if (r->status == HTTP_REQUEST_TIME_OUT) {
                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
                r->status = HTTP_OK;
            }
        }
        else {
            if ((*line == ' ') || (*line == '\t')) {
                /* This line is a continuation of the previous one */
                if (r->pending_header_line == NULL) {
                    r->pending_header_line = line;
                    r->pending_header_size = 0;
                }
                else {
                    apr_size_t pending_len = strlen(r->pending_header_line);
                    apr_size_t fold_len = strlen(line);
                    if (pending_len + fold_len >
                        r->server->limit_req_fieldsize) {
                        /* CVE-2004-0942 */
                        r->status = HTTP_BAD_REQUEST;
                        return APR_ENOSPC;
                    }
                    if (pending_len + fold_len + 1 > r->pending_header_size) {
                        /* Allocate a new buffer big enough to hold the
                         * concatenated lines
                         */
                        apr_size_t new_size = r->pending_header_size;
                        char *new_buf;
                        if (new_size == 0) {
                            new_size = pending_len + fold_len + 1;
                        }
                        else {
                            do {
                                new_size *= 2;
                            } while (new_size < pending_len + fold_len + 1);
                        }
                        new_buf = (char *)apr_palloc(r->pool, new_size);
                        memcpy(new_buf, r->pending_header_line, pending_len);
                        r->pending_header_line = new_buf;
                        r->pending_header_size = new_size;
                    }
                    memcpy(r->pending_header_line + pending_len, line,
                           fold_len + 1);
                }
            }
            else {
                /* Set aside this line in case the next line is a continuation
                 */
                if (r->pending_header_line != NULL) {
                    apr_status_t rv = set_mime_header(r, r->pending_header_line);
                    if (rv != APR_SUCCESS) {
                        return rv;
                    }
                }
                r->pending_header_line = line;
                r->pending_header_size = 0;
            }
        }
    }
    return APR_SUCCESS;
        rv = process_request_line(r, field, 1);
        if (rv != APR_SUCCESS) {
            return;
        if ((field == NULL) || (*field == '\0')) {
            return;
static request_rec *init_request(conn_rec *conn)
    
    return r;
}
static request_rec *request_post_read(request_rec *r, conn_rec *conn)
{
    apr_socket_t *csd;
    const char *expect;
    int access_status;
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->server->timeout);

    if (apr_table_get(r->headers_in, "Transfer-Encoding") &&
        apr_table_get(r->headers_in, "Content-Length")) {
        /* 2616 section 4.4, point 3: "if both Transfer-Encoding
         * and Content-Length are received, the latter MUST be
         * ignored"; so unset it here to prevent any confusion
         * later.
         */
        apr_table_unset(r->headers_in, "Content-Length");
static apr_status_t read_partial_request(request_rec *r) {
    apr_bucket_brigade *tmp_bb;
    apr_status_t rv = APR_SUCCESS;

    /* Read and process lines of the request until we
     * encounter a complete request header, an error, or EAGAIN
     */
    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    while (r->status == HTTP_REQUEST_TIME_OUT) {
        char *line = NULL;
        apr_size_t line_length;
        apr_size_t length_limit;
        int first_line = (r->the_request == NULL);
        if (first_line) {
            length_limit = r->server->limit_req_line;
        }
        else {
            if (r->assbackwards) {
                r->status = HTTP_OK;
                break;
            }
            length_limit = r->server->limit_req_fieldsize;
        }
        /* TODO: use a nonblocking call in place of ap_rgetline */
        rv = ap_rgetline(&line, length_limit + 2,
                         &line_length, r, 0, tmp_bb);
        if (rv == APR_SUCCESS) {
            rv = process_request_line(r, line, 0);
        }
        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();
            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                if (first_line) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: URI too long (longer than %d)",
                                  r->server->limit_req_line);
                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                    r->proto_num = HTTP_VERSION(1,0);
                    r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
                }
                else {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: header line too long "
                                  "(longer than %d)",
                                  r->server->limit_req_fieldsize);
                    r->status = HTTP_BAD_REQUEST;
                }
            }
            break;
        }
    }
    apr_brigade_destroy(tmp_bb);
    return rv;
}

request_rec *ap_read_request(conn_rec *conn)
{
    request_rec *r;
    apr_status_t rv;

    r = init_request(conn);

    rv = read_partial_request(r);
    /* TODO poll if EAGAIN */
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return NULL;
    }

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers! Have to dink things just to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "client sent invalid HTTP/0.9 request: HEAD %s",
                      r->uri);
        r->header_only = 0;
        r->status = HTTP_BAD_REQUEST;
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return r;
    }

    return request_post_read(r, conn);
}

/**
 * Unescape a string
 * @param url The string to unescape
 * @return 0 on success, non-zero otherwise
 */
AP_DECLARE(int) ap_unescape_all(char *url);

/**
 * Escape a path segment, as defined in RFC 1808, to a preallocated buffer.
 * @param c The preallocated buffer to write to
 * @param s The path to convert
 * @return The converted URL (c)
 */
AP_DECLARE(char *) ap_escape_path_segment_b(char *c, const char *s);

/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define CORE_PRIVATE

#include "mod_session.h"
#include "apr_lib.h"
#include "apr_strings.h"
#include "util_filter.h"
#include "http_log.h"
#include "http_request.h"
#include "http_protocol.h"

#define SESSION_PREFIX "mod_session: "
#define SESSION_EXPIRY "expiry"
#define HTTP_SESSION "HTTP_SESSION"

APR_HOOK_STRUCT(
                APR_HOOK_LINK(session_load)
                APR_HOOK_LINK(session_save)
                APR_HOOK_LINK(session_encode)
                APR_HOOK_LINK(session_decode)
)
AP_IMPLEMENT_HOOK_RUN_FIRST(int, session_load,
                      (request_rec * r, session_rec ** z), (r, z), DECLINED)
AP_IMPLEMENT_HOOK_RUN_FIRST(int, session_save,
                       (request_rec * r, session_rec * z), (r, z), DECLINED)
AP_IMPLEMENT_HOOK_RUN_ALL(int, session_encode,
                   (request_rec * r, session_rec * z), (r, z), OK, DECLINED)
AP_IMPLEMENT_HOOK_RUN_ALL(int, session_decode,
                   (request_rec * r, session_rec * z), (r, z), OK, DECLINED)
/**
 * Should the session be included within this URL.
 *
 * This function tests whether a session is valid for this URL. It uses the
 * include and exclude arrays to determine whether they should be included.
 */
    static int session_included(request_rec * r, session_dir_conf * conf)
{

    const char **includes = (const char **) conf->includes->elts;
    const char **excludes = (const char **) conf->excludes->elts;
    int included = 1;                /* defaults to included */
    int i;

    if (conf->includes->nelts) {
        included = 0;
        for (i = 0; !included && i < conf->includes->nelts; i++) {
            const char *include = includes[i];
            if (strncmp(r->parsed_uri.path, include, strlen(include))) {
                included = 1;
            }
        }
    }

    if (conf->excludes->nelts) {
        for (i = 0; included && i < conf->includes->nelts; i++) {
            const char *exclude = excludes[i];
            if (strncmp(r->parsed_uri.path, exclude, strlen(exclude))) {
                included = 0;
            }
        }
    }

    return included;
}

/**
 * Get a particular value from the session.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to get.
 * @param value The buffer to write the value to.
 */
AP_DECLARE(void) ap_session_get(request_rec * r, session_rec * z, const char *key, const char **value)
{
    if (!z) {
        ap_session_load(r, &z);
    }
    *value = apr_table_get(z->entries, key);
}

/**
 * Set a particular value to the session.
 *
 * Using this method ensures that the dirty flag is set correctly, so that
 * the session can be saved efficiently.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to set. The existing key value will be replaced.
 * @param value The value to set.
 */
AP_DECLARE(void) ap_session_set(request_rec * r, session_rec * z,
                                const char *key, const char *value)
{
    if (!z) {
        ap_session_load(r, &z);
    }
    if (value) {
        apr_table_set(z->entries, key, value);
    }
    else {
        apr_table_unset(z->entries, key);
    }
    z->dirty = 1;
}

/**
 * Load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_load(request_rec * r, session_rec ** z)
{

    session_dir_conf *dconf = ap_get_module_config(r->per_dir_config,
                                                   &session_module);
    apr_time_t now;
    session_rec *zz = NULL;

    /* is the session enabled? */
    if (!dconf->enabled) {
        return APR_SUCCESS;
    }

    /* should the session be loaded at all? */
    if (!session_included(r, dconf)) {
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, SESSION_PREFIX
                      "excluded by configuration for: %s", r->uri);
        return APR_SUCCESS;
    }

    /* load the session from the session hook */
    int rv = ap_run_session_load(r, &zz);
    if (DECLINED == rv) {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                      "session is enabled but no session modules have been configured, "
                      "session not loaded: %s", r->uri);
        return APR_EGENERAL;
    }
    else if (OK != rv) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                      "error while loading the session, "
                      "session not loaded: %s", r->uri);
        return rv;
    }

    /* found a session that hasn't expired? */
    now = apr_time_now();
    if (!zz || (zz->expiry && zz->expiry < now)) {

        /* no luck, create a blank session */
        zz = (session_rec *) apr_pcalloc(r->pool, sizeof(session_rec));
        zz->pool = r->pool;
        zz->entries = apr_table_make(zz->pool, 10);
        zz->uuid = (apr_uuid_t *) apr_pcalloc(zz->pool, sizeof(apr_uuid_t));
        apr_uuid_get(zz->uuid);

    }
    else {
        rv = ap_run_session_decode(r, zz);
        if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while decoding the session, "
                          "session not loaded: %s", r->uri);
            return rv;
        }
    }

    /* make sure the expiry is set, if present */
    if (!zz->expiry && dconf->maxage) {
        zz->expiry = now + dconf->maxage * APR_USEC_PER_SEC;
        zz->maxage = dconf->maxage;
    }

    *z = zz;

    return APR_SUCCESS;

}

/**
 * Save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_save(request_rec * r, session_rec * z)
{
    if (z) {
        apr_time_t now = apr_time_now();
        int rv = 0;

        /* sanity checks, should we try save at all? */
        if (z->written) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, SESSION_PREFIX
                          "attempt made to save the session twice, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }
        if (z->expiry && z->expiry < now) {
            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                          "attempt made to save a session when the session had already expired, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }

        /* encode the session */
        rv = ap_run_session_encode(r, z);
        if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while encoding the session, "
                          "session not saved: %s", r->uri);
            return rv;
        }

        /* try the save */
        rv = ap_run_session_save(r, z);
        if (DECLINED == rv) {
            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, SESSION_PREFIX
                          "session is enabled but no session modules have been configured, "
                          "session not saved: %s", r->uri);
            return APR_EGENERAL;
        }
        else if (OK != rv) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, SESSION_PREFIX
                          "error while saving the session, "
                          "session not saved: %s", r->uri);
            return rv;
        }
        else {
            z->written = 1;
        }
    }

    return APR_SUCCESS;

}

static int identity_count(int *count, const char *key, const char *val)
{
    *count += strlen(key) * 3 + strlen(val) * 3 + 1;
    return 1;
}

static int identity_concat(char *buffer, const char *key, const char *val)
{
    char *slider = buffer;
    int length = strlen(slider);
    slider += length;
    if (length) {
        *slider = '&';
        slider++;
    }
    ap_escape_path_segment_b(slider, key);
    slider += strlen(slider);
    *slider = '=';
    slider++;
    ap_escape_path_segment_b(slider, val);
    return 1;
}

/**
 * Default identity encoding for the session.
 *
 * By default, the name value pairs in the session are URLEncoded, separated
 * by equals, and then in turn separated by ampersand, in the format of an
 * html form.
 *
 * This was chosen to make it easy for external code to unpack a session,
 * should there be a need to do so.
 *
 * @param r The request pointer.
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_identity_encode(request_rec * r, session_rec * z)
{

    char *buffer = NULL;
    int length = 0;
    if (z->expiry) {
        char *expiry = apr_psprintf(r->pool, "%" APR_INT64_T_FMT, z->expiry);
        apr_table_set(z->entries, SESSION_EXPIRY, expiry);
    }
    apr_table_do((int (*) (void *, const char *, const char *))
                 identity_count, &length, z->entries, NULL);;
    buffer = apr_pcalloc(r->pool, length + 1);
    apr_table_do((int (*) (void *, const char *, const char *))
                 identity_concat, buffer, z->entries, NULL);
    z->encoded = buffer;
    return OK;

}

/**
 * Default identity decoding for the session.
 *
 * By default, the name value pairs in the session are URLEncoded, separated
 * by equals, and then in turn separated by ampersand, in the format of an
 * html form.
 *
 * This was chosen to make it easy for external code to unpack a session,
 * should there be a need to do so.
 *
 * This function reverses that process, and populates the session table.
 *
 * Name / value pairs that are not encoded properly are ignored.
 *
 * @param r The request pointer.
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_identity_decode(request_rec * r, session_rec * z)
{

    char *last = NULL;
    char *encoded, *pair;
    const char *sep = "&";

    /* sanity check - anything to decode? */
    if (!z->encoded) {
        return OK;
    }

    /* decode what we have */
    encoded = apr_pstrcat(r->pool, z->encoded, NULL);
    pair = apr_strtok(encoded, sep, &last);
    while (pair && pair[0]) {
        char *plast = NULL;
        const char *psep = "=";
        char *key = apr_strtok(pair, psep, &plast);
        char *val = apr_strtok(NULL, psep, &plast);
        if (key && *key) {
            if (!val || !*val) {
                apr_table_unset(z->entries, key);
            }
            if (!ap_unescape_all(key) && !ap_unescape_all(val)) {
                if (!strcmp(SESSION_EXPIRY, key)) {
                    z->expiry = (apr_time_t) apr_atoi64(val);
                }
                else {
                    apr_table_set(z->entries, key, val);
                }
            }
        }
        pair = apr_strtok(NULL, sep, &last);
    }
    z->encoded = NULL;
    return OK;

}

/**
 * Ensure any changes to the session are committed.
 *
 * This is done in an output filter so that our options for where to
 * store the session can include storing the session within a cookie:
 * As an HTTP header, the cookie must be set before the output is
 * written, but after the handler is run.
 *
 * NOTE: It is possible for internal redirects to cause more than one
 * request to be present, and each request might have a session
 * defined. We need to go through each session in turn, and save each
 * one.
 * 
 * The same session might appear in more than one request. The first
 * attempt to save the session will be called
 */
static apr_status_t ap_session_output_filter(ap_filter_t * f,
                                                    apr_bucket_brigade * in)
{

    /* save all the sessions in all the requests */
    request_rec *r = f->r->main;
    if (!r) {
        r = f->r;
    }
    while (r) {
        session_rec *z = NULL;
        session_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                      &session_module);

        /* load the session, or create one if necessary */
        ap_session_load(r, &z);
        if (!z || z->written) {
            r = r->next;
            continue;
        }

        /* if a header was specified, insert the new values from the header */
        if (conf->header_set) {
            const char *override = apr_table_get(r->err_headers_out, conf->header);
            if (!override) {
                override = apr_table_get(r->headers_out, conf->header);
            }
            if (override) {
                z->encoded = override;
                ap_session_identity_decode(r, z);
            }
        }

        /* save away the session, and we're done */
        ap_session_save(r, z);

        r = r->next;
    }

    /* remove ourselves from the filter chain */
    ap_remove_output_filter(f);

    /* send the data up the stack */
    return ap_pass_brigade(f->next, in);

}

/**
 * Insert the output filter.
 */
static void ap_session_insert_output_filter(request_rec * r)
{
    ap_add_output_filter("MOD_SESSION_OUT", NULL, r, r->connection);
}

/**
 * Fixups hook.
 *
 * Load the session within a fixup - this ensures that the session is
 * properly loaded prior to the handler being called.
 * 
 * The fixup is also responsible for injecting the session into the CGI
 * environment, should the admin have configured it so.
 * 
 * @param r The request
 */
AP_DECLARE(int) ap_session_fixups(request_rec * r)
{
    session_dir_conf *conf = ap_get_module_config(r->per_dir_config,
                                                  &session_module);

    session_rec *z = NULL;
    ap_session_load(r, &z);

    if (conf->env) {
        ap_session_identity_encode(r, z);
        if (z->encoded) {
            apr_table_set(r->subprocess_env, HTTP_SESSION, z->encoded);
            z->encoded = NULL;
        }
    }

    return OK;

}


static void *create_session_dir_config(apr_pool_t * p, char *dummy)
{
    session_dir_conf *new =
    (session_dir_conf *) apr_pcalloc(p, sizeof(session_dir_conf));

    new->includes = apr_array_make(p, 10, sizeof(const char **));
    new->excludes = apr_array_make(p, 10, sizeof(const char **));

    return (void *) new;
}

static void *merge_session_dir_config(apr_pool_t * p, void *basev, void *addv)
{
    session_dir_conf *new = (session_dir_conf *) apr_pcalloc(p, sizeof(session_dir_conf));
    session_dir_conf *add = (session_dir_conf *) addv;
    session_dir_conf *base = (session_dir_conf *) basev;

    new->enabled = (add->enabled_set == 0) ? base->enabled : add->enabled;
    new->enabled_set = add->enabled_set || base->enabled_set;
    new->maxage = (add->maxage_set == 0) ? base->maxage : add->maxage;
    new->maxage_set = add->maxage_set || base->maxage_set;
    new->header = (add->header_set == 0) ? base->header : add->header;
    new->header_set = add->header_set || base->header_set;
    new->env = (add->env_set == 0) ? base->env : add->env;
    new->env_set = add->env_set || base->env_set;
    new->includes = apr_array_append(p, base->includes, add->includes);
    new->excludes = apr_array_append(p, base->excludes, add->excludes);

    return new;
}


static const char *
     set_session_enable(cmd_parms * parms, void *dconf, int flag)
{
    session_dir_conf *conf = dconf;

    conf->enabled = flag;
    conf->enabled_set = 1;

    return NULL;
}

static const char *
     set_session_maxage(cmd_parms * parms, void *dconf, const char *arg)
{
    session_dir_conf *conf = dconf;

    conf->maxage = atol(arg);
    conf->maxage_set = 1;

    return NULL;
}

static const char *
     set_session_header(cmd_parms * parms, void *dconf, const char *arg)
{
    session_dir_conf *conf = dconf;

    conf->header = arg;
    conf->header_set = 1;

    return NULL;
}

static const char *
     set_session_env(cmd_parms * parms, void *dconf, int flag)
{
    session_dir_conf *conf = dconf;

    conf->env = flag;
    conf->env_set = 1;

    return NULL;
}

static const char *add_session_include(cmd_parms * cmd, void *dconf, const char *f)
{
    session_dir_conf *conf = dconf;

    const char **new = apr_array_push(conf->includes);
    *new = f;

    return NULL;
}

static const char *add_session_exclude(cmd_parms * cmd, void *dconf, const char *f)
{
    session_dir_conf *conf = dconf;

    const char **new = apr_array_push(conf->excludes);
    *new = f;

    return NULL;
}


static const command_rec session_cmds[] =
{
    AP_INIT_FLAG("Session", set_session_enable, NULL, OR_AUTHCFG,
                 "on if a session should be maintained for these URLs"),
    AP_INIT_TAKE1("SessionMaxAge", set_session_maxage, NULL, OR_AUTHCFG,
                  "length of time for which a session should be valid. Zero to disable"),
    AP_INIT_TAKE1("SessionHeader", set_session_header, NULL, OR_AUTHCFG,
                  "output header, if present, whose contents will be injected into the session."),
    AP_INIT_FLAG("SessionEnv", set_session_env, NULL, OR_AUTHCFG,
                 "on if a session should be written to the CGI environment. Defaults to off"),
    AP_INIT_TAKE1("SessionInclude", add_session_include, NULL, OR_AUTHCFG,
                  "URL prefixes to include in the session. Defaults to all URLs"),
    AP_INIT_TAKE1("SessionExclude", add_session_exclude, NULL, OR_AUTHCFG,
                  "URL prefixes to exclude from the session. Defaults to no URLs"),
    {NULL}
};

static void register_hooks(apr_pool_t * p)
{
    ap_register_output_filter("MOD_SESSION_OUT", ap_session_output_filter,
                              NULL, AP_FTYPE_CONTENT_SET);
    ap_hook_insert_filter(ap_session_insert_output_filter, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_insert_error_filter(ap_session_insert_output_filter,
                                NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_fixups(ap_session_fixups, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_session_encode(ap_session_identity_encode, NULL, NULL, APR_HOOK_REALLY_FIRST);
    ap_hook_session_decode(ap_session_identity_decode, NULL, NULL, APR_HOOK_REALLY_LAST);
    APR_REGISTER_OPTIONAL_FN(ap_session_get);
    APR_REGISTER_OPTIONAL_FN(ap_session_set);
    APR_REGISTER_OPTIONAL_FN(ap_session_load);
    APR_REGISTER_OPTIONAL_FN(ap_session_save);
}

module AP_MODULE_DECLARE_DATA session_module =
{
    STANDARD20_MODULE_STUFF,
    create_session_dir_config,   /* dir config creater */
    merge_session_dir_config,    /* dir merger --- default is to override */
    NULL,                        /* server config */
    NULL,                        /* merge server config */
    session_cmds,                /* command apr_table_t */
    register_hooks               /* register hooks */
};
/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef MOD_SESSION_H
#define MOD_SESSION_H

/**
 * @file  mod_session.h
 * @brief Session Module for Apache
 *
 * @defgroup MOD_SESSION mod_session
 * @ingroup  APACHE_MODS
 * @{
 */

#define CORE_PRIVATE

#include "apr_hooks.h"
#include "apr_optional.h"
#include "apr_tables.h"
#include "apr_uuid.h"
#include "apr_pools.h"
#include "apr_time.h"

#include "httpd.h"
#include "http_config.h"
#include "ap_config.h"

#define MOD_SESSION_NOTES_KEY "mod_session_key"

/**
 * Define the name of a username stored in the session, so that modules interested
 * in the username can find it in a standard place.
 */
#define MOD_SESSION_USER "user"

/**
 * Define the name of a password stored in the session, so that modules interested
 * in the password can find it in a standard place.
 */
#define MOD_SESSION_PW "pw"

/**
 * A session structure.
 *
 * At the core of the session is a set of name value pairs making up the
 * session.
 *
 * The session might be uniquely identified by an anonymous uuid, or
 * a remote_user value, or both.
 */
typedef struct {
    apr_pool_t *pool;             /* pool to be used for this session */
    apr_uuid_t *uuid;             /* anonymous uuid of this particular session */
    const char *remote_user;      /* user who owns this particular session */
    apr_table_t *entries;         /* key value pairs */
    const char *encoded;          /* the encoded version of the key value pairs */
    apr_time_t expiry;            /* if > 0, the time of expiry of this session */
    long maxage;                  /* if > 0, the maxage of the session, from
                                   * which expiry is calculated */
    int dirty;                    /* dirty flag */
    int cached;                   /* true if this session was loaded from a
                                   * cache of some kind */
    int written;                  /* true if this session has already been
                                   * written */
} session_rec;

/**
 * Structure to carry the per-dir session config.
 */
typedef struct {
    int enabled;                  /* whether the session has been enabled for
                                   * this directory */
    int enabled_set;
    long maxage;                  /* seconds until session expiry */
    int maxage_set;
    const char *header;           /* header to inject session */
    int header_set;
    int env;                      /* whether the session has been enabled for
                                   * this directory */
    int env_set;
    apr_array_header_t *includes; /* URL prefixes to be included. All
                                   * URLs included if empty */
    apr_array_header_t *excludes; /* URL prefixes to be excluded. No
                                   * URLs excluded if empty */
} session_dir_conf;

/**
 * Get a particular value from the session.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to get.
 * @param value The buffer to write the value to.
 */
AP_DECLARE(void) ap_session_get(request_rec * r, session_rec * z, const char *key, const char **value);

/**
 * Set a particular value to the session.
 *
 * Using this method ensures that the dirty flag is set correctly, so that
 * the session can be saved efficiently.
 * @param r The current request.
 * @param z The current session. If this value is NULL, the session will be
 * looked up in the request, created if necessary, and saved to the request
 * notes.
 * @param key The key to set. The existing key value will be replaced.
 * @param value The value to set.
 */
AP_DECLARE(void) ap_session_set(request_rec * r, session_rec * z,
                                const char *key, const char *value);

/**
 * Load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_load(request_rec * r, session_rec ** z);

/**
 * Hook to load the session.
 *
 * If the session doesn't exist, a blank one will be created.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_load, (request_rec * r, session_rec ** z))

/**
 * Save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE(int) ap_session_save(request_rec * r, session_rec * z);

/**
 * Hook to save the session.
 *
 * In most implementations the session is only saved if the dirty flag is
 * true. This prevents the session being saved unnecessarily.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_save, (request_rec * r, session_rec * z))

/**
 * Hook to encode the session.
 *
 * In the default implementation, the key value pairs are encoded using
 * key value pairs separated by equals, in turn separated by ampersand,
 * like a web form.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_encode, (request_rec * r, session_rec * z))

/**
 * Hook to decode the session.
 *
 * In the default implementation, the key value pairs are encoded using
 * key value pairs separated by equals, in turn separated by ampersand,
 * like a web form.
 *
 * @param r The request
 * @param z A pointer to where the session will be written.
 */
AP_DECLARE_HOOK(int, session_decode, (request_rec * r, session_rec * z))

APR_DECLARE_OPTIONAL_FN(void, ap_session_get, (request_rec * r, session_rec * z,
                                               const char *key, const char **value));
APR_DECLARE_OPTIONAL_FN(void, ap_session_set, (request_rec * r, session_rec * z,
                                               const char *key, const char *value));
APR_DECLARE_OPTIONAL_FN(int, ap_session_load, (request_rec *, session_rec **));
APR_DECLARE_OPTIONAL_FN(int, ap_session_save, (request_rec *, session_rec *));

/**
 * The name of the module.
 */
extern module AP_MODULE_DECLARE_DATA session_module;

#endif /* MOD_SESSION_H */
/** @} */
AP_DECLARE(int) ap_unescape_all(char *url)
{
    return unescape_url(url, NULL, NULL);
}

AP_DECLARE(char *) ap_escape_path_segment_b(char *copy, const char *segment)
AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char *segment)
{
    return ap_escape_path_segment_b(apr_palloc(p, 3 * strlen(segment) + 1), segment);
}


#ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
    /* 
     * Disallow a session from being resumed during a renegotiation,
     * so that an acceptable cipher suite can be negotiated.
     */
    SSL_CTX_set_options(ctx, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
#endif
        
        /*
         * Also check that SSLCipherSuite has been enforced as expected.
         */
        if (cipher_list) {
            cipher = SSL_get_current_cipher(ssl);
            if (sk_SSL_CIPHER_find(cipher_list, cipher) < 0) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                             "SSL cipher suite not renegotiated: "
                             "access to %s denied using cipher %s",
                              r->filename,
                              SSL_CIPHER_get_name(cipher));
                return HTTP_FORBIDDEN;
            }
        }
 * 20120211.23 (2.4.5-dev) Add ap_proxy_clear_connection()
#define MODULE_MAGIC_NUMBER_MINOR 23                   /* 0...n */
/**
 * Clear the headers referenced by the Connection header from the given
 * table, and remove the Connection header.
 * @param r request
 * @param headers table of headers to clear
 * @return 1 if "close" was present, 0 otherwise.
 */
APR_DECLARE_OPTIONAL_FN(int, ap_proxy_clear_connection,
        (request_rec *r, apr_table_t *headers));

static int (*ap_proxy_clear_connection_fn)(request_rec *r, apr_table_t *headers) =
        NULL;



            backend->close = ap_proxy_clear_connection_fn(r, r->headers_out);



/* post_config hook: */
static int proxy_http_post_config(apr_pool_t *pconf, apr_pool_t *plog,
        apr_pool_t *ptemp, server_rec *s)
{

    /* proxy_http_post_config() will be called twice during startup.  So, don't
     * set up the static data the 1st time through. */
    if (ap_state_query(AP_SQ_MAIN_STATE) == AP_SQ_MS_CREATE_PRE_CONFIG) {
        return OK;
    }

    if (!ap_proxy_clear_connection_fn) {
        ap_proxy_clear_connection_fn =
                APR_RETRIEVE_OPTIONAL_FN(ap_proxy_clear_connection);
        if (!ap_proxy_clear_connection_fn) {
            ap_log_error(APLOG_MARK, APLOG_EMERG, 0, s, APLOGNO(02477)
                         "mod_proxy must be loaded for mod_proxy_http");
            return !OK;
        }
    }

    return OK;
}

    ap_hook_post_config(proxy_http_post_config, NULL, NULL, APR_HOOK_MIDDLE);
typedef struct header_connection {
    apr_array_header_t *array;
    const char *first;
    unsigned int closed:1;
} header_connection;
static int find_conn_headers(void *data, const char *key, const char *val)
    header_connection *x = data;

    do {
        while (*val == ',') {
            val++;
        name = ap_get_token(x->pool, &val, 0);
        if (!strcasecmp(name, "close")) {
            x->closed = 1;
        if (!x->first) {
            x->first = name;
        }
        else {
            const char **elt;
            if (!x->array) {
                x->array = apr_array_make(x->pool, 4, sizeof(char *));
            }
            elt = apr_array_push(x->array);
            *elt = name;
        }
    } while (*val);

/**
 * Remove all headers referred to by the Connection header.
 */
static int ap_proxy_clear_connection(request_rec *r, apr_table_t *headers)
    const char **name;
    header_connection x;

    x.pool = r->pool;
    x.array = NULL;
    x.first = NULL;
    x.closed = 0;


    apr_table_do(find_conn_headers, &x, headers, "Connection", NULL);
    if (x.first) {
        /* fast path - no memory allocated for one header */
        apr_table_unset(headers, "Connection");
        apr_table_unset(headers, x.first);
    }
    if (x.array) {
        /* two or more headers */
        while ((name = apr_array_pop(x.array))) {
            apr_table_unset(headers, *name);
        }
    }

    return x.closed;
    ap_proxy_clear_connection(r, headers_in_copy);

void proxy_util_register_hooks(apr_pool_t *p)
{
    APR_REGISTER_OPTIONAL_FN(ap_proxy_retry_worker);
    APR_REGISTER_OPTIONAL_FN(ap_proxy_clear_connection);
}
    apr_pool_t *pool = s->process->pool;
                          pool);
    mc = (SSLModConfigRec *)apr_palloc(pool, sizeof(*mc));
    mc->pPool = pool;
    mc->aRandSeed              = apr_array_make(pool, 4,
    mc->tVHostKeys             = apr_hash_make(pool);
    mc->tPrivateKey            = apr_hash_make(pool);
    mc->tPublicCert            = apr_hash_make(pool);
    mc->tTmpKeys               = apr_hash_make(pool);
                          pool);
    ssl_randseed_t *seed;
    seed = apr_array_push(mc->aRandSeed);
        seed->nCtx = SSL_RSCTX_STARTUP;
        seed->nCtx = SSL_RSCTX_CONNECT;
        seed->nSrc   = SSL_RSSRC_FILE;
        seed->cpPath = ap_server_root_relative(mc->pPool, arg2+5);
        seed->nSrc   = SSL_RSSRC_EXEC;
        seed->cpPath = ap_server_root_relative(mc->pPool, arg2+5);
        seed->nSrc   = SSL_RSSRC_EGD;
        seed->cpPath = ap_server_root_relative(mc->pPool, arg2+4);
        seed->nSrc   = SSL_RSSRC_BUILTIN;
        seed->cpPath = NULL;
        seed->nSrc   = SSL_RSSRC_FILE;
        seed->cpPath = ap_server_root_relative(mc->pPool, arg2);
    if (seed->nSrc != SSL_RSSRC_BUILTIN) {
        if (!ssl_util_path_check(SSL_PCM_EXISTS, seed->cpPath, cmd->pool)) {
                               seed->cpPath, "' does not exist", NULL);
        seed->nBytes = 0; /* read whole file */
        if (seed->nSrc == SSL_RSSRC_BUILTIN) {
        seed->nBytes = atoi(arg3);
        if (seed->nBytes < 0) {
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
            sc->szPublicCertFile[i] = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
            sc->szPrivateKeyFile[i] = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
    sc->szCertificateChain = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, path, cmd->pool)) {
                           path, "' does not exist", NULL);
        sc->szCACertificatePath = path;
        dc->szCACertificatePath = path;
    sc->szCACertificatePath = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
        sc->szCACertificateFile = path;
        dc->szCACertificateFile = path;
    sc->szCACertificateFile = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, path, cmd->pool)) {
                           path, "' does not exist", NULL);
    sc->szCARevocationPath = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
    sc->szCARevocationFile = path;
                               const char *arg)
    while (*arg) {
        w = ap_getword_conf(cmd->pool, &arg);
                               const char *arg)
    ssl_expr *expr;
    ssl_require_t *require;
    if (!(expr = ssl_expr_comp(cmd->pool, (char *)arg))) {
    require = apr_array_push(dc->aRequirement);
    require->cpExpr = apr_pstrdup(cmd->pool, arg);
    require->mpExpr = expr;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
    sc->szProxyCACertificateFile = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, path, cmd->pool)) {
                           path, "' does not exist", NULL);
    sc->szProxyCACertificatePath = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, path, cmd->pool)) {
                           path, "' does not exist or is empty", NULL);
    sc->szProxyClientCertificateFile = path;
    const char *path = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, path, cmd->pool)) {
                           path, "' does not exist", NULL);
    sc->szProxyClientCertificatePath = path;
    unsigned char *ptr;
        ptr = ssl_asn1_table_set(mc->tTmpKeys, "RSA:512", length);
        (void)i2d_RSAPrivateKey(rsa, &ptr); /* 2nd arg increments */
        ptr = ssl_asn1_table_set(mc->tTmpKeys, "RSA:1024", length);
        (void)i2d_RSAPrivateKey(rsa, &ptr); /* 2nd arg increments */
        ptr = ssl_asn1_table_set(mc->tTmpKeys, "DH:512", length);
        (void)i2d_DHparams(dh, &ptr); /* 2nd arg increments */
        ptr = ssl_asn1_table_set(mc->tTmpKeys, "DH:1024", length);
        (void)i2d_DHparams(dh, &ptr); /* 2nd arg increments */
            ptr = asn1->cpData;
                  d2i_RSAPrivateKey(NULL, &ptr, asn1->nData)))
            ptr = asn1->cpData;
                  d2i_RSAPrivateKey(NULL, &ptr, asn1->nData)))
            ptr = asn1->cpData;
                  d2i_DHparams(NULL, &ptr, asn1->nData)))
            ptr = asn1->cpData;
                  d2i_DHparams(NULL, &ptr, asn1->nData)))
    int verify = SSL_VERIFY_NONE;
    char *cp, *vhost_id;
    EVP_PKEY *pkey;
    STACK_OF(X509_NAME) *ca_list;
    unsigned char *ptr;
    int is_ca, pathlen;
    sc->szVHostID = vhost_id = ssl_util_vhostid(p, s);
                vhost_id);
                "(theoretically shouldn't happen!)", vhost_id);
                vhost_id);
            vhost_id, cp);
        verify |= SSL_VERIFY_PEER_STRICT;
        verify |= SSL_VERIFY_PEER;
    SSL_CTX_set_verify(ctx, verify,  ssl_callback_SSLVerify);
                vhost_id, sc->szCipherSuite);
                    vhost_id);
                "Init: (%s) Configuring client authentication", vhost_id);
                    "for client authentication", vhost_id);
        ca_list = ssl_init_FindCAList(s, p,
                                      sc->szCACertificateFile,
                                      sc->szCACertificatePath);
        if (!ca_list) {
                    vhost_id);
        SSL_CTX_set_client_CA_list(sc->pSSLCtx, (STACK *)ca_list);
                vhost_id);
                    vhost_id);
        ca_list = (STACK_OF(X509_NAME) *)SSL_CTX_get_client_CA_list(ctx);
        if (sk_X509_NAME_num(ca_list) == 0) {
    cp = apr_psprintf(p, "%s:RSA", vhost_id);
                vhost_id);
        ptr = asn1->cpData;
              d2i_X509(NULL, &ptr, asn1->nData)))
                    vhost_id);
                    vhost_id);
    cp = apr_psprintf(p, "%s:DSA", vhost_id);
                vhost_id);
        ptr = asn1->cpData;
              d2i_X509(NULL, &ptr, asn1->nData)))
                    vhost_id);
                    vhost_id);
                vhost_id);
                vhost_id);
                        vhost_id, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
            if (SSL_X509_getBC(sc->pPublicCert[i], &is_ca, &pathlen)) {
                if (is_ca) {
                            vhost_id, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
                            vhost_id, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
                            vhost_id, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
                            vhost_id, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
    cp = apr_psprintf(p, "%s:RSA", vhost_id);
                vhost_id);
        ptr = asn1->cpData;
              d2i_PrivateKey(EVP_PKEY_RSA, NULL, &ptr, asn1->nData)))
                    vhost_id);
                    vhost_id);
    cp = apr_psprintf(p, "%s:DSA", vhost_id);
                vhost_id);
        ptr = asn1->cpData;
              d2i_PrivateKey(EVP_PKEY_DSA, NULL, &ptr, asn1->nData)))
                    vhost_id);
                    vhost_id);
                vhost_id);
        pkey = X509_get_pubkey(sc->pPublicCert[SSL_AIDX_DSA]);
        if (pkey && (EVP_PKEY_key_type(pkey) == EVP_PKEY_DSA) &&
            EVP_PKEY_missing_parameters(pkey))
            EVP_PKEY_copy_parameters(pkey,
        BOOL skip_first = FALSE;
                skip_first = TRUE;
                                          skip_first, NULL);
                    vhost_id);
                vhost_id, n, n == 1 ? "" : "s");
    server_rec *s, **ps;
    ssl_ds_table *table;
    apr_pool_t *subpool;
    BOOL conflict = FALSE;
    apr_pool_create(&subpool, p);
    table = ssl_ds_table_make(subpool, sizeof(server_rec *));
        key = apr_psprintf(subpool, "%pA:%u",
        if ((ps = ssl_ds_table_get(table, key))) {
            conflict = TRUE;
        ps = ssl_ds_table_push(table, key);
    ssl_ds_table_kill(table);
    apr_pool_destroy(subpool);
    if (conflict) {
static void ssl_init_PushCAList(STACK_OF(X509_NAME) *ca_list,
        if (sk_X509_NAME_find(ca_list, name) < 0) {
            /* this will be freed when ca_list is */
            sk_X509_NAME_push(ca_list, name);
                                         apr_pool_t *p,
                                         const char *ca_file,
                                         const char *ca_path)
    STACK_OF(X509_NAME) *ca_list;
    apr_pool_t *subpool;
    apr_pool_sub_make(&subpool, p, NULL);
    ca_list = sk_X509_NAME_new(ssl_init_FindCAList_X509NameCmp);
    if (ca_file) {
        ssl_init_PushCAList(ca_list, s, ca_file);
    if (ca_path) {
        if (apr_dir_open(&dir, ca_path, subpool) != APR_SUCCESS) {
                    ca_path);
            const char *file;
            file = apr_pstrcat(subpool, ca_path, "/", direntry.name, NULL);
            ssl_init_PushCAList(ca_list, s, file);
    sk_X509_NAME_set_cmp_func(ca_list, NULL);
    apr_pool_destroy(subpool);
    return ca_list;
    const char *type = "";
        type = "standard";
        type = "unclean";
        type = "accurate";
                conn->id, type,
    apr_array_header_t *requires;
    ssl_require_t *ssl_requires;
    STACK_OF(X509_NAME) *ca_list;
    char *ca_path, *ca_file;
    STACK_OF(X509) *cert_stack;
    X509_STORE *cert_store;
    X509_STORE_CTX cert_store_ctx;
    STACK_OF(SSL_CIPHER) *cipher_list_old, *cipher_list = NULL;
    SSL_CIPHER *cipher = NULL;
    int depth, verify_old, verify, n;
            cipher = SSL_get_current_cipher(ssl);
            cipher_list_old = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);
            if (cipher_list_old) {
                cipher_list_old = sk_SSL_CIPHER_dup(cipher_list_old);
            if (cipher_list_old) {
                sk_SSL_CIPHER_free(cipher_list_old);
        cipher_list = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);
            if ((!cipher && cipher_list) ||
                (cipher && !cipher_list))
            else if (cipher && cipher_list &&
                     (sk_SSL_CIPHER_find(cipher_list, cipher) < 0))
            if ((!cipher_list_old && cipher_list) ||
                (cipher_list_old && !cipher_list))
            else if (cipher_list_old && cipher_list) {
                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list));
                    SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list, n);
                    if (sk_SSL_CIPHER_find(cipher_list_old, value) < 0) {
                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list_old));
                    SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list_old, n);
                    if (sk_SSL_CIPHER_find(cipher_list, value) < 0) {
        if (cipher_list_old) {
            sk_SSL_CIPHER_free(cipher_list_old);
        verify_old = SSL_get_verify_mode(ssl);
        verify = SSL_VERIFY_NONE;
            verify |= SSL_VERIFY_PEER_STRICT;
            verify |= SSL_VERIFY_PEER;
        SSL_set_verify(ssl, verify, ssl_callback_SSLVerify);
        if (verify != verify_old) {
            if (((verify_old == SSL_VERIFY_NONE) &&
                 (verify     != SSL_VERIFY_NONE)) ||
                (!(verify_old & SSL_VERIFY_PEER) &&
                  (verify     & SSL_VERIFY_PEER)) ||
                (!(verify_old & SSL_VERIFY_PEER_STRICT) &&
                  (verify     & SSL_VERIFY_PEER_STRICT)))
                    (verify_old == SSL_VERIFY_NONE) &&
        ca_file = dc->szCACertificateFile ?
        ca_path = dc->szCACertificatePath ?
           if (!SSL_load_verify_locations(ssl, ca_file, ca_path)) {
        if (!SSL_CTX_load_verify_locations(ctx, ca_file, ca_path)) {
        if (!(ca_list = ssl_init_FindCAList(r->server, r->pool,
                                            ca_file, ca_path)))
        SSL_set_client_CA_list(ssl, ca_list);
            if (!(cert_store = SSL_CTX_get_cert_store(ctx))) {
            cert_stack = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl);
            if (!cert_stack || (sk_X509_num(cert_stack) == 0)) {
            cert = sk_X509_value(cert_stack, 0);
            X509_STORE_CTX_init(&cert_store_ctx, cert_store, cert, cert_stack);
                X509_STORE_CTX_set_depth(&cert_store_ctx, depth);
            X509_STORE_CTX_set_ex_data(&cert_store_ctx,
            if (!X509_verify_cert(&cert_store_ctx)) {
            SSL_set_verify_result(ssl, cert_store_ctx.error);
            X509_STORE_CTX_cleanup(&cert_store_ctx);
            BOOL do_verify = (dc->nVerifyClient == SSL_CVERIFY_REQUIRE);
            if (do_verify && (SSL_get_verify_result(ssl) != X509_V_OK)) {
            if (do_verify && !SSL_get_peer_certificate(ssl)) {
    requires = dc->aRequirement;
    ssl_requires = (ssl_require_t *)requires->elts;
    for (i = 0; i < requires->nelts; i++) {
        ssl_require_t *req = &ssl_requires[i];
        ok = ssl_expr_exec(r, req->mpExpr);
                    "Failed expression: %s", req->cpExpr);
    char buf1[MAX_STRING_LEN], buf2[MAX_STRING_LEN];
    const char *auth_line, *username, *password;
    if ((auth_line = apr_table_get(r->headers_in, "Authorization"))) {
        if (strcEQ(ap_getword(r->pool, &auth_line, ' '), "Basic")) {
            while ((*auth_line == ' ') || (*auth_line == '\t')) {
                auth_line++;
            auth_line = ap_pbase64decode(r->pool, auth_line);
            username = ap_getword_nulls(r->pool, &auth_line, ':');
            password = auth_line;
            if ((username[0] == '/') && strEQ(password, "password")) {
    apr_snprintf(buf1, sizeof(buf1), "%s:password", clientdn);
    ssl_util_uuencode(buf2, buf1, FALSE);
    apr_snprintf(buf1, sizeof(buf1), "Basic %s", buf2);
    apr_table_set(r->headers_in, "Authorization", buf1);
            "Faking HTTP Basic Auth header: \"Authorization: %s\"", buf1);
    apr_table_t *env = r->subprocess_env;
    STACK_OF(X509) *peer_certs;
    apr_table_setn(env, "HTTPS", "on"); 
                apr_table_setn(env, var, val);
        apr_table_setn(env, "SSL_SERVER_CERT", val);
        apr_table_setn(env, "SSL_CLIENT_CERT", val);
        if ((peer_certs = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl))) {
            for (i = 0; i < sk_X509_num(peer_certs); i++) {
                    apr_table_setn(env, var, val);
RSA *ssl_callback_TmpRSA(SSL *ssl, int export, int keylen)
    conn_rec *c = (conn_rec *)SSL_get_app_data(ssl);
    if (export) {
        if (keylen == 512) {
        else if (keylen == 1024) {
DH *ssl_callback_TmpDH(SSL *ssl, int export, int keylen)
    conn_rec *c = (conn_rec *)SSL_get_app_data(ssl);
    if (export) {
        if (keylen == 512) {
        else if (keylen == 1024) {
        X509 *cert  = X509_STORE_CTX_get_current_cert(ctx);
        char *sname = X509_NAME_oneline(X509_get_subject_name(cert), NULL, 0);
        char *iname = X509_NAME_oneline(X509_get_issuer_name(cert),  NULL, 0);
                sname ? sname : "-unknown-",
                iname ? iname : "-unknown-");
        if (sname) {
            free(sname);
        if (iname) {
            free(iname);
    X509 *cert;
    cert    = X509_STORE_CTX_get_current_cert(ctx);
    subject = X509_get_subject_name(cert);
    issuer  = X509_get_issuer_name(cert);
        if (X509_CRL_verify(crl, X509_get_pubkey(cert)) <= 0) {
            if (!ASN1_INTEGER_cmp(sn, X509_get_serialNumber(cert))) {
int ssl_callback_NewSessionCacheEntry(SSL *ssl, SSL_SESSION *session)
    SSL_set_timeout(session, timeout);
    session_id = SSL_SESSION_get_session_id(session);
    session_id_length = SSL_SESSION_get_session_id_length(session);
    timeout += SSL_get_time(session);
                          timeout, session);
     * return 0 which means to OpenSSL that the session is still
                                               int idlen, int *do_copy)
    SSL_SESSION *session;
    session = ssl_scache_retrieve(s, id, idlen);
    if (session) {
     * setting do_copy to 0) that the reference count on the
    *do_copy = 0;
    return session;
                                       SSL_SESSION *session)
    session_id = SSL_SESSION_get_session_id(session);
    session_id_length = SSL_SESSION_get_session_id_length(session);
            char *str = (where & SSL_CB_READ) ? "read" : "write";
static apr_off_t get_content_length(request_rec * r)
{
    apr_off_t len = 0;

    if (r->clength > 0) {
        return r->clength;
    }
    else if (r->main == NULL) {
        const char *clp = apr_table_get(r->headers_in, "Content-Length");

        if (clp) {
            char *errp;
            if (apr_strtoff(&len, clp, &errp, 10) || *errp || len < 0) {
                len = 0; /* parse error */
            }
        }
    }

    return len;
}

    apr_off_t content_length = 0;
        /* Get client provided Content-Length header */
        content_length = get_content_length(r);
        else if (content_length > 0) {
            ap_log_error(APLOG_MARK, APLOG_ERR, status, r->server,
                         "proxy: read zero bytes, expecting"
                         " %" APR_OFF_T_FMT " bytes",
                         content_length);
            status = ajp_send_data_msg(conn->sock, msg, 0);
            if (status != APR_SUCCESS) {
                /* We had a failure: Close connection to backend */
                conn->close++;
                ap_log_error(APLOG_MARK, APLOG_ERR, status, r->server,
                            "proxy: send failed to %pI (%s)",
                            conn->worker->cp->addr,
                            conn->worker->hostname);
                return HTTP_INTERNAL_SERVER_ERROR;
            }
            else {
                /* Client send zero bytes with C-L > 0
                 */
                return HTTP_BAD_REQUEST;
            }
        }
    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, DAV_XML_CONTENT_TYPE);
    ap_set_content_type(r, "text/xml");
    ap_set_content_type(r, apr_pstrdup(r->pool, info->content_type));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html;charset=utf-8");
    ap_set_content_type(r, "text/html");
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(rr, CGI_MAGIC_TYPE);
    ap_set_content_type(r, "text/html");
    ap_set_content_type(r, "text/html");
                    ap_set_content_type(r, "text/plain");
    ap_set_content_type(r, "message/http");
AP_DECLARE(void) ap_set_content_type(request_rec *r, const char *ct)
        ap_set_content_type(r, "text/html; charset=iso-8859-1");
            ap_set_content_type(r, apr_pstrcat(r->pool, "multipart",
                                               use_range_x(r) ? "/x-" : "/",
                                               "byteranges; boundary=",
                                               r->boundary, NULL));
    ap_set_content_type(r, rr->content_type);
        ap_set_content_type(new, r->content_type);
        ap_set_content_type(r, DIR_MAGIC_TYPE);
                ap_set_content_type(r, (char*) type);
                ap_set_content_type(r, exinfo->forced_type);
	    ap_set_content_type(r, apr_pstrcat(r->pool, ctp->type, "/",
                                               ctp->subtype, NULL));
			ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                           "; charset=", charset,
                                                           NULL));
		    ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                       "; ", pp->attr,
                                                       "=", pp->val,
                                                       NULL));
		ap_set_content_type(r, apr_pstrcat(r->pool, r->content_type,
                                                   "; charset=", charset,
                                                   NULL));
    ap_set_content_type(r, "text/html");
            ap_set_content_type(sub_req, CGI_MAGIC_TYPE);
        ap_set_content_type(r, t);
                ap_set_content_type(r, p->forced_mimetype);
	    ap_set_content_type(r, tmp);
	ap_set_content_type(r, tmp);
	ap_set_content_type(r, apr_pstrdup(r->pool, sub->content_type));
        ap_set_content_type(r, "text/html");
            ap_set_content_type(r, ap_default_type(r));
                    ap_set_content_type(r, apr_pstrdup(p, buf));
#include "http_main.h"
#include "http_protocol.h"
    char *date_str = ap_palloc(p, 48 * sizeof(char));
    char *date_str_ptr = date_str;
    int real_year;

    tms = gmtime(&sec);    /* ZZZ replace with AP time routine */

    /* Assumption: this is always 3 */
    /* i = strlen(ap_day_snames[tms->tm_wday]); */
    memcpy(date_str_ptr, ap_day_snames[tms->tm_wday], 3);
    date_str_ptr += 3;
    *date_str_ptr++ = ',';
    *date_str_ptr++ = ' ';
    *date_str_ptr++ = tms->tm_mday / 10 + '0';
    *date_str_ptr++ = tms->tm_mday % 10 + '0';
    *date_str_ptr++ = ' ';
    /* Assumption: this is also always 3 */
    /* i = strlen(ap_month_snames[tms->tm_mon]); */
    memcpy(date_str_ptr, ap_month_snames[tms->tm_mon], 3);
    date_str_ptr += 3;
    *date_str_ptr++ = ' ';
    real_year = 1900 + tms->tm_year;
    /* This routine isn't y10k ready. */
    *date_str_ptr++ = real_year / 1000 + '0';
    *date_str_ptr++ = real_year % 1000 / 100 + '0';
    *date_str_ptr++ = real_year % 100 / 10 + '0';
    *date_str_ptr++ = real_year % 10 + '0';
    *date_str_ptr++ = ' ';
    *date_str_ptr++ = tms->tm_hour / 10 + '0';
    *date_str_ptr++ = tms->tm_hour % 10 + '0';
    *date_str_ptr++ = ':';
    *date_str_ptr++ = tms->tm_min / 10 + '0';
    *date_str_ptr++ = tms->tm_min % 10 + '0';
    *date_str_ptr++ = ':';
    *date_str_ptr++ = tms->tm_sec / 10 + '0';
    *date_str_ptr++ = tms->tm_sec % 10 + '0';
    *date_str_ptr++ = ' ';
    *date_str_ptr++ = 'G';
    *date_str_ptr++ = 'M';
    *date_str_ptr++ = 'T';
    *date_str_ptr = '\0';

    return date_str;

    /* The equivalent using sprintf. Use this for more legible but slower code
    */
    register int badesc, badpath;
    char *x, *y;
    /* Initial scan for first '%'. Don't bother writing values before
     * seeing a '%' */
    y = strchr(url, '%');
    if (y == NULL) {
        return OK;
    }
    for (x = y; *y; ++x, ++y) {
	if (*y != '%')
	    *x = *y;
	    if (!ap_isxdigit(*(y + 1)) || !ap_isxdigit(*(y + 2))) {
		*x = '%';
		*x = x2c(y + 1);
		if (*x == '/' || *x == '\0')
    *x = '\0';
/* XXXX - fix me / EBCDIC
 *        there was a cludge here which would use its
 *	  own version ap_isascii(). Indicating that
 *	  on some platforms that might be needed. 
 *
 *	  #define OS_ASC(c) (c)		    -- for mere mortals 
 *     or
 *        #define OS_ASC(c) (ebcdic2ascii[c]) -- for dino's
 *
 *        #define ap_isascii(c) ((OS_ASC(c) & 0x80) == 0)
 */

/* XXXXX - fix me - See note with NOT_PROXY */

    ap_table_t *charset_types;       /* Added with AddCharset... */       
	                        /* Due to the FUD about JS and charsets 
                                 * default_charset is actually in src/main */
typedef struct param_s {
    char *attr;
    char *val;
    struct param_s *next;
} param;

typedef struct {
    char *type;
    char *subtype;
    param *param;
} content_type;

static char tspecial[] = {
    '(', ')', '<', '>', '@', ',', ';', ':',
    '\\', '"', '/', '[', ']', '?', '=',
    '\0'
};

    new->charset_types = ap_make_table(p, 4);
					 base->forced_types);
    new->charset_types = ap_overlay_tables(p, add->charset_types,
					   base->charset_types);
static const char *add_type(cmd_parms *cmd, mime_dir_config *m, char *ct,
	++ext;
	
static const char *add_encoding(cmd_parms *cmd, mime_dir_config *m, char *enc,
static const char *add_charset(cmd_parms *cmd, mime_dir_config *m,
			       char *charset, char *ext)
{
    if (*ext == '.') {
	++ext;
    }
    ap_str_tolower(charset);
    ap_table_setn(m->charset_types, ext, charset);
    return NULL;
}

static const char *add_language(cmd_parms *cmd, mime_dir_config *m, char *lang,
    if (*ext == '.') {
	++ext;
    }
static const char *add_handler(cmd_parms *cmd, mime_dir_config *m, char *hdlr,
    {"AddCharset", add_charset, NULL, OR_FILEINFO, ITERATE2,
     "a charset (e.g., iso-2022-jp), followed by one or more file extensions"},
static char *zap_sp(char *s)
{
    char *tp;

    if (s == NULL) {
	return (NULL);
    }
    if (*s == '\0') {
	return (s);
    }

    /* delete prefixed white space */
    for (; *s == ' ' || *s == '\t' || *s == '\n'; s++);

    /* delete postfixed white space */
    for (tp = s; *tp != '\0'; tp++);
    for (tp--; tp != s && (*tp == ' ' || *tp == '\t' || *tp == '\n'); tp--) {
	*tp = '\0';
    }
    return (s);
}

static int is_token(char c)
{
    int res;

    res = (ap_isascii(c) && ap_isgraph(c)
	   && (strchr(tspecial, c) == NULL)) ? 1 : -1;
    return res;
}

static int is_qtext(char c)
{
    int res;

    res = (ap_isascii(c) && (c != '"') && (c != '\\') && (c != '\n'))
	? 1 : -1;
    return res;
}

static int is_quoted_pair(char *s)
{
    int res = -1;
    int c;

    if (((s + 1) != NULL) && (*s == '\\')) {
	c = (int) *(s + 1);
	if (ap_isascii(c)) {
	    res = 1;
	}
    }
    return (res);
}

static content_type *analyze_ct(request_rec *r, char *s)
{
    char *tp, *mp, *cp;
    char *attribute, *value;
    int quoted = 0;
    server_rec * ss = r->server;
    ap_context_t  * p = r->pool;

    content_type *ctp;
    param *pp, *npp;

    /* initialize ctp */
    ctp = (content_type *) ap_palloc(p, sizeof(content_type));
    ctp->type = NULL;
    ctp->subtype = NULL;
    ctp->param = NULL;

    tp = ap_pstrdup(p, s);

    mp = tp;
    cp = mp;

    /* getting a type */
    if (!(cp = strchr(mp, '/'))) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
		     "mod_mime: analyze_ct: cannot get media type from '%s'",
		     (const char *) mp);
	return (NULL);
    }
    ctp->type = ap_pstrndup(p, mp, cp - mp);
    ctp->type = zap_sp(ctp->type);
    if (ctp->type == NULL || *(ctp->type) == '\0' ||
	strchr(ctp->type, ';') || strchr(ctp->type, ' ') ||
	strchr(ctp->type, '\t')) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
		     "Cannot get media subtype.");
	return (NULL);
    }

    /* getting a subtype */
    cp++;
    mp = cp;

    for (; *cp != ';' && *cp != '\0'; cp++);
    ctp->subtype = ap_pstrndup(p, mp, cp - mp);
    ctp->subtype = zap_sp(ctp->subtype);
    if ((ctp->subtype == NULL) || (*(ctp->subtype) == '\0') ||
	strchr(ctp->subtype, ' ') || strchr(ctp->subtype, '\t')) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
		     "Cannot get media subtype.");
	return (NULL);
    }
    cp = zap_sp(cp);
    if (cp == NULL || *cp == '\0') {
	return (ctp);
    }

    /* getting parameters */
    cp++;
    cp = zap_sp(cp);
    if (cp == NULL || *cp == '\0') {
	ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
		     "Cannot get media parameter.");
	return (NULL);
    }
    mp = cp;
    attribute = NULL;
    value = NULL;

    while (cp != NULL && *cp != '\0') {
	if (attribute == NULL) {
	    if (is_token((int) *cp) > 0) {
		cp++;
		continue;
	    }
	    else if (*cp == ' ' || *cp == '\t' || *cp == '\n') {
		cp++;
		continue;
	    }
	    else if (*cp == '=') {
		attribute = ap_pstrndup(p, mp, cp - mp);
		attribute = zap_sp(attribute);
		if (attribute == NULL || *attribute == '\0') {
		    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
				 "Cannot get media parameter.");
		    return (NULL);
		}
		cp++;
		cp = zap_sp(cp);
		if (cp == NULL || *cp == '\0') {
		    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
				 "Cannot get media parameter.");
		    return (NULL);
		}
		mp = cp;
		continue;
	    }
	    else {
		ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
			     "Cannot get media parameter.");
		return (NULL);
	    }
	}
	else {
	    if (mp == cp) {
		if (*cp == '"') {
		    quoted = 1;
		    cp++;
		}
		else {
		    quoted = 0;
		}
	    }
	    if (quoted > 0) {
		while (quoted && *cp != '\0') {
		    if (is_qtext((int) *cp) > 0) {
			cp++;
		    }
		    else if (is_quoted_pair(cp) > 0) {
			cp += 2;
		    }
		    else if (*cp == '"') {
			cp++;
			while (*cp == ' ' || *cp == '\t' || *cp == '\n') {
			    cp++;
			}
			if (*cp != ';' && *cp != '\0') {
			    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
					 "Cannot get media parameter.");
			    return(NULL);
			}
			quoted = 0;
		    }
		    else {
			ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
				     "Cannot get media parameter.");
			return (NULL);
		    }
		}
	    }
	    else {
		while (1) {
		    if (is_token((int) *cp) > 0) {
			cp++;
		    }
		    else if (*cp == '\0' || *cp == ';') {
			break;
		    }
		    else {
			ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
				     "Cannot get media parameter.");
			return (NULL);
		    }
		}
	    }
	    value = ap_pstrndup(p, mp, cp - mp);
	    value = zap_sp(value);
	    if (value == NULL || *value == '\0') {
		ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss,
			     "Cannot get media parameter.");
		return (NULL);
	    }

	    pp = ap_palloc(p, sizeof(param));
	    pp->attr = attribute;
	    pp->val = value;
	    pp->next = NULL;

	    if (ctp->param == NULL) {
		ctp->param = pp;
	    }
	    else {
		npp = ctp->param;
		while (npp->next) {
		    npp = npp->next;
		}
		npp->next = pp;
	    }
	    quoted = 0;
	    attribute = NULL;
	    value = NULL;
	    if (*cp == '\0') {
		break;
	    }
	    cp++;
	    mp = cp;
	}
    }
    return (ctp);
}

    const char *charset = NULL;
    if (fn == NULL) {
	fn = r->filename;
    }
	/* Add charset to Content-Type */
	if ((type = ap_table_get(conf->charset_types, ext))) {
	    charset = type;
	    found = 1;
	}

        if ((type = ap_table_get(conf->handlers, ext))
#if 0	
	/* XXX fix me when the proxy code is updated */
	    && r->proxyreq == NOT_PROXY) 
#endif
        ) {
	    charset = NULL;
	}
    }
    if (r->content_type) {
	content_type *ctp;
	char *ct;
	int override = 0;

	ct = (char *) ap_palloc(r->pool,
				sizeof(char) * (strlen(r->content_type) + 1));
	strcpy(ct, r->content_type);

	if ((ctp = analyze_ct(r, ct))) {
	    param *pp = ctp->param;
	    r->content_type = ap_pstrcat(r->pool, ctp->type, "/",
					 ctp->subtype, NULL);
	    while (pp != NULL) {
		if (charset && !strcmp(pp->attr, "charset")) {
		    if (!override) {
			r->content_type = ap_pstrcat(r->pool, r->content_type,
						     "; charset=", charset,
						     NULL);
			override = 1;
		    }
		}
		else {
		    r->content_type = ap_pstrcat(r->pool, r->content_type,
						 "; ", pp->attr,
						 "=", pp->val,
						 NULL);
		}
		pp = pp->next;
	    }
	    if (charset && !override) {
		r->content_type = ap_pstrcat(r->pool, r->content_type,
					     "; charset=", charset,
					     NULL);
	    }
	}
    /* RFC 2616:
     *   Request-URI    = "*" | absoluteURI | abs_path | authority
     *
     * authority is a special case for CONNECT.  If the request is not
     * using CONNECT, and the parsed URI does not have scheme, and
     * it does not begin with '/', and it is not '*', then, fail
     * and give a 400 response. */
    if (r->method_number != M_CONNECT 
        && !r->parsed_uri.scheme 
        && uri[0] != '/'
        && !(uri[0] == '*' && uri[1] == '\0')) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "invalid request-URI %s", uri);
        r->args = NULL;
        r->hostname = NULL;
        r->status = HTTP_BAD_REQUEST;
        r->uri = apr_pstrdup(r->pool, uri);
    }

#include "http_main.h"
#include "http_protocol.h"
    char *date_str = ap_palloc(p, 48 * sizeof(char));
    char *date_str_ptr = date_str;
    int real_year;

    tms = gmtime(&sec);    /* ZZZ replace with AP time routine */

    /* Assumption: this is always 3 */
    /* i = strlen(ap_day_snames[tms->tm_wday]); */
    memcpy(date_str_ptr, ap_day_snames[tms->tm_wday], 3);
    date_str_ptr += 3;
    *date_str_ptr++ = ',';
    *date_str_ptr++ = ' ';
    *date_str_ptr++ = tms->tm_mday / 10 + '0';
    *date_str_ptr++ = tms->tm_mday % 10 + '0';
    *date_str_ptr++ = ' ';
    /* Assumption: this is also always 3 */
    /* i = strlen(ap_month_snames[tms->tm_mon]); */
    memcpy(date_str_ptr, ap_month_snames[tms->tm_mon], 3);
    date_str_ptr += 3;
    *date_str_ptr++ = ' ';
    real_year = 1900 + tms->tm_year;
    /* This routine isn't y10k ready. */
    *date_str_ptr++ = real_year / 1000 + '0';
    *date_str_ptr++ = real_year % 1000 / 100 + '0';
    *date_str_ptr++ = real_year % 100 / 10 + '0';
    *date_str_ptr++ = real_year % 10 + '0';
    *date_str_ptr++ = ' ';
    *date_str_ptr++ = tms->tm_hour / 10 + '0';
    *date_str_ptr++ = tms->tm_hour % 10 + '0';
    *date_str_ptr++ = ':';
    *date_str_ptr++ = tms->tm_min / 10 + '0';
    *date_str_ptr++ = tms->tm_min % 10 + '0';
    *date_str_ptr++ = ':';
    *date_str_ptr++ = tms->tm_sec / 10 + '0';
    *date_str_ptr++ = tms->tm_sec % 10 + '0';
    *date_str_ptr++ = ' ';
    *date_str_ptr++ = 'G';
    *date_str_ptr++ = 'M';
    *date_str_ptr++ = 'T';
    *date_str_ptr = '\0';

    return date_str;

    /* The equivalent using sprintf. Use this for more legible but slower code
    */
    register int badesc, badpath;
    char *x, *y;
    /* Initial scan for first '%'. Don't bother writing values before
     * seeing a '%' */
    y = strchr(url, '%');
    if (y == NULL) {
        return OK;
    }
    for (x = y; *y; ++x, ++y) {
	if (*y != '%')
	    *x = *y;
	    if (!ap_isxdigit(*(y + 1)) || !ap_isxdigit(*(y + 2))) {
		*x = '%';
		*x = x2c(y + 1);
		if (*x == '/' || *x == '\0')
    *x = '\0';
    /* XXX this should be more general, and quit using 'specials' */
    
    /* conf->r and conf->d[_*] are initialized in */
 * components (where the root component is zero).

    if (core_a->r < core_b->r) {
        return -1;
    else if (core_a->r > core_b->r) {
        return 1;
    if (core_a->d_components < core_b->d_components) {
        return -1;
    }
    else if (core_a->d_components > core_b->d_components) {
        return 1;
    /* They have the same number of components, we now have to compare
     * the minor key to maintain the original order. 
     */
    if (!strcmp(cmd->path, "~")) {
    else if (thiscmd->cmd_data) { /* <DirectoryMatch> */
	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
    else if (cmd->path[strlen(cmd->path) - 1] != '/') {
        cmd->path = apr_pstrcat(cmd->pool, cmd->path, "/");

        if (!strcmp(cmd->path, "/") == 0) 
        {
            char *newpath;
	    /* Ensure that the pathname is canonical */
            if (apr_filepath_merge(&newpath, NULL, cmd->path, 
                                   APR_FILEPATH_TRUENAME, cmd->pool) != APR_SUCCESS) {
                return apr_pstrcat(cmd->pool, "<Directory \"", cmd->path,
                                   "\"> path is invalid.", NULL);
            }
            cmd->path = newpath;
    conf->d = cmd->path;
    conf->d_is_fnmatch = (apr_is_fnmatch(conf->d) != 0);

    /* Make this explicit - the "/" root has 0 elements, that is, we
     * will always merge it, and it will always sort and merge first.
     * All others are sorted and tested by the number of slashes.
     */
    if (strcmp(conf->d, "/") == 0)
        conf->d_components = 0;
    else
        conf->d_components = ap_count_dirs(conf->d);
    conf->d = apr_pstrdup(cmd->pool, cmd->path);     /* No mangling, please */
    /* XXX this seems too specific, this should probably become
     * some general-case test 
     */
     * Are we dealing with a file? If not, the handler needed to register
     * a hook to escape from our walking the file.  Since they haven't, we
     * are going to assume the worst and refuse to proceed.
    if (r->filename == NULL || !ap_os_is_path_absolute(r->pool, r->filename)) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                      "Module bug?  Request filename path %s is missing or "
                      "or not absolute for uri %s", 
                      r->filename ? r->filename : "<NULL>", r->uri);
        return HTTP_INTERNAL_SERVER_ERROR;
    /* XXX The garbage below disappears in the new directory_walk;
            if (entry_core->r || entry_core->d_components > i)
     * Now we'll deal with the regexes.
        if (!entry_core->r) {
            continue;
        }
        if (!ap_regexec(entry_core->r, test_dirname, 0, NULL, REG_NOTEOL)) {
            per_dir_defaults = ap_merge_per_dir_configs(r->pool,
                                                        per_dir_defaults,
                                                        entry_config);
     * Are we dealing with a file? If not, the handler needed to register
     * a hook to escape from our walking the file.  Since they haven't, we
     * are going to assume the worst and refuse to proceed.
    if (r->filename == NULL || !ap_os_is_path_absolute(r->filename)) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                      "Module bug?  Request filename path %s is missing or "
                      "or not absolute for uri %s", 
                      r->filename ? r->filename : "<NULL>", r->uri);
        return HTTP_INTERNAL_SERVER_ERROR;
    } else {
        if (r->filename == NULL || !ap_os_is_path_absolute(r->filename)) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                          "Config bug?  Request filename path %s is invalid or "
                          "or not absolute for uri %s", 
                          r->filename, r->uri);
            return HTTP_INTERNAL_SERVER_ERROR;
            if (entry_core->r || entry_core->d_components > seg)
     * Now we'll deal with the regexes.
        if (!entry_core->r) {
            continue;
        }
        if (!ap_regexec(entry_core->r, r->filename, 0, NULL, REG_NOTEOL)) {
            per_dir_defaults = ap_merge_per_dir_configs(r->pool,
                                                        per_dir_defaults,
                                                        entry_config);
 * %...H:  the request protocol
 * %...q:  the query string prepended by "?", or empty if no query string
static const char *log_request_query(request_rec *r, char *a)
{
    return (r->args != NULL) ? apr_pstrcat(r->pool, "?", r->args, NULL)
                             : "";
}
    {
        'q', log_request_query, 0
    },
typedef apr_status_t (*accept_function)(void **csd, ap_listen_rec *lr, apr_pool_t *ptrans);
    /**
     * The accept function for this socket
     */
    accept_function accept_func;
#include "apr_thread_proc.h"

AP_DECLARE(apr_status_t) unixd_accept(void **accepted, ap_listen_rec *lr,
                                        apr_pool_t *ptrans)
{
    apr_socket_t *csd;
    apr_status_t status;
    int sockdes;

    status = apr_accept(&csd, lr->sd, ptrans);
    if (status == APR_SUCCESS) { 
        *accepted = csd;
        apr_os_sock_get(&sockdes, csd);
        if (sockdes >= FD_SETSIZE) {
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
                         "new file descriptor %d is too large; you probably need "
                         "to rebuild Apache with a larger FD_SETSIZE "
                         "(currently %d)",
                         sockdes, FD_SETSIZE);
            apr_socket_close(csd);
            return APR_EINTR;
        } 
#ifdef TPF
        if (sockdes == 0) {                  /* 0 is invalid socket for TPF */
            return APR_EINTR;
        }
#endif
        return status;
    }

    if (APR_STATUS_IS_EINTR(status)) {
        return status;
    }
    /* Our old behaviour here was to continue after accept()
     * errors.  But this leads us into lots of troubles
     * because most of the errors are quite fatal.  For
     * example, EMFILE can be caused by slow descriptor
     * leaks (say in a 3rd party module, or libc).  It's
     * foolish for us to continue after an EMFILE.  We also
     * seem to tickle kernel bugs on some platforms which
     * lead to never-ending loops here.  So it seems best
     * to just exit in most cases.
     */
    switch (status) {
#ifdef EPROTO
        /* EPROTO on certain older kernels really means
         * ECONNABORTED, so we need to ignore it for them.
         * See discussion in new-httpd archives nh.9701
         * search for EPROTO.
         *
         * Also see nh.9603, search for EPROTO:
         * There is potentially a bug in Solaris 2.x x<6,
         * and other boxes that implement tcp sockets in
         * userland (i.e. on top of STREAMS).  On these
         * systems, EPROTO can actually result in a fatal
         * loop.  See PR#981 for example.  It's hard to
         * handle both uses of EPROTO.
         */
        case EPROTO:
#endif
#ifdef ECONNABORTED
        case ECONNABORTED:
#endif
        /* Linux generates the rest of these, other tcp
         * stacks (i.e. bsd) tend to hide them behind
         * getsockopt() interfaces.  They occur when
         * the net goes sour or the client disconnects
         * after the three-way handshake has been done
         * in the kernel but before userland has picked
         * up the socket.
         */
#ifdef ECONNRESET
        case ECONNRESET:
#endif
#ifdef ETIMEDOUT
        case ETIMEDOUT:
#endif
#ifdef EHOSTUNREACH
        case EHOSTUNREACH:
#endif
#ifdef ENETUNREACH
        case ENETUNREACH:
#endif
            break;
#ifdef ENETDOWN
        case ENETDOWN:
            /*
             * When the network layer has been shut down, there
             * is not much use in simply exiting: the parent
             * would simply re-create us (and we'd fail again).
             * Use the CHILDFATAL code to tear the server down.
             * @@@ Martin's idea for possible improvement:
             * A different approach would be to define
             * a new APEXIT_NETDOWN exit code, the reception
             * of which would make the parent shutdown all
             * children, then idle-loop until it detected that
             * the network is up again, and restart the children.
             * Ben Hyde noted that temporary ENETDOWN situations
             * occur in mobile IP.
             */
            ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
                         "apr_accept: giving up.");
            return APR_EGENERAL;
#endif /*ENETDOWN*/

#ifdef TPF
        case EINACT:
            ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
                         "offload device inactive");
            return APR_EGENERAL;
            break;
        default:
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, ap_server_conf,
                         "select/accept error (%d)", status);
            return APR_EGENERAL;
#else
        default:
            ap_log_error(APLOG_MARK, APLOG_ERR, status, ap_server_conf,
                         "apr_accept: (client socket)");
            return APR_EGENERAL;
#endif
    }
    return status;
}

#include "ap_listen.h"
AP_DECLARE(apr_status_t) unixd_accept(void **accepted, ap_listen_rec *lr, apr_pool_t *ptrans);
#ifdef MPM_ACCEPT_FUNC
    server->accept_func = MPM_ACCEPT_FUNC;
#else
    server->accept_func = NULL;
#endif
#define MPM_ACCEPT_FUNC unixd_accept
static ap_listen_rec *listensocks;
    int i;
    int offset;
    void *csd;
    for (lr = ap_listeners, i = 0; i < num_listensocks; lr = lr->next, i++) {
        listensocks[i].accept_func = lr->accept_func;
        listensocks[i].sd = lr->sd;
    }
        apr_poll_socket_add(pollset, listensocks[i].sd, APR_POLLIN);
                offset = 0;
                    apr_poll_revents_get(&event, listensocks[curr_pollfd].sd, pollset);
                        offset = curr_pollfd;
        }
            status = listensocks[offset].accept_func(&csd, 
                                       &listensocks[offset], ptrans);
            if (status == APR_SUCCESS) {
                break;
            }
            if (status == APR_EGENERAL) {
                clean_child_exit(APEXIT_CHILDFATAL);
            }
        }
        ap_rvputs(r, ap_get_server_name(r), " (via ", r->connection->local_ip,
static void recalc_factors(proxy_balancer *balancer,
                           proxy_runtime_worker *fixed)
{
    int i;
    double median, ffactor = 0.0;
    proxy_runtime_worker *workers;    


    /* Recalculate lbfactors */
    workers = (proxy_runtime_worker *)balancer->workers->elts;
    /* Special case if there is only one worker it's
     * load factor will always be 100
     */
    if (balancer->workers->nelts == 1) {
        workers->s->lbstatus = workers->s->lbfactor = 100.0;
        return;
    }
    for (i = 0; i < balancer->workers->nelts; i++) {
        if (workers[i].s->lbfactor > 100.0)
            workers[i].s->lbfactor = 100.0;
        ffactor += workers[i].s->lbfactor;
    }
    if (ffactor < 100.0) {
        median = (100.0 - ffactor) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (&(workers[i]) != fixed)
                workers[i].s->lbfactor += median;
        }
    }
    else if (fixed->s->lbfactor < 100.0) {
        median = (ffactor - 100.0) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (workers[i].s->lbfactor > median &&
                &(workers[i]) != fixed)
                workers[i].s->lbfactor -= median;
        }
    } 
    else {
        median = (ffactor - 100.0) / balancer->workers->nelts;
        for (i = 0; i < balancer->workers->nelts; i++) {
            workers[i].s->lbfactor -= median;
        }
    } 
    for (i = 0; i < balancer->workers->nelts; i++) {
        /* Update the status entires */
        workers[i].s->lbstatus = workers[i].s->lbfactor;
    }
}

/* Invoke handler */
static int balancer_handler(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *conf = (proxy_server_conf *)
        ap_get_module_config(sconf, &proxy_module);
    apr_array_header_t *proxies = conf->proxies;
    struct proxy_remote *ents = (struct proxy_remote *)proxies->elts;
    proxy_balancer *balancer, *bsel = NULL;
    proxy_runtime_worker *worker, *wsel = NULL;
    apr_table_t *params = apr_table_make(r->pool, 10);
    int access_status;
    int i, n;
    const char *name;

    /* is this for us? */
    if (strcmp(r->handler, "balancer-manager"))
        return DECLINED;
    r->allowed = (AP_METHOD_BIT << M_GET);
    if (r->method_number != M_GET)
        return DECLINED;

    if (r->args) {
        char *args = apr_pstrdup(r->pool, r->args);
        char *tok, *val;
        while (args && *args) {
            if ((val = ap_strchr_c(args, '='))) {
                *val++ = '\0';
                if ((tok = ap_strchr_c(val, '&')))
                    *tok++ = '\0';
                if ((access_status = ap_unescape_url(val)) != OK)
                    return access_status;
                apr_table_setn(params, args, val);
                args = tok;
            }
            else
                return HTTP_BAD_REQUEST;
        }
    }
    if ((name = apr_table_get(params, "b")))
        bsel = ap_proxy_get_balancer(r->pool, conf,
            apr_pstrcat(r->pool, "balancer://", name, NULL));
    if ((name = apr_table_get(params, "w"))) {
        const char *sc = apr_table_get(params, "s");
        char *asname = NULL;
        proxy_worker *ws = NULL;
        if (sc) {
            asname = apr_pstrcat(r->pool, sc, "://", name, NULL);
            ws = ap_proxy_get_worker(r->pool, conf, asname);
        }
        if (ws) {
            worker = (proxy_runtime_worker *)bsel->workers->elts;
            for (n = 0; n < bsel->workers->nelts; n++) {
                if (strcasecmp(worker->w->name, ws->name) == 0) {
                    wsel = worker;
                    break;
                }
                ++worker;
            }
        }
    }
    /* First set the params */
    if (bsel) {
        const char *val;
        if ((val = apr_table_get(params, "ss"))) {
            if (strlen(val))
                bsel->sticky = apr_pstrdup(conf->pool, val);
            else
                bsel->sticky = NULL;
        }
        if ((val = apr_table_get(params, "tm"))) {
            int ival = atoi(val);
            if (ival >= 0)
                bsel->timeout = apr_time_from_sec(ival);
        }
    }
    if (wsel) {
        const char *val;
        if ((val = apr_table_get(params, "lf"))) {
            char *ep;
            double dval = strtod(val, &ep);
            if (dval > 1) {
                wsel->s->lbfactor = dval;
                if (bsel)
                    recalc_factors(bsel, wsel);
            }
        }
        if ((val = apr_table_get(params, "wr"))) {
            if (strlen(val))
                wsel->w->route = apr_pstrdup(conf->pool, val);
            else
                wsel->w->route = NULL;
        }
        if ((val = apr_table_get(params, "rr"))) {
            if (strlen(val))
                wsel->w->redirect = apr_pstrdup(conf->pool, val);
            else
                wsel->w->redirect = NULL;
        }
        if ((val = apr_table_get(params, "dw")))
            wsel->w->status |= PROXY_WORKER_DISABLED;
        else
            wsel->w->status &= ~PROXY_WORKER_DISABLED;

    }
    if (apr_table_get(params, "xml")) {
        ap_set_content_type(r, "text/xml");
        ap_rputs("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n", r);
        ap_rputs("<httpd:manager xmlns:httpd=\"http://httpd.apache.org\">\n", r);
        ap_rputs("  <httpd:balancers>\n", r);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("    <httpd:balancer>\n", r);
            ap_rvputs(r, "      <httpd:name>", balancer->name, "</httpd:name>\n", NULL);
            ap_rputs("      <httpd:workers>\n", r);
            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {
                ap_rputs("        <httpd:worker>\n", r);
                ap_rvputs(r, "          <httpd:scheme>", worker->w->scheme,
                          "</httpd:scheme>\n", NULL);                
                ap_rvputs(r, "          <httpd:hostname>", worker->w->hostname,
                          "</httpd:hostname>\n", NULL);                
               ap_rprintf(r, "          <httpd:loadfactor>%.2f</httpd:loadfactor>\n",
                          worker->s->lbfactor);
                ap_rputs("        </httpd:worker>\n", r);
                ++worker;
            }
            ap_rputs("      </httpd:workers>\n", r);
            ap_rputs("    </httpd:balancer>\n", r);
            ++balancer;
        }
        ap_rputs("  </httpd:balancers>\n", r);
        ap_rputs("</httpd:manager>", r);         
    }
    else {
        ap_set_content_type(r, "text/html");
        ap_rputs(DOCTYPE_HTML_3_2
                 "<html><head><title>Balancer Manager</title></head>\n", r);
        ap_rputs("<body><h1>Load Balancer Manager for ", r);
        ap_rvputs(r, ap_get_server_name(r), "</h1>\n\n", NULL);
        ap_rvputs(r, "<dl><dt>Server Version: ",
                  ap_get_server_version(), "</dt>\n", NULL);
        ap_rvputs(r, "<dt>Server Built: ",
                  ap_get_server_built(), "\n</dt></dl>\n", NULL);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("<hr />\n<h3>LoadBalancer Status for ", r);
            ap_rvputs(r, "<a href=\"", r->uri, "?b=",
                      balancer->name + sizeof("balancer://") - 1,
                      "\">", NULL); 
            ap_rvputs(r, balancer->name, "</a></h3>\n\n", NULL);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>StickySesion</th><th>Timeout</th>"
                "</tr>\n<tr>", r);                
            ap_rvputs(r, "<td>", balancer->sticky, NULL);
            ap_rprintf(r, "</td><td>%" APR_TIME_T_FMT "</td>\n",
                apr_time_sec(balancer->timeout));
            ap_rputs("</table>\n", r);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>Scheme</th><th>Host</th>"
                "<th>Route</th><th>RouteRedir</th>"
                "<th>Factor</th><th>Status</th>"
                "</tr>\n", r);

            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {

                ap_rvputs(r, "<tr>\n<td>", worker->w->scheme, "</td><td>", NULL);
                ap_rvputs(r, "<a href=\"", r->uri, "?b=", 
                          balancer->name + sizeof("balancer://") - 1,
                          "&s=", worker->w->scheme, "&w=", worker->w->hostname,
                          "\">", NULL); 
                ap_rvputs(r, worker->w->hostname, "</a></td>", NULL);
                ap_rvputs(r, "<td>", worker->w->route, NULL);
                ap_rvputs(r, "</td><td>", worker->w->redirect, NULL);
                ap_rprintf(r, "</td><td>%.2f</td><td>", worker->s->lbfactor);
                if (worker->w->status & PROXY_WORKER_DISABLED)
                    ap_rputs("Dis", r);
                else if (worker->w->status & PROXY_WORKER_IN_ERROR)
                    ap_rputs("Err", r);
                else if (worker->w->status & PROXY_WORKER_INITIALIZED)
                    ap_rputs("Ok", r);
                else
                    ap_rputs("-", r);
                ap_rputs("</td></tr>\n", r);

                ++worker;
            }
            ap_rputs("</table>\n", r);
            ++balancer;
        }
        ap_rputs("<hr />\n", r);
        if (wsel && bsel) {
            ap_rputs("<h3>Edit worker settings for ", r);
            ap_rvputs(r, wsel->w->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>Load factor:</td><td><input name=\"lf\" type=text ", r);
            ap_rprintf(r, "value=\"%.2f\"></td><tr>\n", wsel->s->lbfactor);            
            ap_rputs("<tr><td>Route:</td><td><input name=\"wr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->route, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Route Redirect:</td><td><input name=\"rr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->redirect, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Disabled:</td><td><input name=\"dw\" type=checkbox", r);
            if (wsel->w->status & PROXY_WORKER_DISABLED)
                ap_rputs(" checked", r);
            ap_rputs("></td><tr>\n", r);            
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"s\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->scheme, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"w\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->hostname, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        else if (bsel) {
            ap_rputs("<h3>Edit balancer settings for ", r);
            ap_rvputs(r, bsel->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>StickySession Identifier:</td><td><input name=\"ss\" type=text ", r);
            if (bsel->sticky)
                ap_rvputs(r, "value=\"", bsel->sticky, "\"", NULL);
            ap_rputs("></td><tr>\n<tr><td>Timeout:</td><td><input name=\"tm\" type=text ", r);
            ap_rprintf(r, "value=\"%" APR_TIME_T_FMT "\"></td></tr>\n",
                       apr_time_sec(bsel->timeout));
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        ap_rputs(ap_psignature("",r), r);
        ap_rputs("</body></html>\n", r);
    }
    return OK;
}

    /* manager handler */
    ap_hook_handler(balancer_handler, NULL, NULL, APR_HOOK_FIRST);
#include "apr_support.h"
    apr_bucket_brigade *tmpbb;
static apr_status_t check_time_left(reqtimeout_con_cfg *ccfg,
                                    apr_time_t *time_left_p)
{
    *time_left_p = ccfg->timeout_at - apr_time_now();
    if (*time_left_p <= 0)
        return APR_TIMEUP;
    
    if (*time_left_p < apr_time_from_sec(1)) {
        *time_left_p = apr_time_from_sec(1);
    }
    return APR_SUCCESS;
}

static apr_status_t have_lf_or_eos(apr_bucket_brigade *bb)
{
    apr_bucket *b = APR_BRIGADE_LAST(bb);

    for ( ; b != APR_BRIGADE_SENTINEL(bb) ; b = APR_BUCKET_PREV(b) ) {
    	const char *str;
    	apr_size_t len;
    	apr_status_t rv;

        if (APR_BUCKET_IS_EOS(b))
            return APR_SUCCESS;

        if (APR_BUCKET_IS_METADATA(b))
            continue;

        rv = apr_bucket_read(b, &str, &len, APR_BLOCK_READ);
        if (rv != APR_SUCCESS)
            return rv;

        if (len == 0)
            continue;

        if (str[len-1] == APR_ASCII_LF)
            return APR_SUCCESS;
    }
    return APR_INCOMPLETE;
}


#define MIN(x,y) ((x) < (y) ? (x) : (y))
    rv = check_time_left(ccfg, &time_left);
    if (rv != APR_SUCCESS)
        goto out;
    rv = apr_socket_timeout_set(ccfg->socket, MIN(time_left, saved_sock_timeout));
    AP_DEBUG_ASSERT(rv == APR_SUCCESS);
    if (mode == AP_MODE_GETLINE) {
        /*
         * For a blocking AP_MODE_GETLINE read, apr_brigade_split_line()
         * would loop until a whole line has been read. As this would make it
         * impossible to enforce a total timeout, we only do non-blocking
         * reads.
         */
        apr_size_t remaining = HUGE_STRING_LEN;
        do {
            apr_off_t bblen;
            rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE, APR_NONBLOCK_READ, remaining);
            if (APR_STATUS_IS_EAGAIN(rv)) {
                rv = APR_SUCCESS;
            }
            else if (rv != APR_SUCCESS) {
                break;
            }

            if (!APR_BRIGADE_EMPTY(bb)) {
                rv = have_lf_or_eos(bb);
                if (rv != APR_INCOMPLETE) {
                    break;
                }

                if (ccfg->min_rate > 0) {
                    extend_timeout(ccfg, bb);
                }

                rv = apr_brigade_length(bb, 1, &bblen);
                if (rv != APR_SUCCESS) {
                    break;
                }
                remaining -= bblen;
                if (remaining <= 0) {
                    break;
                }

                /* Haven't got a whole line yet, save what we have ... */
                if (!ccfg->tmpbb) {
                    ccfg->tmpbb = apr_brigade_create(f->c->pool, f->c->bucket_alloc);
                }
                APR_BRIGADE_CONCAT(ccfg->tmpbb, bb);
            }

            /* ... and wait for more */
            rv = apr_wait_for_io_or_timeout(NULL, ccfg->socket, 1);
            if (rv != APR_SUCCESS)
                break;

            rv = check_time_left(ccfg, &time_left);
            if (rv != APR_SUCCESS)
                break;
            rv = apr_socket_timeout_set(ccfg->socket,
                                   MIN(time_left, saved_sock_timeout));
            AP_DEBUG_ASSERT(rv == APR_SUCCESS);

        } while (1);

        if (ccfg->tmpbb)
            APR_BRIGADE_PREPEND(bb, ccfg->tmpbb);

    }
    else {
        /* mode != AP_MODE_GETLINE */
        rv = ap_get_brigade(f->next, bb, mode, block, readbytes);
        if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {
            extend_timeout(ccfg, bb);
        }
    apr_socket_timeout_set(ccfg->socket, saved_sock_timeout);

out:
        /*
         * If we allow lingering close, the client may keep this
         * process/thread busy for another 30s (MAX_SECS_TO_LINGER).
         * Therefore we have to abort the connection. The downside is
         * that the client will most likely not receive the error
         * message.
         */
        f->c->aborted = 1;
            /* We had a failure: Close connection to backend */
            conn->close++;
AP_DECLARE_HOOK(int,monitor,(apr_pool_t *p))

APR_HOOK_STRUCT(
#if AP_ENABLE_EXCEPTION_HOOK
    APR_HOOK_LINK(fatal_exception)
#endif
    APR_HOOK_LINK(monitor)
)

#if AP_ENABLE_EXCEPTION_HOOK
AP_IMPLEMENT_HOOK_RUN_ALL(int, fatal_exception,
                          (ap_exception_info_t *ei), (ei), OK, DECLINED)
#endif
AP_IMPLEMENT_HOOK_RUN_ALL(int, monitor,
                          (apr_pool_t *p), (p), OK, DECLINED)


        ap_run_monitor(p);
    if (dav_get_provider(lookup.rnew) == NULL) {
        return dav_error_response(r, HTTP_METHOD_NOT_ALLOWED,
                                  "DAV not enabled for Destination URI.");
    }

static int read_request_line(request_rec *r, apr_bucket_brigade *bb)

#if 0
    conn_rec *conn = r->connection;
#endif
    int num_blank_lines = 0;
    int max_blank_lines = r->server->limit_req_fields;

    if (max_blank_lines <= 0) {
        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
    }

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    do {
        apr_status_t rv;

        /* insure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */
        r->the_request = NULL;
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                         &len, r, 0, bb);

        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }
            return 0;
        }
    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));

    /* we've probably got something to do, ignore graceful restart requests */
    ll = r->the_request;
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method",
                                r->method);
#endif

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

             && (minor < HTTP_VERSION(1, 0)) ) /* don't allow HTTP/0.1000 */
    else
    return 1;
    char *last_field = NULL;
    apr_size_t last_len = 0;
    apr_size_t alloc_len = 0;
    char *value;
    int fields_read = 0;
    char *tmp_field;
        int folded = 0;

        if (last_field != NULL) {
            if ((len > 0) && ((*field == '\t') || *field == ' ')) {
                /* This line is a continuation of the preceding line(s),
                 * so append it to the line that we've set aside.
                 * Note: this uses a power-of-two allocator to avoid
                 * doing O(n) allocs and using O(n^2) space for
                 * continuations that span many many lines.
                 */
                apr_size_t fold_len = last_len + len + 1; /* trailing null */

                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field "
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                if (fold_len > alloc_len) {
                    char *fold_buf;
                    alloc_len += alloc_len;
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
                    }
                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);
                    memcpy(fold_buf, last_field, last_len);
                    last_field = fold_buf;
                }
                memcpy(last_field + last_len, field, len +1); /* +1 for nul */
                last_len += len;
                folded = 1;
            }
            else /* not a continuation line */ {

                if (r->server->limit_req_fields
                    && (++fields_read > r->server->limit_req_fields)) {
                    r->status = HTTP_BAD_REQUEST;
                    apr_table_setn(r->notes, "error-notes",
                                   "The number of request header fields "
                                   "exceeds this server's limit.");
                    return;
                }

                if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                    r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Request header field is "
                                               "missing ':' separator.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool,
                                                              last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                tmp_field = value - 1; /* last character of field-name */

                *value++ = '\0'; /* NUL-terminate at colon */

                while (*value == ' ' || *value == '\t') {
                    ++value;            /* Skip to start of value   */
                }

                /* Strip LWS after field-name: */
                while (tmp_field > last_field
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                /* Strip LWS after field-value: */
                tmp_field = last_field + last_len - 1;
                while (tmp_field > value
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                apr_table_addn(r->headers_in, last_field, value);

                /* reset the alloc_len so that we'll allocate a new
                 * buffer if we have to do any more folding: we can't
                 * use the previous buffer because its contents are
                 * now part of r->headers_in
                 */
                alloc_len = 0;

            } /* end if current line is not a continuation starting with tab */

        /* Found a blank line, stop. */
        if (len == 0) {
            break;
        }

        /* Keep track of this line so that we can parse it on
         * the next loop iteration.  (In the folded case, last_field
         * has been updated already.)
         */
        if (!folded) {
            last_field = field;
            last_len = len;

    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
request_rec *ap_read_request(conn_rec *conn)
    const char *expect;
    int access_status;
    apr_bucket_brigade *tmp_bb;
    apr_socket_t *csd;
    apr_interval_time_t cur_timeout;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    /* Get the request... */
    if (!read_request_line(r, tmp_bb)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        apr_brigade_destroy(tmp_bb);
        return NULL;
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_get(csd, &cur_timeout);
    if (cur_timeout != conn->base_server->timeout) {
        apr_socket_timeout_set(csd, conn->base_server->timeout);
        cur_timeout = conn->base_server->timeout;
    }

    if (!r->assbackwards) {
        ap_get_mime_headers_core(r, tmp_bb);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        if (apr_table_get(r->headers_in, "Transfer-Encoding")
            && apr_table_get(r->headers_in, "Content-Length")) {
            /* 2616 section 4.4, point 3: "if both Transfer-Encoding
             * and Content-Length are received, the latter MUST be
             * ignored"; so unset it here to prevent any confusion
             * later. */
            apr_table_unset(r->headers_in, "Content-Length");
        }
    }
    else {
        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }
    }

    apr_brigade_destroy(tmp_bb);
    if (cur_timeout != r->server->timeout) {
        apr_socket_timeout_set(csd, r->server->timeout);
        cur_timeout = r->server->timeout;
#include "apr_support.h"
    apr_bucket_brigade *tmpbb;
static apr_status_t check_time_left(reqtimeout_con_cfg *ccfg,
                                    apr_time_t *time_left_p)
{
    *time_left_p = ccfg->timeout_at - apr_time_now();
    if (*time_left_p <= 0)
        return APR_TIMEUP;
    
    if (*time_left_p < apr_time_from_sec(1)) {
        *time_left_p = apr_time_from_sec(1);
    }
    return APR_SUCCESS;
}

static apr_status_t have_lf_or_eos(apr_bucket_brigade *bb)
{
    apr_bucket *b = APR_BRIGADE_LAST(bb);

    for ( ; b != APR_BRIGADE_SENTINEL(bb) ; b = APR_BUCKET_PREV(b) ) {
    	const char *str;
    	apr_size_t len;
    	apr_status_t rv;

        if (APR_BUCKET_IS_EOS(b))
            return APR_SUCCESS;

        if (APR_BUCKET_IS_METADATA(b))
            continue;

        rv = apr_bucket_read(b, &str, &len, APR_BLOCK_READ);
        if (rv != APR_SUCCESS)
            return rv;

        if (len == 0)
            continue;

        if (str[len-1] == APR_ASCII_LF)
            return APR_SUCCESS;
    }
    return APR_INCOMPLETE;
}


#define MIN(x,y) ((x) < (y) ? (x) : (y))
    rv = check_time_left(ccfg, &time_left);
    if (rv != APR_SUCCESS)
        goto out;
    rv = apr_socket_timeout_set(ccfg->socket, MIN(time_left, saved_sock_timeout));
    AP_DEBUG_ASSERT(rv == APR_SUCCESS);
    if (mode == AP_MODE_GETLINE) {
        /*
         * For a blocking AP_MODE_GETLINE read, apr_brigade_split_line()
         * would loop until a whole line has been read. As this would make it
         * impossible to enforce a total timeout, we only do non-blocking
         * reads.
         */
        apr_size_t remaining = HUGE_STRING_LEN;
        do {
            apr_off_t bblen;
            rv = ap_get_brigade(f->next, bb, AP_MODE_GETLINE, APR_NONBLOCK_READ, remaining);
            if (APR_STATUS_IS_EAGAIN(rv)) {
                rv = APR_SUCCESS;
            }
            else if (rv != APR_SUCCESS) {
                break;
            }

            if (!APR_BRIGADE_EMPTY(bb)) {
                rv = have_lf_or_eos(bb);
                if (rv != APR_INCOMPLETE) {
                    break;
                }

                if (ccfg->min_rate > 0) {
                    extend_timeout(ccfg, bb);
                }

                rv = apr_brigade_length(bb, 1, &bblen);
                if (rv != APR_SUCCESS) {
                    break;
                }
                remaining -= bblen;
                if (remaining <= 0) {
                    break;
                }

                /* Haven't got a whole line yet, save what we have ... */
                if (!ccfg->tmpbb) {
                    ccfg->tmpbb = apr_brigade_create(f->c->pool, f->c->bucket_alloc);
                }
                APR_BRIGADE_CONCAT(ccfg->tmpbb, bb);
            }

            /* ... and wait for more */
            rv = apr_wait_for_io_or_timeout(NULL, ccfg->socket, 1);
            if (rv != APR_SUCCESS)
                break;

            rv = check_time_left(ccfg, &time_left);
            if (rv != APR_SUCCESS)
                break;
            rv = apr_socket_timeout_set(ccfg->socket,
                                   MIN(time_left, saved_sock_timeout));
            AP_DEBUG_ASSERT(rv == APR_SUCCESS);

        } while (1);

        if (ccfg->tmpbb)
            APR_BRIGADE_PREPEND(bb, ccfg->tmpbb);

    }
    else {
        /* mode != AP_MODE_GETLINE */
        rv = ap_get_brigade(f->next, bb, mode, block, readbytes);
        if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {
            extend_timeout(ccfg, bb);
        }
    apr_socket_timeout_set(ccfg->socket, saved_sock_timeout);

out:
        /*
         * If we allow lingering close, the client may keep this
         * process/thread busy for another 30s (MAX_SECS_TO_LINGER).
         * Therefore we have to abort the connection. The downside is
         * that the client will most likely not receive the error
         * message.
         */
        f->c->aborted = 1;
        return 0;
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            else if (r->method == NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                              "request failed: invalid characters in URI");
            }
    /** Did we use HTTP Keep-Alive? */
    unsigned keptalive:1;
    /** How many times have we used it? */
    int keepalives;
	    || (r->server->keep_alive_max > r->connection->keepalives))
        int left = r->server->keep_alive_max - r->connection->keepalives;
        r->connection->keepalives++;
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;

#if 0
    conn_rec *conn = r->connection;
#endif
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
	    /* this is a hack to make sure that request time is set,
	     * it's not perfect, but it's better than nothing 
	     */
	    r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */

    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk

#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */

    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);

#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week 
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method); 
#endif
    uri = ap_getword_white(r->pool, &ll);

    /* Provide quick information about the request method as soon as known */

    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }

    ap_parse_uri(r, uri);

    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }

    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
 	r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))	/* don't allow HTTP/0.1000 */
	r->proto_num = HTTP_VERSION(major, minor);
    else
	r->proto_num = HTTP_VERSION(1,0);

    return 1;
}

    conn->keptalive    = conn->keepalive == 1;
    conn->keepalive    = 0;

    ap_run_create_request(r);
    r->the_request     = NULL;
    apr_setsocketopt(conn->client_socket, APR_SO_TIMEOUT, 
                     (int)(conn->keptalive
                     ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                     : r->server->timeout * APR_USEC_PER_SEC));
                     
    /* Get the request... */
    if (!read_request_line(r)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
			  "request failed: URI too long");
            ap_send_error_response(r, 0);
            ap_run_log_transaction(r);
            return r;
        }
        return NULL;
    }
    if (r->connection->keptalive) {
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(r->server->timeout * APR_USEC_PER_SEC));
    }
    conn->keptalive = 0;        /* We now have a request to play with */

        conf->provider_name = arg1;
            const char *vary = apr_table_get(out_req->headers_out, "Vary");

    const char *note_ratio_name;
    const char *note_input_name;
    const char *note_output_name;
        c->note_ratio_name = arg1;
        c->note_ratio_name = arg2;
        c->note_input_name = arg2;
        c->note_output_name = arg2;
        rv = HTTP_INTERNAL_SERVER_ERROR;
                    return;
                        return;
                        return;
        for (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end)
        process_proxy_header(r, dconf, buffer, value);
            if (s[1] == '{' && (e = ap_strchr_c(s+2, '}'))) {
                char *name = apr_pstrmemdup(p, s+2, e-s-2);
    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);
            /* method has not been registered yet, but resource restriction
module AP_MODULE_DECLARE_DATA imagemap_module;
    icr = ap_get_module_config(r->per_dir_config, &imagemap_module);
module AP_MODULE_DECLARE_DATA imagemap_module =
    bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)(bio->ptr);
    if (!outctx->length && (inl + outctx->blen < sizeof(outctx->buffer))) {
        memcpy(&outctx->buffer[outctx->blen], in, inl);
        outctx->blen += inl;
                                             outctx->bb->bucket_alloc);
        outctx->length += inl;
        APR_BRIGADE_INSERT_TAIL(outctx->bb, bucket);
    bio_filter_out_ctx_t *outctx = (bio_filter_out_ctx_t *)(bio->ptr);
        outctx->blen = outctx->length = 0;
        ret = (long)((outctx->blen + outctx->length) == 0);
        outctx->blen = outctx->length = (apr_size_t)num;
        ret = (long)(outctx->blen + outctx->length);
            *pptr = (char *)&(outctx->buffer[0]);
        ret = (long)(outctx->blen + outctx->length);
    bio_filter_in_ctx_t *inctx = (bio_filter_in_ctx_t *)(bio->ptr);
    apr_read_type_e block = inctx->block;
    SSLConnRec *sslconn = myConnConfig(inctx->f->c);
    inctx->rc = APR_SUCCESS;
    if ((SSL_version(inctx->ssl) == SSL2_VERSION) || sslconn->is_proxy) {
        bio_filter_out_flush(inctx->wbio);
    if (!inctx->bb) {
        inctx->rc = APR_EOF;
    if (APR_BRIGADE_EMPTY(inctx->bb)) {
        inctx->rc = ap_get_brigade(inctx->f->next, inctx->bb,
        if (APR_STATUS_IS_EAGAIN(inctx->rc) || APR_STATUS_IS_EINTR(inctx->rc)
               || (inctx->rc == APR_SUCCESS && APR_BRIGADE_EMPTY(inctx->bb))) {
        if (inctx->rc != APR_SUCCESS) {
            apr_brigade_cleanup(inctx->bb);
            inctx->bb = NULL;
    inctx->rc = brigade_consume(inctx->bb, block, in, &inl);
    if (inctx->rc == APR_SUCCESS) {
    if (APR_STATUS_IS_EAGAIN(inctx->rc) 
            || APR_STATUS_IS_EINTR(inctx->rc)) {
    apr_brigade_cleanup(inctx->bb);
    inctx->bb = NULL;
    if (APR_STATUS_IS_EOF(inctx->rc) && inl) {
    SSLFilterRec *frec = f->ctx;
    n = ssl_io_hook_write(frec->pssl, (unsigned char *)data, len);
        if (SSL_total_renegotiations(frec->pssl)) {
    SSLFilterRec *frec = f->ctx;
    if (!frec->pssl) {
    if ((status = ssl_hook_process_connection(frec)) != APR_SUCCESS) {
            if ((status = bio_filter_out_flush(frec->pbioWrite)) != APR_SUCCESS) {
static apr_status_t ssl_io_input_read(bio_filter_in_ctx_t *inctx,
    if ((bytes = char_buffer_read(&inctx->cbuf, buf, wanted))) {
        if (inctx->mode == AP_MODE_SPECULATIVE) {
            inctx->cbuf.value -= bytes;
            inctx->cbuf.length += bytes;
        if ((*len >= wanted) || inctx->mode == AP_MODE_GETLINE) {
        rc = SSL_read(inctx->frec->pssl, buf + bytes, wanted - bytes);
            if (inctx->mode == AP_MODE_SPECULATIVE) {
                char_buffer_write(&inctx->cbuf, buf, rc);
            return inctx->rc;
            if (APR_STATUS_IS_EAGAIN(inctx->rc)
                    || APR_STATUS_IS_EINTR(inctx->rc)) {
                if (inctx->block == APR_NONBLOCK_READ) {
                inctx->rc = APR_EOF;
            int ssl_err = SSL_get_error(inctx->frec->pssl, rc);
                if (inctx->block == APR_NONBLOCK_READ) {
                    inctx->rc = APR_EAGAIN;
                conn_rec *c = (conn_rec *)SSL_get_app_data(inctx->frec->pssl);
                ap_log_error(APLOG_MARK, APLOG_ERR, inctx->rc, c->base_server,
                conn_rec *c = (conn_rec *)SSL_get_app_data(inctx->frec->pssl);
                ap_log_error(APLOG_MARK, APLOG_ERR, inctx->rc, c->base_server,
                if (inctx->rc == APR_SUCCESS) {
                    inctx->rc = APR_EGENERAL;
    return inctx->rc;
static apr_status_t ssl_io_input_getline(bio_filter_in_ctx_t *inctx,
        status = ssl_io_input_read(inctx, buf + offset, &tmplen);
        char_buffer_write(&inctx->cbuf, value, length);
    bio_filter_in_ctx_t *inctx = f->ctx;
    inctx->ssl = NULL;
    inctx->frec->pssl = NULL;
    bio_filter_in_ctx_t *inctx = f->ctx;
    apr_size_t len = sizeof(inctx->buffer);
    if (!inctx->ssl) {
    inctx->mode = mode;
    inctx->block = block;
    status = ssl_hook_process_connection(inctx->frec);
    if (inctx->mode == AP_MODE_READBYTES || 
        inctx->mode == AP_MODE_SPECULATIVE) {
        status = ssl_io_input_read(inctx, inctx->buffer, &len);
    else if (inctx->mode == AP_MODE_GETLINE) {
        status = ssl_io_input_getline(inctx, inctx->buffer, &len);
            apr_bucket_transient_create(inctx->buffer, len, f->c->bucket_alloc);
    bio_filter_in_ctx_t *inctx;
    inctx = apr_palloc(c->pool, sizeof(*inctx));
    frec->pInputFilter = ap_add_input_filter(ssl_io_filter, inctx, NULL, c);
    frec->pbioRead->ptr = (void *)inctx;
    inctx->frec = frec;
    inctx->ssl = ssl;
    inctx->wbio = frec->pbioWrite;
    inctx->f = frec->pInputFilter;
    inctx->bb = apr_brigade_create(c->pool, c->bucket_alloc);
    inctx->cbuf.length = 0;
    inctx->pool = c->pool;
    if (dav_get_provider(lookup.rnew) == NULL) {
        return dav_error_response(r, HTTP_METHOD_NOT_ALLOWED,
                                  "DAV not enabled for Destination URI.");
    }

    imap_conf_rec *new = (imap_conf_rec *) apr_palloc(p, sizeof(imap_conf_rec));
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted") && *comment) {
    else if (!strcasecmp(menu, "unformatted") && *comment) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    lr = head_listener;
    do {
        if (FD_ISSET(nsd, main_fds)) {
            head_listener = lr->next;
            if (!head_listener) {
            }
            return lr;
        }
        lr = lr->next;
        if (!lr) {
            lr = ap_listeners;
        }
    } while (lr != head_listener);
            ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
                         "Child %d: Listening on port %d.", my_pid, lr->bind_addr->port);
    /** Did we use HTTP Keep-Alive? */
    unsigned keptalive:1;
    /** How many times have we used it? */
    int keepalives;
	    || (r->server->keep_alive_max > r->connection->keepalives))
        int left = r->server->keep_alive_max - r->connection->keepalives;
        r->connection->keepalives++;
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;

#if 0
    conn_rec *conn = r->connection;
#endif
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
	    /* this is a hack to make sure that request time is set,
	     * it's not perfect, but it's better than nothing 
	     */
	    r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */

    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk

#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */

    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);

#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week 
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method); 
#endif
    uri = ap_getword_white(r->pool, &ll);

    /* Provide quick information about the request method as soon as known */

    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }

    ap_parse_uri(r, uri);

    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }

    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
 	r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))	/* don't allow HTTP/0.1000 */
	r->proto_num = HTTP_VERSION(major, minor);
    else
	r->proto_num = HTTP_VERSION(1,0);

    return 1;
}

    conn->keptalive    = conn->keepalive == 1;
    conn->keepalive    = 0;

    ap_run_create_request(r);
    r->the_request     = NULL;
    apr_setsocketopt(conn->client_socket, APR_SO_TIMEOUT, 
                     (int)(conn->keptalive
                     ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                     : r->server->timeout * APR_USEC_PER_SEC));
                     
    /* Get the request... */
    if (!read_request_line(r)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
			  "request failed: URI too long");
            ap_send_error_response(r, 0);
            ap_run_log_transaction(r);
            return r;
        }
        return NULL;
    }
    if (r->connection->keptalive) {
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(r->server->timeout * APR_USEC_PER_SEC));
    }
    conn->keptalive = 0;        /* We now have a request to play with */


    /** Which allow-override-opts bits are set */
    int override_opts;
                                       int override_opts,
    allow_options_t override_opts;
    /** the override options allowed for the .htaccess file */
    int override_opts;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
    parms.override_opts = OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER | OPT_MULTI;
				       int override_opts,
    parms.override_opts = override_opts;
    new->override_opts = override_opts;
    conf->override_opts = OPT_UNSET | OPT_ALL | OPT_INCNOEXEC | OPT_SYM_OWNER
   			 | OPT_MULTI;
    if (!(new->override_opts & OPT_UNSET)) {
	conf->override_opts = new->override_opts;
    }

static const char *set_allow_opts(cmd_parms *cmd, allow_options_t *opts,
                                  const char *l)
{
    allow_options_t opt;
    int first = 1;

    char *p = (char *) l;

    while (p && *p) {
        char *w = strsep(&p, ",");

        if (first) {
            *opts = OPT_NONE;
            first = 0;
        }

	if (!w)
	    continue;

        if (!strcasecmp(w, "Indexes")) {
            opt = OPT_INDEXES;
        }
        else if (!strcasecmp(w, "Includes")) {
            opt = OPT_INCLUDES;
        }
        else if (!strcasecmp(w, "IncludesNOEXEC")) {
            opt = (OPT_INCLUDES | OPT_INCNOEXEC);
        }
        else if (!strcasecmp(w, "FollowSymLinks")) {
            opt = OPT_SYM_LINKS;
        }
        else if (!strcasecmp(w, "SymLinksIfOwnerMatch")) {
            opt = OPT_SYM_OWNER;
        }
        else if (!strcasecmp(w, "ExecCGI")) {
            opt = OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "MultiViews")) {
            opt = OPT_MULTI;
        }
        else if (!strcasecmp(w, "RunScripts")) { /* AI backcompat. Yuck */
            opt = OPT_MULTI|OPT_EXECCGI;
        }
        else if (!strcasecmp(w, "None")) {
            opt = OPT_NONE;
        }
        else if (!strcasecmp(w, "All")) {
            opt = OPT_ALL;
        }
        else {
            return apr_pstrcat(cmd->pool, "Illegal option ", w, NULL);
        }

        *opts |= opt;
    }

    (*opts) &= (~OPT_UNSET);

    return NULL;
}

    char *k, *v;

	k = w;
	v = strchr(k, '=');
	if (v) {
		*v++ = '\0';
	}

        else if (!strcasecmp(k, "Options")) {
	    if (v) 
                set_allow_opts(cmd, &(d->override_opts), v);
	    else
	        d->override_opts = OPT_ALL;
        else if (!strcasecmp(w, "ExecCGI")) {
	if (!(cmd->override_opts & opt) && opt != OPT_NONE) {
	    return apr_pstrcat(cmd->pool, "Option ", w, " not allowed here", NULL);
        }
        else if (action == '-') {
            /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        overrides_t override_opts;
    if (!(this_dir->override_opts & OR_UNSET)) {
        opts->override_opts = this_dir->override_opts;
    }
					opts.override_opts,
        /* SNAFU: no call to apr_pool_note_subprocess() to cause the
         *        CGI to be cleaned up when the request ends (in case
         *        client drops connection)...  can't write the pid back
         *        to cgid_handler() because by the time we know the pid
         *        the new CGI is already started and potentially writing
         *        headers and body back to the handler...
         *        perhaps cgid_handler() needs to provide a key with
         *        a request to which cgid daemon will associate the
         *        CGI pid...  at request_rec cleanup time, that key
         *        gets sent back to cgid_handler() telling it to kill
         *        whatever pid is associated with the key...
         *        2 flows per request, which isn't cool...  but 
         *        having the CGI running after client killed connection
         *        isn't cool either...
         */
                                   proxy_conn_rec *conn, 
                                   conn_rec *origin, 
    status = ajp_send_header(conn->sock, r);
        conn->close++;
                     conn->worker->cp->addr,
                     conn->worker->hostname);
            status = ajp_send_data_msg(conn->sock, r, msg, bufsiz);
                             conn->worker->cp->addr,
                             conn->worker->hostname);
    status = ajp_read_header(conn->sock, r,
                             (ajp_msg_t **)&(conn->data));
                     conn->worker->cp->addr,
                     conn->worker->hostname);
    result = ajp_parse_type(r, conn->data);
                     conn->worker->cp->addr,
                     conn->worker->hostname);
    type = ajp_parse_type(r, backend->data);
            status = ajp_parse_header(r, backend->data); 
        } 
        else if  (type == CMD_AJP13_SEND_BODY_CHUNK) {
            status = ajp_parse_data(r, backend->data, &size, &buff);
        } 
        else {
        status = ajp_read_header(backend->sock, r,
                                 (ajp_msg_t **)&(backend->data));
        type = ajp_parse_type(r, backend->data);
                      "server %s:%d",
                      backend->worker->cp->addr,
                      backend->worker->hostname);
int ap_proxy_ajp_handler(request_rec *r, proxy_worker *worker,
                         proxy_server_conf *conf,
                         char *url, const char *proxyname, 
                         apr_port_t proxyport)
    const char *scheme = "ajp";

        status = ap_proxy_acquire_connection(scheme, &backend, worker, r->server);
        if (status != OK) {
            if (backend) {
                backend->close_on_recycle = 1;
                ap_proxy_release_connection(scheme, backend, r->server);
            }
            return status;
        }
    backend->is_ssl = 0;
    backend->close_on_recycle = 0;
    status = ap_proxy_determine_connection(p, r, conf, worker, backend, c->pool,
                                           uri, &url, proxyname, proxyport,
                                           server_portstr,
                                           sizeof(server_portstr));

    if (status != OK)
        goto cleanup;
    status = ap_proxy_connect_backend(scheme, backend, worker, r->server);
    if (status != OK)
        goto cleanup;

    /* Step Three: Create conn_rec */
    if (!backend->connection) {
        status = ap_proxy_connection_create(scheme, backend, c, r->server);
        if (status != OK)
            goto cleanup;
   
    /* Step Four: Send the Request */
    status = ap_proxy_ajp_request(p, r, backend, origin, conf, uri, url,
                                  server_portstr);
    if (status != OK)
        goto cleanup;

    /* Step Five: Receive the Response */
    status = ap_proxy_ajp_process_response(p, r, origin, backend,
cleanup:
    /* Clear the module config */
    ap_set_module_config(c->conn_config, &proxy_ajp_module, NULL);
    /* Do not close the socket */
    ap_proxy_release_connection(scheme, backend, r->server);
    return status;
        /* basedir is either "", or "/%2f" for the "squid %2f hack" */
        const char *basedir = "";  /* By default, path is relative to the $HOME dir */
        char *wildcard = NULL;

        /* If path began with /%2f, change the basedir */
        if (strncasecmp(path, "/%2f", 4) == 0) {
            basedir = "/%2f";
        }

        while (path[1] == '/') /* collapse multiple leading slashes to one */
            ++path;

        reldir = strrchr(path, '/');
        if (reldir != NULL) {
            for (n=0; reldir[n] != '\0'; ++n) {
                if (reldir[n] == '\\' && reldir[n+1] != '\0')
                    ++n; /* escaped character */
                else if (reldir[n] == '*' || reldir[n] == '?') {
                    wildcard = &reldir[1];
                    reldir[0] = '\0'; /* strip off the wildcard suffix */
                    break;
                }
            }
        }

        /* (the trailing slash is needed for the dir component loop below) */
        path = dir = ap_pstrcat(p, path, "/", NULL);
        for (n = strlen(path); n > 1 && path[n - 1] == '/' && path[n - 2] == '/'; --n)
        /* Add a link to the root directory (if %2f hack was used) */
        str = (basedir[0] != '\0') ? "<a href=\"/%2f/\">%2f</a>/" : "";

                "<html>\n <head>\n  <title>%s%s%s</title>\n"
                "  <base href=\"%s%s%s\">\n </head>\n"
                " <body>\n  <h2>Directory of "
                "<a href=\"/\">%s</a>/%s",
                site, basedir, ap_escape_html(p, path),
                site, basedir, ap_escape_uri(p, path),
                site, str);
        for (dir = path+1; (dir = strchr(dir, '/')) != NULL; )
        {
            if ((reldir = strrchr(path+1, '/'))==NULL) {
                reldir = path+1;
            }
            str = apr_psprintf(p, "<a href=\"%s%s/\">%s</a>/", basedir,
                        ap_escape_uri(p, path),
                        ap_escape_html(p, reldir));
            while (*dir == '/')
              ++dir;
            APR_BRIGADE_INSERT_TAIL(out, apr_bucket_pool_create(str, strlen(str), p));
        if (wildcard != NULL) {
            APR_BRIGADE_INSERT_TAIL(out, apr_bucket_pool_create(wildcard, strlen(wildcard), p));
        }

            str = apr_psprintf(p, "</h2>\n\n  <hr />\n\n<pre>");
            str = apr_psprintf(p, "</h2>\n\n(%s)\n\n  <hr />\n\n<pre>",
                               ap_escape_html(p, pwd));

            /* len+1 to leave spave for the trailing nil char */

            if (ctx->buffer[n-1] == CRLF[1])  /* strip trailing '\n' */
            if (ctx->buffer[n-1] == CRLF[0])  /* strip trailing '\r' if present */
        str = apr_psprintf(p, "</pre>\n\n  <hr />\n\n  %s\n\n </body>\n</html>\n", ap_psignature("", r));
             * should be created with the correct family in the first place.
             */
         * So we need to escape the URI metacharacters.
                ;
 * - ssl_io_filter_input    (Apache input filter)
 * - ssl_io_filter_output   (Apache output filter)
 * ssl_io_filter_input->ssl_io_input_read->SSL_read->...
 * Note that the filter context of ssl_io_filter_input and bio_filter_in_*
    SSL                *pssl;
    BIO                *pbioRead;
    BIO                *pbioWrite;
    ap_filter_t        *pInputFilter;
    ap_filter_t        *pOutputFilter;
} ssl_filter_ctx_t;

typedef struct {
    ssl_filter_ctx_t *filter_ctx;
static bio_filter_out_ctx_t *bio_filter_out_ctx_new(ssl_filter_ctx_t *filter_ctx,
    ssl_filter_ctx_t *filter_ctx;
        if (!inctx->filter_ctx->pssl) {
            break;
        }


static apr_status_t ssl_filter_write(ap_filter_t *f,
                                     const char *data,
                                     apr_size_t len)
{
    ssl_filter_ctx_t *filter_ctx = f->ctx;
    bio_filter_out_ctx_t *outctx = 
           (bio_filter_out_ctx_t *)(filter_ctx->pbioWrite->ptr);
    int res;

    /* write SSL */
    if (filter_ctx->pssl == NULL) {
        return APR_EGENERAL;
    }

    res = SSL_write(filter_ctx->pssl, (unsigned char *)data, len);

    if (res < 0) {
        int ssl_err = SSL_get_error(filter_ctx->pssl, res);

        if (ssl_err == SSL_ERROR_WANT_WRITE) {
            /*
             * If OpenSSL wants to write more, and we were nonblocking,
             * report as an EAGAIN.  Otherwise loop, pushing more
             * data at the network filter.
             *
             * (This is usually the case when the client forces an SSL
             * renegotation which is handled implicitly by OpenSSL.)
             */
            outctx->rc = APR_EAGAIN;
        }
        else if (ssl_err == SSL_ERROR_SYSCALL) {
            conn_rec *c = (conn_rec*)SSL_get_app_data(outctx->filter_ctx->pssl);
            ap_log_error(APLOG_MARK, APLOG_ERR, outctx->rc, c->base_server,
                        "SSL filter out error writing data");
        }
        else /* if (ssl_err == SSL_ERROR_SSL) */ {
            /*
             * Log SSL errors
             */
            conn_rec *c = (conn_rec *)SSL_get_app_data(filter_ctx->pssl);
            ap_log_error(APLOG_MARK, APLOG_ERR, outctx->rc, c->base_server,
                    "SSL library out error writing data");
            ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);

        }
        if (outctx->rc == APR_SUCCESS) {
            outctx->rc = APR_EGENERAL;
        }
    }
    else if ((apr_size_t)res != len) {
        conn_rec *c = f->c;
        char *reason = "reason unknown";

        /* XXX: probably a better way to determine this */
        if (SSL_total_renegotiations(filter_ctx->pssl)) {
            reason = "likely due to failed renegotiation";
        }

        ap_log_error(APLOG_MARK, APLOG_ERR, outctx->rc, c->base_server,
                     "failed to write %d of %d bytes (%s)",
                     len - (apr_size_t)res, len, reason);

        outctx->rc = APR_EGENERAL;
    }
    return outctx->rc;
}

static const char ssl_io_filter[] = "SSL/TLS Filter";

/*
 *  Close the SSL part of the socket connection
 *  (called immediately _before_ the socket is closed)
 *  or called with 
 */
static apr_status_t ssl_filter_io_shutdown(ssl_filter_ctx_t *filter_ctx,
                                           conn_rec *c,
                                           int abortive)
{
    SSL *ssl = filter_ctx->pssl;
    const char *type = "";
    SSLConnRec *sslconn = myConnConfig(c);
    int shutdown_type;

    if (!ssl) {
        return APR_SUCCESS;
    }

    /*
     * Now close the SSL layer of the connection. We've to take
     * the TLSv1 standard into account here:
     *
     * | 7.2.1. Closure alerts
     * |
     * | The client and the server must share knowledge that the connection is
     * | ending in order to avoid a truncation attack. Either party may
     * | initiate the exchange of closing messages.
     * |
     * | close_notify
     * |     This message notifies the recipient that the sender will not send
     * |     any more messages on this connection. The session becomes
     * |     unresumable if any connection is terminated without proper
     * |     close_notify messages with level equal to warning.
     * |
     * | Either party may initiate a close by sending a close_notify alert.
     * | Any data received after a closure alert is ignored.
     * |
     * | Each party is required to send a close_notify alert before closing
     * | the write side of the connection. It is required that the other party
     * | respond with a close_notify alert of its own and close down the
     * | connection immediately, discarding any pending writes. It is not
     * | required for the initiator of the close to wait for the responding
     * | close_notify alert before closing the read side of the connection.
     *
     * This means we've to send a close notify message, but haven't to wait
     * for the close notify of the client. Actually we cannot wait for the
     * close notify of the client because some clients (including Netscape
     * 4.x) don't send one, so we would hang.
     */

    /*
     * exchange close notify messages, but allow the user
     * to force the type of handshake via SetEnvIf directive
     */
    if (abortive) {
        shutdown_type = SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN;
        type = "abortive";
    }
    else switch (sslconn->shutdown_type) {
      case SSL_SHUTDOWN_TYPE_UNSET:
      case SSL_SHUTDOWN_TYPE_STANDARD:
        /* send close notify, but don't wait for clients close notify
           (standard compliant and safe, so it's the DEFAULT!) */
        shutdown_type = SSL_RECEIVED_SHUTDOWN;
        type = "standard";
        break;
      case SSL_SHUTDOWN_TYPE_UNCLEAN:
        /* perform no close notify handshake at all
           (violates the SSL/TLS standard!) */
        shutdown_type = SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN;
        type = "unclean";
        break;
      case SSL_SHUTDOWN_TYPE_ACCURATE:
        /* send close notify and wait for clients close notify
           (standard compliant, but usually causes connection hangs) */
        shutdown_type = 0;
        type = "accurate";
        break;
    }

    SSL_set_shutdown(ssl, shutdown_type);
    SSL_smart_shutdown(ssl);

    /* and finally log the fact that we've closed the connection */
    if (c->base_server->loglevel >= APLOG_INFO) {
        ap_log_error(APLOG_MARK, APLOG_INFO, 0, c->base_server,
                     "Connection to child %ld closed with %s shutdown"
                     "(server %s, client %s)",
                     c->id, type,
                     ssl_util_vhostid(c->pool, c->base_server),
                     c->remote_ip ? c->remote_ip : "unknown");
    }

    /* deallocate the SSL connection */
    SSL_free(ssl);
    sslconn->ssl = NULL;
    filter_ctx->pssl = NULL; /* so filters know we've been shutdown */

    return APR_SUCCESS;
}

static apr_status_t ssl_io_filter_cleanup(void *data)
{
    apr_status_t ret;
    ssl_filter_ctx_t *filter_ctx = (ssl_filter_ctx_t *)data;
    conn_rec *c;

    if (!filter_ctx->pssl) {
        /* already been shutdown */
        return APR_SUCCESS;
    }

    c = (conn_rec *)SSL_get_app_data(filter_ctx->pssl);
    if ((ret = ssl_filter_io_shutdown(filter_ctx, c, 0)) != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, ret, NULL,
                     "SSL filter error shutting down I/O");
    }

    return ret;
}

/*
 * The hook is NOT registered with ap_hook_process_connection. Instead, it is
 * called manually from the churn () before it tries to read any data.
 * There is some problem if I accept conn_rec *. Still investigating..
 * Adv. if conn_rec * can be accepted is we can hook this function using the
 * ap_hook_process_connection hook.
 */
static int ssl_io_filter_connect(ssl_filter_ctx_t *filter_ctx)
{
    conn_rec *c         = (conn_rec *)SSL_get_app_data(filter_ctx->pssl);
    SSLConnRec *sslconn = myConnConfig(c);
    SSLSrvConfigRec *sc = mySrvConfig(c->base_server);
    X509 *cert;
    int n, err;
    long verify_result;

    if (SSL_is_init_finished(filter_ctx->pssl)) {
        return APR_SUCCESS;
    }

    if (sslconn->is_proxy) {
        if ((n = SSL_connect(filter_ctx->pssl)) <= 0) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                         c->base_server,
                         "SSL Proxy connect failed");
            ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);
            return ssl_filter_io_shutdown(filter_ctx, c, 1);
        }

        return APR_SUCCESS;
    }

    if ((n = SSL_accept(filter_ctx->pssl)) <= 0) {
        err = SSL_get_error(filter_ctx->pssl, n);

        if (err == SSL_ERROR_ZERO_RETURN) {
            /*
             * The case where the connection was closed before any data
             * was transferred. That's not a real error and can occur
             * sporadically with some clients.
             */
            ap_log_error(APLOG_MARK, APLOG_INFO, 0,
                         c->base_server,
                         "SSL handshake stopped: connection was closed");
        }
        else if (err == SSL_ERROR_WANT_READ) {
            /*
             * This is in addition to what was present earlier. It is 
             * borrowed from openssl_state_machine.c [mod_tls].
             * TBD.
             */
            return SSL_ERROR_WANT_READ;
        }
        else if (ERR_GET_REASON(ERR_peek_error()) == SSL_R_HTTP_REQUEST) {
            /*
             * The case where OpenSSL has recognized a HTTP request:
             * This means the client speaks plain HTTP on our HTTPS port.
             * ssl_io_filter_error will disable the ssl filters when it
             * sees this status code.
             */
            return HTTP_BAD_REQUEST;
        }
        else if ((SSL_get_error(filter_ctx->pssl, n) == SSL_ERROR_SYSCALL) &&
                 (errno != EINTR))
        {
            if (errno > 0) {
                ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                             c->base_server,
                             "SSL handshake interrupted by system "
                             "[Hint: Stop button pressed in browser?!]");
                ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);
            }
            else {
                ap_log_error(APLOG_MARK, APLOG_ERR, 0, 
                             c->base_server,
                             "Spurious SSL handshake interrupt [Hint: "
                             "Usually just one of those OpenSSL "
                             "confusions!?]");
                ssl_log_ssl_error(APLOG_MARK, APLOG_INFO, c->base_server);
            }
        }
        else {
            /*
             * Ok, anything else is a fatal error
             */
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, 
                         c->base_server,
                         "SSL handshake failed (server %s, client %s)",
                         ssl_util_vhostid(c->pool, c->base_server),
                         c->remote_ip ? c->remote_ip : "unknown");
            ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);
        }

        return ssl_filter_io_shutdown(filter_ctx, c, 1);
    }

    /*
     * Check for failed client authentication
     */
    verify_result = SSL_get_verify_result(filter_ctx->pssl);

    if ((verify_result != X509_V_OK) ||
        sslconn->verify_error)
    {
        if (ssl_verify_error_is_optional(verify_result) &&
            (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA))
        {
            /* leaving this log message as an error for the moment,
             * according to the mod_ssl docs:
             * "level optional_no_ca is actually against the idea
             *  of authentication (but can be used to establish 
             * SSL test pages, etc.)"
             * optional_no_ca doesn't appear to work as advertised
             * in 1.x
             */
            ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                         c->base_server,
                         "SSL client authentication failed, "
                         "accepting certificate based on "
                         "\"SSLVerifyClient optional_no_ca\" "
                         "configuration");
            ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);
        }
        else {
            const char *error = sslconn->verify_error ?
                sslconn->verify_error :
                X509_verify_cert_error_string(verify_result);

            ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                         c->base_server,
                         "SSL client authentication failed: %s",
                         error ? error : "unknown");
            ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);

            return ssl_filter_io_shutdown(filter_ctx, c, 1);
        }
    }

    /*
     * Remember the peer certificate's DN
     */
    if ((cert = SSL_get_peer_certificate(filter_ctx->pssl))) {
        sslconn->client_cert = cert;
        sslconn->client_dn = NULL;
        X509_free(cert);
    }

    /*
     * Make really sure that when a peer certificate
     * is required we really got one... (be paranoid)
     */
    if ((sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE) &&
        !sslconn->client_cert)
    {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server,
                     "No acceptable peer certificate available");

        return ssl_filter_io_shutdown(filter_ctx, c, 1);
    }

    return APR_SUCCESS;
}

static apr_status_t ssl_io_filter_input(ap_filter_t *f,
    /* XXX: we could actually move ssl_io_filter_connect to an
    status = ssl_io_filter_connect(inctx->filter_ctx);
static apr_status_t ssl_io_filter_output(ap_filter_t *f,
                                         apr_bucket_brigade *bb)
{
    apr_status_t status = APR_SUCCESS;
    ssl_filter_ctx_t *filter_ctx = f->ctx;

    if (f->c->aborted) {
        apr_brigade_cleanup(bb);
        return APR_ECONNABORTED;
    }

    if (!filter_ctx->pssl) {
        /* ssl_filter_io_shutdown was called */
        return ap_pass_brigade(f->next, bb);
    }

    if ((status = ssl_io_filter_connect(filter_ctx)) != APR_SUCCESS) {
        return status;
    }

    while (!APR_BRIGADE_EMPTY(bb)) {
        apr_bucket *bucket = APR_BRIGADE_FIRST(bb);

        /* If it is a flush or EOS, we need to pass this down. 
         * These types do not require translation by OpenSSL.  
         */
        if (APR_BUCKET_IS_EOS(bucket) || APR_BUCKET_IS_FLUSH(bucket)) {
            if (bio_filter_out_flush(filter_ctx->pbioWrite) < 0) {
                bio_filter_out_ctx_t *outctx = 
                       (bio_filter_out_ctx_t *)(filter_ctx->pbioWrite->ptr);
                status = outctx->rc;
                break;
            }

            if (APR_BUCKET_IS_EOS(bucket)) {
                /*
                 * By definition, nothing can come after EOS.
                 * which also means we can pass the rest of this brigade
                 * without creating a new one since it only contains the
                 * EOS bucket.
                 */

                if ((status = ap_pass_brigade(f->next, bb)) != APR_SUCCESS) {
                    return status;
                }
                break;
            }
            else {
                /* bio_filter_out_flush() already passed down a flush bucket
                 * if there was any data to be flushed.
                 */
                apr_bucket_delete(bucket);
            }
        }
        else {
            /* filter output */
            const char *data;
            apr_size_t len;
            
            status = apr_bucket_read(bucket, &data, &len, APR_BLOCK_READ);

            if (!APR_STATUS_IS_EOF(status) && (status != APR_SUCCESS)) {
                break;
            }

            status = ssl_filter_write(f, data, len);
            apr_bucket_delete(bucket);

            if (status != APR_SUCCESS) {
                break;
            }
        }
    }

    return status;
}

static void ssl_io_input_add_filter(ssl_filter_ctx_t *filter_ctx, conn_rec *c,
    ssl_filter_ctx_t *filter_ctx;
    filter_ctx = apr_palloc(c->pool, sizeof(ssl_filter_ctx_t));
    ap_register_input_filter  (ssl_io_filter, ssl_io_filter_input,  NULL, AP_FTYPE_CONNECTION + 5);
    ap_register_output_filter (ssl_io_filter, ssl_io_filter_output, NULL, AP_FTYPE_CONNECTION + 5);
    /* Prepend any earlier saved brigades. */
    APR_BRIGADE_PREPEND(bb, ctx->bb);
#include "mod_ssl.h"
#include "ssl_private.h"
/* The ssl_var_lookup() optional function retrieves SSL environment
 * variables. */
/* The ssl_proxy_enable() and ssl_engine_disable() optional functions
 * are used by mod_proxy to enable use of SSL for outgoing
 * connections. */
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
 * $Header: /home/striker/cvs2svn/dumps/httpd-2.0/../../httpd-2.0/modules/ssl/ssl_expr_scan.c,v 1.19 2004/02/28 18:06:35 jorton Exp $
#include "ssl_private.h"
/* Copyright 2001-2004 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SSL_PRIVATE_H
#define SSL_PRIVATE_H

/*
 * Internal interfaces private to mod_ssl.
 */

/* Apache headers */
#include "httpd.h"
#include "http_config.h"
#include "http_core.h"
#include "http_log.h"
#include "http_main.h"
#include "http_connection.h"
#include "http_request.h"
#include "http_protocol.h"
#include "util_script.h"
#include "util_filter.h"
#include "util_ebcdic.h"
#include "mpm.h"
#include "apr.h"
#include "apr_strings.h"
#define APR_WANT_STRFUNC
#include "apr_want.h"
#include "apr_tables.h"
#include "apr_lib.h"
#include "apr_fnmatch.h"
#include "apr_strings.h"
#include "apr_dbm.h"
#include "apr_rmm.h"
#include "apr_shm.h"
#include "apr_global_mutex.h"
#include "apr_optional.h"

#define MOD_SSL_VERSION AP_SERVER_BASEREVISION

/* mod_ssl headers */
#include "ssl_toolkit_compat.h"
#include "ssl_expr.h"
#include "ssl_util_ssl.h"

/* The #ifdef macros are only defined AFTER including the above
 * therefore we cannot include these system files at the top  :-(
 */
#if APR_HAVE_SYS_TIME_H
#include <sys/time.h>
#endif
#if APR_HAVE_UNISTD_H
#include <unistd.h> /* needed for STDIN_FILENO et.al., at least on FreeBSD */
#endif

/*
 * Provide reasonable default for some defines
 */
#ifndef FALSE
#define FALSE (0)
#endif
#ifndef TRUE
#define TRUE (!FALSE)
#endif
#ifndef PFALSE
#define PFALSE ((void *)FALSE)
#endif
#ifndef PTRUE
#define PTRUE ((void *)TRUE)
#endif
#ifndef UNSET
#define UNSET (-1)
#endif
#ifndef NUL
#define NUL '\0'
#endif
#ifndef RAND_MAX
#include <limits.h>
#define RAND_MAX INT_MAX
#endif

/*
 * Provide reasonable defines for some types
 */
#ifndef BOOL
#define BOOL unsigned int
#endif
#ifndef UCHAR
#define UCHAR unsigned char
#endif

/*
 * Provide useful shorthands
 */
#define strEQ(s1,s2)     (strcmp(s1,s2)        == 0)
#define strNE(s1,s2)     (strcmp(s1,s2)        != 0)
#define strEQn(s1,s2,n)  (strncmp(s1,s2,n)     == 0)
#define strNEn(s1,s2,n)  (strncmp(s1,s2,n)     != 0)

#define strcEQ(s1,s2)    (strcasecmp(s1,s2)    == 0)
#define strcNE(s1,s2)    (strcasecmp(s1,s2)    != 0)
#define strcEQn(s1,s2,n) (strncasecmp(s1,s2,n) == 0)
#define strcNEn(s1,s2,n) (strncasecmp(s1,s2,n) != 0)

#define strIsEmpty(s)    (s == NULL || s[0] == NUL)

#define myConnConfig(c) \
(SSLConnRec *)ap_get_module_config(c->conn_config, &ssl_module)
#define myCtxConfig(sslconn, sc) (sslconn->is_proxy ? sc->proxy : sc->server)
#define myConnConfigSet(c, val) \
ap_set_module_config(c->conn_config, &ssl_module, val)
#define mySrvConfig(srv) (SSLSrvConfigRec *)ap_get_module_config(srv->module_config,  &ssl_module)
#define myDirConfig(req) (SSLDirConfigRec *)ap_get_module_config(req->per_dir_config, &ssl_module)
#define myModConfig(srv) (mySrvConfig((srv)))->mc

#define myCtxVarSet(mc,num,val)  mc->rCtx.pV##num = val
#define myCtxVarGet(mc,num,type) (type)(mc->rCtx.pV##num)

/*
 * Defaults for the configuration
 */
#ifndef SSL_SESSION_CACHE_TIMEOUT
#define SSL_SESSION_CACHE_TIMEOUT  300
#endif

/*
 * Support for MM library
 */
#define SSL_MM_FILE_MODE ( APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD )

/*
 * Support for DBM library
 */
#define SSL_DBM_FILE_MODE ( APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD )

#if !defined(SSL_DBM_FILE_SUFFIX_DIR) && !defined(SSL_DBM_FILE_SUFFIX_PAG)
#if defined(DBM_SUFFIX)
#define SSL_DBM_FILE_SUFFIX_DIR DBM_SUFFIX
#define SSL_DBM_FILE_SUFFIX_PAG DBM_SUFFIX
#elif defined(__FreeBSD__) || (defined(DB_LOCK) && defined(DB_SHMEM))
#define SSL_DBM_FILE_SUFFIX_DIR ".db"
#define SSL_DBM_FILE_SUFFIX_PAG ".db"
#else
#define SSL_DBM_FILE_SUFFIX_DIR ".dir"
#define SSL_DBM_FILE_SUFFIX_PAG ".pag"
#endif
#endif

/*
 * Define the certificate algorithm types
 */

typedef int ssl_algo_t;

#define SSL_ALGO_UNKNOWN (0)
#define SSL_ALGO_RSA     (1<<0)
#define SSL_ALGO_DSA     (1<<1)
#define SSL_ALGO_ALL     (SSL_ALGO_RSA|SSL_ALGO_DSA)

#define SSL_AIDX_RSA     (0)
#define SSL_AIDX_DSA     (1)
#define SSL_AIDX_MAX     (2)


/*
 * Define IDs for the temporary RSA keys and DH params
 */

#define SSL_TMP_KEY_RSA_512  (0)
#define SSL_TMP_KEY_RSA_1024 (1)
#define SSL_TMP_KEY_DH_512   (2)
#define SSL_TMP_KEY_DH_1024  (3)
#define SSL_TMP_KEY_MAX      (4)

/*
 * Define the SSL options
 */
#define SSL_OPT_NONE           (0)
#define SSL_OPT_RELSET         (1<<0)
#define SSL_OPT_STDENVVARS     (1<<1)
#define SSL_OPT_COMPATENVVARS  (1<<2)
#define SSL_OPT_EXPORTCERTDATA (1<<3)
#define SSL_OPT_FAKEBASICAUTH  (1<<4)
#define SSL_OPT_STRICTREQUIRE  (1<<5)
#define SSL_OPT_OPTRENEGOTIATE (1<<6)
#define SSL_OPT_ALL            (SSL_OPT_STDENVVARS|SSL_OPT_COMPATENVVAR|SSL_OPT_EXPORTCERTDATA|SSL_OPT_FAKEBASICAUTH|SSL_OPT_STRICTREQUIRE|SSL_OPT_OPTRENEGOTIATE)
typedef int ssl_opt_t;

/*
 * Define the SSL Protocol options
 */
#define SSL_PROTOCOL_NONE  (0)
#define SSL_PROTOCOL_SSLV2 (1<<0)
#define SSL_PROTOCOL_SSLV3 (1<<1)
#define SSL_PROTOCOL_TLSV1 (1<<2)
#define SSL_PROTOCOL_ALL   (SSL_PROTOCOL_SSLV2|SSL_PROTOCOL_SSLV3|SSL_PROTOCOL_TLSV1)
typedef int ssl_proto_t;

/*
 * Define the SSL verify levels
 */
typedef enum {
    SSL_CVERIFY_UNSET           = UNSET,
    SSL_CVERIFY_NONE            = 0,
    SSL_CVERIFY_OPTIONAL        = 1,
    SSL_CVERIFY_REQUIRE         = 2,
    SSL_CVERIFY_OPTIONAL_NO_CA  = 3
} ssl_verify_t;

#define SSL_VERIFY_PEER_STRICT \
     (SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT)

#ifndef X509_V_ERR_CERT_UNTRUSTED
#define X509_V_ERR_CERT_UNTRUSTED 27
#endif

#define ssl_verify_error_is_optional(errnum) \
   ((errnum == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT) \
    || (errnum == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN) \
    || (errnum == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY) \
    || (errnum == X509_V_ERR_CERT_UNTRUSTED) \
    || (errnum == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE))

/*
 * Define the SSL pass phrase dialog types
 */
typedef enum {
    SSL_PPTYPE_UNSET   = UNSET,
    SSL_PPTYPE_BUILTIN = 0,
    SSL_PPTYPE_FILTER  = 1,
	SSL_PPTYPE_PIPE    = 2
} ssl_pphrase_t;

/*
 * Define the Path Checking modes
 */
#define SSL_PCM_EXISTS     1
#define SSL_PCM_ISREG      2
#define SSL_PCM_ISDIR      4
#define SSL_PCM_ISNONZERO  8
typedef unsigned int ssl_pathcheck_t;

/*
 * Define the SSL session cache modes and structures
 */
typedef enum {
    SSL_SCMODE_UNSET = UNSET,
    SSL_SCMODE_NONE  = 0,
    SSL_SCMODE_DBM   = 1,
    SSL_SCMODE_SHMCB = 3,
    SSL_SCMODE_DC    = 4
} ssl_scmode_t;

/*
 * Define the SSL mutex modes
 */
typedef enum {
    SSL_MUTEXMODE_UNSET  = UNSET,
    SSL_MUTEXMODE_NONE   = 0,
    SSL_MUTEXMODE_USED   = 1
} ssl_mutexmode_t;

/*
 * Define the SSL requirement structure
 */
typedef struct {
    char     *cpExpr;
    ssl_expr *mpExpr;
} ssl_require_t;

/*
 * Define the SSL random number generator seeding source
 */
typedef enum {
    SSL_RSCTX_STARTUP = 1,
    SSL_RSCTX_CONNECT = 2
} ssl_rsctx_t;
typedef enum {
    SSL_RSSRC_BUILTIN = 1,
    SSL_RSSRC_FILE    = 2,
    SSL_RSSRC_EXEC    = 3,
    SSL_RSSRC_EGD     = 4
} ssl_rssrc_t;
typedef struct {
    ssl_rsctx_t  nCtx;
    ssl_rssrc_t  nSrc;
    char        *cpPath;
    int          nBytes;
} ssl_randseed_t;

/*
 * Define the structure of an ASN.1 anything
 */
typedef struct {
    long int       nData;
    unsigned char *cpData;
    apr_time_t     source_mtime;
} ssl_asn1_t;

/*
 * Define the mod_ssl per-module configuration structure
 * (i.e. the global configuration for each httpd process)
 */

typedef enum {
    SSL_SHUTDOWN_TYPE_UNSET,
    SSL_SHUTDOWN_TYPE_STANDARD,
    SSL_SHUTDOWN_TYPE_UNCLEAN,
    SSL_SHUTDOWN_TYPE_ACCURATE
} ssl_shutdown_type_e;

typedef struct {
    SSL *ssl;
    const char *client_dn;
    X509 *client_cert;
    ssl_shutdown_type_e shutdown_type;
    const char *verify_info;
    const char *verify_error;
    int verify_depth;
    int is_proxy;
    int disabled;
    int non_ssl_request;
} SSLConnRec;

typedef struct {
    pid_t           pid;
    apr_pool_t     *pPool;
    BOOL            bFixed;
    int             nSessionCacheMode;
    char           *szSessionCacheDataFile;
    int             nSessionCacheDataSize;
    apr_shm_t      *pSessionCacheDataMM;
    apr_rmm_t      *pSessionCacheDataRMM;
    void           *tSessionCacheDataTable;
    ssl_mutexmode_t nMutexMode;
    apr_lockmech_e  nMutexMech;
    const char     *szMutexFile;
    apr_global_mutex_t   *pMutex;
    apr_array_header_t   *aRandSeed;
    apr_hash_t     *tVHostKeys;
    void           *pTmpKeys[SSL_TMP_KEY_MAX];
    apr_hash_t     *tPublicCert;
    apr_hash_t     *tPrivateKey;
#if defined(HAVE_OPENSSL_ENGINE_H) && defined(HAVE_ENGINE_INIT)
    const char     *szCryptoDevice;
#endif
    struct {
        void *pV1, *pV2, *pV3, *pV4, *pV5, *pV6, *pV7, *pV8, *pV9, *pV10;
    } rCtx;
} SSLModConfigRec;

/* public cert/private key */
typedef struct {
    /* 
     * server only has 1-2 certs/keys
     * 1 RSA and/or 1 DSA
     */
    const char  *cert_files[SSL_AIDX_MAX];
    const char  *key_files[SSL_AIDX_MAX];
    X509        *certs[SSL_AIDX_MAX];
    EVP_PKEY    *keys[SSL_AIDX_MAX];
} modssl_pk_server_t;

typedef struct {
    /* proxy can have any number of cert/key pairs */
    const char  *cert_file;
    const char  *cert_path;
    STACK_OF(X509_INFO) *certs;
} modssl_pk_proxy_t;

/* stuff related to authentication that can also be per-dir */
typedef struct {
    /* known/trusted CAs */
    const char  *ca_cert_path;
    const char  *ca_cert_file;

    const char  *cipher_suite;

    /* for client or downstream server authentication */
    int          verify_depth;
    ssl_verify_t verify_mode;
} modssl_auth_ctx_t;

typedef struct SSLSrvConfigRec SSLSrvConfigRec;

typedef struct {
    SSLSrvConfigRec *sc; /* pointer back to server config */
    SSL_CTX *ssl_ctx;

    /* we are one or the other */
    modssl_pk_server_t *pks;
    modssl_pk_proxy_t  *pkp;

    ssl_proto_t  protocol;

    /* config for handling encrypted keys */
    ssl_pphrase_t pphrase_dialog_type;
    const char   *pphrase_dialog_path;

    const char  *cert_chain;

    /* certificate revocation list */
    const char  *crl_path;
    const char  *crl_file;
    X509_STORE  *crl;

    modssl_auth_ctx_t auth;
} modssl_ctx_t;

struct SSLSrvConfigRec {
    SSLModConfigRec *mc;
    BOOL             enabled;
    BOOL             proxy_enabled;
    const char      *vhost_id;
    int              vhost_id_len;
    int              session_cache_timeout;
    modssl_ctx_t    *server;
    modssl_ctx_t    *proxy;
};

/*
 * Define the mod_ssl per-directory configuration structure
 * (i.e. the local configuration for all <Directory>
 *  and .htaccess contexts)
 */
typedef struct {
    BOOL          bSSLRequired;
    apr_array_header_t *aRequirement;
    ssl_opt_t     nOptions;
    ssl_opt_t     nOptionsAdd;
    ssl_opt_t     nOptionsDel;
    const char   *szCipherSuite;
    ssl_verify_t  nVerifyClient;
    int           nVerifyDepth;
    const char   *szCACertificatePath;
    const char   *szCACertificateFile;
} SSLDirConfigRec;

/*
 *  function prototypes
 */

/*  API glue structures  */
extern module AP_MODULE_DECLARE_DATA ssl_module;

/* "global" stuff */
extern const char ssl_valid_ssl_mutex_string[];

/*  configuration handling   */
SSLModConfigRec *ssl_config_global_create(server_rec *);
void         ssl_config_global_fix(SSLModConfigRec *);
BOOL         ssl_config_global_isfixed(SSLModConfigRec *);
void        *ssl_config_server_create(apr_pool_t *, server_rec *);
void        *ssl_config_server_merge(apr_pool_t *, void *, void *);
void        *ssl_config_perdir_create(apr_pool_t *, char *);
void        *ssl_config_perdir_merge(apr_pool_t *, void *, void *);
const char  *ssl_cmd_SSLMutex(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLPassPhraseDialog(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCryptoDevice(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLRandomSeed(cmd_parms *, void *, const char *, const char *, const char *);
const char  *ssl_cmd_SSLEngine(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCipherSuite(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCertificateFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCertificateKeyFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCertificateChainFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCACertificatePath(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCACertificateFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCARevocationPath(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCARevocationFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLVerifyClient(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLVerifyDepth(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLSessionCache(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLSessionCacheTimeout(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProtocol(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLOptions(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLRequireSSL(cmd_parms *, void *);
const char  *ssl_cmd_SSLRequire(cmd_parms *, void *, const char *);

const char *ssl_cmd_SSLProxyEngine(cmd_parms *cmd, void *dcfg, int flag);
const char  *ssl_cmd_SSLProxyProtocol(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyCipherSuite(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyVerify(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyVerifyDepth(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyCACertificatePath(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyCACertificateFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyCARevocationPath(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyCARevocationFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyMachineCertificatePath(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyMachineCertificateFile(cmd_parms *, void *, const char *);

/*  module initialization  */
int          ssl_init_Module(apr_pool_t *, apr_pool_t *, apr_pool_t *, server_rec *);
void         ssl_init_Engine(server_rec *, apr_pool_t *);
void         ssl_init_ConfigureServer(server_rec *, apr_pool_t *, apr_pool_t *, SSLSrvConfigRec *);
void         ssl_init_CheckServers(server_rec *, apr_pool_t *);
STACK_OF(X509_NAME) 
            *ssl_init_FindCAList(server_rec *, apr_pool_t *, const char *, const char *);
void         ssl_init_Child(apr_pool_t *, server_rec *);
apr_status_t ssl_init_ModuleKill(void *data);

/*  Apache API hooks  */
int          ssl_hook_Translate(request_rec *);
int          ssl_hook_Auth(request_rec *);
int          ssl_hook_UserCheck(request_rec *);
int          ssl_hook_Access(request_rec *);
int          ssl_hook_Fixup(request_rec *);
int          ssl_hook_ReadReq(request_rec *);
int          ssl_hook_Upgrade(request_rec *);

/*  OpenSSL callbacks */
RSA         *ssl_callback_TmpRSA(SSL *, int, int);
DH          *ssl_callback_TmpDH(SSL *, int, int);
int          ssl_callback_SSLVerify(int, X509_STORE_CTX *);
int          ssl_callback_SSLVerify_CRL(int, X509_STORE_CTX *, conn_rec *);
int          ssl_callback_proxy_cert(SSL *ssl, MODSSL_CLIENT_CERT_CB_ARG_TYPE **x509, EVP_PKEY **pkey);
int          ssl_callback_NewSessionCacheEntry(SSL *, SSL_SESSION *);
SSL_SESSION *ssl_callback_GetSessionCacheEntry(SSL *, unsigned char *, int, int *);
void         ssl_callback_DelSessionCacheEntry(SSL_CTX *, SSL_SESSION *);
void         ssl_callback_LogTracingState(MODSSL_INFO_CB_ARG_TYPE, int, int);

/*  Session Cache Support  */
void         ssl_scache_init(server_rec *, apr_pool_t *);
void         ssl_scache_status_register(apr_pool_t *p);
void         ssl_scache_kill(server_rec *);
BOOL         ssl_scache_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
SSL_SESSION *ssl_scache_retrieve(server_rec *, UCHAR *, int);
void         ssl_scache_remove(server_rec *, UCHAR *, int);
void         ssl_scache_expire(server_rec *);

char        *ssl_scache_id2sz(UCHAR *, int);
void         ssl_scache_dbm_init(server_rec *, apr_pool_t *);
void         ssl_scache_dbm_kill(server_rec *);
BOOL         ssl_scache_dbm_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
SSL_SESSION *ssl_scache_dbm_retrieve(server_rec *, UCHAR *, int);
void         ssl_scache_dbm_remove(server_rec *, UCHAR *, int);
void         ssl_scache_dbm_expire(server_rec *);
void         ssl_scache_dbm_status(request_rec *r, int flags, apr_pool_t *pool);

void         ssl_scache_shmcb_init(server_rec *, apr_pool_t *);
void         ssl_scache_shmcb_kill(server_rec *);
BOOL         ssl_scache_shmcb_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
SSL_SESSION *ssl_scache_shmcb_retrieve(server_rec *, UCHAR *, int);
void         ssl_scache_shmcb_remove(server_rec *, UCHAR *, int);
void         ssl_scache_shmcb_expire(server_rec *);
void         ssl_scache_shmcb_status(request_rec *r, int flags, apr_pool_t *pool);

void         ssl_scache_dc_init(server_rec *, apr_pool_t *);
void         ssl_scache_dc_kill(server_rec *);
BOOL         ssl_scache_dc_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
SSL_SESSION *ssl_scache_dc_retrieve(server_rec *, UCHAR *, int);
void         ssl_scache_dc_remove(server_rec *, UCHAR *, int);
void         ssl_scache_dc_expire(server_rec *);
void         ssl_scache_dc_status(request_rec *r, int flags, apr_pool_t *pool);

/* Proxy Support */
int ssl_proxy_enable(conn_rec *c);
int ssl_engine_disable(conn_rec *c);

/*  I/O  */
void         ssl_io_filter_init(conn_rec *, SSL *);
void         ssl_io_filter_register(apr_pool_t *);
long         ssl_io_data_cb(BIO *, int, MODSSL_BIO_CB_ARG_TYPE *, int, long, long);

/*  PRNG  */
int          ssl_rand_seed(server_rec *, apr_pool_t *, ssl_rsctx_t, char *);

/*  Utility Functions  */
char        *ssl_util_vhostid(apr_pool_t *, server_rec *);
void         ssl_util_strupper(char *);
void         ssl_util_uuencode(char *, const char *, BOOL);
void         ssl_util_uuencode_binary(unsigned char *, const unsigned char *, int, BOOL);
apr_file_t  *ssl_util_ppopen(server_rec *, apr_pool_t *, const char *,
                             const char * const *);
void         ssl_util_ppclose(server_rec *, apr_pool_t *, apr_file_t *);
char        *ssl_util_readfilter(server_rec *, apr_pool_t *, const char *,
                                 const char * const *);
BOOL         ssl_util_path_check(ssl_pathcheck_t, const char *, apr_pool_t *);
ssl_algo_t   ssl_util_algotypeof(X509 *, EVP_PKEY *); 
char        *ssl_util_algotypestr(ssl_algo_t);
char        *ssl_util_ptxtsub(apr_pool_t *, const char *, const char *, char *);
void         ssl_util_thread_setup(apr_pool_t *);
int          ssl_init_ssl_connection(conn_rec *c);

/*  Pass Phrase Support  */
void         ssl_pphrase_Handle(server_rec *, apr_pool_t *);

/*  Diffie-Hellman Parameter Support  */
DH           *ssl_dh_GetTmpParam(int);
DH           *ssl_dh_GetParamFromFile(char *);

unsigned char *ssl_asn1_table_set(apr_hash_t *table,
                                  const char *key,
                                  long int length);

ssl_asn1_t *ssl_asn1_table_get(apr_hash_t *table,
                               const char *key);

void ssl_asn1_table_unset(apr_hash_t *table,
                          const char *key);

const char *ssl_asn1_keystr(int keytype);

const char *ssl_asn1_table_keyfmt(apr_pool_t *p,
                                  const char *id,
                                  int keytype);
/*  Mutex Support  */
int          ssl_mutex_init(server_rec *, apr_pool_t *);
int          ssl_mutex_reinit(server_rec *, apr_pool_t *);
int          ssl_mutex_on(server_rec *);
int          ssl_mutex_off(server_rec *);

/*  Logfile Support  */
void         ssl_die(void);
void         ssl_log_ssl_error(const char *, int, int, server_rec *);

/*  Variables  */
void         ssl_var_register(void);
char        *ssl_var_lookup(apr_pool_t *, server_rec *, conn_rec *, request_rec *, char *);
void         ssl_var_log_config_register(apr_pool_t *p);

#define APR_SHM_MAXSIZE (64 * 1024 * 1024)

#endif /* SSL_PRIVATE_H */
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
#include "ssl_private.h"
/* Is the scoreboard shared between processes or not? 
 * Set by the MPM when the scoreboard is created.
 */
typedef enum {
    SB_SHARED = 1,
    SB_NOT_SHARED = 2
} ap_scoreboard_e;

    ap_scoreboard_e sb_type;
AP_DECLARE(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e t);
void ap_sync_scoreboard_image(void);
/*    ap_sync_scoreboard_image(); */
/* mpm.h is the place to make declarations that are MPM specific but that must be 
 * shared with non-mpm specific code in the server.  Hummm, perhaps we can
 * move most of this stuff to mpm_common.h?
 */
extern int ap_threads_per_child;
/* AP_CHILD_THREAD_FROM_ID is used by the scoreboard.  */
#define AP_CHILD_THREAD_FROM_ID(i)       i, 0


#include "scoreboard.h"

int ap_threads_per_child = 0;
/* ap_get_max_daemons and ap_my_generation are used by the scoreboard
 * code
 */
ap_generation_t volatile ap_my_generation=0; /* Used by the scoreboard */
AP_DECLARE(int) ap_get_max_daemons(void)
{
    return 1;
}

    /* Set up the scoreboard. The scoreboard in this MPM only applies to the
     * child process and is not shared across processes
     */
    ap_create_scoreboard(pconf, SB_NOT_SHARED);
/* ToDo: Fix this right */
#ifndef WIN32
#endif

#endif
/*
 * ToDo:
 * This function should be renamed to cleanup_shared
 * and it should handle cleaning up a scoreboard shared
 * between processes using any form of IPC (file, shared memory
 * segment, etc.). Leave it as is now because it is being used
 * by various MPMs. 
 */
#if APR_HAD_SHARED_MEMORY
#endif
/* ToDo: This function should be made to handle setting up 
 * a scoreboard shared between processes using any IPC technique, 
 * not just a shared memory segment
 */
static void setup_shared(apr_pool_t *p)
#if APR_HAD_SHARED_MEMORY
#endif
AP_DECLARE(void) reopen_scoreboard(apr_pool_t *p)
/* ap_cleanup_scoreboard
 * 
 */
static void ap_cleanup_scoreboard(void *d) {
    if (ap_scoreboard_image == NULL)
        return;
    if (ap_scoreboard_image->global.sb_type == SB_SHARED) {
        ap_cleanup_shared_mem(NULL);
    }
    else {
        free(ap_scoreboard_image);
        ap_scoreboard_image = NULL;
    }
}

/* ap_create_scoreboard(apr_pool_t*, ap_scoreboard_e t)
 *
 * Create or reinit an existing scoreboard. The MPM can control whether
 * the scoreboard is shared across multiple processes or not
 */
AP_DECLARE(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
        if (sb_type == SB_SHARED) {
            setup_shared(p);
            ap_scoreboard_image->global.sb_type = SB_SHARED;
        }
        else {
            /* A simple malloc will suffice */
            char buf[512];
            ap_scoreboard_image = (scoreboard *) malloc(SCOREBOARD_SIZE);
            if (ap_scoreboard_image == NULL) {
                apr_snprintf(buf, sizeof(buf), "%s: cannot allocate scoreboard",
                             ap_server_argv0);
                perror(buf); /* o.k. since MM sets errno */
                exit(APEXIT_INIT);            
            }
            ap_scoreboard_image->global.sb_type = SB_NOT_SHARED;
        }
    apr_register_cleanup(p, NULL, ap_cleanup_scoreboard, apr_null_cleanup);
}

/* ToDo:
 * reinit_scoreboard should be eliminated when all MPMs migrate to
 * ap_create_scoreboard()
 */
void reinit_scoreboard(apr_pool_t *p)
{
    ap_create_scoreboard(p, SB_SHARED);
void ap_sync_scoreboard_image(void)
#define RULEFLAG_NOSUB              1<<14
    backrefinfo briRR;
    backrefinfo briRC;
            backrefinfo *bri = (*p == '$') ? &ctx->briRR : &ctx->briRC;
            if (bri->source && n <= bri->nsub
    if (*a2 == '-' && !a2[1]) {
        newrule->flags |= RULEFLAG_NOSUB;
    }
            ctx->briRC.source = input;
            ctx->briRC.nsub   = p->regexp->re_nsub;
            memcpy(ctx->briRC.regmatch, regmatch, sizeof(regmatch));
 * Apply a single RewriteRule
    int i, rc;
    char *newuri = NULL;
    ctx->uri = r->filename;
    if (ctx->perdir) {
        apr_size_t dirlen = strlen(ctx->perdir);
        /* Since we want to match against the (so called) full URL, we have
         * to re-add the PATH_INFO postfix
         */
        if (r->path_info && *r->path_info) {
            rewritelog((r, 3, ctx->perdir, "add path info postfix: %s -> %s%s",
                        ctx->uri, ctx->uri, r->path_info));
            ctx->uri = apr_pstrcat(r->pool, ctx->uri, r->path_info, NULL);
        }

        /* Additionally we strip the physical path from the url to match
         * it independent from the underlaying filesystem.
         */
        if (strlen(ctx->uri) >= dirlen &&
            !strncmp(ctx->uri, ctx->perdir, dirlen)) {

            rewritelog((r, 3, ctx->perdir, "strip per-dir prefix: %s -> %s",
                        ctx->uri, ctx->uri + dirlen));
            ctx->uri = ctx->uri + dirlen;
    /* Try to match the URI against the RewriteRule pattern
     * and exit immediately if it didn't apply.
    rewritelog((r, 3, ctx->perdir, "applying pattern '%s' to uri '%s'",
                p->pattern, ctx->uri));
    rc = !ap_regexec(p->regexp, ctx->uri, p->regexp->re_nsub+1, regmatch, 0);
    /* It matched, wow! Now it's time to prepare the context structure for
     * further processing
    ctx->briRC.source = NULL;
    if (p->flags & RULEFLAG_NOTMATCH) {
        ctx->briRR.source = NULL;
        ctx->briRR.source = apr_pstrdup(r->pool, ctx->uri);
        ctx->briRR.nsub   = p->regexp->re_nsub;
        memcpy(ctx->briRR.regmatch, regmatch, sizeof(regmatch));
    /* Ok, we already know the pattern has matched, but we now
     * additionally have to check for all existing preconditions
     * (RewriteCond) which have to be also true. We do this at
     * this very late stage to avoid unnessesary checks which
     * would slow down the rewriting engine.
    for (i = 0; i < rewriteconds->nelts; ++i) {
        rewritecond_entry *c = &conds[i];

            if (!rc) {
                /* One condition is false, but another can be still true. */
                /* skip the rest of the chained OR conditions */
                    c = &conds[++i];
        else if (!rc) {
            return 0;

        /* If some HTTP header was involved in the condition, remember it
         * for later use
         */
    /* expand the result */
    if (!(p->flags & RULEFLAG_NOSUB)) {
        newuri = do_expand(p->output, ctx);
        rewritelog((r, 2, ctx->perdir, "rewrite '%s' -> '%s'", ctx->uri,
                    newuri));
    }

    /* expand [E=var:val] and [CO=<cookie>] */
    do_expand_env(p->env, ctx);
    do_expand_cookie(p->cookie, ctx);

    /* non-substitution rules ('RewriteRule <pat> -') end here. */
    if (p->flags & RULEFLAG_NOSUB) {
            rewritelog((r, 2, ctx->perdir, "remember %s to have MIME-type '%s'",

    /* Now adjust API's knowledge about r->filename and r->args */
    r->filename = newuri;
    /* Add the previously stripped per-directory location prefix, unless
     * (1) it's an absolute URL path and
     * (2) it's a full qualified URL
    if (ctx->perdir && *r->filename != '/' && !is_absolute_uri(r->filename)) {
        rewritelog((r, 3, ctx->perdir, "add per-dir prefix: %s -> %s%s",
                    r->filename, ctx->perdir, r->filename));

        r->filename = apr_pstrcat(r->pool, ctx->perdir, r->filename, NULL);
    /* If this rule is forced for proxy throughput
     * (`RewriteRule ... ... [P]') then emulate mod_proxy's
     * URL-to-filename handler to be sure mod_proxy is triggered
     * for this URL later in the Apache API. But make sure it is
     * a fully-qualified URL. (If not it is qualified with
     * ourself).

        rewritelog((r, 2, ctx->perdir, "forcing proxy-throughput with %s",

    /* If this rule is explicitly forced for HTTP redirection
     * (`RewriteRule .. .. [R]') then force an external HTTP
     * redirect. But make sure it is a fully-qualified URL. (If
     * not it is qualified with ourself).

        rewritelog((r, 2, ctx->perdir, "explicitly forcing redirect with %s",
    /* Special Rewriting Feature: Self-Reduction
     * We reduce the URL by stripping a possible
     * http[s]://<ourhost>[:<port>] prefix, i.e. a prefix which
     * corresponds to ourself. This is to simplify rewrite maps
     * and to avoid recursion, etc. When this prefix is not a
     * coincidence then the user has to use [R] explicitly (see
     * above).
    /* If this rule is still implicitly forced for HTTP
     * redirection (`RewriteRule .. <scheme>://...') then
     * directly force an external HTTP redirect.
        rewritelog((r, 2, ctx->perdir, "implicitly forcing redirect (rc=%d) "
                    "with %s", p->forced_responsecode, r->filename));
    /* Finally remember the forced mime-type */
    if (p->forced_mimetype) {
        rewritelog((r, 2, ctx->perdir, "remember %s to have MIME-type '%s'",

        apr_table_setn(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR,
                       p->forced_mimetype);
    /* Puuhhhhhhhh... WHAT COMPLICATED STUFF ;_)
     * But now we're done for this particular rule.
static void recalc_factors(proxy_balancer *balancer,
                           proxy_runtime_worker *fixed)
{
    int i;
    double median, ffactor = 0.0;
    proxy_runtime_worker *workers;    


    /* Recalculate lbfactors */
    workers = (proxy_runtime_worker *)balancer->workers->elts;
    /* Special case if there is only one worker it's
     * load factor will always be 100
     */
    if (balancer->workers->nelts == 1) {
        workers->s->lbstatus = workers->s->lbfactor = 100.0;
        return;
    }
    for (i = 0; i < balancer->workers->nelts; i++) {
        if (workers[i].s->lbfactor > 100.0)
            workers[i].s->lbfactor = 100.0;
        ffactor += workers[i].s->lbfactor;
    }
    if (ffactor < 100.0) {
        median = (100.0 - ffactor) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (&(workers[i]) != fixed)
                workers[i].s->lbfactor += median;
        }
    }
    else if (fixed->s->lbfactor < 100.0) {
        median = (ffactor - 100.0) / (balancer->workers->nelts - 1);
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (workers[i].s->lbfactor > median &&
                &(workers[i]) != fixed)
                workers[i].s->lbfactor -= median;
        }
    } 
    else {
        median = (ffactor - 100.0) / balancer->workers->nelts;
        for (i = 0; i < balancer->workers->nelts; i++) {
            workers[i].s->lbfactor -= median;
        }
    } 
    for (i = 0; i < balancer->workers->nelts; i++) {
        /* Update the status entires */
        workers[i].s->lbstatus = workers[i].s->lbfactor;
    }
}

/* Invoke handler */
static int balancer_handler(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *conf = (proxy_server_conf *)
        ap_get_module_config(sconf, &proxy_module);
    apr_array_header_t *proxies = conf->proxies;
    struct proxy_remote *ents = (struct proxy_remote *)proxies->elts;
    proxy_balancer *balancer, *bsel = NULL;
    proxy_runtime_worker *worker, *wsel = NULL;
    apr_table_t *params = apr_table_make(r->pool, 10);
    int access_status;
    int i, n;
    const char *name;

    /* is this for us? */
    if (strcmp(r->handler, "balancer-manager"))
        return DECLINED;
    r->allowed = (AP_METHOD_BIT << M_GET);
    if (r->method_number != M_GET)
        return DECLINED;

    if (r->args) {
        char *args = apr_pstrdup(r->pool, r->args);
        char *tok, *val;
        while (args && *args) {
            if ((val = ap_strchr_c(args, '='))) {
                *val++ = '\0';
                if ((tok = ap_strchr_c(val, '&')))
                    *tok++ = '\0';
                if ((access_status = ap_unescape_url(val)) != OK)
                    return access_status;
                apr_table_setn(params, args, val);
                args = tok;
            }
            else
                return HTTP_BAD_REQUEST;
        }
    }
    if ((name = apr_table_get(params, "b")))
        bsel = ap_proxy_get_balancer(r->pool, conf,
            apr_pstrcat(r->pool, "balancer://", name, NULL));
    if ((name = apr_table_get(params, "w"))) {
        const char *sc = apr_table_get(params, "s");
        char *asname = NULL;
        proxy_worker *ws = NULL;
        if (sc) {
            asname = apr_pstrcat(r->pool, sc, "://", name, NULL);
            ws = ap_proxy_get_worker(r->pool, conf, asname);
        }
        if (ws) {
            worker = (proxy_runtime_worker *)bsel->workers->elts;
            for (n = 0; n < bsel->workers->nelts; n++) {
                if (strcasecmp(worker->w->name, ws->name) == 0) {
                    wsel = worker;
                    break;
                }
                ++worker;
            }
        }
    }
    /* First set the params */
    if (bsel) {
        const char *val;
        if ((val = apr_table_get(params, "ss"))) {
            if (strlen(val))
                bsel->sticky = apr_pstrdup(conf->pool, val);
            else
                bsel->sticky = NULL;
        }
        if ((val = apr_table_get(params, "tm"))) {
            int ival = atoi(val);
            if (ival >= 0)
                bsel->timeout = apr_time_from_sec(ival);
        }
    }
    if (wsel) {
        const char *val;
        if ((val = apr_table_get(params, "lf"))) {
            char *ep;
            double dval = strtod(val, &ep);
            if (dval > 1) {
                wsel->s->lbfactor = dval;
                if (bsel)
                    recalc_factors(bsel, wsel);
            }
        }
        if ((val = apr_table_get(params, "wr"))) {
            if (strlen(val))
                wsel->w->route = apr_pstrdup(conf->pool, val);
            else
                wsel->w->route = NULL;
        }
        if ((val = apr_table_get(params, "rr"))) {
            if (strlen(val))
                wsel->w->redirect = apr_pstrdup(conf->pool, val);
            else
                wsel->w->redirect = NULL;
        }
        if ((val = apr_table_get(params, "dw")))
            wsel->w->status |= PROXY_WORKER_DISABLED;
        else
            wsel->w->status &= ~PROXY_WORKER_DISABLED;

    }
    if (apr_table_get(params, "xml")) {
        ap_set_content_type(r, "text/xml");
        ap_rputs("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n", r);
        ap_rputs("<httpd:manager xmlns:httpd=\"http://httpd.apache.org\">\n", r);
        ap_rputs("  <httpd:balancers>\n", r);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("    <httpd:balancer>\n", r);
            ap_rvputs(r, "      <httpd:name>", balancer->name, "</httpd:name>\n", NULL);
            ap_rputs("      <httpd:workers>\n", r);
            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {
                ap_rputs("        <httpd:worker>\n", r);
                ap_rvputs(r, "          <httpd:scheme>", worker->w->scheme,
                          "</httpd:scheme>\n", NULL);                
                ap_rvputs(r, "          <httpd:hostname>", worker->w->hostname,
                          "</httpd:hostname>\n", NULL);                
               ap_rprintf(r, "          <httpd:loadfactor>%.2f</httpd:loadfactor>\n",
                          worker->s->lbfactor);
                ap_rputs("        </httpd:worker>\n", r);
                ++worker;
            }
            ap_rputs("      </httpd:workers>\n", r);
            ap_rputs("    </httpd:balancer>\n", r);
            ++balancer;
        }
        ap_rputs("  </httpd:balancers>\n", r);
        ap_rputs("</httpd:manager>", r);         
    }
    else {
        ap_set_content_type(r, "text/html");
        ap_rputs(DOCTYPE_HTML_3_2
                 "<html><head><title>Balancer Manager</title></head>\n", r);
        ap_rputs("<body><h1>Load Balancer Manager for ", r);
        ap_rvputs(r, ap_get_server_name(r), "</h1>\n\n", NULL);
        ap_rvputs(r, "<dl><dt>Server Version: ",
                  ap_get_server_version(), "</dt>\n", NULL);
        ap_rvputs(r, "<dt>Server Built: ",
                  ap_get_server_built(), "\n</dt></dl>\n", NULL);
        balancer = (proxy_balancer *)conf->balancers->elts;
        for (i = 0; i < conf->balancers->nelts; i++) {
            ap_rputs("<hr />\n<h3>LoadBalancer Status for ", r);
            ap_rvputs(r, "<a href=\"", r->uri, "?b=",
                      balancer->name + sizeof("balancer://") - 1,
                      "\">", NULL); 
            ap_rvputs(r, balancer->name, "</a></h3>\n\n", NULL);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>StickySesion</th><th>Timeout</th>"
                "</tr>\n<tr>", r);                
            ap_rvputs(r, "<td>", balancer->sticky, NULL);
            ap_rprintf(r, "</td><td>%" APR_TIME_T_FMT "</td>\n",
                apr_time_sec(balancer->timeout));
            ap_rputs("</table>\n", r);
            ap_rputs("\n\n<table border=\"0\"><tr>"
                "<th>Scheme</th><th>Host</th>"
                "<th>Route</th><th>RouteRedir</th>"
                "<th>Factor</th><th>Status</th>"
                "</tr>\n", r);

            worker = (proxy_runtime_worker *)balancer->workers->elts;
            for (n = 0; n < balancer->workers->nelts; n++) {

                ap_rvputs(r, "<tr>\n<td>", worker->w->scheme, "</td><td>", NULL);
                ap_rvputs(r, "<a href=\"", r->uri, "?b=", 
                          balancer->name + sizeof("balancer://") - 1,
                          "&s=", worker->w->scheme, "&w=", worker->w->hostname,
                          "\">", NULL); 
                ap_rvputs(r, worker->w->hostname, "</a></td>", NULL);
                ap_rvputs(r, "<td>", worker->w->route, NULL);
                ap_rvputs(r, "</td><td>", worker->w->redirect, NULL);
                ap_rprintf(r, "</td><td>%.2f</td><td>", worker->s->lbfactor);
                if (worker->w->status & PROXY_WORKER_DISABLED)
                    ap_rputs("Dis", r);
                else if (worker->w->status & PROXY_WORKER_IN_ERROR)
                    ap_rputs("Err", r);
                else if (worker->w->status & PROXY_WORKER_INITIALIZED)
                    ap_rputs("Ok", r);
                else
                    ap_rputs("-", r);
                ap_rputs("</td></tr>\n", r);

                ++worker;
            }
            ap_rputs("</table>\n", r);
            ++balancer;
        }
        ap_rputs("<hr />\n", r);
        if (wsel && bsel) {
            ap_rputs("<h3>Edit worker settings for ", r);
            ap_rvputs(r, wsel->w->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>Load factor:</td><td><input name=\"lf\" type=text ", r);
            ap_rprintf(r, "value=\"%.2f\"></td><tr>\n", wsel->s->lbfactor);            
            ap_rputs("<tr><td>Route:</td><td><input name=\"wr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->route, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Route Redirect:</td><td><input name=\"rr\" type=text ", r);
            ap_rvputs(r, "value=\"", wsel->w->redirect, NULL); 
            ap_rputs("\"></td><tr>\n", r);            
            ap_rputs("<tr><td>Disabled:</td><td><input name=\"dw\" type=checkbox", r);
            if (wsel->w->status & PROXY_WORKER_DISABLED)
                ap_rputs(" checked", r);
            ap_rputs("></td><tr>\n", r);            
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"s\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->scheme, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"w\" ", NULL);
            ap_rvputs(r, "value=\"", wsel->w->hostname, "\">\n", NULL);
            ap_rvputs(r, "<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        else if (bsel) {
            ap_rputs("<h3>Edit balancer settings for ", r);
            ap_rvputs(r, bsel->name, "</h3>\n", NULL);
            ap_rvputs(r, "<form method=\"GET\" action=\"", NULL);
            ap_rvputs(r, r->uri, "\">\n<dl>", NULL); 
            ap_rputs("<table><tr><td>StickySession Identifier:</td><td><input name=\"ss\" type=text ", r);
            if (bsel->sticky)
                ap_rvputs(r, "value=\"", bsel->sticky, "\"", NULL);
            ap_rputs("></td><tr>\n<tr><td>Timeout:</td><td><input name=\"tm\" type=text ", r);
            ap_rprintf(r, "value=\"%" APR_TIME_T_FMT "\"></td></tr>\n",
                       apr_time_sec(bsel->timeout));
            ap_rputs("<tr><td colspan=2><input type=submit value=\"Submit\"></td></tr>\n", r);
            ap_rvputs(r, "</table>\n<input type=hidden name=\"b\" ", NULL);
            ap_rvputs(r, "value=\"", bsel->name + sizeof("balancer://") - 1,
                      "\">\n</form>\n", NULL);
            ap_rputs("<hr />\n", r);
        }
        ap_rputs(ap_psignature("",r), r);
        ap_rputs("</body></html>\n", r);
    }
    return OK;
}

    /* manager handler */
    ap_hook_handler(balancer_handler, NULL, NULL, APR_HOOK_FIRST);
                (!(verify_old & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) &&
                  (verify     & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)))
    imap_conf_rec *new = (imap_conf_rec *) apr_palloc(p, sizeof(imap_conf_rec));
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted") && *comment) {
    else if (!strcasecmp(menu, "unformatted") && *comment) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    else if (!strcasecmp(menu, "semiformatted")) {
    else if (!strcasecmp(menu, "unformatted")) {
    /** Did we use HTTP Keep-Alive? */
    unsigned keptalive:1;
    /** How many times have we used it? */
    int keepalives;
	    || (r->server->keep_alive_max > r->connection->keepalives))
        int left = r->server->keep_alive_max - r->connection->keepalives;
        r->connection->keepalives++;
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;

#if 0
    conn_rec *conn = r->connection;
#endif
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
	    /* this is a hack to make sure that request time is set,
	     * it's not perfect, but it's better than nothing 
	     */
	    r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */

    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk

#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */

    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);

#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week 
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method); 
#endif
    uri = ap_getword_white(r->pool, &ll);

    /* Provide quick information about the request method as soon as known */

    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }

    ap_parse_uri(r, uri);

    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }

    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
 	r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))	/* don't allow HTTP/0.1000 */
	r->proto_num = HTTP_VERSION(major, minor);
    else
	r->proto_num = HTTP_VERSION(1,0);

    return 1;
}

    conn->keptalive    = conn->keepalive == 1;
    conn->keepalive    = 0;

    ap_run_create_request(r);
    r->the_request     = NULL;
    apr_setsocketopt(conn->client_socket, APR_SO_TIMEOUT, 
                     (int)(conn->keptalive
                     ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                     : r->server->timeout * APR_USEC_PER_SEC));
                     
    /* Get the request... */
    if (!read_request_line(r)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
			  "request failed: URI too long");
            ap_send_error_response(r, 0);
            ap_run_log_transaction(r);
            return r;
        }
        return NULL;
    }
    if (r->connection->keptalive) {
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(r->server->timeout * APR_USEC_PER_SEC));
    }
    conn->keptalive = 0;        /* We now have a request to play with */

        apr_socket_opt_set(csd, APR_INCOMPLETE_READ, 1);
        && (rv = apr_socket_opt_set(sock, APR_SO_RCVBUF,
                                    conf->recv_buffer_size))) {
                      "apr_socket_opt_set(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
    if ((rv = apr_socket_opt_set(sock, APR_SO_REUSEADDR, one)) 
            != APR_SUCCESS) {
                      "proxy: FTP: error setting reuseaddr option: apr_socket_opt_set(SO_REUSEADDR)");
                if (conf->recv_buffer_size > 0 
                        && (rv = apr_socket_opt_set(data_sock, APR_SO_RCVBUF,
                                                    conf->recv_buffer_size))) {
                                  "proxy: FTP: apr_socket_opt_set(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
                if (conf->recv_buffer_size > 0 
                        && (rv = apr_socket_opt_set(data_sock, APR_SO_RCVBUF,
                                                    conf->recv_buffer_size))) {
                                  "proxy: FTP: apr_socket_opt_set(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
        if ((rv = apr_socket_opt_set(local_sock, APR_SO_REUSEADDR, one)) 
                != APR_SUCCESS) {
            (rv = apr_socket_opt_set(*newsock, APR_SO_RCVBUF,
                                     conf->recv_buffer_size))) {
                         "apr_socket_opt_set(SO_RCVBUF): Failed to set "
    apr_socket_opt_set(csd, APR_INCOMPLETE_READ, 1);
    stat = apr_socket_opt_set(s, APR_SO_REUSEADDR, one);
                      "make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEADDR)",
    stat = apr_socket_opt_set(s, APR_SO_KEEPALIVE, one);
                      "make_sock: for address %pI, apr_socket_opt_set: (SO_KEEPALIVE)",
        stat = apr_socket_opt_set(s, APR_SO_SNDBUF,  send_buffer_size);
    stat = apr_socket_opt_set(s, APR_SO_REUSEADDR, one);
                    "make_sock: for address %pI, apr_socket_opt_set: (SO_REUSEADDR)", 
        apr_socket_opt_set(lr->sd, APR_SO_NONBLOCK, 1);
                apr_socket_opt_set(csd, APR_SO_NONBLOCK, 0);
        apr_socket_opt_set(lr->sd, APR_SO_NONBLOCK, 1);
            apr_socket_opt_get(context->sock, APR_SO_DISCONNECTED, 
                               &disconnected);
    apr_status_t status = apr_socket_opt_set(s, APR_TCP_NODELAY, 1);
                     "apr_socket_opt_set: (TCP_NODELAY)");
	    apr_socket_timeout_set(c->aprsock, 0);
    if ((rv = apr_socket_opt_set(c->aprsock, APR_SO_NONBLOCK, 1))
	printf("This is ApacheBench, Version %s\n", AP_AB_BASEREVISION " <$Revision: 1.111 $> apache-2.0");
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-2.0<br>\n", AP_AB_BASEREVISION, "$Revision: 1.111 $");
	    /* RFC2616 tells us to forward this.
	     *
	     * OTOH, an interim response here may mean the backend
	     * is playing sillybuggers.  The Client didn't ask for
	     * it within the defined HTTP/1.1 mechanisms, and if
	     * it's an extension, it may also be unsupported by us.
	     *
	     * There's also the possibility that changing existing
	     * behaviour here might break something.
	     *
	     * So let's make it configurable.
	     */
            const char *policy = apr_table_get(r->subprocess_env,
			                       "proxy-interim-response");
	    if (!policy || !strcasecmp(policy, "RFC")) {
                ap_send_interim_response(r);
	    }
	    /* FIXME: refine this to be able to specify per-response-status
	     * policies and maybe also add option to bail out with 502
	     */
	    else if (strcasecmp(policy, "Suppress")) {
                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,
                             "undefined proxy interim response policy");
	    }
            /* We had a failure: Close connection to backend */
            conn->close++;
module AP_MODULE_DECLARE_DATA imagemap_module;
    icr = ap_get_module_config(r->per_dir_config, &imagemap_module);
module AP_MODULE_DECLARE_DATA imagemap_module =
    if (strcmp(r->unparsed_uri, "*") == 0) {
        /* Don't apply rewrite rules to "*". */
        return DECLINED;
    }

    /* Check that the URI is valid. */
    if (!r->uri || r->uri[0] != '/') {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "Invalid URI in request %s", r->the_request);
        return HTTP_BAD_REQUEST;
    }
    
    if (strcmp(r->unparsed_uri, "*") == 0) {
        /* "*" cannot be proxied. */
        return DECLINED;
    }

    /* Check that the URI is valid. */
    if (!r->uri || r->uri[0] != '/') {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                     "Invalid URI in request %s", r->the_request);
        return HTTP_BAD_REQUEST;
    }

/* if a request with a body creates a subrequest, clone the original request's
 * input headers minus any headers pertaining to the body which has already
 * been read.  out-of-line helper function for ap_set_sub_req_protocol.
 */

static void clone_headers_no_body(request_rec *rnew,
                                  const request_rec *r)
{
    rnew->headers_in = apr_table_copy(rnew->pool, r->headers_in);
    apr_table_unset(rnew->headers_in, "Content-Length");
    apr_table_unset(rnew->headers_in, "Transfer-Encoding");
    apr_table_unset(rnew->headers_in, "Content-Type");
    apr_table_unset(rnew->headers_in, "Content-Encoding");
}        

    /* did the original request have a body?  (e.g. POST w/SSI tags)
     * if so, make sure the subrequest doesn't inherit body headers
     */
    if (r->read_length) {
        clone_headers_no_body(rnew, r);
    } else {
        /* no body (common case).  clone headers the cheap way */
        rnew->headers_in      = r->headers_in;
    }
 * 20150222.3 (2.5.0-dev)  Add ap_some_authn_required, ap_force_authn hook.
 *                         Deprecate broken ap_some_auth_required.
#define MODULE_MAGIC_NUMBER_MINOR 3                 /* 0...n */
 * @bug Behavior changed in 2.4.x refactoring, API no longer usable
 * @deprecated @see ap_some_authn_required()
 *
/**
 * This hook allows a module to force authn to be required when
 * processing a request.
 * This hook should be registered with ap_hook_force_authn().
 * @param r The current request
 * @return OK (force authn), DECLINED (let later modules decide)
 * @ingroup hooks
 */
AP_DECLARE_HOOK(int,force_authn,(request_rec *r))

/**
 * Can be used within any handler to determine if any authentication
 * is required for the current request.  Note that if used with an
 * access_checker hook, an access_checker_ex hook or an authz provider; the
 * caller should take steps to avoid a loop since this function is
 * implemented by calling these hooks.
 * @param r The current request
 * @return TRUE if authentication is required, FALSE otherwise
 */
AP_DECLARE(int) ap_some_authn_required(request_rec *r);

    APR_HOOK_LINK(force_authn)
AP_IMPLEMENT_HOOK_RUN_FIRST(int,force_authn,
                            (request_rec *r), (r), DECLINED)
AP_DECLARE(int) ap_some_authn_required(request_rec *r)
{
    int access_status;

    switch (ap_satisfies(r)) {
    case SATISFY_ALL:
    case SATISFY_NOSPEC:
        if ((access_status = ap_run_access_checker(r)) != OK) {
            break;
        }

        access_status = ap_run_access_checker_ex(r);
        if (access_status == DECLINED) {
            return TRUE;
        }

        break;
    case SATISFY_ANY:
        if ((access_status = ap_run_access_checker(r)) == OK) {
            break;
        }

        access_status = ap_run_access_checker_ex(r);
        if (access_status == DECLINED) {
            return TRUE;
        }

        break;
    }

    return FALSE;
}

            if (access_status == DECLINED
                || (access_status == OK && ap_run_force_authn(r) == OK)) {
            else if (access_status == OK) {
                ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,
                              "request authorized without authentication by "
                              "access_checker_ex hook: %s", r->uri);
            }
            else {
                return decl_die(access_status, "check access", r);
            }
            if (access_status == DECLINED
                || (access_status == OK && ap_run_force_authn(r) == OK)) {
            else if (access_status == OK) {
                ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,
                              "request authorized without authentication by "
                              "access_checker_ex hook: %s", r->uri);
            }
            else {
                return decl_die(access_status, "check access", r);
            }
                                   proxy_conn_rec *conn, 
                                   conn_rec *origin, 
    status = ajp_send_header(conn->sock, r);
        conn->close++;
                     conn->worker->cp->addr,
                     conn->worker->hostname);
            status = ajp_send_data_msg(conn->sock, r, msg, bufsiz);
                             conn->worker->cp->addr,
                             conn->worker->hostname);
    status = ajp_read_header(conn->sock, r,
                             (ajp_msg_t **)&(conn->data));
                     conn->worker->cp->addr,
                     conn->worker->hostname);
    result = ajp_parse_type(r, conn->data);
                     conn->worker->cp->addr,
                     conn->worker->hostname);
    type = ajp_parse_type(r, backend->data);
            status = ajp_parse_header(r, backend->data); 
        } 
        else if  (type == CMD_AJP13_SEND_BODY_CHUNK) {
            status = ajp_parse_data(r, backend->data, &size, &buff);
        } 
        else {
        status = ajp_read_header(backend->sock, r,
                                 (ajp_msg_t **)&(backend->data));
        type = ajp_parse_type(r, backend->data);
                      "server %s:%d",
                      backend->worker->cp->addr,
                      backend->worker->hostname);
int ap_proxy_ajp_handler(request_rec *r, proxy_worker *worker,
                         proxy_server_conf *conf,
                         char *url, const char *proxyname, 
                         apr_port_t proxyport)
    const char *scheme = "ajp";

        status = ap_proxy_acquire_connection(scheme, &backend, worker, r->server);
        if (status != OK) {
            if (backend) {
                backend->close_on_recycle = 1;
                ap_proxy_release_connection(scheme, backend, r->server);
            }
            return status;
        }
    backend->is_ssl = 0;
    backend->close_on_recycle = 0;
    status = ap_proxy_determine_connection(p, r, conf, worker, backend, c->pool,
                                           uri, &url, proxyname, proxyport,
                                           server_portstr,
                                           sizeof(server_portstr));

    if (status != OK)
        goto cleanup;
    status = ap_proxy_connect_backend(scheme, backend, worker, r->server);
    if (status != OK)
        goto cleanup;

    /* Step Three: Create conn_rec */
    if (!backend->connection) {
        status = ap_proxy_connection_create(scheme, backend, c, r->server);
        if (status != OK)
            goto cleanup;
   
    /* Step Four: Send the Request */
    status = ap_proxy_ajp_request(p, r, backend, origin, conf, uri, url,
                                  server_portstr);
    if (status != OK)
        goto cleanup;

    /* Step Five: Receive the Response */
    status = ap_proxy_ajp_process_response(p, r, origin, backend,
cleanup:
    /* Clear the module config */
    ap_set_module_config(c->conn_config, &proxy_ajp_module, NULL);
    /* Do not close the socket */
    ap_proxy_release_connection(scheme, backend, r->server);
    return status;
 * 20091119.0 (2.3.4-dev)  dav_error interface uses apr_status_t parm, not errno
    err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, errcode, status, errstr);
                                 DAV_ERR_PROP_BAD_MAJOR, 0,
                                 DAV_ERR_PROP_BAD_MAJOR, 0,
                             HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN, 0,
                             DAV_ERR_LOCK_NO_DB, 0,
                             HTTP_INTERNAL_SERVER_ERROR, 0, 0,
                                 DAV_ERR_LOCK_CORRUPT_DB, 0,
                         DAV_ERR_LOCK_CORRUPT_DB, 0,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
    if ((rv = apr_file_read(file, pbuf->buf, &amt)) != APR_SUCCESS
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
    apr_status_t rv;
        if ((rv = apr_file_remove(pathname, p)) != APR_SUCCESS) {
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
    if ((rv = apr_file_open(&file, pathname,
                            APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BINARY,
                            APR_OS_DEFAULT, p)) != APR_SUCCESS) {
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
    if ((rv = apr_file_write(file, pbuf->buf, &amt)) != APR_SUCCESS
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
                             HTTP_INTERNAL_SERVER_ERROR, 0, 0,
            return dav_new_error(ctx->pool, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
            if ((status = apr_file_perms_set(dst, perms)) != APR_SUCCESS) {
                return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
    if ((status = apr_file_open(&inf, src, APR_READ | APR_BINARY, 
                                APR_OS_DEFAULT, p)) != APR_SUCCESS) {
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
        return dav_new_error(p, MAP_IO2HTTP(status), 0, status,
            apr_status_t lcl_status;

            if ((lcl_status = apr_file_remove(dst, p)) != APR_SUCCESS) {
                return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, 
                                     lcl_status,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
            apr_status_t lcl_status;

            if ((lcl_status = apr_file_remove(dst, p)) != APR_SUCCESS) {
                                     lcl_status,
            return dav_new_error(p, MAP_IO2HTTP(status), 0, status,
        apr_status_t lcl_status;
            err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
        else if ((lcl_status = apr_file_remove(dst, p)) != APR_SUCCESS) {
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, lcl_status,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
                return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, 0,
        return dav_new_error(p, MAP_IO2HTTP(rv), 0, rv,
            if ((rv = apr_file_remove(stream->pathname, stream->p))
                != APR_SUCCESS) {
                                     rv,
            return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
        return dav_new_error(stream->p, HTTP_INSUFFICIENT_STORAGE, 0, status,
        return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
    apr_status_t status;

    if ((status = apr_file_seek(stream->f, APR_SET, &abs_pos))
        != APR_SUCCESS) {
        return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
        return dav_new_error(pool, HTTP_CONFLICT, 0, 0,
        return dav_new_error(pool, HTTP_CONFLICT, 0, 0,
        return dav_new_error(pool, HTTP_FORBIDDEN, 0, status,
        return dav_new_error(pool, HTTP_FORBIDDEN, 0, status,
        return dav_new_error(ctx->pool, HTTP_INSUFFICIENT_STORAGE, 0, status,
        return dav_new_error(ctx->pool, HTTP_CONFLICT, 0, status,
        return dav_new_error(ctx->pool, HTTP_FORBIDDEN, 0, status,
    apr_status_t status;
            if ((status = apr_dir_make(dstinfo->pathname, APR_OS_DEFAULT,
                                       ctx->pool)) != APR_SUCCESS) {
                err = dav_new_error(ctx->pool, HTTP_FORBIDDEN, 0, status, NULL);
            return dav_new_error(src->info->pool, HTTP_MULTI_STATUS, 0, 0,
        return dav_new_error(src->info->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        return dav_new_error(src->info->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        return dav_new_error(srcinfo->pool, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
    apr_status_t status;
            return dav_new_error(info->pool, HTTP_MULTI_STATUS, 0, 0,
    if ((status = apr_file_remove(info->pathname, info->pool)) != APR_SUCCESS) {
        return dav_new_error(info->pool, HTTP_FORBIDDEN, 0, status, NULL);
    apr_status_t status;
    if ((status = apr_dir_open(&dirp, fsctx->path1.buf, pool)) != APR_SUCCESS) {
        return dav_new_error(pool, HTTP_NOT_FOUND, 0, status, NULL);
            err = dav_new_error(pool, HTTP_NOT_FOUND, 0, status, NULL);
        return dav_new_error(params->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,
            return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,
        return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,
    return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,
    apr_status_t status;
    if ((status = apr_file_perms_set(resource->info->pathname, perms))
        != APR_SUCCESS) {
                             HTTP_INTERNAL_SERVER_ERROR, 0, status,
    apr_status_t status;
    if ((status = apr_file_perms_set(resource->info->pathname, perms))
        != APR_SUCCESS) {
                             HTTP_INTERNAL_SERVER_ERROR, 0, status,
    err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, errcode, status, errstr);
                             HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN, 0,
                             DAV_ERR_LOCK_NO_DB, 0,
                             HTTP_INTERNAL_SERVER_ERROR, 0, 0,
                                 DAV_ERR_LOCK_CORRUPT_DB, 0,
                         DAV_ERR_LOCK_CORRUPT_DB, 0,
                             HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        ap_log_rerror(APLOG_MARK, level, errscan->aprerr, r, "%s  [%d, #%d]",
                      errscan->desc, errscan->status, errscan->error_id);
        return dav_new_error(r->pool, HTTP_NOT_FOUND, 0, 0,
                err = dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0, rc,
                    err = dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, rc,
                    return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, 0,
                    err = dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, 0,
                            return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, 0,
                    err424_set = dav_new_error(p, HTTP_FAILED_DEPENDENCY, 0, 0,
                    err424_delete = dav_new_error(p, HTTP_FAILED_DEPENDENCY, 0, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
        err = dav_new_error(ctx->w.pool, HTTP_CONFLICT, 0, 0,
        err = dav_new_error(ctx->w.pool, HTTP_CONFLICT, 0, 0,
            err = dav_new_error(r->pool, multi_status->status, 0, 0,
                                multi_status->desc);
            err = dav_new_error(r->pool, HTTP_MULTI_STATUS, 0, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
      err = dav_new_error(r->pool, HTTP_FORBIDDEN, 0, 0,
    apr_status_t aprerr;        /* APR error if any, or 0/APR_SUCCESS */
                                      int error_id, apr_status_t aprerr,
                                      const char *desc);
** namespace may be NULL, which means "DAV:".
                                          int error_id, apr_status_t aprerr,
                                          const char *desc,
        return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
                                     0,
                                 DAV_ERR_PROP_READONLY, 0,
                                 DAV_ERR_PROP_NO_DATABASE, 0,
DAV_DECLARE(dav_error*) dav_new_error(apr_pool_t *p, int status, int error_id,
                                      apr_status_t aprerr, const char *desc)
    err->aprerr = aprerr;
                                          int error_id, apr_status_t aprerr,
                                          const char *desc,
    dav_error *err = dav_new_error(p, status, error_id, aprerr, desc);
    apr_status_t rv;
                                     DAV_ERR_IF_TAGGED, 0,
            if ((rv = apr_uri_parse(r->pool, uri, &parsed_uri)) != APR_SUCCESS) {
                                     DAV_ERR_IF_TAGGED, rv,
                                     DAV_ERR_IF_UNCLOSED_PAREN, 0,
                                     DAV_ERR_IF_PARSE, 0,
                                             DAV_ERR_IF_PARSE, 0, NULL);
                                             DAV_ERR_IF_PARSE, 0, NULL);
                                                 DAV_ERR_IF_MULTIPLE_NOT, 0,
                                         DAV_ERR_IF_UNK_CHAR, 0,
                                 DAV_ERR_IF_UNK_CHAR, 0,
            return dav_new_error(p, HTTP_LOCKED, 0, 0,
                return dav_new_error(p, HTTP_LOCKED, 0, 0,
        return dav_new_error(p, HTTP_LOCKED, 0, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
                        return dav_new_error(p, HTTP_FORBIDDEN, 0, 0, errmsg);
            return dav_new_error(p, HTTP_LOCKED, 0 /* error_id */, 0,
            return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
            return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,
        return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
    return dav_new_error(p, HTTP_LOCKED, 1 /* error_id */, 0,
        return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
        return dav_new_error(r->pool, result, 0, 0, NULL);
            err = dav_new_error(r->pool, HTTP_FORBIDDEN, 0, 0,
            return dav_new_error(r->pool, HTTP_FAILED_DEPENDENCY, 0, 0,
        return dav_new_error(r->pool, HTTP_MULTI_STATUS, 0, 0,
        return dav_new_error(r->pool, HTTP_BAD_REQUEST, DAV_ERR_IF_ABSENT, 0,
                return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
                err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
        return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,
            return dav_new_error(r->pool, HTTP_MULTI_STATUS, 0, 0,
            return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,
    return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
            return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0, 0,
    if (apr_table_get(r->subprocess_env, "force-proxy-request-1.0")) {
        p_conn->close++;
    int interim_response; /* non-zero whilst interim 1xx responses
                           * are being read. */
    do {
        interim_response = ap_is_HTTP_INFO(r->status);
        if (interim_response) {
                         "proxy: HTTP: received interim %d response",
                         r->status);
            !interim_response &&                   /* not any 1xx response */
    } while (interim_response);
            if ((status != HTTP_NO_CONTENT) && /* not 204 */
    "            ['indexOf', 'slice', 'split', 'substr', 'toUpperCase',\n"
    "             'replace']);\n"
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, url1);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, url2);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, url1);
      main_test_rfh(), -1, GURL(kUnreachableWebDataURL));
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, url1);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, url2);
  bool is_main_frame = render_frame_host->frame_tree_node()->IsMainFrame();
        render_frame_host, parent_routing_id,
        render_frame_host, url, error_code,
    // TODO(creis): Until we mirror the frame tree in the subframe's process,
    // cross-process subframe navigations happen in a renderer's main frame.
    // Correct the transition type here if we know it is for a subframe.
    if (!render_frame_host->frame_tree_node()->IsMainFrame() &&
        pending_entry &&
        pending_entry->frame_tree_node_id() ==
            render_frame_host->frame_tree_node()->frame_tree_node_id()) {
    FrameTreeNode* frame = render_frame_host->frame_tree_node();
      this, parent_routing_id, url);
      this, validated_url, error_code, error_description);
  FrameTreeNode* node = frame_tree_.root();

  // If we are using --site-per-process, we should navigate in the FrameTreeNode
  // specified in the pending entry.
  NavigationEntryImpl* pending_entry =
      NavigationEntryImpl::FromNavigationEntry(controller_.GetPendingEntry());
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSitePerProcess) &&
      pending_entry->frame_tree_node_id() != -1) {
    node = frame_tree_.FindByID(pending_entry->frame_tree_node_id());
  }

  return node->navigator()->NavigateToPendingEntry(
      node->current_frame_host(), reload_type);
  bool is_main_frame = render_frame_host->frame_tree_node()->IsMainFrame();
  bool is_main_frame = render_frame_host->frame_tree_node()->IsMainFrame();
                             is_main_frame,
  bool is_main_frame = render_frame_host->frame_tree_node()->IsMainFrame();
                                error_description, render_view_host));
    const GURL& url) {
  RenderFrameHostImpl* rfh =
      static_cast<RenderFrameHostImpl*>(render_frame_message_source_);
  bool is_main_frame = rfh->frame_tree_node()->IsMainFrame();
  void OnDidFinishLoad(const GURL& url);
  contents()->TestDidFinishLoad(url_from_ipc);
      url_from_ipc, 1, base::string16());
IPC_MESSAGE_ROUTED2(FrameHostMsg_DidStartProvisionalLoadForFrame,
IPC_MESSAGE_ROUTED3(FrameHostMsg_DidFailLoadWithError,
IPC_MESSAGE_ROUTED1(FrameHostMsg_DidFinishLoad,
                    GURL /* validated_url */)
       routing_id_, parent_routing_id, ds->request().url()));
                                      ds->request().url()));
  OnDidStartProvisionalLoadForFrame(-1, url_copy);
  OnDidStartProvisionalLoadForFrame(-1, url);
void TestWebContents::TestDidFinishLoad(const GURL& url) {
  FrameHostMsg_DidFinishLoad msg(0, url);
      0, url, error_code, error_description);
  void TestDidFinishLoad(const GURL& url);
      extension_dispatcher_(extension_dispatcher),
      did_create_current_document_element_(false) {
  did_create_current_document_element_ = true;
void ExtensionFrameHelper::DidCreateNewDocument() {
  did_create_current_document_element_ = false;
}

  bool did_create_current_document_element() const {
    return did_create_current_document_element_;
  }
  void DidCreateNewDocument() override;
  // Whether or not the current document element has been created.
  bool did_create_current_document_element_;

#include "base/bind.h"
#include "base/message_loop/message_loop.h"
#include "extensions/renderer/extension_frame_helper.h"
        callback_(context->isolate(), cb) {
    if (ExtensionFrameHelper::Get(frame)->
            did_create_current_document_element()) {
      // If the document element is already created, then we can call the
      // callback immediately (though post it to the message loop so as to not
      // call it re-entrantly).
      // The Unretained is safe because this class manages its own lifetime.
      base::MessageLoop::current()->PostTask(
          FROM_HERE,
          base::Bind(&LoadWatcher::CallbackAndDie, base::Unretained(this),
                     true));
    }
  }
    , m_currentSpeechUtterance(nullptr)
    return m_currentSpeechUtterance;
void SpeechSynthesis::startSpeakingImmediately(SpeechSynthesisUtterance* utterance)
    ASSERT(!m_currentSpeechUtterance);
    m_currentSpeechUtterance = utterance;
    // If the queue was empty, speak this immediately and add it to the queue.
        startSpeakingImmediately(utterance);
    // Remove all the items from the utterance queue.
    // Hold on to the current utterance so the platform synthesizer can have a chance to clean up.
    RefPtrWillBeMember<SpeechSynthesisUtterance> current = m_currentSpeechUtterance;
    current = nullptr;

    // The platform should have called back immediately and cleared the current utterance.
    ASSERT(!m_currentSpeechUtterance);
    if (!m_currentSpeechUtterance)
    ASSERT(m_currentSpeechUtterance);
    m_currentSpeechUtterance = nullptr;
    if (m_utteranceQueue.size()) {
        RefPtrWillBeMember<SpeechSynthesisUtterance> firstUtterance = m_utteranceQueue.first();
        ASSERT(firstUtterance == utterance);
        if (firstUtterance == utterance)
            m_utteranceQueue.removeFirst();

        // Start the next job if there is one pending.
        if (!m_utteranceQueue.isEmpty())
            startSpeakingImmediately(m_utteranceQueue.first().get());
    }
    visitor->trace(m_currentSpeechUtterance);
    void startSpeakingImmediately(SpeechSynthesisUtterance*);
    RawPtrWillBeMember<SpeechSynthesisUtterance> m_currentSpeechUtterance;
    client()->speakingErrorOccurred(m_utterance);
    m_utterance = nullptr;
  SharedMemoryCreateOptions() : name_deprecated(NULL), size(0),
                                open_existing_deprecated(false),
  // DEPRECATED (crbug.com/345734):
  const std::string* name_deprecated;
  // DEPRECATED (crbug.com/345734):
  // shared memory must not exist.  This flag is meaningless unless
  // name_deprecated is non-NULL.
  bool open_existing_deprecated;
  // DEPRECATED (crbug.com/345734):
  bool CreateNamedDeprecated(
      const std::string& name, bool open_existing, size_t size) {
    options.name_deprecated = &name;
    options.open_existing_deprecated = open_existing;
      options.name_deprecated == NULL ? "" : options.name_deprecated->c_str(),
  if (options.name_deprecated == NULL || options.name_deprecated->empty()) {
    DCHECK(!options.open_existing_deprecated);
    if (!FilePathForMemoryName(*options.name_deprecated, &path))
    if (fd == -1 && options.open_existing_deprecated) {
    bool rv = memory.CreateNamedDeprecated(s_test_name_, true, kDataSize);
      EXPECT_TRUE(memory1.CreateNamedDeprecated(
          "SharedMemoryMultipleLockThreadTest", true, kDataSize));
// CreateNamedDeprecated(openExisting=true)
  rv = memory1.CreateNamedDeprecated(test_name, false, kDataSize);
  // Open two handles to a memory segment and check that
  // open_existing_deprecated works as expected.
  bool rv = memory1.CreateNamedDeprecated(test_name, false, kDataSize);
  rv = memory2.CreateNamedDeprecated(test_name, false, kDataSize2);
  rv = memory2.CreateNamedDeprecated(test_name, true, kDataSize2);
  options.name_deprecated = &shared_mem_name;
    bool rv = memory.CreateNamedDeprecated(s_test_name_, true, kDataSize);
  name_ = ASCIIToWide(options.name_deprecated == NULL ? "" :
                          *options.name_deprecated);
    if (!options.open_existing_deprecated) {
  if (!shared_memory->CreateNamedDeprecated(name, true, size))
  // TODO(viettrungluu): Named shared memory is deprecated (crbug.com/345734).
  if (!shared_mem_service_data->CreateNamedDeprecated
          (GetServiceProcessSharedMemName(), true, alloc_size))
    // TODO(viettrungluu): Named shared memory is deprecated (crbug.com/345734).
    // (I don't think we even need it here.)
    EXPECT_TRUE(shared_handle_.CreateNamedDeprecated(kShmemSegmentName, false,
                                                     100));
    RouteFunction("CHECK",
        base::Bind(&LoggingNativeHandler::Check, base::Unretained(this)));
  }

  v8::Handle<v8::Value> Check(const v8::Arguments& args) {
    bool check_value;
    std::string error_message;
    ParseArgs(args, &check_value, &error_message);
    CHECK(check_value) << error_message;
    return v8::Undefined();
    bool check_value;
    ParseArgs(args, &check_value, &error_message);
    DCHECK(check_value) << error_message;
    return v8::Undefined();
  }

 private:
  void ParseArgs(const v8::Arguments& args,
                 bool* check_value,
                 std::string* error_message) {
    CHECK_LE(args.Length(), 2);
    *check_value = args[0]->BooleanValue();
      *error_message = "Error: " + std::string(
          *v8::String::AsciiValue(args[1]));
      *error_message += "\n    <no stack trace>";
        *error_message += base::StringPrintf("\n    at %s (%s:%d:%d)",
  // Custom types sources.
  source_map_.RegisterSource("ChromeSetting", IDR_CHROME_SETTING_JS);
  source_map_.RegisterSource("StorageArea", IDR_STORAGE_AREA_JS);
  source_map_.RegisterSource("ContentSetting", IDR_CONTENT_SETTING_JS);

        "    CHECK: function(foo, bar) { return undefined; },"
        "    loadTypeSchema: function(foo) { return undefined; },"
DevToolsManager::DevToolsManager() : tab_contents_listeners_(NULL) {
  DCHECK(!tab_contents_listeners_.get()) <<
    Source<TabContents> src(source);
    const TabContents& tab_contents) {
  const NavigationController& navigation_controller = tab_contents.controller();
    TabContents& tab_contents,
  DCHECK(!GetDevToolsClientHostFor(tab_contents));
  NavigationController* navigation_controller = &tab_contents.controller();
  SendAttachToAgent(tab_contents, tab_contents.render_view_host());
  RenderViewHost* target_host = tc->render_view_host();
  TabContents* wc = from.delegate()->GetAsWebContents();
void DevToolsManager::OpenDevToolsWindow(TabContents* wc) {
void DevToolsManager::InspectElement(TabContents* wc, int x, int y) {
  SendDetachToAgent(*tab_contents);
  if (!tab_contents_listeners_.get()) {
    tab_contents_listeners_.reset(new NotificationRegistrar);
    tab_contents_listeners_->Add(
  DCHECK(tab_contents_listeners_.get());
    tab_contents_listeners_.reset();
void DevToolsManager::SendAttachToAgent(const TabContents& wc,
void DevToolsManager::SendDetachToAgent(const TabContents& wc) {
class TabContents;
  // Returns DevToolsClientHost registered for |tab_contents| or NULL if
  // there is no alive DevToolsClientHost registered for |tab_contents|.
  DevToolsClientHost* GetDevToolsClientHostFor(const TabContents& tab_contents);
  // Registers new DevToolsClientHost for |tab_contents|. There must be no
  // other DevToolsClientHosts registered for the TabContents at the moment.
  void RegisterDevToolsClientHostFor(TabContents& tab_contents,
  void OpenDevToolsWindow(TabContents* wc);
  void InspectElement(TabContents* tab_contents, int x, int y);
  // there is a DevToolsClientHost registered for the |tab_contents|.
      const TabContents& tab_contents,
  void SendDetachToAgent(const TabContents& tab_contents);
  scoped_ptr<NotificationRegistrar> tab_contents_listeners_;
#include "base/string16.h"
#include "base/time.h"
#include "chrome/browser/browser_process.h"
#include "chrome/browser/debugger/devtools_manager.h"
#include "chrome/browser/dom_ui/dom_ui.h"
#include "chrome/browser/dom_ui/dom_ui_factory.h"
#include "chrome/browser/renderer_host/render_widget_host_view.h"
#include "chrome/browser/renderer_host/web_cache_manager.h"
#include "chrome/common/url_constants.h"
const string16& TabContents::GetTitle() const {
  DOMUI* our_dom_ui = render_manager_.pending_dom_ui() ?
      render_manager_.pending_dom_ui() : render_manager_.dom_ui();
  if (our_dom_ui) {
    // Don't override the title in view source mode.
    NavigationEntry* entry = controller_.GetActiveEntry();
    if (!(entry && entry->IsViewSourceMode())) {
      // Give the DOM UI the chance to override our title.
      const string16& title = our_dom_ui->overridden_title();
      if (!title.empty())
        return title;
    }
  }

  // We use the title for the last committed entry rather than a pending
  // navigation entry. For example, when the user types in a URL, we want to
  // keep the old page's title until the new load has committed and we get a new
  // title.
  // The exception is with transient pages, for which we really want to use
  // their title, as they are not committed.
  NavigationEntry* entry = controller_.GetTransientEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);

  entry = controller_.GetLastCommittedEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);
  else if (controller_.LoadingURLLazily())
    return controller_.GetLazyTitle();
  return EmptyString16();
}

SiteInstance* TabContents::GetSiteInstance() const {
  return render_manager_.current_host()->site_instance();
}

bool TabContents::ShouldDisplayURL() {
  // Don't hide the url in view source mode.
  NavigationEntry* entry = controller_.GetActiveEntry();
  if (entry && entry->IsViewSourceMode())
    return true;
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->should_hide_url();
  return true;
}

bool TabContents::ShouldDisplayFavIcon() {
  // Always display a throbber during pending loads.
  if (controller_.GetLastCommittedEntry() && controller_.pending_entry())
    return true;

  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->hide_favicon();
  return true;
}

std::wstring TabContents::GetStatusText() const {
  if (!is_loading() || load_state_ == net::LOAD_STATE_IDLE)
    return std::wstring();

  switch (load_state_) {
    case net::LOAD_STATE_WAITING_FOR_CACHE:
      return l10n_util::GetString(IDS_LOAD_STATE_WAITING_FOR_CACHE);
    case net::LOAD_STATE_RESOLVING_PROXY_FOR_URL:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_PROXY_FOR_URL);
    case net::LOAD_STATE_RESOLVING_HOST:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_HOST);
    case net::LOAD_STATE_CONNECTING:
      return l10n_util::GetString(IDS_LOAD_STATE_CONNECTING);
    case net::LOAD_STATE_SENDING_REQUEST:
      return l10n_util::GetString(IDS_LOAD_STATE_SENDING_REQUEST);
    case net::LOAD_STATE_WAITING_FOR_RESPONSE:
      return l10n_util::GetStringF(IDS_LOAD_STATE_WAITING_FOR_RESPONSE,
                                   load_state_host_);
    // Ignore net::LOAD_STATE_READING_RESPONSE and net::LOAD_STATE_IDLE
    case net::LOAD_STATE_IDLE:
    case net::LOAD_STATE_READING_RESPONSE:
      break;
  }

  return std::wstring();
}

void TabContents::DidBecomeSelected() {
  controller_.SetActive(true);

  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // If pid() is -1, that means the RenderProcessHost still hasn't been
  // initialized.  It'll register with CacheManagerHost when it is.
  if (process()->pid() != -1)
    WebCacheManager::GetInstance()->ObserveActivity(process()->pid());
}

void TabContents::WasHidden() {
  if (!capturing_contents()) {
    // |render_view_host()| can be NULL if the user middle clicks a link to open
    // a tab in then background, then closes the tab before selecting it.  This
    // is because closing the tab calls TabContents::Destroy(), which removes
    // the |render_view_host()|; then when we actually destroy the window,
    // OnWindowPosChanged() notices and calls HideContents() (which calls us).
    if (render_widget_host_view())
      render_widget_host_view()->WasHidden();

    // Loop through children and send WasHidden to them, too.
    int count = static_cast<int>(child_windows_.size());
    for (int i = count - 1; i >= 0; --i) {
      ConstrainedWindow* window = child_windows_.at(i);
      window->WasHidden();
    }
  }

  NotificationService::current()->Notify(
      NotificationType::TAB_CONTENTS_HIDDEN,
      Source<TabContents>(this),
      NotificationService::NoDetails());
}

void TabContents::ShowContents() {
  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // Loop through children and send DidBecomeSelected to them, too.
  int count = static_cast<int>(child_windows_.size());
  for (int i = count - 1; i >= 0; --i) {
    ConstrainedWindow* window = child_windows_.at(i);
    window->DidBecomeSelected();
  }
}

void TabContents::HideContents() {
  // TODO(pkasting): http://b/1239839  Right now we purposefully don't call
  // our superclass HideContents(), because some callers want to be very picky
  // about the order in which these get called.  In addition to making the code
  // here practically impossible to understand, this also means we end up
  // calling TabContents::WasHidden() twice if callers call both versions of
  // HideContents() on a WebContents.
  WasHidden();
}

  const NavigationEntry& entry = *controller_.pending_entry();

  RenderViewHost* dest_render_view_host = render_manager_.Navigate(entry);
  if (!dest_render_view_host)
    return false;  // Unable to create the desired render view host.

  // Tell DevTools agent that it is attached prior to the navigation.
  DevToolsManager* dev_tools_manager = g_browser_process->devtools_manager();
  if (dev_tools_manager)  // NULL in unit tests.
    dev_tools_manager->SendAttachToAgent(*this, dest_render_view_host);

  // Used for page load time metrics.
  current_load_start_ = base::TimeTicks::Now();

  // Navigate in the desired RenderViewHost.
  dest_render_view_host->NavigateToEntry(entry, reload);

  if (entry.page_id() == -1) {
    // HACK!!  This code suppresses javascript: URLs from being added to
    // session history, which is what we want to do for javascript: URLs that
    // do not generate content.  What we really need is a message from the
    // renderer telling us that a new page was not created.  The same message
    // could be used for mailto: URLs and the like.
    if (entry.url().SchemeIs(chrome::kJavaScriptScheme))
      return false;
  }

  // Clear any provisional password saves - this stops password infobars
  // showing up on pages the user navigates to while the right page is
  // loading.
  GetPasswordManager()->ClearProvisionalSave();

  if (reload && !profile()->IsOffTheRecord()) {
    HistoryService* history =
        profile()->GetHistoryService(Profile::IMPLICIT_ACCESS);
    if (history)
      history->SetFavIconOutOfDateForPage(entry.url());
  }

void TabContents::Stop() {
  render_manager_.Stop();
  printing_.Stop();
}

void TabContents::Cut() {
  render_view_host()->Cut();
}

void TabContents::Copy() {
  render_view_host()->Copy();
}

void TabContents::Paste() {
  render_view_host()->Paste();
}

void TabContents::DisassociateFromPopupCount() {
  render_view_host()->DisassociateFromPopupCount();
}

TabContents* TabContents::Clone() {
  // We create a new SiteInstance so that the new tab won't share processes
  // with the old one. This can be changed in the future if we need it to share
  // processes for some reason.
  TabContents* tc = new WebContents(profile(),
                                    SiteInstance::CreateSiteInstance(profile()),
                                    MSG_ROUTING_NONE, NULL);
  tc->controller().CopyStateFrom(controller_);
  return tc;
}

void TabContents::PopupNotificationVisibilityChanged(bool visible) {
  render_view_host()->PopupNotificationVisibilityChanged(visible);
}

gfx::NativeView TabContents::GetContentNativeView() {
  return view_->GetContentNativeView();
}

gfx::NativeView TabContents::GetNativeView() const {
  return view_->GetNativeView();
}

void TabContents::GetContainerBounds(gfx::Rect *out) const {
  view_->GetContainerBounds(out);
}

void TabContents::Focus() {
  view_->Focus();
}

void TabContents::SetInitialFocus(bool reverse) {
  render_view_host()->SetInitialFocus(reverse);
}

bool TabContents::FocusLocationBarByDefault() {
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return dom_ui->focus_location_bar_by_default();
  return false;
}

bool TabContents::IsBookmarkBarAlwaysVisible() {
  // See GetDOMUIForCurrentState() comment for more info. This case is very
  // similar, but for non-first loads, we want to use the committed entry. This
  // is so the bookmarks bar disappears at the same time the page does.
  if (controller_.GetLastCommittedEntry()) {
    // Not the first load, always use the committed DOM UI.
    if (render_manager_.dom_ui())
      return render_manager_.dom_ui()->force_bookmark_bar_visible();
    return false;  // Default.
  }

  // When it's the first load, we know either the pending one or the committed
  // one will have the DOM UI in it (see GetDOMUIForCurrentState), and only one
  // of them will be valid, so we can just check both.
  if (render_manager_.pending_dom_ui())
    return render_manager_.pending_dom_ui()->force_bookmark_bar_visible();
  if (render_manager_.dom_ui())
    return render_manager_.dom_ui()->force_bookmark_bar_visible();
  return false;  // Default.
}

void TabContents::SetDownloadShelfVisible(bool visible) {
  if (shelf_visible_ != visible) {
    if (visible) {
      // Invoke GetDownloadShelf to force the shelf to be created.
      GetDownloadShelf();
    }
    shelf_visible_ = visible;

    if (delegate_)
      delegate_->ContentsStateChanged(this);
  }

  // SetShelfVisible can force-close the shelf, so make sure we lay out
  // everything correctly, as if the animation had finished. This doesn't
  // matter for showing the shelf, as the show animation will do it.
  ToolbarSizeChanged(false);

  if (visible) {
    // Always set this value as it reflects the last time the download shelf
    // was made visible (even if it was already visible).
    last_download_shelf_show_ = base::TimeTicks::Now();
  }
}

// Notifies the RenderWidgetHost instance about the fact that the page is
// loading, or done loading and calls the base implementation.
void TabContents::SetIsLoading(bool is_loading,
                               LoadNotificationDetails* details) {
  if (is_loading == is_loading_)
    return;

  if (!is_loading) {
    load_state_ = net::LOAD_STATE_IDLE;
    load_state_host_.clear();
  }

  render_manager_.SetIsLoading(is_loading);

  is_loading_ = is_loading;
  waiting_for_response_ = is_loading;

  if (delegate_)
    delegate_->LoadingStateChanged(this);

  NotificationType type = is_loading ? NotificationType::LOAD_START :
      NotificationType::LOAD_STOP;
  NotificationDetails det = NotificationService::NoDetails();;
  if (details)
      det = Details<LoadNotificationDetails>(details);
  NotificationService::current()->Notify(type,
      Source<NavigationController>(&controller_),
      det);
}


DOMUI* TabContents::GetDOMUIForCurrentState() {
  // When there is a pending navigation entry, we want to use the pending DOMUI
  // that goes along with it to control the basic flags. For example, we want to
  // show the pending URL in the URL bar, so we want the display_url flag to
  // be from the pending entry.
  //
  // The confusion comes because there are multiple possibilities for the
  // initial load in a tab as a side effect of the way the RenderViewHostManager
  // works.
  //
  //  - For the very first tab the load looks "normal". The new tab DOM UI is
  //    the pending one, and we want it to apply here.
  //
  //  - For subsequent new tabs, they'll get a new SiteInstance which will then
  //    get switched to the one previously associated with the new tab pages.
  //    This switching will cause the manager to commit the RVH/DOMUI. So we'll
  //    have a committed DOM UI in this case.
  //
  // This condition handles all of these cases:
  //
  //  - First load in first tab: no committed nav entry + pending nav entry +
  //    pending dom ui:
  //    -> Use pending DOM UI if any.
  //
  //  - First load in second tab: no committed nav entry + pending nav entry +
  //    no pending DOM UI:
  //    -> Use the committed DOM UI if any.
  //
  //  - Second navigation in any tab: committed nav entry + pending nav entry:
  //    -> Use pending DOM UI if any.
  //
  //  - Normal state with no load: committed nav entry + no pending nav entry:
  //    -> Use committed DOM UI.
  if (controller_.pending_entry() &&
      (controller_.GetLastCommittedEntry() ||
       render_manager_.pending_dom_ui()))
    return render_manager_.pending_dom_ui();
  return render_manager_.dom_ui();
}
  virtual const string16& GetTitle() const;
  virtual SiteInstance* GetSiteInstance() const;
  virtual bool ShouldDisplayURL();
  virtual bool ShouldDisplayFavIcon();
  virtual std::wstring GetStatusText() const;
  virtual void DidBecomeSelected();
  virtual void WasHidden();
  // TODO(brettw) document these.
  virtual void ShowContents();
  virtual void HideContents();

  virtual bool NavigateToPendingEntry(bool reload);
  virtual void Stop();
  virtual void Cut();
  virtual void Copy();
  virtual void Paste();
  virtual void DisassociateFromPopupCount();
  virtual TabContents* Clone();
  virtual void PopupNotificationVisibilityChanged(bool visible);
  // TODO(brettw): Most of these should be removed and the caller should call
  // the view directly.
  gfx::NativeView GetContentNativeView();
  gfx::NativeView GetNativeView() const;
  void GetContainerBounds(gfx::Rect *out) const;
  void Focus();
  void SetInitialFocus(bool reverse);

  // Returns true if the location bar should be focused by default rather than
  // the page contents. The view will call this function when the tab is
  // to see what it should do.
  bool FocusLocationBarByDefault();
  virtual bool IsBookmarkBarAlwaysVisible();
  virtual void SetDownloadShelfVisible(bool visible);
  RenderWidgetHostView* render_widget_host_view() const {
    return render_manager_.current_view();
  }

  void SetIsLoading(bool is_loading,
                    LoadNotificationDetails* details);

  // Returns the DOMUI for the current state of the tab. This will either be
  // the pending DOMUI, the committed DOMUI, or NULL.
  DOMUI* GetDOMUIForCurrentState();

  // calling LockDeprecated() to acquire the named mutex before either Create or
  // Open are called on Windows.
  // DEPRECATED (crbug.com/345734):
  // processes, not across threads.  The LockDeprecated method is not currently
  void LockDeprecated();
  // DEPRECATED (crbug.com/345734):
  void UnlockDeprecated();
  HANDLE             lock_;
// DEPRECATED (crbug.com/345734):
// the SharedMemoryAutoLockDeprecated is in scope.
class SharedMemoryAutoLockDeprecated {
  explicit SharedMemoryAutoLockDeprecated(SharedMemory* shared_memory)
    shared_memory_->LockDeprecated();
  ~SharedMemoryAutoLockDeprecated() {
    shared_memory_->UnlockDeprecated();
  DISALLOW_COPY_AND_ASSIGN(SharedMemoryAutoLockDeprecated);
void SharedMemory::LockDeprecated() {
void SharedMemory::UnlockDeprecated() {
void SharedMemory::LockDeprecated() {
void SharedMemory::UnlockDeprecated() {
      memory2.LockDeprecated();
      memory2.UnlockDeprecated();
      memory.LockDeprecated();
      memory.UnlockDeprecated();
void SharedMemory::LockDeprecated() {
    lock_ = CreateMutex(NULL, FALSE, name.c_str());
      NOTREACHED();
      return;  // There is nothing good we can do here.
  DWORD result = WaitForSingleObject(lock_, INFINITE);
  DCHECK_EQ(result, WAIT_OBJECT_0);
void SharedMemory::UnlockDeprecated() {
  // TODO(viettrungluu): crbug.com/345734: Use a different locking mechanism.
    SharedMemoryAutoLockDeprecated lock(internal_->shared_memory());
    SharedMemoryAutoLockDeprecated lock(internal_->shared_memory());
  if (profile_->GetExtensionsService())
    profile_->GetExtensionsService()->InstallExtension(full_path, download_url,
                                                       referrer_url);
#if defined(OS_WIN)
#include "app/win_util.h"
#elif defined(OS_MACOSX)
#include "base/scoped_cftyperef.h"
#include "base/sys_string_conversions.h"
#include <CoreFoundation/CFUserNotification.h>
#endif
                           bool extensions_enabled,
                           bool is_from_gallery,
                           bool show_prompts,
                           ExtensionsService* frontend)
      extensions_enabled_(extensions_enabled),
      is_from_gallery_(is_from_gallery),
      show_prompts_(show_prompts),
  // Note: this is a refptr so that we keep the frontend alive long enough to
  // get our response.
  frontend_ = frontend;
  // temp_dir_deleter is stack allocated instead of a member of CrxInstaller, so
  // that delete always happens on the file thread.
  ScopedTempDir temp_dir_deleter;
  temp_dir_deleter.Set(temp_dir);

  // If we were supposed to delete the source file, we can do that now.
  if (delete_crx_)
    file_util::Delete(crx_path_, false);  // non-recursive

    ReportFailureFromFileThread(
        StringPrintf("ID in new extension manifest (%s) does not match "
                     "expected id (%s)",
                     extension->id().c_str(),
                     expected_id_.c_str()));
  // Show the confirm UI if necessary.
  // NOTE: We also special case themes to not have a dialog, because we show
  // a special infobar UI for them instead.
  if (show_prompts_ && !extension->IsTheme()) {
    if (!ConfirmInstall())
      return;  // error reported by ConfirmInstall()

  CompleteInstall();
bool CrxInstaller::ConfirmInstall() {
#if defined(OS_WIN)
  if (win_util::MessageBox(GetForegroundWindow(),
          L"Are you sure you want to install this extension?\n\n"
          L"You should only install extensions from sources you trust.",
          l10n_util::GetString(IDS_PRODUCT_NAME).c_str(),
          MB_OKCANCEL) != IDOK) {
    ReportFailureFromFileThread("User did not allow extension to be "
                                "installed.");
    return false;
#elif defined(OS_MACOSX)
  // Using CoreFoundation to do this dialog is unimaginably lame but will do
  // until the UI is redone.
  scoped_cftyperef<CFStringRef> product_name(
      base::SysWideToCFStringRef(l10n_util::GetString(IDS_PRODUCT_NAME)));
  CFOptionFlags response;
  if (kCFUserNotificationAlternateResponse == CFUserNotificationDisplayAlert(
      0, kCFUserNotificationCautionAlertLevel, NULL, NULL, NULL,
      product_name,
      CFSTR("Are you sure you want to install this extension?\n\n"
           "This is a temporary message and it will be removed when "
           "extensions UI is finalized."),
      NULL, CFSTR("Cancel"), NULL, &response)) {
    ReportFailureFromFileThread("User did not allow extension to be "
                                "installed.");
    return false;
  }
#endif  // OS_*
  return true;
  ExtensionErrorReporter::GetInstance()->ReportError(error, show_prompts_);
  ui_loop_->PostTask(FROM_HERE, NewRunnableMethod(frontend_.get(),
      &ExtensionsService::OnExtensionOverinstallAttempted, extension_->id()));
  ui_loop_->PostTask(FROM_HERE, NewRunnableMethod(frontend_.get(),
      &ExtensionsService::OnExtensionInstalled, extension_.release()));
//
// 
//
// NOTE: This class is rather huge at the moment because it is handling all
// types of installation (external, autoupdate, and manual). In the future,
// manual installation will probably pulled out of it.
// TODO(aa): Pull out the manual installation bits.
               bool extensions_enabled,
               bool is_from_gallery,
               bool show_prompts,
               ExtensionsService* frontend);
  ~CrxInstaller() {
    // This is only here for debugging purposes, as a convenient place to set
    // breakpoints.
  }
 private:
  // Confirm with the user that it is OK to install this extension.
  //
  // Note that this runs on the file thread. It happens to be OK to do this on
  // Windows and Mac, and although ugly, we leave it because this is all getting
  // pulled out soon, anyway.
  //
  // TODO(aa): Pull this up, closer to the UI layer.
  bool ConfirmInstall();
  // Whether extension installation is set. We can't just check this before
  // trying to install because themes are special-cased to always be allowed.
  // Whether this installation was initiated from the gallery. We trust it more
  // and have special UI if it was.
  bool is_from_gallery_;

  // Whether we shoud should show prompts. This is sometimes false for testing
  // and autoupdate.
  bool show_prompts_;

#include "chrome/browser/extensions/theme_preview_infobar_delegate.h"
#include "chrome/browser/tab_contents/tab_contents.h"
  InstallExtension(extension_path, GURL(), GURL());
}

void ExtensionsService::InstallExtension(const FilePath& extension_path,
                                         const GURL& download_url,
                                         const GURL& referrer_url) {
  new CrxInstaller(extension_path, install_directory_, Extension::INTERNAL,
                   "",   // no expected id
                   extensions_enabled_,
                   IsDownloadFromGallery(download_url, referrer_url),
                   show_extensions_prompts(),
                   false,  // don't delete crx when complete
                   backend_loop_,
                   this);
  new CrxInstaller(extension_path, install_directory_, Extension::INTERNAL,
                   id, extensions_enabled_,
                   false,  // not from gallery
                   show_extensions_prompts(),
                   true,  // delete crx when complete
                   backend_loop_,
                   this);
    ShowThemePreviewInfobar(extension);
    ShowThemePreviewInfobar(extension);
bool ExtensionsService::ShowThemePreviewInfobar(Extension* extension) {
  if (!profile_)
    return false;

  Browser* browser = BrowserList::GetLastActiveWithProfile(profile_);
  if (!browser)
    return false;

  TabContents* tab_contents = browser->GetSelectedTabContents();
  if (!tab_contents)
    return false;

  tab_contents->AddInfoBar(new ThemePreviewInfobarDelegate(tab_contents,
                                                           extension->name()));
  return true;
}

  new CrxInstaller(path, install_directory_, location, id, extensions_enabled_,
                   false,  // not from gallery
                   show_extensions_prompts(),
                   false,  // don't delete crx when complete
                   backend_loop_,
                   this);
  // XXX Hack: This is a temporary nasty hack to get theme installation working
  // without a dialog. Will be fixed by making ExtensionsService more modular.
  void InstallExtension(const FilePath& extension_path,
                        const GURL& download_url,
                        const GURL& referrer_url);

  // Show a confirm installation infobar on the currently active tab.
  // TODO(aa): This should be moved up into the UI and attached to the tab it
  // actually occured in. This requires some modularization of
  // ExtensionsService.
  bool ShowThemePreviewInfobar(Extension* extension);

      : crx_path_(crx_path), client_loop_(MessageLoop::current()), rdh_(rdh),
        client_(client), got_response_(false) {
  UtilityProcessHost* host = new UtilityProcessHost(rdh_, this,
                                                    MessageLoop::current());
  MessageLoop* client_loop_;
bool ThemePreviewInfobarDelegate::EqualsDelegate(InfoBarDelegate* delegate)
    const {
  // If another infobar of this type is showing, this will prevent us adding
  // a new one, we only care if they're the same type, as pressing undo always
  // has the same result each time. This does mean that the text continues
  // to refer to the old theme, but this is good enough for beta.
  // http://crbug.com/17932
  if (delegate->AsThemePreviewInfobarDelegate())
    return true;

  return false;
}

  virtual bool EqualsDelegate(InfoBarDelegate* delegate) const;
  if (listener_) {
    if (chose_color)
      listener_->OnColorChosen(color);
    listener_->OnColorChooserDialogClosed();
  }
  virtual void End() OVERRIDE;
void ColorChooserWin::End() {
  // The ColorChooserDialog's listener is going away.  Ideally we'd
  // programmatically close the dialog at this point.  Since that's impossible,
  // we instead tell the dialog its listener is going away, so that the dialog
  // doesn't try to communicate with a destroyed listener later.  (We also tell
  // the renderer the dialog is closed, since from the renderer's perspective
  // it effectively is.)
  OnColorChooserDialogClosed();
}

  IPC_SYNC_MESSAGE_ROUTED3_0(PluginMsg_DidFinishLoadWithReason,
                             GURL /* url */,
                             int /* reason */,
                             intptr_t /* notify_data */)
                      GURL /* url */,
                      std::string /* result */,
void WebPluginDelegateStub::OnDidFinishLoadWithReason(
    const GURL& url, int reason, intptr_t notify_data) {
  delegate_->DidFinishLoadWithReason(url, reason, notify_data);
void WebPluginDelegateStub::OnSendJavaScriptStream(const GURL& url,
                                                   const std::string& result,
  void OnDidFinishLoadWithReason(const GURL& url, int reason,
                                 intptr_t notify_data);
  void OnSendJavaScriptStream(const GURL& url,
                              const std::string& result,
#include "webkit/api/public/WebString.h"
using WebKit::WebString;
  WebFrame* sub1_frame =
      view_->webview()->GetFrameWithName(WebString::fromUTF8("sub1"));
void WebPluginDelegateProxy::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
void WebPluginDelegateProxy::DidFinishLoadWithReason(
    const GURL& url, NPReason reason, intptr_t notify_data) {
  Send(new PluginMsg_DidFinishLoadWithReason(
      instance_id_, url, reason, notify_data));
  virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,
                                       intptr_t notify_data);
  virtual void SendJavaScriptStream(const GURL& url,
                                    const std::string& result,
    class WebDataSource;
    class WebFrame;
    class WebURL;
        // Called in response to WebPluginContainer::loadFrameRequest
        virtual void didFinishLoadingFrameRequest(
            const WebURL&, void* notifyData) = 0;
        virtual void didFailLoadingFrameRequest(
            const WebURL&, void* notifyData, const WebURLError&) = 0;

    class WebString;
    class WebURL;
    class WebURLRequest;
        // Executes a "javascript:" URL on behalf of the plugin in the context
        // of the frame containing the plugin.  Returns the result of script
        // execution, if any.
        virtual WebString executeScriptURL(const WebURL&, bool popupsAllowed) = 0;

        // Loads an URL in the specified frame (or the frame containing this
        // plugin if target is empty).  If notifyNeeded is true, then upon
        // completion, WebPlugin::didFinishLoadingFrameRequest is called if the
        // load was successful or WebPlugin::didFailLoadingFrameRequest is
        // called if the load failed.  The given notifyData is passed along to
        // the callback.
        virtual void loadFrameRequest(
            const WebURLRequest&, const WebString& target, bool notifyNeeded, void* notifyData) = 0;

/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "WebDataSourceImpl.h"

#include "WebURL.h"
#include "WebURLError.h"
#include "WebVector.h"

using namespace WebCore;

namespace WebKit {

WebPluginLoadObserver* WebDataSourceImpl::m_nextPluginLoadObserver = 0;

PassRefPtr<WebDataSourceImpl> WebDataSourceImpl::create(const ResourceRequest& request, const SubstituteData& data)
{
    return adoptRef(new WebDataSourceImpl(request, data));
}

const WebURLRequest& WebDataSourceImpl::originalRequest() const
{
    m_originalRequestWrapper.bind(DocumentLoader::originalRequest());
    return m_originalRequestWrapper;
}

const WebURLRequest& WebDataSourceImpl::request() const
{
    m_requestWrapper.bind(DocumentLoader::request());
    return m_requestWrapper;
}

const WebURLResponse& WebDataSourceImpl::response() const
{
    m_responseWrapper.bind(DocumentLoader::response());
    return m_responseWrapper;
}

bool WebDataSourceImpl::hasUnreachableURL() const
{
    return !DocumentLoader::unreachableURL().isEmpty();
}

WebURL WebDataSourceImpl::unreachableURL() const
{
    return DocumentLoader::unreachableURL();
}

void WebDataSourceImpl::redirectChain(WebVector<WebURL>& result) const
{
    result.assign(m_redirectChain);
}

WebString WebDataSourceImpl::pageTitle() const
{
    return title();
}

WebNavigationType WebDataSourceImpl::navigationType() const
{
    return toWebNavigationType(triggeringAction().type());
}

double WebDataSourceImpl::triggeringEventTime() const
{
    if (!triggeringAction().event())
        return 0.0;

    // DOMTimeStamp uses units of milliseconds.
    return triggeringAction().event()->timeStamp() / 1000.0;
}

WebDataSource::ExtraData* WebDataSourceImpl::extraData() const
{
    return m_extraData.get();
}

void WebDataSourceImpl::setExtraData(ExtraData* extraData)
{
    m_extraData.set(extraData);
}

WebNavigationType WebDataSourceImpl::toWebNavigationType(NavigationType type)
{
    switch (type) {
    case NavigationTypeLinkClicked:
        return WebNavigationTypeLinkClicked;
    case NavigationTypeFormSubmitted:
        return WebNavigationTypeFormSubmitted;
    case NavigationTypeBackForward:
        return WebNavigationTypeBackForward;
    case NavigationTypeReload:
        return WebNavigationTypeReload;
    case NavigationTypeFormResubmitted:
        return WebNavigationTypeFormResubmitted;
    case NavigationTypeOther:
    default:
        return WebNavigationTypeOther;
    }
}

WebURL WebDataSourceImpl::endOfRedirectChain() const
{
    ASSERT(!m_redirectChain.isEmpty());
    return m_redirectChain.last();
}

void WebDataSourceImpl::clearRedirectChain()
{
    m_redirectChain.clear();
}

void WebDataSourceImpl::appendRedirect(const WebURL& url)
{
    m_redirectChain.append(url);
}

void WebDataSourceImpl::setNextPluginLoadObserver(PassOwnPtr<WebPluginLoadObserver> observer)
{
    // This call should always be followed up with the creation of a
    // WebDataSourceImpl, so we should never leak this object.
    m_nextPluginLoadObserver = observer.release();
}

WebDataSourceImpl::WebDataSourceImpl(const ResourceRequest& request, const SubstituteData& data)
    : DocumentLoader(request, data)
{
    if (m_nextPluginLoadObserver) {
        // When a new frame is created, it initially gets a data source for an
        // empty document.  Then it is navigated to the source URL of the
        // frame, which results in a second data source being created.  We want
        // to wait to attach the WebPluginLoadObserver to that data source.
        if (!request.url().isEmpty()) {
            ASSERT(m_nextPluginLoadObserver->url() == request.url());
            m_pluginLoadObserver.set(m_nextPluginLoadObserver);
            m_nextPluginLoadObserver = 0;
        }
    }
}

WebDataSourceImpl::~WebDataSourceImpl()
{
}

} // namespace WebKit
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef WebDataSourceImpl_h
#define WebDataSourceImpl_h

// FIXME: This relative path is a temporary hack to support using this
// header from webkit/glue.
#include "../public/WebDataSource.h"
#include "WebPluginLoadObserver.h"
#include "WrappedResourceRequest.h"
#include "WrappedResourceResponse.h"

#include "DocumentLoader.h"
#include <wtf/PassOwnPtr.h>
#include <wtf/OwnPtr.h>
#include <wtf/Vector.h>

namespace WebKit {
    class WebPluginLoadObserver;

    class WebDataSourceImpl : public WebCore::DocumentLoader, public WebDataSource {
    public:
        static PassRefPtr<WebDataSourceImpl> create(const WebCore::ResourceRequest&,
                                                    const WebCore::SubstituteData&);

        static WebDataSourceImpl* fromDocumentLoader(WebCore::DocumentLoader* loader)
        {
            return static_cast<WebDataSourceImpl*>(loader);
        }

        // WebDataSource methods:
        virtual const WebURLRequest& originalRequest() const;
        virtual const WebURLRequest& request() const;
        virtual const WebURLResponse& response() const;
        virtual bool hasUnreachableURL() const;
        virtual WebURL unreachableURL() const;
        virtual void redirectChain(WebVector<WebURL>&) const;
        virtual WebString pageTitle() const;
        virtual WebNavigationType navigationType() const;
        virtual double triggeringEventTime() const;
        virtual ExtraData* extraData() const;
        virtual void setExtraData(ExtraData*);

        static WebNavigationType toWebNavigationType(WebCore::NavigationType type);

        bool hasRedirectChain() const { return !m_redirectChain.isEmpty(); }
        WebURL endOfRedirectChain() const;
        void clearRedirectChain();
        void appendRedirect(const WebURL& url);

        PassOwnPtr<WebPluginLoadObserver> releasePluginLoadObserver() { return m_pluginLoadObserver.release(); }
        static void setNextPluginLoadObserver(PassOwnPtr<WebPluginLoadObserver>);

    private:
        WebDataSourceImpl(const WebCore::ResourceRequest&, const WebCore::SubstituteData&);
        ~WebDataSourceImpl();

        // Mutable because the const getters will magically sync these to the
        // latest version from WebKit.
        mutable WrappedResourceRequest m_originalRequestWrapper;
        mutable WrappedResourceRequest m_requestWrapper;
        mutable WrappedResourceResponse m_responseWrapper;

        // Lists all intermediate URLs that have redirected for the current provisional load.
        // See WebFrameLoaderClient::dispatchDidReceiveServerRedirectForProvisionalLoad for a
        // description of who modifies this when to keep it up to date.
        Vector<WebURL> m_redirectChain;

        OwnPtr<ExtraData> m_extraData;
        OwnPtr<WebPluginLoadObserver> m_pluginLoadObserver;

        static WebPluginLoadObserver* m_nextPluginLoadObserver;
    };

} // namespace WebKit

#endif  // WebDataSourceImpl_h
#include "WebDataSourceImpl.h"
#include "WebURLRequest.h"
#include "FormState.h"
#include "FrameLoadRequest.h"
#include "HTMLFormElement.h"
WebString WebPluginContainerImpl::executeScriptURL(const WebURL& url, bool popupsAllowed)
{
    Frame* frame = m_element->document()->frame();
    if (!frame)
        return WebString();

    const KURL& kurl = url;
    ASSERT(kurl.protocolIs("javascript"));

    String script = decodeURLEscapeSequences(
        kurl.string().substring(strlen("javascript:")));

    ScriptValue result = frame->loader()->executeScript(script, popupsAllowed);

    // Failure is reported as a null string.
    String resultStr;
    result.getString(resultStr);
    return resultStr;
}

void WebPluginContainerImpl::loadFrameRequest(
    const WebURLRequest& request, const WebString& target, bool notifyNeeded, void* notifyData)
{
    Frame* frame = m_element->document()->frame();
    if (!frame)
        return;  // FIXME: send a notification in this case?

    if (notifyNeeded) {
        // FIXME: This is a bit of hack to allow us to observe completion of
        // our frame request.  It would be better to evolve FrameLoader to
        // support a completion callback instead.
        WebDataSourceImpl::setNextPluginLoadObserver(
            new WebPluginLoadObserver(this, request.url(), notifyData));
    }

    FrameLoadRequest frameRequest(request.toResourceRequest());
    frameRequest.setFrameName(target);

    frame->loader()->loadFrameRequest(
        frameRequest,
        false,  // lock history
        false,  // lock back forward list
        0,      // event
        0);     // form state
}

void WebPluginContainerImpl::willDestroyPluginLoadObserver(WebPluginLoadObserver* observer)
{
    size_t pos = m_pluginLoadObservers.find(observer);
    if (pos == notFound)
        return;
    m_pluginLoadObservers.remove(pos);
}

    class WebPluginLoadObserver;
        virtual WebString executeScriptURL(const WebURL&, bool popupsAllowed);
        virtual void loadFrameRequest(const WebURLRequest&, const WebString& target, bool notifyNeeded, void* notifyData);
        // This cannot be null.
        WebPlugin* plugin() { return m_webPlugin; }

        void willDestroyPluginLoadObserver(WebPluginLoadObserver*);

        Vector<WebPluginLoadObserver*> m_pluginLoadObservers;
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "WebPluginLoadObserver.h"

#include "WebPlugin.h"
#include "WebPluginContainerImpl.h"

namespace WebKit {

WebPluginLoadObserver::~WebPluginLoadObserver()
{
    if (m_pluginContainer)
        m_pluginContainer->willDestroyPluginLoadObserver(this);
}

void WebPluginLoadObserver::didFinishLoading()
{
    if (m_pluginContainer)
        m_pluginContainer->plugin()->didFinishLoadingFrameRequest(m_notifyURL, m_notifyData);
}

void WebPluginLoadObserver::didFailLoading(const WebURLError& error)
{
    if (m_pluginContainer)
        m_pluginContainer->plugin()->didFailLoadingFrameRequest(m_notifyURL, m_notifyData, error);
}

} // namespace WebKit
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef WebPluginLoadObserver_h
#define WebPluginLoadObserver_h

#include "../public/WebURL.h"

namespace WebKit {
    class WebPluginContainerImpl;
    struct WebURLError;

    class WebPluginLoadObserver {
    public:
        WebPluginLoadObserver(WebPluginContainerImpl* pluginContainer,
                              const WebURL& notifyURL, void* notifyData)
            : m_pluginContainer(pluginContainer)
            , m_notifyURL(notifyURL)
            , m_notifyData(notifyData)
        {
        }

        ~WebPluginLoadObserver();

        const WebURL& url() const { return m_notifyURL; }

        void clearPluginContainer() { m_pluginContainer = 0; }
        void didFinishLoading();
        void didFailLoading(const WebURLError&);

    private:
        WebPluginContainerImpl* m_pluginContainer;
        WebURL m_notifyURL;
        void* m_notifyData;
    };

} // namespace WebKit

#endif
#include "webkit/api/src/WebDataSourceImpl.h"
using WebKit::WebDataSourceImpl;
      WebDataSource* ds = WebDataSourceImpl::fromDocumentLoader(dl);
  WebDataSource* ds = WebDataSourceImpl::fromDocumentLoader(dl);
#include "webkit/api/public/WebString.h"
using WebKit::WebString;
  WebFrame* iframe =
      test_shell_->webView()->GetFrameWithName(WebString::fromUTF8("ifr"));
void PluginInstance::DidFinishLoadWithReason(const GURL& url, NPReason reason,
                                             void* notify_data) {
  NPP_URLNotify(url.spec().c_str(), reason, notify_data);
void PluginInstance::SendJavaScriptStream(const GURL& url,
                                          const std::string& result,
    stream->SendToPlugin(result, "text/html");
      this->NPP_URLNotify(url.spec().c_str(), NPRES_DONE,
  virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,
                                       void* notify_data);
  void SendJavaScriptStream(const GURL& url, const std::string& result,
#include "googleurl/src/gurl.h"

    PluginInstance* instance,
    const GURL& url,
    void* notify_data)
    : PluginStream(instance, url.spec().c_str(), notify_needed, notify_data) {
#ifndef WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H_
#define WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H_
class GURL;

  PluginStringStream(PluginInstance* instance,
                     const GURL& url,
                     void* notify_data);
  void SendToPlugin(const std::string& data,
                    const std::string& mime_type);
  DISALLOW_COPY_AND_ASSIGN(PluginStringStream);
#endif // WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H_
void WebPluginDelegateImpl::DidFinishLoadWithReason(const GURL& url,
                                                    NPReason reason,
                                                    intptr_t notify_data) {
  instance()->DidFinishLoadWithReason(
      url, reason, reinterpret_cast<void*>(notify_data));
void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                 const std::string& result,
  virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,
                                       intptr_t notify_data);
  virtual void SendJavaScriptStream(const GURL& url,
                                    const std::string& result,
#include "webkit/api/src/WebDataSourceImpl.h"
using WebKit::WebDataSourceImpl;
  return loader ? WebDataSourceImpl::fromDocumentLoader(loader) : NULL;
namespace WebKit {
class WebDataSourceImpl;
}

  WebKit::WebDataSourceImpl* GetDataSourceImpl() const;
  WebKit::WebDataSourceImpl* GetProvisionalDataSourceImpl() const;
#include "webkit/api/src/WebDataSourceImpl.h"
#include "webkit/api/src/WebPluginLoadObserver.h"
using WebKit::WebDataSourceImpl;
using WebKit::WebPluginLoadObserver;
      WebDataSourceImpl::fromDocumentLoader(documentLoader);
  DCHECK(ds->hasRedirectChain());
  ds->appendRedirect(ds->request().url());
    GURL chain_end = ds->endOfRedirectChain();
    ds->clearRedirectChain();
      ds->appendRedirect(chain_end);
    ds->appendRedirect(url);
  DCHECK(!ds->hasRedirectChain());
    ds->appendRedirect(expected_client_redirect_src_);
  ds->appendRedirect(url);
  // TODO(darin): This means the plugin won't receive NPP_URLNotify, which
  // seems like it could result in a memory leak in the plugin!!
    return;

  OwnPtr<WebPluginLoadObserver> plugin_load_observer = GetPluginLoadObserver();
  webframe_->DidFail(error, true);
  if (plugin_load_observer)
    plugin_load_observer->didFailLoading(error);
  OwnPtr<WebPluginLoadObserver> plugin_load_observer = GetPluginLoadObserver();
  if (plugin_load_observer)
    plugin_load_observer->didFailLoading(error);
  OwnPtr<WebPluginLoadObserver> plugin_load_observer = GetPluginLoadObserver();

  if (plugin_load_observer)
    plugin_load_observer->didFinishLoading();
        bool is_redirect = ds->hasRedirectChain();
            WebDataSourceImpl::toWebNavigationType(action.type());
  OwnPtr<WebPluginLoadObserver> plugin_load_observer = GetPluginLoadObserver();
  if (plugin_load_observer)
    plugin_load_observer->didFinishLoading();

  RefPtr<WebDataSourceImpl> ds = WebDataSourceImpl::create(request, data);

PassOwnPtr<WebPluginLoadObserver> WebFrameLoaderClient::GetPluginLoadObserver() {
  WebDataSourceImpl* ds = WebDataSourceImpl::fromDocumentLoader(
      webframe_->frame()->loader()->activeDocumentLoader());
  return ds->releasePluginLoadObserver();
}
#include <wtf/PassOwnPtr.h>
class WebPluginLoadObserver;
  virtual WebCore::ObjectContentType objectContentType(
      const WebCore::KURL& url, const WebCore::String& mimeType);
  PassOwnPtr<WebKit::WebPluginLoadObserver> GetPluginLoadObserver();

#include "base/string16.h"
  virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,
                                       intptr_t notify_data) = 0;
  // The result, UTF-8 encoded, of the script execution is returned via this
  // function.
  virtual void SendJavaScriptStream(const GURL& url,
                                    const std::string& result,
#include "webkit/api/public/WebConsoleMessage.h"
using WebKit::WebConsoleMessage;
using WebKit::WebDataSource;
using WebKit::WebFrame;
using WebKit::WebURL;
void WebPluginImpl::didFinishLoadingFrameRequest(
    const WebURL& url, void* notify_data) {
  if (delegate_) {
    delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
  }
}

void WebPluginImpl::didFailLoadingFrameRequest(
    const WebURL& url, void* notify_data, const WebURLError& error) {
  // TODO(darin): Map net::ERR_ABORTED to NPRES_USER_BREAK?
  if (delegate_) {
    delegate_->DidFinishLoadWithReason(
        url, NPRES_NETWORK_ERR, reinterpret_cast<intptr_t>(notify_data));
  }
}

                                          bool notify_needed,
                                          intptr_t notify_data,
                                          const char* url, GURL* unused) {
  if (!webframe_)
  WebString target_str = WebString::fromUTF8(target);

    WebFrame* target_frame = webframe_->view()->GetFrameWithName(target_str);
    if (target_frame != webframe_) {
      // TODO(darin): Localize this message.
      const char kMessage[] =
          "Ignoring cross-frame javascript URL load requested by plugin.";
      webframe_->addMessageToConsole(
          WebConsoleMessage(WebConsoleMessage::LevelError,
                            WebString::fromUTF8(kMessage)));
  container_->loadFrameRequest(request, target_str, notify_needed,
                               reinterpret_cast<void*>(notify_data));
                                    buf, is_file_data, notify, notify_data,
                                    url, &complete_url);
  if (routing_status == ROUTED)
    GURL gurl(url);
    WebString result = container_->executeScriptURL(gurl, popups_allowed);

    // delegate_ could be NULL because executeScript caused the container to
    // be deleted.
    if (delegate_) {
      delegate_->SendJavaScriptStream(
          gurl, result.utf8(), !result.isNull(), notify, notify_data);
    }
  virtual void didFinishLoadingFrameRequest(
      const WebKit::WebURL& url, void* notify_data);
  virtual void didFailLoadingFrameRequest(
      const WebKit::WebURL& url, void* notify_data,
      const WebKit::WebURLError& error);
  // plugin as is. This avoids having to track the notification arguments in
  // the plugin process.
                     bool notify_needed, intptr_t notify_data,
                     bool popups_allowed);
  // Given a download request, check if we need to route the output to a frame.
  // Returns ROUTED if the load is done and routed to a frame, NOT_ROUTED or
  // corresponding error codes otherwise.
  RoutingStatus RouteToFrame(const char* method, bool is_javascript_url,
                             const char* buf, bool is_file_data,
                             bool notify_needed, intptr_t notify_data,
  virtual WebKit::WebFrame* GetFrameWithName(const WebKit::WebString& name) = 0;
WebFrame* WebViewImpl::GetFrameWithName(const WebString& name) {
  String name_str = webkit_glue::WebStringToString(name);
  virtual WebKit::WebFrame* GetFrameWithName(const WebKit::WebString& name);
#include "webkit/api/src/WebDataSourceImpl.h"
    static_cast<WebKit::WebDataSourceImpl*>(ds)->
        setDeferMainResourceDataLoad(false);
  if (!entry.GetTargetFrame().empty()) {
      frame = webView()->GetFrameWithName(
          WideToUTF16Hack(entry.GetTargetFrame()));
  }
  if (!MakeCurrent()) {
    LOG(ERROR) << "MakeCurrent failed.";
  }
  if (glGetError() != GL_NO_ERROR) {
    LOG(ERROR) << "glClear failed.";
  }
  if (!g_display) {
    LOG(ERROR) << "eglGetDisplay failed.";
  }
  if (!eglInitialize(g_display, NULL, NULL)) {
    LOG(ERROR) << "eglInitialize failed.";
  }
    LOG(ERROR) << "eglChooseConfig failed.";
  if (num_configs == 0) {
    LOG(ERROR) << "No suitable EGL configs found.";
  }
    LOG(ERROR) << "eglChooseConfig failed.";
    LOG(ERROR) << "eglCreateWindowSurface failed.";
    LOG(ERROR) << "eglCreateContext failed.";
    LOG(ERROR) << "MakeCurrent failed.";
    LOG(ERROR) << "GLContext::InitializeCommon failed.";
    LOG(ERROR) << "InitializeBestGLBindings failed.";
    LOG(ERROR) << "GLContext::InitlializeCommon failed.";
    LOG(ERROR) << "OSMesaGLContext::Initialize failed.";
  if (!UpdateSize()) {
    LOG(ERROR) << "Failed to update size of OSMesaGLContext.";
  }
    LOG(ERROR) << "GLContext::InitializeCommon failed.";
    LOG(ERROR) << "GLContext::InitializeCommon failed.";
    LOG(ERROR) << "InitializeBestGLBindings failed.";
    LOG(ERROR) << "Error choosing pixel format.";
    LOG(ERROR) << "pixel_format == 0.";
    LOG(ERROR) << "Error creating context.";
    LOG(ERROR) << "Error creating pbuffer.";
    LOG(ERROR) << "Error attaching pbuffer to context.";
    LOG(ERROR) << "Couldn't make context current for initialization.";
    LOG(ERROR) << "GLContext::InitializeCommon failed.";
      LOG(ERROR) << "Unable to make gl context current.";
  if (!context_) {
    LOG(ERROR) << "OSMesaCreateContextExt failed.";
  }
    LOG(ERROR) << "MakeCurrent failed.";
    LOG(ERROR) << "GLContext::InitializeCommon failed.";
    LOG(ERROR) << "InitializeBestGLBinding failed.";
    LOG(ERROR) << "GetModuleHandleEx failed.";
    LOG(ERROR) << "RegisterClass failed.";
    LOG(ERROR) << "CreateWindow failed.";
        LOG(ERROR) << "Unable to get the pixel format for GL context.";
        LOG(ERROR) << "Unable to set the pixel format for GL context.";
      if (!BaseEGLContext::InitializeOneOff()) {
        LOG(ERROR) << "BaseEGLContext::InitializeOneOff failed.";
      }
    LOG(ERROR) << "Unable to set the pixel format for GL context.";
    LOG(ERROR) << "Failed to create GL context.";
    LOG(ERROR) << "MakeCurrent failed.";
    LOG(ERROR) << "GLContext::InitializeCommon failed.";
    LOG(ERROR) << "Unable to make gl context current.";
    LOG(ERROR) << "OSMesaGLContext::Initialize failed.";
    LOG(ERROR) << "Unable to create pbuffer.";
    LOG(ERROR) << "Unable to get pbuffer device context.";
    LOG(ERROR) << "Failed to create GL context.";
      LOG(ERROR) << "Could not share GL contexts.";
    LOG(ERROR) << "MakeCurrent failed.";
    LOG(ERROR) << "GLContext::InitializeCommon failed.";
    LOG(ERROR) << "Unable to make gl context current.";
      if (!PathService::Get(base::DIR_MODULE, &module_path)) {
        LOG(ERROR) << "PathService::Get failed.";
      }
        LOG(ERROR) << "libGL.so.1 not found.";
        DLOG(ERROR) << "libEGL.so not found";
        DLOG(ERROR) << "libGLESv2.so not found";
      if (!PathService::Get(base::DIR_MODULE, &module_path)) {
        LOG(ERROR) << "PathService::Get failed.";
      }
        DLOG(INFO) << "libosmesa.so not found";
        LOG(ERROR) << "OpenGL framework not found";
      if (!PathService::Get(base::DIR_MODULE, &module_path)) {
        LOG(ERROR) << "PathService::Get failed.";
      }
        DLOG(INFO) << "osmesa.dll not found";
        LOG(ERROR) << "libegl.dll not found.";
  if (ring_buffer_.get()) {
    LOG(ERROR) << "CommandBufferService::Initialize "
               << "failed because already initialized.";
  }
  if (size <= 0 || size > kMaxCommandBufferSize) {
    LOG(ERROR) << "CommandBufferService::Initialize "
               << "because command buffer size was invalid.";
  }

  LOG(ERROR) << "CommandBufferService::Initialize failed because ring buffer "
             << "could not be created or mapped ";

  if (max_vertex_attribs_ < kGLES2RequiredMinimumVertexAttribs) {
    LOG(ERROR) << "ContextGroup::Initialize failed because too few "
               << "vertex attributes supported.";
  }
  if (max_texture_units_ < kGLES2RequiredMinimumTextureUnits) {
    LOG(ERROR) << "ContextGroup::Initialize failed because too few "
               << "texture units supported.";
  }
    LOG(ERROR) << "Context::Group::Initialize failed because texture manager "
               << "failed to initialize.";
    LOG(ERROR) << "GLES2DecoderImpl::Initialize failed because "
               << "MakeCurrent failed.";
    LOG(ERROR) << "GLES2DecoderImpl::Initialize failed becaue "
               << "ContextGroup failed to initialize.";
  if (depth24_stencil8_oes_supported_) {
    LOG(INFO) << "GL_OES_packed_depth_stencil supported.";
  } else {
    LOG(INFO) << "GL_OES_packed_depth_stencil not supported.";
  }
      LOG(ERROR) << "Could not allocate offscreen buffer storage.";
        LOG(ERROR) << "Could not initialize vertex shader translator.";
        LOG(ERROR) << "Could not initialize fragment shader translator.";
    LOG(ERROR) << "GLES2DecoderImpl::UpdateOffscreenFrameBufferSize failed "
               << "to allocate storage for offscreen target buffer.";
      LOG(ERROR) << "GLES2DecoderImpl::UpdateOffscreenFrameBufferSize failed "
                 << "to allocate storage for offscreen target depth buffer.";
      LOG(ERROR) << "GLES2DecoderImpl::UpdateOffscreenFrameBufferSize failed "
                 << "to allocate storage for offscreen target stencil buffer.";
      LOG(ERROR) << "GLES2DecoderImpl::UpdateOffscreenFrameBufferSize failed "
                 << "to allocate storage for offscreen target "
                 << "depth stencil buffer.";
      LOG(ERROR) << "GLES2DecoderImpl::UpdateOffscreenFrameBufferSize failed "
                 << "because offscreen FBO was incomplete.";
        LOG(ERROR) << "GLES2DecoderImpl::UpdateOffscreenFrameBufferSize failed "
                   << "because offscreen FBO was incomplete prior ro clearing "
                   << "offscreen saved texture.";
    LOG(ERROR) << last_error_;
    if (!UpdateOffscreenFrameBufferSize()) {
      LOG(ERROR) << "Context lost because reallocation of offscreen FBO "
                 << "failed.";
    }
    if (!context_->SwapBuffers()) {
      LOG(ERROR) << "Context lost because SwapBuffers failed.";
    }
    LOG(ERROR) << "GPUProcessor::InitializeCommon failed because decoder "
               << "failed to initialize.";
    if (!decoder_->MakeCurrent()) {
      LOG(ERROR) << "Context lost because MakeCurrent failed.";
      command_buffer_->SetParseError(error::kLostContext);
    }
  if (!context.get()) {
    LOG(ERROR) << "GPUProcessor::Initialize failed";
  }
      LOG(ERROR) << "GPUProcessor::Initialize failed to "
                 << "initialize AcceleratedSurface.";
    , m_currentSpeechUtterance(nullptr)
    return m_currentSpeechUtterance;
void SpeechSynthesis::startSpeakingImmediately(SpeechSynthesisUtterance* utterance)
    ASSERT(!m_currentSpeechUtterance);
    m_currentSpeechUtterance = utterance;
    // If the queue was empty, speak this immediately and add it to the queue.
        startSpeakingImmediately(utterance);
    // Remove all the items from the utterance queue.
    // Hold on to the current utterance so the platform synthesizer can have a chance to clean up.
    RefPtrWillBeMember<SpeechSynthesisUtterance> current = m_currentSpeechUtterance;
    current = nullptr;

    // The platform should have called back immediately and cleared the current utterance.
    ASSERT(!m_currentSpeechUtterance);
    if (!m_currentSpeechUtterance)
    ASSERT(m_currentSpeechUtterance);
    m_currentSpeechUtterance = nullptr;
    if (m_utteranceQueue.size()) {
        RefPtrWillBeMember<SpeechSynthesisUtterance> firstUtterance = m_utteranceQueue.first();
        ASSERT(firstUtterance == utterance);
        if (firstUtterance == utterance)
            m_utteranceQueue.removeFirst();

        // Start the next job if there is one pending.
        if (!m_utteranceQueue.isEmpty())
            startSpeakingImmediately(m_utteranceQueue.first().get());
    }
    visitor->trace(m_currentSpeechUtterance);
    void startSpeakingImmediately(SpeechSynthesisUtterance*);
    RawPtrWillBeMember<SpeechSynthesisUtterance> m_currentSpeechUtterance;
    client()->speakingErrorOccurred(m_utterance);
    m_utterance = nullptr;
#include "core/frame/UseCounter.h"
        if (resource && resource->mimeType().lower().startsWith("image/")) {
            contextDocument->addConsoleMessage(ConsoleMessage::create(SecurityMessageSource, ErrorMessageLevel, "Refused to execute script from '" + resource->url().elidedString() + "' because its MIME type ('" + resource->mimeType() + "') is not executable."));
            UseCounter::count(frame, UseCounter::BlockedSniffingImageToScript);
            return;
        }

        BlockedSniffingImageToScript = 674,
  if (context_->is_valid())
  context_->Invalidate();
// A gin::Runner that delegates to its ScriptContext.
class ScriptContext::Runner : public gin::Runner {
 public:
  explicit Runner(ScriptContext* context);

  // gin::Runner overrides.
  void Run(const std::string& source,
           const std::string& resource_name) override;
  v8::Handle<v8::Value> Call(v8::Handle<v8::Function> function,
                             v8::Handle<v8::Value> receiver,
                             int argc,
                             v8::Handle<v8::Value> argv[]) override;
  gin::ContextHolder* GetContextHolder() override;

 private:
  ScriptContext* context_;
};

      url_(web_frame_ ? GetDataSourceURLForFrame(web_frame_) : GURL()),
      runner_(new Runner(this)) {
  gin::PerContextData::From(v8_context)->set_runner(runner_.get());
  runner_.reset();
ScriptContext::Runner::Runner(ScriptContext* context) : context_(context) {
}
void ScriptContext::Runner::Run(const std::string& source,
                                const std::string& resource_name) {
  context_->module_system()->RunString(source, resource_name);
}

v8::Handle<v8::Value> ScriptContext::Runner::Call(
    v8::Handle<v8::Function> function,
    v8::Handle<v8::Value> receiver,
    int argc,
    v8::Handle<v8::Value> argv[]) {
  return context_->CallFunction(function, argc, argv);
}

gin::ContextHolder* ScriptContext::Runner::GetContextHolder() {
  v8::HandleScope handle_scope(context_->isolate());
  return gin::PerContextData::From(context_->v8_context())->context_holder();
}

class ScriptContext : public RequestSender::Source {
  class Runner;

  scoped_ptr<Runner> runner_;

// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/module_system_test.h"
#include "extensions/renderer/script_context.h"
#include "gin/per_context_data.h"
#include "gin/runner.h"

namespace extensions {

using ScriptContextTest = ModuleSystemTest;

TEST_F(ScriptContextTest, GinRunnerLifetime) {
  ExpectNoAssertionsMade();
  base::WeakPtr<gin::Runner> weak_runner =
      gin::PerContextData::From(env()->context()->v8_context())
          ->runner()
          ->GetWeakPtr();
  env()->ShutdownModuleSystem();
  EXPECT_FALSE(weak_runner);
}

}  // namespace extensions
                                      NULL);
  localized_strings->SetString("deleteCookiesFlashCheckbox",
      l10n_util::GetStringUTF16(IDS_DEL_COOKIES_FLASH_CHKBOX));
    if (*clear_plugin_lso_data_enabled_)
#include "chrome/browser/prefs/pref_member.h"
  // Keeps track of whether clearing LSO data is supported.
  BooleanPrefMember clear_plugin_lso_data_enabled_;
    { "cookies_clear_when_close", IDS_COOKIES_CLEAR_WHEN_CLOSE_CHKBOX },
    { "cookies_lso_clear_when_close", IDS_COOKIES_LSO_CLEAR_WHEN_CLOSE_CHKBOX },
#include "chrome/browser/browser_process.h"
#include "chrome/common/pref_names.h"
void CoreOptionsHandler::Initialize() {
  clear_plugin_lso_data_enabled_.Init(prefs::kClearPluginLSODataEnabled,
                                      g_browser_process->local_state(),
                                      this);
  UpdateClearPluginLSOData();
}

void CoreOptionsHandler::UpdateClearPluginLSOData() {
  scoped_ptr<Value> enabled(
      Value::CreateBooleanValue(clear_plugin_lso_data_enabled_.GetValue()));
  web_ui_->CallJavascriptFunction(
      "OptionsPage.setClearPluginLSODataEnabled", *enabled);
}

  if (*pref_name == prefs::kClearPluginLSODataEnabled) {
    // This preference is stored in Local State, not in the user preferences.
    UpdateClearPluginLSOData();
    return;
  }

#include "chrome/browser/plugin_data_remover_helper.h"
  virtual void Initialize();
  void UpdateClearPluginLSOData();

  // Used for asynchronously updating the preference stating whether clearing
  // LSO data is supported.
  PluginDataRemoverHelper clear_plugin_lso_data_enabled_;

  virtual void SetUpOnMainThread() {
    mock_core_options_handler_.reset(new StrictMock<MockCoreOptionsHandler>());
  }

  virtual void CleanUpOnMainThread() {
    mock_core_options_handler_.reset();
  }

    return mock_core_options_handler_.get();
  scoped_ptr<StrictMock<MockCoreOptionsHandler> > mock_core_options_handler_;
  EXPECT_CALL(*mock_core_options_handler_,
// Whether there is a Flash version installed that supports clearing LSO data.
const char kClearPluginLSODataEnabled[] = "browser.clear_lso_data_enabled";

extern const char kClearPluginLSODataEnabled[];

const KURL& WebDataSourceImpl::endOfRedirectChain() const
void WebDataSourceImpl::appendRedirect(const KURL& url)
#include "KURL.h"
        const WebCore::KURL& endOfRedirectChain() const;
        void appendRedirect(const WebCore::KURL& url);
        Vector<WebCore::KURL> m_redirectChain;
  if (webview_->client()) {
    webview_->client()->setWindowRect(
  if (webview_->client()) {
    rect = webview_->client()->rootWindowRect();
  if (!webview_->client())
    return;
  webview_->client()->didFocus();
  // If accessibility is enabled, we should notify assistive technology that
  // the active AccessibilityObject changed.
  const WebCore::Frame* frame = webview_->GetFocusedWebCoreFrame();
  if (!frame)
    return;
  WebCore::Document* doc = frame->document();
  if (doc && doc->axObjectCache()->accessibilityEnabled()) {
    WebCore::Node* focused_node = webview_->GetFocusedNode();
    if (!focused_node) {
      // Could not retrieve focused Node.
      return;

    // Retrieve the focused AccessibilityObject.
    WebCore::AccessibilityObject* focused_acc_obj =
        doc->axObjectCache()->getOrCreate(focused_node->renderer());

    // Alert assistive technology that focus changed.
    if (focused_acc_obj)
      webview_->delegate()->FocusAccessibilityObject(focused_acc_obj);
  if (webview_->client())
    webview_->client()->didBlur();
  return webview_->client() != NULL;
  if (webview_->client())
    webview_->client()->runModal();
  return webview_->client() != NULL;
  if (webview_->client()) {
        webview_->client()->windowResizerRect());
  if (webview_->client()) {
    webview_->client()->didInvalidateRect(
        webkit_glue::IntRectToWebRect(paint_rect));
  }
  if (webview_->client()) {
    webview_->client()->didScrollRect(
  if (webview_->client()) {
    WebRect window_rect = webview_->client()->windowRect();
  if (webview_->client())
    webview_->client()->didChangeCursor(cursor);
    // Got a server redirect when there is no provisional DS!
    ASSERT_NOT_REACHED();
  ASSERT(ds->hasRedirectChain());
  ds->appendRedirect(webkit_glue::WebURLToKURL(ds->request().url()));
    expected_client_redirect_src_ = KURL();
    expected_client_redirect_dest_ = KURL();
  expected_client_redirect_src_ = webkit_glue::WebURLToKURL(webframe_->url());
  expected_client_redirect_dest_ = url;
  if (expected_client_redirect_dest_.isLocalFile() &&
      expected_client_redirect_src_.protocolInHTTPFamily()) {
    expected_client_redirect_src_ = KURL();
    expected_client_redirect_dest_ = KURL();
        webkit_glue::KURLToWebURL(expected_client_redirect_src_),
        webkit_glue::KURLToWebURL(expected_client_redirect_dest_),
  ASSERT(ds);  // Should not be null when navigating to a reference fragment!
    KURL url = webkit_glue::WebURLToKURL(ds->request().url());
    KURL chain_end = ds->endOfRedirectChain();
      if (webframe_->client()) {
        webframe_->client()->didCompleteClientRedirect(
            webframe_, webkit_glue::KURLToWebURL(chain_end));
      }
      expected_client_redirect_src_ = KURL();
      expected_client_redirect_dest_ = KURL();
    ASSERT_NOT_REACHED();
  KURL url = webkit_glue::WebURLToKURL(ds->request().url());
  ASSERT(!ds->hasRedirectChain());
  if (expected_client_redirect_src_.isValid()) {
    ASSERT(expected_client_redirect_dest_.protocolIs("javascript") ||
          webframe_, webkit_glue::KURLToWebURL(expected_client_redirect_src_));
  ASSERT(next_navigation_policy_ != WebKit::WebNavigationPolicyIgnore);
  if (webview && webview->client())
    webview->client()->show(webview->initial_navigation_policy());
      KURL url = webkit_glue::WebURLToKURL(ds->request().url());
      if (url.protocolIs(webkit_glue::kBackForwardNavigationScheme)) {
  // The page cache should be disabled.
  ASSERT_NOT_REACHED();
  ASSERT_NOT_REACHED();
  ASSERT(plugin_widget_.get());
  return String();
void WebFrameLoaderClient::HandleBackForwardNavigation(const KURL& url) {
  ASSERT(url.protocolIs(webkit_glue::kBackForwardNavigationScheme));
  bool ok;
  int offset = url.lastPathComponent().toIntStrict(&ok);
  if (!ok)
#include "KURL.h"
  void HandleBackForwardNavigation(const WebCore::KURL&);
  WebCore::KURL expected_client_redirect_src_;
  WebCore::KURL expected_client_redirect_dest_;
  IPC_SYNC_MESSAGE_ROUTED3_0(PluginMsg_DidFinishLoadWithReason,
                             GURL /* url */,
                             int /* reason */,
                             intptr_t /* notify_data */)
                      GURL /* url */,
                      std::string /* result */,
void WebPluginDelegateStub::OnDidFinishLoadWithReason(
    const GURL& url, int reason, intptr_t notify_data) {
  delegate_->DidFinishLoadWithReason(url, reason, notify_data);
void WebPluginDelegateStub::OnSendJavaScriptStream(const GURL& url,
                                                   const std::string& result,
  void OnDidFinishLoadWithReason(const GURL& url, int reason,
                                 intptr_t notify_data);
  void OnSendJavaScriptStream(const GURL& url,
                              const std::string& result,
#include "webkit/api/public/WebString.h"
using WebKit::WebString;
  WebFrame* sub1_frame =
      view_->webview()->GetFrameWithName(WebString::fromUTF8("sub1"));
void WebPluginDelegateProxy::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
void WebPluginDelegateProxy::DidFinishLoadWithReason(
    const GURL& url, NPReason reason, intptr_t notify_data) {
  Send(new PluginMsg_DidFinishLoadWithReason(
      instance_id_, url, reason, notify_data));
  virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,
                                       intptr_t notify_data);
  virtual void SendJavaScriptStream(const GURL& url,
                                    const std::string& result,
    class WebDataSource;
    class WebFrame;
    class WebURL;
        // Called in response to WebPluginContainer::loadFrameRequest
        virtual void didFinishLoadingFrameRequest(
            const WebURL&, void* notifyData) = 0;
        virtual void didFailLoadingFrameRequest(
            const WebURL&, void* notifyData, const WebURLError&) = 0;

    class WebString;
    class WebURL;
    class WebURLRequest;
        // Executes a "javascript:" URL on behalf of the plugin in the context
        // of the frame containing the plugin.  Returns the result of script
        // execution, if any.
        virtual WebString executeScriptURL(const WebURL&, bool popupsAllowed) = 0;

        // Loads an URL in the specified frame (or the frame containing this
        // plugin if target is empty).  If notifyNeeded is true, then upon
        // completion, WebPlugin::didFinishLoadingFrameRequest is called if the
        // load was successful or WebPlugin::didFailLoadingFrameRequest is
        // called if the load failed.  The given notifyData is passed along to
        // the callback.
        virtual void loadFrameRequest(
            const WebURLRequest&, const WebString& target, bool notifyNeeded, void* notifyData) = 0;

/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "WebDataSourceImpl.h"

#include "WebURL.h"
#include "WebURLError.h"
#include "WebVector.h"

using namespace WebCore;

namespace WebKit {

WebPluginLoadObserver* WebDataSourceImpl::m_nextPluginLoadObserver = 0;

PassRefPtr<WebDataSourceImpl> WebDataSourceImpl::create(const ResourceRequest& request, const SubstituteData& data)
{
    return adoptRef(new WebDataSourceImpl(request, data));
}

const WebURLRequest& WebDataSourceImpl::originalRequest() const
{
    m_originalRequestWrapper.bind(DocumentLoader::originalRequest());
    return m_originalRequestWrapper;
}

const WebURLRequest& WebDataSourceImpl::request() const
{
    m_requestWrapper.bind(DocumentLoader::request());
    return m_requestWrapper;
}

const WebURLResponse& WebDataSourceImpl::response() const
{
    m_responseWrapper.bind(DocumentLoader::response());
    return m_responseWrapper;
}

bool WebDataSourceImpl::hasUnreachableURL() const
{
    return !DocumentLoader::unreachableURL().isEmpty();
}

WebURL WebDataSourceImpl::unreachableURL() const
{
    return DocumentLoader::unreachableURL();
}

void WebDataSourceImpl::redirectChain(WebVector<WebURL>& result) const
{
    result.assign(m_redirectChain);
}

WebString WebDataSourceImpl::pageTitle() const
{
    return title();
}

WebNavigationType WebDataSourceImpl::navigationType() const
{
    return toWebNavigationType(triggeringAction().type());
}

double WebDataSourceImpl::triggeringEventTime() const
{
    if (!triggeringAction().event())
        return 0.0;

    // DOMTimeStamp uses units of milliseconds.
    return triggeringAction().event()->timeStamp() / 1000.0;
}

WebDataSource::ExtraData* WebDataSourceImpl::extraData() const
{
    return m_extraData.get();
}

void WebDataSourceImpl::setExtraData(ExtraData* extraData)
{
    m_extraData.set(extraData);
}

WebNavigationType WebDataSourceImpl::toWebNavigationType(NavigationType type)
{
    switch (type) {
    case NavigationTypeLinkClicked:
        return WebNavigationTypeLinkClicked;
    case NavigationTypeFormSubmitted:
        return WebNavigationTypeFormSubmitted;
    case NavigationTypeBackForward:
        return WebNavigationTypeBackForward;
    case NavigationTypeReload:
        return WebNavigationTypeReload;
    case NavigationTypeFormResubmitted:
        return WebNavigationTypeFormResubmitted;
    case NavigationTypeOther:
    default:
        return WebNavigationTypeOther;
    }
}

WebURL WebDataSourceImpl::endOfRedirectChain() const
{
    ASSERT(!m_redirectChain.isEmpty());
    return m_redirectChain.last();
}

void WebDataSourceImpl::clearRedirectChain()
{
    m_redirectChain.clear();
}

void WebDataSourceImpl::appendRedirect(const WebURL& url)
{
    m_redirectChain.append(url);
}

void WebDataSourceImpl::setNextPluginLoadObserver(PassOwnPtr<WebPluginLoadObserver> observer)
{
    // This call should always be followed up with the creation of a
    // WebDataSourceImpl, so we should never leak this object.
    m_nextPluginLoadObserver = observer.release();
}

WebDataSourceImpl::WebDataSourceImpl(const ResourceRequest& request, const SubstituteData& data)
    : DocumentLoader(request, data)
{
    if (m_nextPluginLoadObserver) {
        // When a new frame is created, it initially gets a data source for an
        // empty document.  Then it is navigated to the source URL of the
        // frame, which results in a second data source being created.  We want
        // to wait to attach the WebPluginLoadObserver to that data source.
        if (!request.url().isEmpty()) {
            ASSERT(m_nextPluginLoadObserver->url() == request.url());
            m_pluginLoadObserver.set(m_nextPluginLoadObserver);
            m_nextPluginLoadObserver = 0;
        }
    }
}

WebDataSourceImpl::~WebDataSourceImpl()
{
}

} // namespace WebKit
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef WebDataSourceImpl_h
#define WebDataSourceImpl_h

// FIXME: This relative path is a temporary hack to support using this
// header from webkit/glue.
#include "../public/WebDataSource.h"
#include "WebPluginLoadObserver.h"
#include "WrappedResourceRequest.h"
#include "WrappedResourceResponse.h"

#include "DocumentLoader.h"
#include <wtf/PassOwnPtr.h>
#include <wtf/OwnPtr.h>
#include <wtf/Vector.h>

namespace WebKit {
    class WebPluginLoadObserver;

    class WebDataSourceImpl : public WebCore::DocumentLoader, public WebDataSource {
    public:
        static PassRefPtr<WebDataSourceImpl> create(const WebCore::ResourceRequest&,
                                                    const WebCore::SubstituteData&);

        static WebDataSourceImpl* fromDocumentLoader(WebCore::DocumentLoader* loader)
        {
            return static_cast<WebDataSourceImpl*>(loader);
        }

        // WebDataSource methods:
        virtual const WebURLRequest& originalRequest() const;
        virtual const WebURLRequest& request() const;
        virtual const WebURLResponse& response() const;
        virtual bool hasUnreachableURL() const;
        virtual WebURL unreachableURL() const;
        virtual void redirectChain(WebVector<WebURL>&) const;
        virtual WebString pageTitle() const;
        virtual WebNavigationType navigationType() const;
        virtual double triggeringEventTime() const;
        virtual ExtraData* extraData() const;
        virtual void setExtraData(ExtraData*);

        static WebNavigationType toWebNavigationType(WebCore::NavigationType type);

        bool hasRedirectChain() const { return !m_redirectChain.isEmpty(); }
        WebURL endOfRedirectChain() const;
        void clearRedirectChain();
        void appendRedirect(const WebURL& url);

        PassOwnPtr<WebPluginLoadObserver> releasePluginLoadObserver() { return m_pluginLoadObserver.release(); }
        static void setNextPluginLoadObserver(PassOwnPtr<WebPluginLoadObserver>);

    private:
        WebDataSourceImpl(const WebCore::ResourceRequest&, const WebCore::SubstituteData&);
        ~WebDataSourceImpl();

        // Mutable because the const getters will magically sync these to the
        // latest version from WebKit.
        mutable WrappedResourceRequest m_originalRequestWrapper;
        mutable WrappedResourceRequest m_requestWrapper;
        mutable WrappedResourceResponse m_responseWrapper;

        // Lists all intermediate URLs that have redirected for the current provisional load.
        // See WebFrameLoaderClient::dispatchDidReceiveServerRedirectForProvisionalLoad for a
        // description of who modifies this when to keep it up to date.
        Vector<WebURL> m_redirectChain;

        OwnPtr<ExtraData> m_extraData;
        OwnPtr<WebPluginLoadObserver> m_pluginLoadObserver;

        static WebPluginLoadObserver* m_nextPluginLoadObserver;
    };

} // namespace WebKit

#endif  // WebDataSourceImpl_h
#include "WebDataSourceImpl.h"
#include "WebURLRequest.h"
#include "FormState.h"
#include "FrameLoadRequest.h"
#include "HTMLFormElement.h"
WebString WebPluginContainerImpl::executeScriptURL(const WebURL& url, bool popupsAllowed)
{
    Frame* frame = m_element->document()->frame();
    if (!frame)
        return WebString();

    const KURL& kurl = url;
    ASSERT(kurl.protocolIs("javascript"));

    String script = decodeURLEscapeSequences(
        kurl.string().substring(strlen("javascript:")));

    ScriptValue result = frame->loader()->executeScript(script, popupsAllowed);

    // Failure is reported as a null string.
    String resultStr;
    result.getString(resultStr);
    return resultStr;
}

void WebPluginContainerImpl::loadFrameRequest(
    const WebURLRequest& request, const WebString& target, bool notifyNeeded, void* notifyData)
{
    Frame* frame = m_element->document()->frame();
    if (!frame)
        return;  // FIXME: send a notification in this case?

    if (notifyNeeded) {
        // FIXME: This is a bit of hack to allow us to observe completion of
        // our frame request.  It would be better to evolve FrameLoader to
        // support a completion callback instead.
        WebDataSourceImpl::setNextPluginLoadObserver(
            new WebPluginLoadObserver(this, request.url(), notifyData));
    }

    FrameLoadRequest frameRequest(request.toResourceRequest());
    frameRequest.setFrameName(target);

    frame->loader()->loadFrameRequest(
        frameRequest,
        false,  // lock history
        false,  // lock back forward list
        0,      // event
        0);     // form state
}

void WebPluginContainerImpl::willDestroyPluginLoadObserver(WebPluginLoadObserver* observer)
{
    size_t pos = m_pluginLoadObservers.find(observer);
    if (pos == notFound)
        return;
    m_pluginLoadObservers.remove(pos);
}

    class WebPluginLoadObserver;
        virtual WebString executeScriptURL(const WebURL&, bool popupsAllowed);
        virtual void loadFrameRequest(const WebURLRequest&, const WebString& target, bool notifyNeeded, void* notifyData);
        // This cannot be null.
        WebPlugin* plugin() { return m_webPlugin; }

        void willDestroyPluginLoadObserver(WebPluginLoadObserver*);

        Vector<WebPluginLoadObserver*> m_pluginLoadObservers;
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "WebPluginLoadObserver.h"

#include "WebPlugin.h"
#include "WebPluginContainerImpl.h"

namespace WebKit {

WebPluginLoadObserver::~WebPluginLoadObserver()
{
    if (m_pluginContainer)
        m_pluginContainer->willDestroyPluginLoadObserver(this);
}

void WebPluginLoadObserver::didFinishLoading()
{
    if (m_pluginContainer)
        m_pluginContainer->plugin()->didFinishLoadingFrameRequest(m_notifyURL, m_notifyData);
}

void WebPluginLoadObserver::didFailLoading(const WebURLError& error)
{
    if (m_pluginContainer)
        m_pluginContainer->plugin()->didFailLoadingFrameRequest(m_notifyURL, m_notifyData, error);
}

} // namespace WebKit
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef WebPluginLoadObserver_h
#define WebPluginLoadObserver_h

#include "../public/WebURL.h"

namespace WebKit {
    class WebPluginContainerImpl;
    struct WebURLError;

    class WebPluginLoadObserver {
    public:
        WebPluginLoadObserver(WebPluginContainerImpl* pluginContainer,
                              const WebURL& notifyURL, void* notifyData)
            : m_pluginContainer(pluginContainer)
            , m_notifyURL(notifyURL)
            , m_notifyData(notifyData)
        {
        }

        ~WebPluginLoadObserver();

        const WebURL& url() const { return m_notifyURL; }

        void clearPluginContainer() { m_pluginContainer = 0; }
        void didFinishLoading();
        void didFailLoading(const WebURLError&);

    private:
        WebPluginContainerImpl* m_pluginContainer;
        WebURL m_notifyURL;
        void* m_notifyData;
    };

} // namespace WebKit

#endif
#include "webkit/api/src/WebDataSourceImpl.h"
using WebKit::WebDataSourceImpl;
      WebDataSource* ds = WebDataSourceImpl::fromDocumentLoader(dl);
  WebDataSource* ds = WebDataSourceImpl::fromDocumentLoader(dl);
#include "webkit/api/public/WebString.h"
using WebKit::WebString;
  WebFrame* iframe =
      test_shell_->webView()->GetFrameWithName(WebString::fromUTF8("ifr"));
void PluginInstance::DidFinishLoadWithReason(const GURL& url, NPReason reason,
                                             void* notify_data) {
  NPP_URLNotify(url.spec().c_str(), reason, notify_data);
void PluginInstance::SendJavaScriptStream(const GURL& url,
                                          const std::string& result,
    stream->SendToPlugin(result, "text/html");
      this->NPP_URLNotify(url.spec().c_str(), NPRES_DONE,
  virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,
                                       void* notify_data);
  void SendJavaScriptStream(const GURL& url, const std::string& result,
#include "googleurl/src/gurl.h"

    PluginInstance* instance,
    const GURL& url,
    void* notify_data)
    : PluginStream(instance, url.spec().c_str(), notify_needed, notify_data) {
#ifndef WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H_
#define WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H_
class GURL;

  PluginStringStream(PluginInstance* instance,
                     const GURL& url,
                     void* notify_data);
  void SendToPlugin(const std::string& data,
                    const std::string& mime_type);
  DISALLOW_COPY_AND_ASSIGN(PluginStringStream);
#endif // WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H_
void WebPluginDelegateImpl::DidFinishLoadWithReason(const GURL& url,
                                                    NPReason reason,
                                                    intptr_t notify_data) {
  instance()->DidFinishLoadWithReason(
      url, reason, reinterpret_cast<void*>(notify_data));
void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                 const std::string& result,
  virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,
                                       intptr_t notify_data);
  virtual void SendJavaScriptStream(const GURL& url,
                                    const std::string& result,
#include "webkit/api/src/WebDataSourceImpl.h"
using WebKit::WebDataSourceImpl;
  return loader ? WebDataSourceImpl::fromDocumentLoader(loader) : NULL;
namespace WebKit {
class WebDataSourceImpl;
}

  WebKit::WebDataSourceImpl* GetDataSourceImpl() const;
  WebKit::WebDataSourceImpl* GetProvisionalDataSourceImpl() const;
#include "webkit/api/src/WebDataSourceImpl.h"
#include "webkit/api/src/WebPluginLoadObserver.h"
using WebKit::WebDataSourceImpl;
using WebKit::WebPluginLoadObserver;
      WebDataSourceImpl::fromDocumentLoader(documentLoader);
  DCHECK(ds->hasRedirectChain());
  ds->appendRedirect(ds->request().url());
    GURL chain_end = ds->endOfRedirectChain();
    ds->clearRedirectChain();
      ds->appendRedirect(chain_end);
    ds->appendRedirect(url);
  DCHECK(!ds->hasRedirectChain());
    ds->appendRedirect(expected_client_redirect_src_);
  ds->appendRedirect(url);
  // TODO(darin): This means the plugin won't receive NPP_URLNotify, which
  // seems like it could result in a memory leak in the plugin!!
    return;

  OwnPtr<WebPluginLoadObserver> plugin_load_observer = GetPluginLoadObserver();
  webframe_->DidFail(error, true);
  if (plugin_load_observer)
    plugin_load_observer->didFailLoading(error);
  OwnPtr<WebPluginLoadObserver> plugin_load_observer = GetPluginLoadObserver();
  if (plugin_load_observer)
    plugin_load_observer->didFailLoading(error);
  OwnPtr<WebPluginLoadObserver> plugin_load_observer = GetPluginLoadObserver();

  if (plugin_load_observer)
    plugin_load_observer->didFinishLoading();
        bool is_redirect = ds->hasRedirectChain();
            WebDataSourceImpl::toWebNavigationType(action.type());
  OwnPtr<WebPluginLoadObserver> plugin_load_observer = GetPluginLoadObserver();
  if (plugin_load_observer)
    plugin_load_observer->didFinishLoading();

  RefPtr<WebDataSourceImpl> ds = WebDataSourceImpl::create(request, data);

PassOwnPtr<WebPluginLoadObserver> WebFrameLoaderClient::GetPluginLoadObserver() {
  WebDataSourceImpl* ds = WebDataSourceImpl::fromDocumentLoader(
      webframe_->frame()->loader()->activeDocumentLoader());
  return ds->releasePluginLoadObserver();
}
#include <wtf/PassOwnPtr.h>
class WebPluginLoadObserver;
  virtual WebCore::ObjectContentType objectContentType(
      const WebCore::KURL& url, const WebCore::String& mimeType);
  PassOwnPtr<WebKit::WebPluginLoadObserver> GetPluginLoadObserver();

#include "base/string16.h"
  virtual void DidFinishLoadWithReason(const GURL& url, NPReason reason,
                                       intptr_t notify_data) = 0;
  // The result, UTF-8 encoded, of the script execution is returned via this
  // function.
  virtual void SendJavaScriptStream(const GURL& url,
                                    const std::string& result,
#include "webkit/api/public/WebConsoleMessage.h"
using WebKit::WebConsoleMessage;
using WebKit::WebDataSource;
using WebKit::WebFrame;
using WebKit::WebURL;
void WebPluginImpl::didFinishLoadingFrameRequest(
    const WebURL& url, void* notify_data) {
  if (delegate_) {
    delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
  }
}

void WebPluginImpl::didFailLoadingFrameRequest(
    const WebURL& url, void* notify_data, const WebURLError& error) {
  // TODO(darin): Map net::ERR_ABORTED to NPRES_USER_BREAK?
  if (delegate_) {
    delegate_->DidFinishLoadWithReason(
        url, NPRES_NETWORK_ERR, reinterpret_cast<intptr_t>(notify_data));
  }
}

                                          bool notify_needed,
                                          intptr_t notify_data,
                                          const char* url, GURL* unused) {
  if (!webframe_)
  WebString target_str = WebString::fromUTF8(target);

    WebFrame* target_frame = webframe_->view()->GetFrameWithName(target_str);
    if (target_frame != webframe_) {
      // TODO(darin): Localize this message.
      const char kMessage[] =
          "Ignoring cross-frame javascript URL load requested by plugin.";
      webframe_->addMessageToConsole(
          WebConsoleMessage(WebConsoleMessage::LevelError,
                            WebString::fromUTF8(kMessage)));
  container_->loadFrameRequest(request, target_str, notify_needed,
                               reinterpret_cast<void*>(notify_data));
                                    buf, is_file_data, notify, notify_data,
                                    url, &complete_url);
  if (routing_status == ROUTED)
    GURL gurl(url);
    WebString result = container_->executeScriptURL(gurl, popups_allowed);

    // delegate_ could be NULL because executeScript caused the container to
    // be deleted.
    if (delegate_) {
      delegate_->SendJavaScriptStream(
          gurl, result.utf8(), !result.isNull(), notify, notify_data);
    }
  virtual void didFinishLoadingFrameRequest(
      const WebKit::WebURL& url, void* notify_data);
  virtual void didFailLoadingFrameRequest(
      const WebKit::WebURL& url, void* notify_data,
      const WebKit::WebURLError& error);
  // plugin as is. This avoids having to track the notification arguments in
  // the plugin process.
                     bool notify_needed, intptr_t notify_data,
                     bool popups_allowed);
  // Given a download request, check if we need to route the output to a frame.
  // Returns ROUTED if the load is done and routed to a frame, NOT_ROUTED or
  // corresponding error codes otherwise.
  RoutingStatus RouteToFrame(const char* method, bool is_javascript_url,
                             const char* buf, bool is_file_data,
                             bool notify_needed, intptr_t notify_data,
  virtual WebKit::WebFrame* GetFrameWithName(const WebKit::WebString& name) = 0;
WebFrame* WebViewImpl::GetFrameWithName(const WebString& name) {
  String name_str = webkit_glue::WebStringToString(name);
  virtual WebKit::WebFrame* GetFrameWithName(const WebKit::WebString& name);
#include "webkit/api/src/WebDataSourceImpl.h"
    static_cast<WebKit::WebDataSourceImpl*>(ds)->
        setDeferMainResourceDataLoad(false);
  if (!entry.GetTargetFrame().empty()) {
      frame = webView()->GetFrameWithName(
          WideToUTF16Hack(entry.GetTargetFrame()));
  }
#include "chrome/browser/ui/webui/options/options_managed_banner_handler.h"
#include "chrome/browser/ui/webui/options/core_options_handler.h"
#include "chrome/browser/ui/webui/options/language_options_handler.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/content_settings_handler.h"
#include "chrome/browser/ui/webui/options/about_page_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#include "chrome/browser/ui/webui/options/add_startup_page_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#include "chrome/browser/ui/webui/options/advanced_options_handler.h"
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#include "chrome/browser/ui/webui/options/options_managed_banner_handler.h"
#include "chrome/browser/ui/webui/options/advanced_options_utils.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#include "chrome/browser/ui/webui/options/advanced_options_utils.h"
#include "chrome/browser/ui/webui/options/advanced_options_utils.h"
#include "chrome/browser/ui/webui/options/autofill_options_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/browser_options_handler.h"
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#include "chrome/browser/ui/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/certificate_manager_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/clear_browser_data_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#include "chrome/browser/ui/webui/options/content_settings_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#include "chrome/browser/ui/webui/options/cookies_view_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#include "chrome/browser/ui/webui/options/core_options_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#include "chrome/browser/ui/webui/options/font_settings_handler.h"
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#include "chrome/browser/ui/webui/options/font_settings_utils.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#include "chrome/browser/ui/webui/options/font_settings_utils.h"
#include "chrome/browser/ui/webui/options/font_settings_utils.h"
#include "chrome/browser/ui/webui/options/import_data_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#include "chrome/browser/ui/webui/options/language_options_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/language_options_handler_common.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/language_options_handler_common.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#include "chrome/browser/ui/webui/options/language_options_handler.h"
#include "chrome/browser/ui/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/about_page_handler.h"
#include "chrome/browser/ui/webui/options/add_startup_page_handler.h"
#include "chrome/browser/ui/webui/options/advanced_options_handler.h"
#include "chrome/browser/ui/webui/options/autofill_options_handler.h"
#include "chrome/browser/ui/webui/options/browser_options_handler.h"
#include "chrome/browser/ui/webui/options/clear_browser_data_handler.h"
#include "chrome/browser/ui/webui/options/content_settings_handler.h"
#include "chrome/browser/ui/webui/options/cookies_view_handler.h"
#include "chrome/browser/ui/webui/options/core_options_handler.h"
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#include "chrome/browser/ui/webui/options/font_settings_handler.h"
#include "chrome/browser/ui/webui/options/import_data_handler.h"
#include "chrome/browser/ui/webui/options/language_options_handler.h"
#include "chrome/browser/ui/webui/options/password_manager_handler.h"
#include "chrome/browser/ui/webui/options/personal_options_handler.h"
#include "chrome/browser/ui/webui/options/search_engine_manager_handler.h"
#include "chrome/browser/ui/webui/options/stop_syncing_handler.h"
#include "chrome/browser/ui/webui/options/certificate_manager_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_UI_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_UI_H_
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_UI_H_
#include "chrome/browser/ui/webui/options/password_manager_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/personal_options_handler.h"
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#include "chrome/browser/ui/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/search_engine_manager_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/stop_syncing_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#include "chrome/browser/ui/webui/options/core_options_handler.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
  ASSERT_TRUE(shared_buf.Create("", false, true, bytes));
  if (!dib->shared_memory_.Create("", false /* read write */,
  if (!dib->shared_memory_.Create("", false /* read write */,
  bool Create(const std::string& name, bool read_only, bool open_existing,
  bool Delete(const std::string& name);
  bool Open(const std::string& name, bool read_only);
  bool CreateOrOpen(const std::string& name, int posix_flags, uint32 size);
  bool FilePathForMemoryName(const std::string& mem_name, FilePath* path);
bool SharedMemory::Create(const std::string& name, bool read_only,
bool SharedMemory::Delete(const std::string& name) {
bool SharedMemory::Open(const std::string& name, bool read_only) {
// For the given shmem named |mem_name|, return a filename to mmap()
bool SharedMemory::FilePathForMemoryName(const std::string& mem_name,
  DCHECK(mem_name.find('/') == std::string::npos);
  DCHECK(mem_name.find('\0') == std::string::npos);
  if (!file_util::GetShmemTempDir(&temp_dir))
  *path = temp_dir.AppendASCII("com.google.chrome.shmem." + mem_name);
bool SharedMemory::CreateOrOpen(const std::string& name,
  if (name.empty()) {
  static const char* const s_test_name_;
const char* const MultipleThreadMain::s_test_name_ =
    "SharedMemoryOpenThreadTest";
      EXPECT_TRUE(memory1.Create("SharedMemoryMultipleLockThreadTest",
  std::string test_name = "SharedMemoryOpenCloseTest";
    rv = memories[i].Create("", false, true, kDataSize);
  static const char* const s_test_name_;
const char* const SharedMemoryProcessTest::s_test_name_ = "MPMem";
#include "base/utf_string_conversions.h"
bool SharedMemory::Create(const std::string& name, bool read_only,
  name_ = ASCIIToWide(name);
      name_.empty() ? NULL : name_.c_str());
bool SharedMemory::Delete(const std::string& name) {
bool SharedMemory::Open(const std::string& name, bool read_only) {
  name_ = ASCIIToWide(name);
      name_.empty() ? NULL : name_.c_str());
  if (!priv->shared_memory_.Create(name, false, true, size))
  void DeleteShmem(const std::string& name) {
    mem.Delete(name);
  if (!shared_memory->Create(std::string(),  // anonymous
    if (shared_memory_.Create(std::string(), false, false, buffer_size_) &&
  if (!entry->shared_memory.Create("", false, false, hardware_packet_size) ||
    if (shm.Create("", false, false, shm_size))
  if (!shared_memory->Create("", false /* read write */,
  shared_buf.Create("", false, false, buffer_size);
  if (!shared_memory_->Create(std::string() /* anonymous */,
      EXPECT_TRUE(shared_mem.Create(std::string(), false, false,
                                    test_page_contents_len));
    EXPECT_EQ(true, shared_handle_.Create("DeferredResourceLoaderTest", false,
  if (!input_transfer_buffer_->Create(std::string(), false, false, size))
  if (!shared_buf->Create(std::string(), false, false, size)) {
    CHECK(shared_mem_.Create("", false, false, kSize));
  shared_buf.Create("", false, false, buffer_size);
    if (shared_buf.Create("", false, false, buf_size) &&
      "", false /* read write */, true /* open existing */, buf_size);
  ASSERT_TRUE(shared_memory.Create(std::string(), false, false, body.size()));
  memory.Delete(filename);
  if (ring_buffer_->Create(std::string(), false, false, size)) {
  if (!buffer->Create(std::string(), false, false, size))
    shared_memory_->Create(std::string(), false, false, kRingBufferSize);
  memory.Delete(filename);
#ifndef CHROME_BROWSER_CERT_STORE_H_
#define CHROME_BROWSER_CERT_STORE_H_
#endif  // CHROME_BROWSER_CERT_STORE_H_
#include "base/logging.h"
#include "chrome/browser/page_load_tracker.h"

#include "chrome/common/gfx/chrome_font.h"
#include "base/stats_counters.h"

#ifndef CHROME_COMMON_CHROME_COUNTERS_H_
#define CHROME_COMMON_CHROME_COUNTERS_H_
class StatsCounter;
class StatsCounterTimer;
class StatsRate;
#endif  // CHROME_COMMON_CHROME_COUNTERS_H_
#include <limits>

#include "chrome/common/gfx/chrome_font.h"
#include "chrome/common/l10n_util.h"
  shader_scale.postTranslate(SkIntToScalar(dest_x - src_x),
                             SkIntToScalar(dest_y - src_y));
void ChromeCanvas::DrawStringInt(const std::wstring& text,
                                 const ChromeFont& font,
                                 const SkColor& color,
                                 int x, int y,
                                 int w, int h) {
  DrawStringInt(text, font, color, x, y, w, h,
                l10n_util::DefaultCanvasTextAlignment());
}

#ifndef CHROME_COMMON_GFX_CHROME_CANVAS_H_
#define CHROME_COMMON_GFX_CHROME_CANVAS_H_
class ChromeFont;
                     const SkColor& color, int x, int y, int w, int h);
  // aligned to the left, vertically centered, clipped to the region. If the
  // text is too big, it is truncated and '...' is added to the end.
#endif  // CHROME_COMMON_GFX_CHROME_CANVAS_H_
#include "SkBitmap.h"
namespace {

struct SkBitmap_Data {
  // The configuration for the bitmap (bits per pixel, etc).
  SkBitmap::Config fConfig;

  // The width of the bitmap in pixels.
  uint32 fWidth;

  // The height of the bitmap in pixels.
  uint32 fHeight;

  // The number of bytes between subsequent rows of the bitmap.
  uint32 fRowBytes;

  void InitSkBitmapDataForTransfer(const SkBitmap& bitmap) {
    fConfig = bitmap.config();
    fWidth = bitmap.width();
    fHeight = bitmap.height();
    fRowBytes = bitmap.rowBytes();
  }

  void InitSkBitmapFromData(SkBitmap* bitmap, const char* pixels,
                            size_t total_pixels) const {
    if (total_pixels) {
      bitmap->setConfig(fConfig, fWidth, fHeight, fRowBytes);
      bitmap->allocPixels();
      memcpy(bitmap->getPixels(), pixels, total_pixels);
    }
  }
};

struct WebCursor_Data {
  WebCursor::Type cursor_type;
  int hotspot_x;
  int hotspot_y;
  SkBitmap_Data bitmap_info;
};

}  // namespace


void ParamTraits<SkBitmap>::Write(Message* m, const SkBitmap& p) {
  size_t fixed_size = sizeof(SkBitmap_Data);
  SkBitmap_Data bmp_data;
  bmp_data.InitSkBitmapDataForTransfer(p);
  m->WriteData(reinterpret_cast<const char*>(&bmp_data),
               static_cast<int>(fixed_size));
  size_t pixel_size = p.getSize();
  SkAutoLockPixels p_lock(p);
  m->WriteData(reinterpret_cast<const char*>(p.getPixels()),
               static_cast<int>(pixel_size));
}

bool ParamTraits<SkBitmap>::Read(const Message* m, void** iter, SkBitmap* r) {
  const char* fixed_data;
  int fixed_data_size = 0;
  if (!m->ReadData(iter, &fixed_data, &fixed_data_size) ||
     (fixed_data_size <= 0)) {
    NOTREACHED();
    return false;
  }
  if (fixed_data_size != sizeof(SkBitmap_Data))
    return false;  // Message is malformed.

  const char* variable_data;
  int variable_data_size = 0;
  if (!m->ReadData(iter, &variable_data, &variable_data_size) ||
     (variable_data_size < 0)) {
    NOTREACHED();
    return false;
  }
  const SkBitmap_Data* bmp_data =
      reinterpret_cast<const SkBitmap_Data*>(fixed_data);
  bmp_data->InitSkBitmapFromData(r, variable_data, variable_data_size);
  return true;
}

void ParamTraits<SkBitmap>::Log(const SkBitmap& p, std::wstring* l) {
  l->append(StringPrintf(L"<SkBitmap>"));
}


  l->append(StringPrintf(L"(%d, %d, %d, %d)", p.x(), p.y(),
                         p.width(), p.height()));
#ifndef CHROME_COMMON_IPC_MESSAGE_UTILS_H_
#define CHROME_COMMON_IPC_MESSAGE_UTILS_H_
class SkBitmap;
  explicit MessageIterator(const Message& m) : msg_(m), iter_(NULL) {
    m->WriteData(reinterpret_cast<const char*>(&p), sizeof(param_type));
    if (result && data_size == sizeof(param_type)) {
      memcpy(r, data, sizeof(param_type));
    m->WriteData(reinterpret_cast<const char*>(&p), sizeof(param_type));
    if (result && data_size == sizeof(param_type)) {
      memcpy(r, data, sizeof(param_type));
  static void Write(Message* m, const param_type& p);

  static bool Read(const Message* m, void** iter, param_type* r);
  static void Log(const param_type& p, std::wstring* l);
  int64 receive;  // Time before it was dispatched (i.e. before calling
                  // OnMessageReceived).
  int64 dispatch;  // Time after it was dispatched (i.e. after calling
                   // OnMessageReceived).
  explicit ParamDeserializer(const RefTuple& out) : out_(out) { }
#endif  // CHROME_COMMON_IPC_MESSAGE_UTILS_H_
#include "base/logging.h"
#include "chrome/common/stl_util-inl.h"

void SqliteStatementCache::set_db(sqlite3* db) {
  DCHECK(!db_) << "Setting the database twice";
  db_ = db;
}


SQLStatement& SqliteCompiledStatement::operator*() {
  DCHECK(statement_) << "Should check is_valid() before using the statement.";
  return *statement_;
}
SQLStatement* SqliteCompiledStatement::operator->() {
  DCHECK(statement_) << "Should check is_valid() before using the statement.";
  return statement_;
}
SQLStatement* SqliteCompiledStatement::statement() {
  DCHECK(statement_) << "Should check is_valid() before using the statement.";
  return statement_;
}
#ifndef CHROME_COMMON_SQLITE_COMPILED_STATEMENT_
#define CHROME_COMMON_SQLITE_COMPILED_STATEMENT_
  explicit SqliteStatementCache(sqlite3* db) : db_(db) {
  void set_db(sqlite3* db);
  SQLStatement& operator*();
  SQLStatement* operator->();
  SQLStatement* statement();
#endif  // CHROME_COMMON_SQLITE_COMPILED_STATEMENT_
#include "base/logging.h"



SQLTransaction::SQLTransaction(sqlite3* db) : db_(db), began_(false) {
}

SQLTransaction::~SQLTransaction() {
  if (began_) {
    Rollback();
  }
}

int SQLTransaction::BeginCommand(const char* command) {
  int rv = SQLITE_ERROR;
  if (!began_ && db_) {
    rv = sqlite3_exec(db_, command, NULL, NULL, NULL);
    began_ = (rv == SQLITE_OK);
  }
  return rv;
}

int SQLTransaction::EndCommand(const char* command) {
  int rv = SQLITE_ERROR;
  if (began_ && db_) {
    rv = sqlite3_exec(db_, command, NULL, NULL, NULL);
    began_ = (rv != SQLITE_OK);
  }
  return rv;
}

SQLNestedTransactionSite::~SQLNestedTransactionSite() {
  DCHECK(!top_transaction_);
}

void SQLNestedTransactionSite::SetTopTransaction(SQLNestedTransaction* top) {
  DCHECK(!top || !top_transaction_);
  top_transaction_ = top;
}

SQLNestedTransaction::SQLNestedTransaction(SQLNestedTransactionSite* site)
  : SQLTransaction(site->GetSqlite3DB()),
    needs_rollback_(false),
    site_(site) {
  DCHECK(site);
  if (site->GetTopTransaction() == NULL) {
    site->SetTopTransaction(this);
  }
}

SQLNestedTransaction::~SQLNestedTransaction() {
  if (began_) {
    Rollback();
  }
  if (site_->GetTopTransaction() == this) {
    site_->SetTopTransaction(NULL);
  }
}

int SQLNestedTransaction::BeginCommand(const char* command) {
  DCHECK(db_);
  DCHECK(site_ && site_->GetTopTransaction());
  if (!db_ || began_) {
    return SQLITE_ERROR;
  }
  if (site_->GetTopTransaction() == this) {
    int rv = sqlite3_exec(db_, command, NULL, NULL, NULL);
    began_ = (rv == SQLITE_OK);
    if (began_) {
      site_->OnBegin();
    }
    return rv;
  } else {
    if (site_->GetTopTransaction()->needs_rollback_) {
      return SQLITE_ERROR;
    }
    began_ = true;
    return SQLITE_OK;
  }
}

int SQLNestedTransaction::EndCommand(const char* command) {
  DCHECK(db_);
  DCHECK(site_ && site_->GetTopTransaction());
  if (!db_ || !began_) {
    return SQLITE_ERROR;
  }
  if (site_->GetTopTransaction() == this) {
    if (needs_rollback_) {
      sqlite3_exec(db_, "ROLLBACK", NULL, NULL, NULL);
      began_ = false;  // reset so we don't try to rollback or call
                       // OnRollback() again
      site_->OnRollback();
      return SQLITE_ERROR;
    } else {
      int rv = sqlite3_exec(db_, command, NULL, NULL, NULL);
      began_ = (rv != SQLITE_OK);
      if (strcmp(command, "ROLLBACK") == 0) {
        began_ = false;  // reset so we don't try to rollbck or call
                         // OnRollback() again
        site_->OnRollback();
      } else {
        DCHECK(strcmp(command, "COMMIT") == 0);
        if (rv == SQLITE_OK) {
          site_->OnCommit();
        }
      }
      return rv;
    }
  } else {
    if (strcmp(command, "ROLLBACK") == 0) {
      site_->GetTopTransaction()->needs_rollback_ = true;
    }
    began_ = false;
    return SQLITE_OK;
  }
}

int SQLStatement::prepare(sqlite3* db, const char* sql, int sql_len) {
  DCHECK(!stmt_);
  int rv = sqlite3_prepare_v2(db, sql, sql_len, &stmt_, NULL);
  if (rv != SQLITE_OK) {
    DLOG(ERROR) << "SQLStatement.prepare_v2 failed: " << sqlite3_errmsg(db);
  }
  return rv;
}

int SQLStatement::prepare16(sqlite3* db, const wchar_t* sql, int sql_len) {
  DCHECK(!stmt_);
  sql_len *= sizeof(wchar_t);
  int rv = sqlite3_prepare16_v2(db, sql, sql_len, &stmt_, NULL);
  if (rv != SQLITE_OK) {
    DLOG(ERROR) << "SQLStatement.prepare16_v2 failed: " << sqlite3_errmsg(db);
  }
  return rv;
}

int SQLStatement::step() {
  DCHECK(stmt_);
  return sqlite3_step(stmt_);
}

int SQLStatement::reset() {
  DCHECK(stmt_);
  return sqlite3_reset(stmt_);
}

sqlite_int64 SQLStatement::last_insert_rowid() {
  DCHECK(stmt_);
  return sqlite3_last_insert_rowid(db_handle());
}

sqlite3* SQLStatement::db_handle() {
  DCHECK(stmt_);
  return sqlite3_db_handle(stmt_);
}

int SQLStatement::bind_parameter_count() {
  DCHECK(stmt_);
  return sqlite3_bind_parameter_count(stmt_);
}

int SQLStatement::bind_blob(int index, std::vector<unsigned char>* blob) {
  if (blob) {
    const void* value = &(*blob)[0];
    int len = static_cast<int>(blob->size());
    return bind_blob(index, value, len);
  } else {
    return bind_null(index);
  }
}

int SQLStatement::bind_blob(int index, const void* value, int value_len) {
   return bind_blob(index, value, value_len, SQLITE_TRANSIENT);
}

int SQLStatement::bind_blob(int index, const void* value, int value_len,
                            Function dtor) {
  DCHECK(stmt_);
  return sqlite3_bind_blob(stmt_, index + 1, value, value_len, dtor);
}

int SQLStatement::bind_double(int index, double value) {
  DCHECK(stmt_);
  return sqlite3_bind_double(stmt_, index + 1, value);
}

int SQLStatement::bind_bool(int index, bool value) {
  DCHECK(stmt_);
  return sqlite3_bind_int(stmt_, index + 1, value);
}

int SQLStatement::bind_int(int index, int value) {
  DCHECK(stmt_);
  return sqlite3_bind_int(stmt_, index + 1, value);
}

int SQLStatement::bind_int64(int index, sqlite_int64 value) {
  DCHECK(stmt_);
  return sqlite3_bind_int64(stmt_, index + 1, value);
}

int SQLStatement::bind_null(int index) {
  DCHECK(stmt_);
  return sqlite3_bind_null(stmt_, index + 1);
}

int SQLStatement::bind_text(int index, const char* value, int value_len,
              Function dtor) {
  DCHECK(stmt_);
  return sqlite3_bind_text(stmt_, index + 1, value, value_len, dtor);
}

int SQLStatement::bind_text16(int index, const wchar_t* value, int value_len,
                Function dtor) {
  DCHECK(stmt_);
  value_len *= sizeof(wchar_t);
  return sqlite3_bind_text16(stmt_, index + 1, value, value_len, dtor);
}

int SQLStatement::bind_value(int index, const sqlite3_value* value) {
  DCHECK(stmt_);
  return sqlite3_bind_value(stmt_, index + 1, value);
}

int SQLStatement::column_count() {
  DCHECK(stmt_);
  return sqlite3_column_count(stmt_);
}

int SQLStatement::column_type(int index) {
  DCHECK(stmt_);
  return sqlite3_column_type(stmt_, index);
}

const wchar_t* SQLStatement::column_name16(int index) {
  DCHECK(stmt_);
  return static_cast<const wchar_t*>( sqlite3_column_name16(stmt_, index) );
}

const void* SQLStatement::column_blob(int index) {
  DCHECK(stmt_);
  return sqlite3_column_blob(stmt_, index);
}

bool SQLStatement::column_blob_as_vector(int index,
                                         std::vector<unsigned char>* blob) {
  DCHECK(stmt_);
  const void* p = column_blob(index);
  size_t len = column_bytes(index);
  blob->resize(len);
  if (blob->size() != len) {
    return false;
  }
  if (len > 0)
    memcpy(&(blob->front()), p, len);
  return true;
}

bool SQLStatement::column_blob_as_string(int index, std::string* blob) {
  DCHECK(stmt_);
  const void* p = column_blob(index);
  size_t len = column_bytes(index);
  blob->resize(len);
  if (blob->size() != len) {
    return false;
  }
  blob->assign(reinterpret_cast<const char*>(p), len);
  return true;
}

int SQLStatement::column_bytes(int index) {
  DCHECK(stmt_);
  return sqlite3_column_bytes(stmt_, index);
}

int SQLStatement::column_bytes16(int index) {
  DCHECK(stmt_);
  return sqlite3_column_bytes16(stmt_, index);
}

double SQLStatement::column_double(int index) {
  DCHECK(stmt_);
  return sqlite3_column_double(stmt_, index);
}

bool SQLStatement::column_bool(int index) {
  DCHECK(stmt_);
  return sqlite3_column_int(stmt_, index) ? true : false;
}

int SQLStatement::column_int(int index) {
  DCHECK(stmt_);
  return sqlite3_column_int(stmt_, index);
}

sqlite_int64 SQLStatement::column_int64(int index) {
  DCHECK(stmt_);
  return sqlite3_column_int64(stmt_, index);
}

const char* SQLStatement::column_text(int index) {
  DCHECK(stmt_);
  return reinterpret_cast<const char*>(sqlite3_column_text(stmt_, index));
}

bool SQLStatement::column_string(int index, std::string* str) {
  DCHECK(stmt_);
  DCHECK(str);
  const char* s = column_text(index);
str->assign(s ? s : std::string(""));
  return s != NULL;
}

std::string SQLStatement::column_string(int index) {
  std::string str;
  column_string(index, &str);
  return str;
}

const wchar_t* SQLStatement::column_text16(int index) {
  DCHECK(stmt_);
  return static_cast<const wchar_t*>( sqlite3_column_text16(stmt_, index) );
}

bool SQLStatement::column_string16(int index, std::wstring* str) {
  DCHECK(stmt_);
  DCHECK(str);
  const wchar_t* s = column_text16(index);
  str->assign(s ? s : std::wstring(L""));
  return (s != NULL);
}

std::wstring SQLStatement::column_string16(int index) {
  std::wstring wstr;
  column_string16(index, &wstr);
  return wstr;
}
#ifndef CHROME_COMMON_SQLITEUTILS_H_
#define CHROME_COMMON_SQLITEUTILS_H_
#include "base/basictypes.h"
  explicit SQLTransaction(sqlite3* db);
  virtual ~SQLTransaction();
  virtual int BeginCommand(const char* command);
  virtual int EndCommand(const char* command);
  sqlite3* db_;
  DISALLOW_COPY_AND_ASSIGN(SQLTransaction);
  virtual ~SQLNestedTransactionSite();
  SQLNestedTransaction* GetTopTransaction() {
  void SetTopTransaction(SQLNestedTransaction* top);
  SQLNestedTransaction* top_transaction_;
  explicit SQLNestedTransaction(SQLNestedTransactionSite* site);
  virtual ~SQLNestedTransaction();
  virtual int BeginCommand(const char* command);
  virtual int EndCommand(const char* command);
  SQLNestedTransactionSite* site_;
  DISALLOW_COPY_AND_ASSIGN(SQLNestedTransaction);
  explicit scoped_sqlite3_stmt_ptr(sqlite3_stmt* stmt)
  sqlite3_stmt* get() const {
  void set(sqlite3_stmt* stmt) {
  sqlite3_stmt* release() {
    sqlite3_stmt* tmp = stmt_;
  sqlite3_stmt* stmt_;
  DISALLOW_COPY_AND_ASSIGN(scoped_sqlite3_stmt_ptr);
 public:
  int prepare(sqlite3* db, const char* sql) {
  int prepare(sqlite3* db, const char* sql, int sql_len);
  int prepare16(sqlite3* db, const wchar_t* sql) {
  int prepare16(sqlite3* db, const wchar_t* sql, int sql_len);
  int step();
  int reset();
  sqlite_int64 last_insert_rowid();
  sqlite3* db_handle();
  int bind_parameter_count();
  int bind_blob(int index, std::vector<unsigned char>* blob);
  int bind_blob(int index, const void* value, int value_len);
  int bind_blob(int index, const void* value, int value_len, Function dtor);
  int bind_double(int index, double value);
  int bind_bool(int index, bool value);
  int bind_int(int index, int value);
  int bind_int64(int index, sqlite_int64 value);
  int bind_null(int index);
  int bind_text(int index, const char* value) {
  int bind_text(int index, const char* value, int value_len) {
  int bind_text(int index, const char* value, int value_len,
                Function dtor);
  int bind_text16(int index, const wchar_t* value) {
  int bind_text16(int index, const wchar_t* value, int value_len) {
  int bind_text16(int index, const wchar_t* value, int value_len,
                  Function dtor);
  int bind_value(int index, const sqlite3_value* value);
  int column_count();
  int column_type(int index);
  const wchar_t* column_name16(int index);
  const void* column_blob(int index);
  bool column_blob_as_vector(int index, std::vector<unsigned char>* blob);
  bool column_blob_as_string(int index, std::string* blob);
  int column_bytes(int index);
  int column_bytes16(int index);
  double column_double(int index);
  bool column_bool(int index);
  int column_int(int index);
  sqlite_int64 column_int64(int index);
  const char* column_text(int index);
  bool column_string(int index, std::string* str);
  std::string column_string(int index);
  const wchar_t* column_text16(int index);
  bool column_string16(int index, std::wstring* str);
  std::wstring column_string16(int index);
  DISALLOW_COPY_AND_ASSIGN(SQLStatement);
#endif  // CHROME_COMMON_SQLITEUTILS_H_

#include "base/gfx/skia_utils.h"
#include "base/logging.h"
#include "chrome/common/gfx/chrome_canvas.h"
#include "chrome/views/border.h"

#include "base/logging.h"
#include "chrome/common/gfx/chrome_font.h"
#include "chrome/browser/pref_service.h"
#include "chrome/browser/profile.h"
#include "chrome/common/pref_names.h"
#include "grit/locale_settings.h"
  localized_strings->SetString(L"clearBrowsingDataLabel",
      l10n_util::GetString(IDS_CLEAR_BROWSING_DATA_LABEL));
  localized_strings->SetString(L"clearBrowsingDataTimeLabel",
      l10n_util::GetString(IDS_CLEAR_BROWSING_DATA_TIME_LABEL));
  localized_strings->SetString(L"deleteBrowsingHistoryCheckbox",
      l10n_util::GetString(IDS_DEL_BROWSING_HISTORY_CHKBOX));
  localized_strings->SetString(L"deleteDownloadHistoryCheckbox",
      l10n_util::GetString(IDS_DEL_DOWNLOAD_HISTORY_CHKBOX));
  localized_strings->SetString(L"deleteCacheCheckbox",
      l10n_util::GetString(IDS_DEL_CACHE_CHKBOX));
  localized_strings->SetString(L"deleteCookiesCheckbox",
      l10n_util::GetString(IDS_DEL_COOKIES_CHKBOX));
  localized_strings->SetString(L"deletePasswordsCheckbox",
      l10n_util::GetString(IDS_DEL_PASSWORDS_CHKBOX));
  localized_strings->SetString(L"deleteFormDataCheckbox",
      l10n_util::GetString(IDS_DEL_FORM_DATA_CHKBOX));
  localized_strings->SetString(L"clearBrowsingDataCommit",
      l10n_util::GetString(IDS_CLEAR_BROWSING_DATA_COMMIT));
  localized_strings->SetString(L"flashStorageSettings",
      l10n_util::GetString(IDS_FLASH_STORAGE_SETTINGS));
  localized_strings->SetString(L"flash_storage_url",
      l10n_util::GetString(IDS_FLASH_STORAGE_URL));
  localized_strings->SetString(L"clearDataDeleting",
      l10n_util::GetString(IDS_CLEAR_DATA_DELETING));

  ListValue* time_list = new ListValue;
  for (int i = 0; i < 5; i++) {
    std::wstring label_string;
    switch (i) {
      case 0:
        label_string = l10n_util::GetString(IDS_CLEAR_DATA_HOUR);
        break;
      case 1:
        label_string = l10n_util::GetString(IDS_CLEAR_DATA_DAY);
        break;
      case 2:
        label_string = l10n_util::GetString(IDS_CLEAR_DATA_WEEK);
        break;
      case 3:
        label_string = l10n_util::GetString(IDS_CLEAR_DATA_4WEEKS);
        break;
      case 4:
        label_string = l10n_util::GetString(IDS_CLEAR_DATA_EVERYTHING);
        break;
    }
    ListValue* option = new ListValue();
    option->Append(Value::CreateIntegerValue(i));
    option->Append(Value::CreateStringValue(label_string));
    time_list->Append(option);
  }
  localized_strings->Set(L"clearBrowsingDataTimeList", time_list);
}

void ClearBrowserDataHandler::RegisterMessages() {
  // Setup handlers specific to this panel.
  DCHECK(dom_ui_);
  dom_ui_->RegisterMessageCallback("performClearBrowserData",
      NewCallback(this, &ClearBrowserDataHandler::HandleClearBrowserData));
}

void ClearBrowserDataHandler::HandleClearBrowserData(const Value* value) {
  Profile *profile = dom_ui_->GetProfile();
  PrefService *prefs = profile->GetPrefs();

  int remove_mask = 0;
  if (prefs->GetBoolean(prefs::kDeleteBrowsingHistory))
    remove_mask |= BrowsingDataRemover::REMOVE_HISTORY;
  if (prefs->GetBoolean(prefs::kDeleteDownloadHistory))
    remove_mask |= BrowsingDataRemover::REMOVE_DOWNLOADS;
  if (prefs->GetBoolean(prefs::kDeleteCache))
    remove_mask |= BrowsingDataRemover::REMOVE_CACHE;
  if (prefs->GetBoolean(prefs::kDeleteCookies))
    remove_mask |= BrowsingDataRemover::REMOVE_COOKIES;
  if (prefs->GetBoolean(prefs::kDeletePasswords))
    remove_mask |= BrowsingDataRemover::REMOVE_PASSWORDS;
  if (prefs->GetBoolean(prefs::kDeleteFormData))
    remove_mask |= BrowsingDataRemover::REMOVE_FORM_DATA;

  int period_selected = prefs->GetInteger(prefs::kDeleteTimePeriod);

  FundamentalValue state(true);
  dom_ui_->CallJavascriptFunction(L"clearBrowserDataSetClearingState", state);

  // BrowsingDataRemover deletes itself when done.
  remover_ = new BrowsingDataRemover(profile,
      static_cast<BrowsingDataRemover::TimePeriod>(period_selected),
      base::Time());
  remover_->AddObserver(this);
  remover_->Remove(remove_mask);
}

void ClearBrowserDataHandler::OnBrowsingDataRemoverDone() {
  // No need to remove ourselves as an observer as BrowsingDataRemover deletes
  // itself after we return.
  remover_ = NULL;
  DCHECK(dom_ui_);
  dom_ui_->CallJavascriptFunction(L"clearBrowserDataDismiss");
#include "chrome/browser/browsing_data_remover.h"
// Clear browser data handler page UI handler.
class ClearBrowserDataHandler : public OptionsPageUIHandler,
                                public BrowsingDataRemover::Observer {
  // DOMMessageHandler implementation.
  virtual void RegisterMessages();

  void HandleClearBrowserData(const Value* value);

  // Callback from BrowsingDataRemover. Closes the dialog.
  virtual void OnBrowsingDataRemoverDone();

  // If non-null it means removal is in progress. BrowsingDataRemover takes care
  // of deleting itself when done.
  BrowsingDataRemover* remover_;


  localized_strings->SetString(L"ok",
      l10n_util::GetString(IDS_OK));
  localized_strings->SetString(L"cancel",
      l10n_util::GetString(IDS_CANCEL));
  localized_strings->SetString(L"delete",
      l10n_util::GetString(IDS_DELETE));
  localized_strings->SetString(L"edit",
      l10n_util::GetString(IDS_EDIT));
  localized_strings->SetString(L"learnMore",
      l10n_util::GetString(IDS_LEARN_MORE));
  localized_strings->SetString(L"abort",
      l10n_util::GetString(IDS_ABORT));
  localized_strings->SetString(L"close",
      l10n_util::GetString(IDS_CLOSE));
  localized_strings->SetString(L"done",
      l10n_util::GetString(IDS_DONE));
WebRtcAudioDeviceImpl*
MediaStreamDependencyFactory::GetWebRtcAudioDevice() {
  return audio_device_;
}

  WebRtcAudioDeviceImpl* GetWebRtcAudioDevice();

#include "content/renderer/media/webrtc_audio_renderer.h"
#include "webkit/media/media_stream_audio_renderer.h"
scoped_refptr<webkit_media::MediaStreamAudioRenderer>
MediaStreamImpl::GetAudioRenderer(const GURL& url) {
  DCHECK(CalledOnValidThread());
  WebKit::WebMediaStreamDescriptor descriptor(GetMediaStream(url));

  if (descriptor.isNull() || !descriptor.extraData())
    return NULL;  // This is not a valid stream.

  DVLOG(1) << "MediaStreamImpl::GetAudioRenderer stream:"
           << UTF16ToUTF8(descriptor.label());

  MediaStreamExtraData* extra_data =
      static_cast<MediaStreamExtraData*>(descriptor.extraData());
  if (extra_data->remote_stream()) {
    scoped_refptr<WebRtcAudioRenderer> renderer =
        CreateRemoteAudioRenderer(extra_data->remote_stream());

    if (dependency_factory_->GetWebRtcAudioDevice()->SetRenderer(renderer)) {
      return renderer;
    }

    // WebRtcAudioDeviceImpl can only support one renderer.
    return NULL;
  }

  if (extra_data->local_stream()) {
    // TODO(xians): Implement a WebRtcAudioFIFO to handle the local loopback.
    return NULL;
  }

  NOTREACHED();
  return NULL;
}

scoped_refptr<WebRtcAudioRenderer> MediaStreamImpl::CreateRemoteAudioRenderer(
    webrtc::MediaStreamInterface* stream) {
  if (!stream->audio_tracks() || stream->audio_tracks()->count() == 0)
    return NULL;

  DVLOG(1) << "MediaStreamImpl::CreateRemoteAudioRenderer label:"
           << stream->label();

  return new WebRtcAudioRenderer();
}

namespace webkit_media {
class MediaStreamAudioRenderer;
}

class WebRtcAudioRenderer;
  virtual scoped_refptr<webkit_media::MediaStreamAudioRenderer>
      GetAudioRenderer(const GURL& url) OVERRIDE;
  scoped_refptr<WebRtcAudioRenderer> CreateRemoteAudioRenderer(
        webrtc::MediaStreamInterface* stream);
  {
    // It is necessary to stop the |renderer_| before going away.
    base::AutoLock auto_lock(lock_);
    if (renderer_)
      renderer_->Stop();
  }
void WebRtcAudioDeviceImpl::RenderData(uint8* audio_data,
                                       int number_of_channels,
                                       int number_of_frames,
                                       int audio_delay_milliseconds) {
  DCHECK_LE(number_of_frames, output_buffer_size());
  const int channels = number_of_channels;
  while (accumulated_audio_samples < number_of_frames) {
                                                audio_data,
    audio_data += bytes_per_10_msec;
void WebRtcAudioDeviceImpl::SetRenderFormat(const AudioParameters& params) {
  output_audio_parameters_ = params;
  {
    base::AutoLock auto_lock(lock_);
    if (!renderer_)
      return -1;

    renderer_->Play();
  }

  start_render_time_ = base::Time::Now();

  {
    base::AutoLock auto_lock(lock_);
    if (!renderer_)
      return -1;

    renderer_->Pause();
  }

bool WebRtcAudioDeviceImpl::SetRenderer(WebRtcAudioRenderer* renderer) {
  DCHECK(renderer);

  base::AutoLock auto_lock(lock_);
  if (renderer_)
    return false;

  if (!renderer->Initialize(this))
    return false;

  renderer_ = renderer;
  return true;
}

#include "content/renderer/media/webrtc_audio_renderer.h"
// TODO(xians): Move this interface to webrtc so that libjingle can own a
// reference to the renderer object.
class WebRtcAudioRendererSource {
 public:
  // Callback to get the rendered interleaved data.
  virtual void RenderData(uint8* audio_data,
                          int number_of_channels,
                          int number_of_frames,
                          int audio_delay_milliseconds) = 0;

  // Set the format for the capture audio parameters.
  virtual void SetRenderFormat(const media::AudioParameters& params) = 0;

 protected:
  virtual ~WebRtcAudioRendererSource() {}
};

class WebRtcAudioRenderer;

      NON_EXPORTED_BASE(public media::AudioInputDevice::CaptureEventHandler),
      NON_EXPORTED_BASE(public WebRtcAudioRendererSource) {
  // WebRtcAudioRendererSource implementation.
  virtual void RenderData(uint8* audio_data,
                          int number_of_channels,
                          int number_of_frames,
                          int audio_delay_milliseconds) OVERRIDE;
  virtual void SetRenderFormat(const media::AudioParameters& params) OVERRIDE;
  // Sets the |renderer_|, returns false if |renderer_| has already existed.
  bool SetRenderer(WebRtcAudioRenderer* renderer);

  // Provides access to the audio renderer in the browser process.
  scoped_refptr<WebRtcAudioRenderer> renderer_;
  // Protects |recording_|, |output_delay_ms_|, |input_delay_ms_|, |renderer_|.
#include "content/renderer/media/webrtc_audio_renderer.h"

  scoped_refptr<WebRtcAudioRenderer> renderer = new WebRtcAudioRenderer();
  EXPECT_TRUE(webrtc_audio_device->SetRenderer(renderer));

  renderer->Play();
  renderer->Stop();

  scoped_refptr<WebRtcAudioRenderer> renderer = new WebRtcAudioRenderer();

  EXPECT_TRUE(webrtc_audio_device->SetRenderer(renderer));
  renderer->Play();
  renderer->Stop();
  scoped_refptr<WebRtcAudioRenderer> renderer = new WebRtcAudioRenderer();

  EXPECT_TRUE(webrtc_audio_device->SetRenderer(renderer));

  renderer->Play();
  renderer->Stop();
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/renderer/media/webrtc_audio_renderer.h"

#include "base/logging.h"
#include "base/metrics/histogram.h"
#include "base/string_util.h"
#include "content/renderer/media/audio_device_factory.h"
#include "content/renderer/media/audio_hardware.h"
#include "content/renderer/media/webrtc_audio_device_impl.h"
#include "media/audio/audio_util.h"
#include "media/audio/sample_rates.h"

namespace content {

namespace {

// Supported hardware sample rates for output sides.
#if defined(OS_WIN) || defined(OS_MACOSX)
// media::GetAudioOutputHardwareSampleRate() asks the audio layer
// for its current sample rate (set by the user) on Windows and Mac OS X.
// The listed rates below adds restrictions and Initialize()
// will fail if the user selects any rate outside these ranges.
int kValidOutputRates[] = {96000, 48000, 44100};
#elif defined(OS_LINUX) || defined(OS_OPENBSD)
int kValidOutputRates[] = {48000, 44100};
#endif

// TODO(xians): Merge the following code to WebRtcAudioCapturer, or remove.
enum AudioFramesPerBuffer {
  k160,
  k320,
  k440,  // WebRTC works internally with 440 audio frames at 44.1kHz.
  k480,
  k640,
  k880,
  k960,
  k1440,
  k1920,
  kUnexpectedAudioBufferSize  // Must always be last!
};

// Helper method to convert integral values to their respective enum values
// above, or kUnexpectedAudioBufferSize if no match exists.
AudioFramesPerBuffer AsAudioFramesPerBuffer(int frames_per_buffer) {
  switch (frames_per_buffer) {
    case 160: return k160;
    case 320: return k320;
    case 440: return k440;
    case 480: return k480;
    case 640: return k640;
    case 880: return k880;
    case 960: return k960;
    case 1440: return k1440;
    case 1920: return k1920;
  }
  return kUnexpectedAudioBufferSize;
}

void AddHistogramFramesPerBuffer(int param) {
  AudioFramesPerBuffer afpb = AsAudioFramesPerBuffer(param);
  if (afpb != kUnexpectedAudioBufferSize) {
    UMA_HISTOGRAM_ENUMERATION("WebRTC.AudioOutputFramesPerBuffer",
                              afpb, kUnexpectedAudioBufferSize);
  } else {
    // Report unexpected sample rates using a unique histogram name.
    UMA_HISTOGRAM_COUNTS("WebRTC.AudioOutputFramesPerBufferUnexpected", param);
  }
}

}  // namespace

WebRtcAudioRenderer::WebRtcAudioRenderer()
    : state_(UNINITIALIZED),
      source_(NULL) {
}

WebRtcAudioRenderer::~WebRtcAudioRenderer() {
  DCHECK_EQ(state_, UNINITIALIZED);
  buffer_.reset();
}

bool WebRtcAudioRenderer::Initialize(WebRtcAudioRendererSource* source) {
  base::AutoLock auto_lock(lock_);
  DCHECK_EQ(state_, UNINITIALIZED);
  DCHECK(source);
  DCHECK(!sink_);
  DCHECK(!source_);

  sink_ = AudioDeviceFactory::NewOutputDevice();
  DCHECK(sink_);

  // Ask the browser for the default audio output hardware sample-rate.
  // This request is based on a synchronous IPC message.
  int sample_rate = GetAudioOutputSampleRate();
  DVLOG(1) << "Audio output hardware sample rate: " << sample_rate;
  UMA_HISTOGRAM_ENUMERATION("WebRTC.AudioOutputSampleRate",
                            sample_rate, media::kUnexpectedAudioSampleRate);

  // Verify that the reported output hardware sample rate is supported
  // on the current platform.
  if (std::find(&kValidOutputRates[0],
                &kValidOutputRates[0] + arraysize(kValidOutputRates),
                sample_rate) ==
                    &kValidOutputRates[arraysize(kValidOutputRates)]) {
    DLOG(ERROR) << sample_rate << " is not a supported output rate.";
    return false;
  }

  media::ChannelLayout channel_layout = media::CHANNEL_LAYOUT_STEREO;

  int buffer_size = 0;

  // Windows
#if defined(OS_WIN)
  // Always use stereo rendering on Windows.
  channel_layout = media::CHANNEL_LAYOUT_STEREO;

  // Render side: AUDIO_PCM_LOW_LATENCY is based on the Core Audio (WASAPI)
  // API which was introduced in Windows Vista. For lower Windows versions,
  // a callback-driven Wave implementation is used instead. An output buffer
  // size of 10ms works well for WASAPI but 30ms is needed for Wave.

  // Use different buffer sizes depending on the current hardware sample rate.
  if (sample_rate == 96000 || sample_rate == 48000) {
    buffer_size = (sample_rate / 100);
  } else {
    // We do run at 44.1kHz at the actual audio layer, but ask for frames
    // at 44.0kHz to ensure that we can feed them to the webrtc::VoiceEngine.
    // TODO(henrika): figure out why we seem to need 20ms here for glitch-
    // free audio.
    buffer_size = 2 * 440;
  }

  // Windows XP and lower can't cope with 10 ms output buffer size.
  // It must be extended to 30 ms (60 ms will be used internally by WaveOut).
  if (!media::IsWASAPISupported()) {
    buffer_size = 3 * buffer_size;
    DLOG(WARNING) << "Extending the output buffer size by a factor of three "
                  << "since Windows XP has been detected.";
  }
#elif defined(OS_MACOSX)
  channel_layout = media::CHANNEL_LAYOUT_MONO;

  // Render side: AUDIO_PCM_LOW_LATENCY on Mac OS X is based on a callback-
  // driven Core Audio implementation. Tests have shown that 10ms is a suitable
  // frame size to use, both for 48kHz and 44.1kHz.

  // Use different buffer sizes depending on the current hardware sample rate.
  if (sample_rate == 48000) {
    buffer_size = 480;
  } else {
    // We do run at 44.1kHz at the actual audio layer, but ask for frames
    // at 44.0kHz to ensure that we can feed them to the webrtc::VoiceEngine.
    buffer_size = 440;
  }
#elif defined(OS_LINUX) || defined(OS_OPENBSD)
  channel_layout = media::CHANNEL_LAYOUT_MONO;

  // Based on tests using the current ALSA implementation in Chrome, we have
  // found that 10ms buffer size on the output side works fine.
  buffer_size = 480;
#else
  DLOG(ERROR) << "Unsupported platform";
  return false;
#endif

  // Store utilized parameters to ensure that we can check them
  // after a successful initialization.
  params_.Reset(media::AudioParameters::AUDIO_PCM_LOW_LATENCY, channel_layout,
                sample_rate, 16, buffer_size);

  // Allocate local audio buffers based on the parameters above.
  // It is assumed that each audio sample contains 16 bits and each
  // audio frame contains one or two audio samples depending on the
  // number of channels.
  buffer_.reset(new int16[params_.frames_per_buffer() * params_.channels()]);

  source_ = source;
  source->SetRenderFormat(params_);

  // Configure the audio rendering client and start the rendering.
  sink_->Initialize(params_, this);

  sink_->Start();

  state_ = PAUSED;

  UMA_HISTOGRAM_ENUMERATION("WebRTC.AudioOutputChannelLayout",
                            channel_layout, media::CHANNEL_LAYOUT_MAX);
  UMA_HISTOGRAM_ENUMERATION("WebRTC.AudioOutputFramesPerBuffer",
                            buffer_size, kUnexpectedAudioBufferSize);
  AddHistogramFramesPerBuffer(buffer_size);

  return true;
}

void WebRtcAudioRenderer::Play() {
  base::AutoLock auto_lock(lock_);
  if (state_ == UNINITIALIZED)
    return;

  state_ = PLAYING;
}

void WebRtcAudioRenderer::Pause() {
  base::AutoLock auto_lock(lock_);
  if (state_ == UNINITIALIZED)
    return;

  state_ = PAUSED;
}

void WebRtcAudioRenderer::Stop() {
  base::AutoLock auto_lock(lock_);
  if (state_ == UNINITIALIZED)
    return;

  state_ = UNINITIALIZED;
  source_ = NULL;
  sink_->Stop();
}

void WebRtcAudioRenderer::SetVolume(float volume) {
  base::AutoLock auto_lock(lock_);
  if (state_ == UNINITIALIZED)
    return;

  sink_->SetVolume(volume);
}

int WebRtcAudioRenderer::Render(media::AudioBus* audio_bus,
                                int audio_delay_milliseconds) {
  {
    base::AutoLock auto_lock(lock_);
    // Return 0 frames to play out zero if it is not in PLAYING state.
    if (state_ != PLAYING)
      return 0;

    // We need to keep render data for the |source_| reglardless of |state_|,
    // otherwise the data will be buffered up inside |source_|.
    source_->RenderData(reinterpret_cast<uint8*>(buffer_.get()),
                        audio_bus->channels(), audio_bus->frames(),
                        audio_delay_milliseconds);
  }

  // Deinterleave each channel and convert to 32-bit floating-point
  // with nominal range -1.0 -> +1.0 to match the callback format.
  audio_bus->FromInterleaved(buffer_.get(), audio_bus->frames(),
                             params_.bits_per_sample() / 8);
  return audio_bus->frames();
}

void WebRtcAudioRenderer::OnRenderError() {
  NOTIMPLEMENTED();
  LOG(ERROR) << "OnRenderError()";
}

}  // namespace content
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_RENDERER_MEDIA_WEBRTC_AUDIO_CAPTURER_H_
#define CONTENT_RENDERER_MEDIA_WEBRTC_AUDIO_CAPTURER_H_

#include "base/memory/ref_counted.h"
#include "base/synchronization/lock.h"
#include "content/renderer/media/webrtc_audio_device_impl.h"
#include "media/base/audio_decoder.h"
#include "media/base/audio_renderer_sink.h"
#include "webkit/media/media_stream_audio_renderer.h"

namespace content {

class WebRtcAudioRendererSource;

// This renderer handles calls from the pipeline and WebRtc ADM. It is used
// for connecting WebRtc MediaStream with pipeline.
class CONTENT_EXPORT WebRtcAudioRenderer
    : NON_EXPORTED_BASE(public media::AudioRendererSink::RenderCallback),
      NON_EXPORTED_BASE(public webkit_media::MediaStreamAudioRenderer) {
 public:
  WebRtcAudioRenderer();

  // Initialize function called by clients like WebRtcAudioDeviceImpl. Note,
  // Stop() has to be called before |source| is deleted.
  // Returns false if Initialize() fails.
  bool Initialize(WebRtcAudioRendererSource* source);

  // Methods called by WebMediaPlayerMS and WebRtcAudioDeviceImpl.
  // MediaStreamAudioRenderer implementation.
  virtual void Play() OVERRIDE;
  virtual void Pause() OVERRIDE;
  virtual void Stop() OVERRIDE;
  virtual void SetVolume(float volume) OVERRIDE;

 protected:
  virtual ~WebRtcAudioRenderer();

 private:
  enum State {
    UNINITIALIZED,
    PLAYING,
    PAUSED,
  };
  // Flag to keep track the state of the renderer.
  State state_;

  // media::AudioRendererSink::RenderCallback implementation.
  virtual int Render(media::AudioBus* audio_bus,
                     int audio_delay_milliseconds) OVERRIDE;
  virtual void OnRenderError() OVERRIDE;

  // The sink (destination) for rendered audio.
  scoped_refptr<media::AudioRendererSink> sink_;

  // Audio data source from the browser process.
  WebRtcAudioRendererSource* source_;

  // Cached values of utilized audio parameters. Platform dependent.
  media::AudioParameters params_;

  // Buffers used for temporary storage during render callbacks.
  // Allocated during initialization.
  scoped_array<int16> buffer_;

  // Protect access to |state_|.
  base::Lock lock_;

  DISALLOW_COPY_AND_ASSIGN(WebRtcAudioRenderer);
};

}  // namespace content

#endif  // CONTENT_RENDERER_MEDIA_WEBRTC_AUDIO_CAPTURER_H_
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "media/audio/linux/alsa_util.h"

#include <string>

#include "base/logging.h"
#include "media/audio/linux/alsa_wrapper.h"

namespace alsa_util {

static snd_pcm_t* OpenDevice(media::AlsaWrapper* wrapper,
                             const char* device_name,
                             snd_pcm_stream_t type,
                             int channels,
                             int sample_rate,
                             snd_pcm_format_t pcm_format,
                             int latency_us) {
  snd_pcm_t* handle = NULL;
  int error = wrapper->PcmOpen(&handle, device_name, type, SND_PCM_NONBLOCK);
  if (error < 0) {
    LOG(WARNING) << "PcmOpen: " << device_name << ","
                 << wrapper->StrError(error);
    return NULL;
  }

  error = wrapper->PcmSetParams(handle, pcm_format,
                                SND_PCM_ACCESS_RW_INTERLEAVED, channels,
                                sample_rate, 1, latency_us);
  if (error < 0) {
    LOG(WARNING) << "PcmSetParams: " << device_name << ", "
                 << wrapper->StrError(error) << " - Format: " << pcm_format
                 << " Channels: " << channels << " Latency: " << latency_us;
    if (alsa_util::CloseDevice(wrapper, handle) < 0) {
      // TODO(ajwong): Retry on certain errors?
      LOG(WARNING) << "Unable to close audio device. Leaking handle.";
    }
    return NULL;
  }

  return handle;
}

static std::string DeviceNameToControlName(const std::string& device_name) {
  const char kMixerPrefix[] = "hw";
  std::string control_name;
  size_t pos1 = device_name.find(':');
  if (pos1 == std::string::npos) {
    control_name = device_name;
  } else {
    // Examples:
    // deviceName: "front:CARD=Intel,DEV=0", controlName: "hw:CARD=Intel".
    // deviceName: "default:CARD=Intel", controlName: "CARD=Intel".
    size_t pos2 = device_name.find(',');
    control_name = (pos2 == std::string::npos) ?
        device_name.substr(pos1) :
        kMixerPrefix + device_name.substr(pos1, pos2 - pos1);
  }

  return control_name;
}

snd_pcm_format_t BitsToFormat(int bits_per_sample) {
  switch (bits_per_sample) {
    case 8:
      return SND_PCM_FORMAT_U8;

    case 16:
      return SND_PCM_FORMAT_S16;

    case 24:
      return SND_PCM_FORMAT_S24;

    case 32:
      return SND_PCM_FORMAT_S32;

    default:
      return SND_PCM_FORMAT_UNKNOWN;
  }
}

int CloseDevice(media::AlsaWrapper* wrapper, snd_pcm_t* handle) {
  std::string device_name = wrapper->PcmName(handle);
  int error = wrapper->PcmClose(handle);
  if (error < 0) {
    LOG(ERROR) << "PcmClose: " << device_name << ", "
               << wrapper->StrError(error);
  }

  return error;
}

snd_pcm_t* OpenCaptureDevice(media::AlsaWrapper* wrapper,
                             const char* device_name,
                             int channels,
                             int sample_rate,
                             snd_pcm_format_t pcm_format,
                             int latency_us) {
  return OpenDevice(wrapper, device_name, SND_PCM_STREAM_CAPTURE, channels,
                    sample_rate, pcm_format, latency_us);
}

snd_pcm_t* OpenPlaybackDevice(media::AlsaWrapper* wrapper,
                              const char* device_name,
                              int channels,
                              int sample_rate,
                              snd_pcm_format_t pcm_format,
                              int latency_us) {
  return OpenDevice(wrapper, device_name, SND_PCM_STREAM_PLAYBACK, channels,
                    sample_rate, pcm_format, latency_us);
}

snd_mixer_t* OpenMixer(media::AlsaWrapper* wrapper,
                       const std::string& device_name) {
  snd_mixer_t* mixer = NULL;

  int error = wrapper->MixerOpen(&mixer, 0);
  if (error < 0) {
    LOG(ERROR) << "MixerOpen: " << device_name << ", "
               << wrapper->StrError(error);
    return NULL;
  }

  std::string control_name = DeviceNameToControlName(device_name);
  error = wrapper->MixerAttach(mixer, control_name.c_str());
  if (error < 0) {
    LOG(ERROR) << "MixerAttach, " << control_name << ", "
               << wrapper->StrError(error);
    alsa_util::CloseMixer(wrapper, mixer, device_name);
    return NULL;
  }

  error = wrapper->MixerElementRegister(mixer, NULL, NULL);
  if (error < 0) {
    LOG(ERROR) << "MixerElementRegister: " << control_name << ", "
               << wrapper->StrError(error);
    alsa_util::CloseMixer(wrapper, mixer, device_name);
    return NULL;
  }

  return mixer;
}

void CloseMixer(media::AlsaWrapper* wrapper, snd_mixer_t* mixer,
                const std::string& device_name) {
  if (!mixer)
    return;

  wrapper->MixerFree(mixer);

  int error = 0;
  if (!device_name.empty()) {
    std::string control_name = DeviceNameToControlName(device_name);
    error = wrapper->MixerDetach(mixer, control_name.c_str());
    if (error < 0) {
      LOG(WARNING) << "MixerDetach: " << control_name << ", "
                   << wrapper->StrError(error);
    }
  }

  error = wrapper->MixerClose(mixer);
  if (error < 0) {
    LOG(WARNING) << "MixerClose: " << wrapper->StrError(error);
  }
}

snd_mixer_elem_t* LoadCaptureMixerElement(media::AlsaWrapper* wrapper,
                                          snd_mixer_t* mixer) {
  if (!mixer)
    return NULL;

  int error = wrapper->MixerLoad(mixer);
  if (error < 0) {
    LOG(ERROR) << "MixerLoad: " << wrapper->StrError(error);
    return NULL;
  }

  snd_mixer_elem_t* elem = NULL;
  snd_mixer_elem_t* mic_elem = NULL;
  const char kCaptureElemName[] = "Capture";
  const char kMicElemName[] = "Mic";
  for (elem = wrapper->MixerFirstElem(mixer);
       elem;
       elem = wrapper->MixerNextElem(elem)) {
    if (wrapper->MixerSelemIsActive(elem)) {
      const char* elem_name = wrapper->MixerSelemName(elem);
      if (strcmp(elem_name, kCaptureElemName) == 0)
        return elem;
      else if (strcmp(elem_name, kMicElemName) == 0)
        mic_elem = elem;
    }
  }

  // Did not find any Capture handle, use the Mic handle.
  return mic_elem;
}

}  // namespace alsa_util
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_AUDIO_LINUX_ALSA_UTIL_H_
#define MEDIA_AUDIO_LINUX_ALSA_UTIL_H_

#include <alsa/asoundlib.h>
#include <string>

namespace media {
class AlsaWrapper;
}

namespace alsa_util {

snd_pcm_format_t BitsToFormat(int bits_per_sample);

snd_pcm_t* OpenCaptureDevice(media::AlsaWrapper* wrapper,
                             const char* device_name,
                             int channels,
                             int sample_rate,
                             snd_pcm_format_t pcm_format,
                             int latency_us);

snd_pcm_t* OpenPlaybackDevice(media::AlsaWrapper* wrapper,
                              const char* device_name,
                              int channels,
                              int sample_rate,
                              snd_pcm_format_t pcm_format,
                              int latency_us);

int CloseDevice(media::AlsaWrapper* wrapper, snd_pcm_t* handle);

snd_mixer_t* OpenMixer(media::AlsaWrapper* wrapper,
                       const std::string& device_name);

void CloseMixer(media::AlsaWrapper* wrapper,
                snd_mixer_t* mixer,
                const std::string& device_name);

snd_mixer_elem_t* LoadCaptureMixerElement(media::AlsaWrapper* wrapper,
                                          snd_mixer_t* mixer);

}  // namespace alsa_util

#endif  // MEDIA_AUDIO_LINUX_ALSA_UTIL_H_
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "webkit/media/media_stream_audio_renderer.h"

namespace webkit_media {

MediaStreamAudioRenderer::MediaStreamAudioRenderer() {}
MediaStreamAudioRenderer::~MediaStreamAudioRenderer() {}

}  // namespace webkit_media
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef WEBKIT_MEDIA_MEDIA_STREAM_AUDIO_RENDERER_H_
#define WEBKIT_MEDIA_MEDIA_STREAM_AUDIO_RENDERER_H_

#include "base/memory/ref_counted.h"
#include "media/base/media_export.h"

namespace webkit_media {

class MediaStreamAudioRenderer
    : public base::RefCountedThreadSafe<MediaStreamAudioRenderer> {
 public:
  // Starts rendering audio.
  virtual void Play() = 0;

  // Temporarily suspends rendering audio.
  virtual void Pause() = 0;

  // Stops all operations in preparation for being deleted.
  virtual void Stop() = 0;

  // Sets the output volume.
  virtual void SetVolume(float volume) = 0;

 protected:
  friend class base::RefCountedThreadSafe<MediaStreamAudioRenderer>;

  MediaStreamAudioRenderer();
  virtual ~MediaStreamAudioRenderer();

 private:
  DISALLOW_COPY_AND_ASSIGN(MediaStreamAudioRenderer);
};

}  // namespace webkit_media

#endif  // WEBKIT_MEDIA_MEDIA_STREAM_AUDIO_RENDERER_H_
class MediaStreamAudioRenderer;

  virtual scoped_refptr<MediaStreamAudioRenderer> GetAudioRenderer(
      const GURL& url) = 0;

#include "webkit/media/media_stream_audio_renderer.h"
  if (audio_renderer_) {
    audio_renderer_->Stop();
  }


  audio_renderer_ = media_stream_client_->GetAudioRenderer(url);

  if (video_frame_provider_ || audio_renderer_) {
  if (video_frame_provider_ && paused_)
  if (audio_renderer_ && paused_)
    audio_renderer_->Play();

  paused_ = false;

  if (audio_renderer_)
    audio_renderer_->Pause();

  if (audio_renderer_)
    audio_renderer_->SetVolume(volume);
  return (audio_renderer_ != NULL);
class MediaStreamAudioRenderer;
  scoped_refptr<MediaStreamAudioRenderer> audio_renderer_;

#include "webkit/media/media_stream_audio_renderer.h"
scoped_refptr<webkit_media::MediaStreamAudioRenderer>
TestMediaStreamClient::GetAudioRenderer(const GURL& url) {
  return NULL;
}

namespace webkit_media {
class MediaStreamAudioRenderer;
}

  virtual scoped_refptr<webkit_media::MediaStreamAudioRenderer>
      GetAudioRenderer(const GURL& url) OVERRIDE;
#include "extensions/browser/extension_service_worker_message_filter.h"
#include "extensions/common/extensions_client.h"
  if (extensions::ExtensionsClient::Get()
          ->ExtensionAPIEnabledInExtensionServiceWorkers()) {
    host->AddFilter(new ExtensionServiceWorkerMessageFilter(id, profile));
  }
  Profile* profile = Profile::FromBrowserContext(
      web_contents ? web_contents->GetBrowserContext() : browser_context());
  Browser* browser = chrome::FindAnyBrowser(profile, include_incognito_);
  if (browser)
    return browser;
IN_PROC_BROWSER_TEST_F(ServiceWorkerTest, TabsCreate) {
  // Extensions APIs from SW are only enabled on trunk.
  ScopedCurrentChannel current_channel_override(version_info::Channel::UNKNOWN);
  const Extension* extension = LoadExtensionWithFlags(
      test_data_dir_.AppendASCII("service_worker/tabs_create"), kFlagNone);
  ASSERT_TRUE(extension);
  ui_test_utils::NavigateToURL(browser(),
                               extension->GetResourceURL("page.html"));
  content::WebContents* web_contents =
      browser()->tab_strip_model()->GetActiveWebContents();

  int starting_tab_count = browser()->tab_strip_model()->count();
  std::string result;
  ASSERT_TRUE(content::ExecuteScriptAndExtractString(
      web_contents, "window.runServiceWorker()", &result));
  ASSERT_EQ("chrome.tabs.create callback", result);
  EXPECT_EQ(starting_tab_count + 1, browser()->tab_strip_model()->count());

  // Check extension shutdown path.
  UnloadExtension(extension->id());
  EXPECT_EQ(starting_tab_count, browser()->tab_strip_model()->count());
}

bool ChromeContentClient::AllowScriptExtensionForServiceWorker(
    const GURL& script_url) {
#if defined(ENABLE_EXTENSIONS)
  return script_url.SchemeIs(extensions::kExtensionScheme) ||
         script_url.SchemeIs(extensions::kExtensionResourceScheme);
#else
  return false;
#endif
}

  bool AllowScriptExtensionForServiceWorker(const GURL& script_url) override;
bool ChromeExtensionsClient::ExtensionAPIEnabledInExtensionServiceWorkers()
    const {
  return GetCurrentChannel() == version_info::Channel::UNKNOWN;
}

  bool ExtensionAPIEnabledInExtensionServiceWorkers() const override;
void ChromeContentRendererClient::
    DidInitializeServiceWorkerContextOnWorkerThread(
        v8::Local<v8::Context> context,
        int embedded_worker_id,
        const GURL& url) {
  ChromeExtensionsRendererClient::GetInstance()
      ->extension_dispatcher()
      ->DidInitializeServiceWorkerContextOnWorkerThread(
          context, embedded_worker_id, url);
    int embedded_worker_id,
  extensions::Dispatcher::WillDestroyServiceWorkerContextOnWorkerThread(
      context, embedded_worker_id, url);
      int embedded_worker_id,
      int embedded_worker_id,
bool BlinkPlatformImpl::allowScriptExtensionForServiceWorker(
    const blink::WebURL& scriptUrl) {
  return GetContentClient()->AllowScriptExtensionForServiceWorker(scriptUrl);
}

  bool allowScriptExtensionForServiceWorker(
      const blink::WebURL& script_url) override;
bool ContentClient::AllowScriptExtensionForServiceWorker(
    const GURL& script_url) {
  return false;
}

  // Returns whether or not V8 script extensions should be allowed for a
  // service worker.
  virtual bool AllowScriptExtensionForServiceWorker(const GURL& script_url);

      int embedded_worker_id,
      int embedded_worker_id,
      ->DidInitializeServiceWorkerContextOnWorkerThread(
          context, embedded_worker_id_, script_url_);
      context, embedded_worker_id_, script_url_);
  // An extension function from Service Worker does not have a RenderFrameHost.
  if (!render_frame_host)
    return;
#include "base/scoped_observer.h"
#include "content/public/browser/render_process_host_observer.h"
#include "extensions/common/extensions_client.h"
  // The renderer has done validation before sending extension api requests.
  // Therefore, we should never receive a request that is invalid in a way
  // that JSON validation in the renderer should have caught. It could be an
  // attacker trying to exploit the browser, so we crash the renderer instead.
  LOG(ERROR) << "Terminating renderer because of malformed extension message.";
  if (content::RenderProcessHost::run_renderer_in_process()) {
    // In single process mode it is better if we don't suicide but just crash.
    CHECK(false);
    return;
  }

void KillBadMessageSenderRPH(content::RenderProcessHost* sender_process_host,
                             functions::HistogramValue histogram_value) {
  base::Process peer_process =
      content::RenderProcessHost::run_renderer_in_process()
          ? base::Process::Current()
          : base::Process::DeprecatedGetProcessFromHandle(
                sender_process_host->GetHandle());
  KillBadMessageSender(peer_process, histogram_value);
}

    KillBadMessageSender(peer_process, histogram_value);
class ExtensionFunctionDispatcher::UIThreadWorkerResponseCallbackWrapper
    : public content::RenderProcessHostObserver {
 public:
  UIThreadWorkerResponseCallbackWrapper(
      const base::WeakPtr<ExtensionFunctionDispatcher>& dispatcher,
      int render_process_id,
      int worker_thread_id)
      : dispatcher_(dispatcher),
        observer_(this),
        render_process_id_(render_process_id),
        worker_thread_id_(worker_thread_id),
        weak_ptr_factory_(this) {
    observer_.Add(content::RenderProcessHost::FromID(render_process_id_));
    DCHECK(ExtensionsClient::Get()
               ->ExtensionAPIEnabledInExtensionServiceWorkers());
  }

  ~UIThreadWorkerResponseCallbackWrapper() override {}

  // content::RenderProcessHostObserver override.
  void RenderProcessExited(content::RenderProcessHost* rph,
                           base::TerminationStatus status,
                           int exit_code) override {
    CleanUp();
  }

  // content::RenderProcessHostObserver override.
  void RenderProcessHostDestroyed(content::RenderProcessHost* rph) override {
    CleanUp();
  }

  ExtensionFunction::ResponseCallback CreateCallback(int request_id) {
    return base::Bind(
        &UIThreadWorkerResponseCallbackWrapper::OnExtensionFunctionCompleted,
        weak_ptr_factory_.GetWeakPtr(), request_id);
  }

 private:
  void CleanUp() {
    DCHECK_CURRENTLY_ON(BrowserThread::UI);
    if (dispatcher_)
      dispatcher_->RemoveWorkerCallbacksForProcess(render_process_id_);
    // Note: we are deleted here!
  }

  void OnExtensionFunctionCompleted(int request_id,
                                    ExtensionFunction::ResponseType type,
                                    const base::ListValue& results,
                                    const std::string& error,
                                    functions::HistogramValue histogram_value) {
    content::RenderProcessHost* sender =
        content::RenderProcessHost::FromID(render_process_id_);
    if (type == ExtensionFunction::BAD_MESSAGE) {
      KillBadMessageSenderRPH(sender, histogram_value);
      return;
    }
    DCHECK(sender);
    sender->Send(new ExtensionMsg_ResponseWorker(
        worker_thread_id_, request_id, type == ExtensionFunction::SUCCEEDED,
        results, error));
  }

  base::WeakPtr<ExtensionFunctionDispatcher> dispatcher_;
  ScopedObserver<content::RenderProcessHost,
                 UIThreadWorkerResponseCallbackWrapper>
      observer_;
  const int render_process_id_;
  const int worker_thread_id_;
  base::WeakPtrFactory<UIThreadWorkerResponseCallbackWrapper> weak_ptr_factory_;

  DISALLOW_COPY_AND_ASSIGN(UIThreadWorkerResponseCallbackWrapper);
};

struct ExtensionFunctionDispatcher::WorkerResponseCallbackMapKey {
  WorkerResponseCallbackMapKey(int render_process_id, int embedded_worker_id)
      : render_process_id(render_process_id),
        embedded_worker_id(embedded_worker_id) {}

  bool operator<(const WorkerResponseCallbackMapKey& other) const {
    return std::tie(render_process_id, embedded_worker_id) <
           std::tie(other.render_process_id, other.embedded_worker_id);
  }

  int render_process_id;
  int embedded_worker_id;
};

    content::RenderFrameHost* render_frame_host,
    int render_process_id) {
  if (render_frame_host) {
    // Extension API from a non Service Worker context, e.g. extension page,
    // background page, content script.
    UIThreadResponseCallbackWrapperMap::const_iterator iter =
        ui_thread_response_callback_wrappers_.find(render_frame_host);
    UIThreadResponseCallbackWrapper* callback_wrapper = nullptr;
    if (iter == ui_thread_response_callback_wrappers_.end()) {
      callback_wrapper =
          new UIThreadResponseCallbackWrapper(AsWeakPtr(), render_frame_host);
      ui_thread_response_callback_wrappers_[render_frame_host] =
          callback_wrapper;
    } else {
      callback_wrapper = iter->second;
    }
    DispatchWithCallbackInternal(
        params, render_frame_host, render_process_id,
        callback_wrapper->CreateCallback(params.request_id));
    // Extension API from Service Worker.
    DCHECK_GE(params.embedded_worker_id, 0);
    WorkerResponseCallbackMapKey key(render_process_id,
                                     params.embedded_worker_id);
    UIThreadWorkerResponseCallbackWrapperMap::const_iterator iter =
        ui_thread_response_callback_wrappers_for_worker_.find(key);
    UIThreadWorkerResponseCallbackWrapper* callback_wrapper = nullptr;
    if (iter == ui_thread_response_callback_wrappers_for_worker_.end()) {
      callback_wrapper = new UIThreadWorkerResponseCallbackWrapper(
          AsWeakPtr(), render_process_id, params.worker_thread_id);
      ui_thread_response_callback_wrappers_for_worker_[key] =
          base::WrapUnique(callback_wrapper);
    } else {
      callback_wrapper = iter->second.get();
    }
    DispatchWithCallbackInternal(
        params, nullptr, render_process_id,
        callback_wrapper->CreateCallback(params.request_id));
    int render_process_id,
  if (render_frame_host)
    DCHECK_EQ(render_process_id, render_frame_host->GetProcess()->GetID());

  scoped_refptr<ExtensionFunction> function(CreateExtensionFunction(
      params, extension, render_process_id, *process_map,
      ExtensionAPI::GetSharedInstance(), browser_context_, callback));
  // TODO(lazyboy): API functions from extension Service Worker will incorrectly
  // change keepalive count below.
void ExtensionFunctionDispatcher::RemoveWorkerCallbacksForProcess(
    int render_process_id) {
  UIThreadWorkerResponseCallbackWrapperMap& map =
      ui_thread_response_callback_wrappers_for_worker_;
  for (UIThreadWorkerResponseCallbackWrapperMap::iterator it = map.begin();
       it != map.end();) {
    if (it->first.render_process_id == render_process_id) {
      it = map.erase(it);
      continue;
    }
    ++it;
  }
}

  // TODO(lazyboy): API functions from extension Service Worker will incorrectly
  // change keepalive count below.
                content::RenderFrameHost* render_frame_host,
                int render_process_id);
  // Same as UIThreadResponseCallbackWrapper above, but applies to an extension
  // function from an extension Service Worker.
  class UIThreadWorkerResponseCallbackWrapper;

  // Key used to store UIThreadWorkerResponseCallbackWrapper in the map
  // |ui_thread_response_callback_wrappers_for_worker_|.
  struct WorkerResponseCallbackMapKey;

      int render_process_id,
  void RemoveWorkerCallbacksForProcess(int render_process_id);


  using UIThreadWorkerResponseCallbackWrapperMap =
      std::map<WorkerResponseCallbackMapKey,
               std::unique_ptr<UIThreadWorkerResponseCallbackWrapper>>;
  // TODO(lazyboy): The map entries are cleared upon RenderProcessHost shutown,
  // we should really be clearing it on service worker shutdown.
  UIThreadWorkerResponseCallbackWrapperMap
      ui_thread_response_callback_wrappers_for_worker_;
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/browser/extension_service_worker_message_filter.h"

#include "extensions/browser/extension_function_dispatcher.h"
#include "extensions/common/extension_messages.h"

namespace extensions {

ExtensionServiceWorkerMessageFilter::ExtensionServiceWorkerMessageFilter(
    int render_process_id,
    content::BrowserContext* context)
    : content::BrowserMessageFilter(ExtensionWorkerMsgStart),
      render_process_id_(render_process_id),
      browser_context_(context),
      dispatcher_(new ExtensionFunctionDispatcher(context)) {}

ExtensionServiceWorkerMessageFilter::~ExtensionServiceWorkerMessageFilter() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
}

void ExtensionServiceWorkerMessageFilter::OverrideThreadForMessage(
    const IPC::Message& message,
    content::BrowserThread::ID* thread) {
  if (message.type() == ExtensionHostMsg_RequestWorker::ID) {
    *thread = content::BrowserThread::UI;
  }
}

bool ExtensionServiceWorkerMessageFilter::OnMessageReceived(
    const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(ExtensionServiceWorkerMessageFilter, message)
    IPC_MESSAGE_HANDLER(ExtensionHostMsg_RequestWorker, OnRequestWorker)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}

void ExtensionServiceWorkerMessageFilter::OnRequestWorker(
    const ExtensionHostMsg_Request_Params& params) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  dispatcher_->Dispatch(params, nullptr, render_process_id_);
}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_BROWSER_EXTENSION_SERVICE_WORKER_MESSAGE_FILTER_H_
#define EXTENSIONS_BROWSER_EXTENSION_SERVICE_WORKER_MESSAGE_FILTER_H_

#include "base/macros.h"
#include "content/public/browser/browser_message_filter.h"

struct ExtensionHostMsg_Request_Params;

namespace content {
class BrowserContext;
}

namespace extensions {

class ExtensionFunctionDispatcher;

// IPC handler class for extension service worker.
class ExtensionServiceWorkerMessageFilter
    : public content::BrowserMessageFilter {
 public:
  ExtensionServiceWorkerMessageFilter(int render_process_id,
                                      content::BrowserContext* context);

  // content::BrowserMessageFilter:
  bool OnMessageReceived(const IPC::Message& message) override;
  void OverrideThreadForMessage(const IPC::Message& message,
                                content::BrowserThread::ID* thread) override;

 private:
  ~ExtensionServiceWorkerMessageFilter() override;

  void OnRequestWorker(const ExtensionHostMsg_Request_Params& params);

  const int render_process_id_;
  content::BrowserContext* browser_context_;

  std::unique_ptr<ExtensionFunctionDispatcher,
                  content::BrowserThread::DeleteOnUIThread>
      dispatcher_;

  DISALLOW_COPY_AND_ASSIGN(ExtensionServiceWorkerMessageFilter);
};

}  // namespace extensions

#endif  // EXTENSIONS_BROWSER_EXTENSION_SERVICE_WORKER_MESSAGE_FILTER_H_
  dispatcher_.Dispatch(params, render_frame_host,
                       render_frame_host->GetProcess()->GetID());

  // If this API call is for a service worker, then this is the worker thread
  // id. Otherwise, this is -1.
  IPC_STRUCT_MEMBER(int, worker_thread_id)

  // If this API call is for a service worker, then this is the embedded
  // worker id. Otherwise, this is -1.
  IPC_STRUCT_MEMBER(int, embedded_worker_id)

// Messages related to Extension Service Worker.
#undef IPC_MESSAGE_START
#define IPC_MESSAGE_START ExtensionWorkerMsgStart
// A service worker thread sends this message when an extension service worker
// starts an API request. The browser will always respond with a
// ExtensionMsg_ResponseWorker.
IPC_MESSAGE_CONTROL1(ExtensionHostMsg_RequestWorker,
                     ExtensionHostMsg_Request_Params)

// The browser sends this message in response to all service worker extension
// api calls. The response data (if any) is one of the base::Value subclasses,
// wrapped as the first element in a ListValue.
IPC_MESSAGE_CONTROL5(ExtensionMsg_ResponseWorker,
                     int /* thread_id */,
                     int /* request_id */,
                     bool /* success */,
                     base::ListValue /* response wrapper (see comment above) */,
                     std::string /* error */)
bool ExtensionsClient::ExtensionAPIEnabledInExtensionServiceWorkers() const {
  return false;
}

  // Returns whether or not extension APIs are allowed in extension service
  // workers.
  // This is currently disallowed as the code to support this is work in
  // progress.
  // Can be overridden in tests.
  virtual bool ExtensionAPIEnabledInExtensionServiceWorkers() const;

    contexts["extension_service_worker"] = Feature::SERVICE_WORKER_CONTEXT;
  // TODO(lazyboy): This isn't quite right for Extension Service Worker
  // extension API calls, since there's no guarantee that the extension is
  // "active" in current renderer process when the API permission check is
  // done.
  contexts->Append(new base::StringValue("extension_service_worker"));
  EXPECT_EQ(7u, feature->contexts()->size());
#include "content/public/child/worker_thread.h"
  // A worker's ScriptContext neither lives in ScriptContextSet nor it has a
  // RenderFrame associated with it, so early exit in this case.
  // TODO(lazyboy): Fix.
  if (content::WorkerThread::GetCurrentId() > 0)
    return;

#include "extensions/common/features/feature_util.h"
#include "extensions/renderer/worker_thread_dispatcher.h"
#include "third_party/WebKit/public/web/WebScriptController.h"
  // Ideally this should be done after checking
  // ExtensionAPIEnabledInExtensionServiceWorkers(), but the Dispatcher is
  // created so early that sending an IPC from browser/ process to synchronize
  // this enabled-ness is too late.
  WorkerThreadDispatcher::Get()->Init(RenderThread::Get());
  RegisterNativeHandlers(module_system, context, request_sender_.get(),
                         v8_schema_registry_.get());
    int embedded_worker_id,
  if (ExtensionsClient::Get()->ExtensionAPIEnabledInExtensionServiceWorkers()) {
    WorkerThreadDispatcher::Get()->AddWorkerData(embedded_worker_id);
    {
      // TODO(lazyboy): Make sure accessing |source_map_| in worker thread is
      // safe.
      std::unique_ptr<ModuleSystem> module_system(
          new ModuleSystem(context, &source_map_));
      context->set_module_system(std::move(module_system));
    }

    ModuleSystem* module_system = context->module_system();
    // Enable natives in startup.
    ModuleSystem::NativesEnabledScope natives_enabled_scope(module_system);
    RegisterNativeHandlers(
        module_system, context,
        WorkerThreadDispatcher::Get()->GetRequestSender(),
        WorkerThreadDispatcher::Get()->GetV8SchemaRegistry());
    // chrome.Event is part of the public API (although undocumented). Make it
    // lazily evalulate to Event from event_bindings.js.
    v8::Local<v8::Object> chrome = AsObjectOrEmpty(GetOrCreateChrome(context));
    if (!chrome.IsEmpty())
      module_system->SetLazyField(chrome, "Event", kEventBindings, "Event");

    UpdateBindingsForContext(context);
    // TODO(lazyboy): Get rid of RequireGuestViewModules() as this doesn't seem
    // necessary for Extension SW.
    RequireGuestViewModules(context);
    delegate_->RequireAdditionalModules(context,
                                        false /* is_within_platform_app */);
  }

    int embedded_worker_id,
  if (ExtensionsClient::Get()->ExtensionAPIEnabledInExtensionServiceWorkers())
    WorkerThreadDispatcher::Get()->RemoveWorkerData(embedded_worker_id);
// Note: this function runs on multiple threads: main renderer thread and
// service worker threads.
    case Feature::SERVICE_WORKER_CONTEXT:
      DCHECK(ExtensionsClient::Get()
                 ->ExtensionAPIEnabledInExtensionServiceWorkers());
    // Intentional fallthrough.
        if (context->IsAnyFeatureAvailableToContext(*map_entry.second.get())) {
          // TODO(lazyboy): RegisterBinding() uses |source_map_|, any thread
          // safety issue?
        }
                                        ScriptContext* context,
                                        RequestSender* request_sender,
                                        V8SchemaRegistry* v8_schema_registry) {
  RegisterNativeHandlers(module_system, context, this, request_sender,
                         v8_schema_registry);
// static.
// static.
  // Runs on a different thread and should only use thread safe member
  // variables.
  void DidInitializeServiceWorkerContextOnWorkerThread(
      int embedded_worker_id,
      int embedded_worker_id,
                              ScriptContext* context,
                              RequestSender* request_sender,
                              V8SchemaRegistry* v8_schema_registry);
  static v8::Local<v8::Object> GetOrCreateObject(
      const v8::Local<v8::Object>& object,
      const std::string& field,
      v8::Isolate* isolate);
  static v8::Local<v8::Object> GetOrCreateBindObjectIfAvailable(
  // TODO(lazyboy): ScriptContextSet isn't available on worker threads. We
  // should probably use WorkerScriptContextSet somehow.
      content::WorkerThread::GetCurrentId() == 0
          ? ScriptContextSet::GetContextByObject(object)
          : nullptr;
  bool for_service_worker =
      context->context_type() == Feature::SERVICE_WORKER_CONTEXT;
  // Note that |render_frame| would be nullptr for Service Workers. Service
  // Workers use control IPC instead.
  if (!for_service_worker && !render_frame) {
    // It is important to early exit here for non Service Worker contexts so
    // that we do not create orphaned PendingRequests below.
  }

  // Set Service Worker specific params to default values.
  params.worker_thread_id = -1;
  params.embedded_worker_id = -1;

  SendRequest(render_frame, for_io_thread, params);
}

void RequestSender::SendRequest(content::RenderFrame* render_frame,
                                bool for_io_thread,
                                ExtensionHostMsg_Request_Params& params) {
struct ExtensionHostMsg_Request_Params;

namespace content {
class RenderFrame;
}

  virtual ~RequestSender();
  // Sends the IPC to extension host for the API function that is described
  // in |params|.
  virtual void SendRequest(content::RenderFrame* render_frame,
                           bool for_io_thread,
                           ExtensionHostMsg_Request_Params& params);

  // TODO(lazyboy): Decide what we should do for SERVICE_WORKER_CONTEXT.
  GURL url = context_type() == Feature::SERVICE_WORKER_CONTEXT
                 ? url_
                 : GetDataSourceURLForFrame(web_frame());
      api, extension(), context_type(), url);
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/service_worker_data.h"

#include "extensions/renderer/service_worker_request_sender.h"
#include "extensions/renderer/worker_thread_dispatcher.h"

namespace extensions {

ServiceWorkerData::ServiceWorkerData(WorkerThreadDispatcher* dispatcher,
                                     int embedded_worker_id)
    : embedded_worker_id_(embedded_worker_id),
      v8_schema_registry_(new V8SchemaRegistry),
      request_sender_(
          new ServiceWorkerRequestSender(dispatcher, embedded_worker_id)) {}

ServiceWorkerData::~ServiceWorkerData() {}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_BROWSER_SERVICE_WORKER_DATA_H_
#define EXTENSIONS_BROWSER_SERVICE_WORKER_DATA_H_

#include <memory>

#include "base/macros.h"
#include "extensions/renderer/service_worker_request_sender.h"
#include "extensions/renderer/v8_schema_registry.h"

namespace extensions {
class WorkerThreadDispatcher;

// Per ServiceWorker data in worker thread.
// Contains: RequestSender, V8SchemaRegistry.
// TODO(lazyboy): Also put worker ScriptContexts in this.
class ServiceWorkerData {
 public:
  ServiceWorkerData(WorkerThreadDispatcher* dispatcher, int embedded_worker_id);
  ~ServiceWorkerData();

  V8SchemaRegistry* v8_schema_registry() { return v8_schema_registry_.get(); }
  RequestSender* request_sender() { return request_sender_.get(); }
  int embedded_worker_id() const { return embedded_worker_id_; }

 private:
  const int embedded_worker_id_;

  std::unique_ptr<V8SchemaRegistry> v8_schema_registry_;
  std::unique_ptr<ServiceWorkerRequestSender> request_sender_;

  DISALLOW_COPY_AND_ASSIGN(ServiceWorkerData);
};

}  // namespace extensions

#endif  // EXTENSIONS_BROWSER_SERVICE_WORKER_DATA_H_
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/service_worker_request_sender.h"

#include "content/public/child/worker_thread.h"
#include "extensions/common/extension_messages.h"
#include "extensions/renderer/worker_thread_dispatcher.h"

namespace extensions {

ServiceWorkerRequestSender::ServiceWorkerRequestSender(
    WorkerThreadDispatcher* dispatcher,
    int embedded_worker_id)
    : dispatcher_(dispatcher), embedded_worker_id_(embedded_worker_id) {}

ServiceWorkerRequestSender::~ServiceWorkerRequestSender() {}

void ServiceWorkerRequestSender::SendRequest(
    content::RenderFrame* render_frame,
    bool for_io_thread,
    ExtensionHostMsg_Request_Params& params) {
  DCHECK(!render_frame && !for_io_thread);
  int worker_thread_id = content::WorkerThread::GetCurrentId();
  DCHECK_GT(worker_thread_id, 0);
  params.worker_thread_id = worker_thread_id;
  params.embedded_worker_id = embedded_worker_id_;

  dispatcher_->Send(new ExtensionHostMsg_RequestWorker(params));
}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_RENDERER_SERVICE_WORKER_REQUEST_SENDER_H_
#define EXTENSIONS_RENDERER_SERVICE_WORKER_REQUEST_SENDER_H_

#include "extensions/renderer/request_sender.h"

namespace extensions {
class WorkerThreadDispatcher;

// A RequestSender variant for Extension Service Worker.
class ServiceWorkerRequestSender : public RequestSender {
 public:
  ServiceWorkerRequestSender(WorkerThreadDispatcher* dispatcher,
                             int embedded_worker_id);
  ~ServiceWorkerRequestSender() override;

  void SendRequest(content::RenderFrame* render_frame,
                   bool for_io_thread,
                   ExtensionHostMsg_Request_Params& params) override;

 private:
  WorkerThreadDispatcher* const dispatcher_;
  const int embedded_worker_id_;

  DISALLOW_COPY_AND_ASSIGN(ServiceWorkerRequestSender);
};

}  // namespace extensions

#endif  // EXTENSIONS_RENDERER_SERVICE_WORKER_REQUEST_SENDER_H_
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/worker_thread_dispatcher.h"

#include "base/threading/thread_local.h"
#include "base/values.h"
#include "content/public/child/worker_thread.h"
#include "content/public/renderer/render_thread.h"
#include "extensions/common/extension_messages.h"
#include "extensions/renderer/service_worker_data.h"

namespace extensions {

namespace {

base::LazyInstance<WorkerThreadDispatcher> g_instance =
    LAZY_INSTANCE_INITIALIZER;
base::LazyInstance<base::ThreadLocalPointer<extensions::ServiceWorkerData>>
    g_data_tls = LAZY_INSTANCE_INITIALIZER;

void OnResponseOnWorkerThread(int request_id,
                              bool succeeded,
                              const std::unique_ptr<base::ListValue>& response,
                              const std::string& error) {
  WorkerThreadDispatcher::GetRequestSender()->HandleResponse(
      request_id, succeeded, *response, error);
}

}  // namespace

WorkerThreadDispatcher::WorkerThreadDispatcher() {}
WorkerThreadDispatcher::~WorkerThreadDispatcher() {}

WorkerThreadDispatcher* WorkerThreadDispatcher::Get() {
  return g_instance.Pointer();
}

void WorkerThreadDispatcher::Init(content::RenderThread* render_thread) {
  DCHECK(render_thread);
  DCHECK_EQ(content::RenderThread::Get(), render_thread);
  DCHECK(!message_filter_);
  message_filter_ = render_thread->GetSyncMessageFilter();
  render_thread->AddObserver(this);
}

V8SchemaRegistry* WorkerThreadDispatcher::GetV8SchemaRegistry() {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  DCHECK(data);
  return data->v8_schema_registry();
}

// static
RequestSender* WorkerThreadDispatcher::GetRequestSender() {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  DCHECK(data);
  return data->request_sender();
}

bool WorkerThreadDispatcher::OnControlMessageReceived(
    const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(WorkerThreadDispatcher, message)
    IPC_MESSAGE_HANDLER(ExtensionMsg_ResponseWorker, OnResponseWorker)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}

bool WorkerThreadDispatcher::Send(IPC::Message* message) {
  return message_filter_->Send(message);
}

void WorkerThreadDispatcher::OnResponseWorker(int worker_thread_id,
                                              int request_id,
                                              bool succeeded,
                                              const base::ListValue& response,
                                              const std::string& error) {
  content::WorkerThread::PostTask(
      worker_thread_id,
      base::Bind(&OnResponseOnWorkerThread, request_id, succeeded,
                 // TODO(lazyboy): Can we avoid CreateDeepCopy()?
                 base::Passed(response.CreateDeepCopy()), error));
}

void WorkerThreadDispatcher::AddWorkerData(int embedded_worker_id) {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  if (!data) {
    ServiceWorkerData* new_data =
        new ServiceWorkerData(this, embedded_worker_id);
    g_data_tls.Pointer()->Set(new_data);
  }
}

void WorkerThreadDispatcher::RemoveWorkerData(int embedded_worker_id) {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  if (data) {
    DCHECK_EQ(embedded_worker_id, data->embedded_worker_id());
    delete data;
    g_data_tls.Pointer()->Set(nullptr);
  }
}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_RENDERER_WORKER_THREAD_DISPATCHER_H_
#define EXTENSIONS_RENDERER_WORKER_THREAD_DISPATCHER_H_

#include "base/synchronization/lock.h"
#include "content/public/renderer/render_thread_observer.h"
#include "ipc/ipc_sync_message_filter.h"

namespace base {
class ListValue;
}

namespace content {
class RenderThread;
}

namespace extensions {
class RequestSender;
class V8SchemaRegistry;

// Sends and receives IPC in an extension Service Worker.
// TODO(lazyboy): This class should really be a combination of the following
// two:
// 1) A content::WorkerThreadMessageFilter, so that we can receive IPC directly
// on worker thread.
// 2) A content::ThreadSafeSender, so we can safely send IPC from worker thread.
class WorkerThreadDispatcher : public content::RenderThreadObserver {
 public:
  WorkerThreadDispatcher();
  ~WorkerThreadDispatcher() override;

  // Thread safe.
  static WorkerThreadDispatcher* Get();
  static RequestSender* GetRequestSender();

  void Init(content::RenderThread* render_thread);
  bool Send(IPC::Message* message);
  void AddWorkerData(int embedded_worker_id);
  void RemoveWorkerData(int embedded_worker_id);
  V8SchemaRegistry* GetV8SchemaRegistry();

 private:
  // content::RenderThreadObserver:
  bool OnControlMessageReceived(const IPC::Message& message) override;

  // IPC handlers.
  void OnResponseWorker(int worker_thread_id,
                        int request_id,
                        bool succeeded,
                        const base::ListValue& response,
                        const std::string& error);

  // IPC sender. Belongs to the render thread, but thread safe.
  scoped_refptr<IPC::SyncMessageFilter> message_filter_;

  DISALLOW_COPY_AND_ASSIGN(WorkerThreadDispatcher);
};

}  // namespace extensions

#endif  // EXTENSIONS_RENDERER_WORKER_THREAD_DISPATCHER_H_
  ExtensionWorkerMsgStart,
#include "bindings/core/v8/ScriptController.h"
        // Initialize V8 extensions before creating the context.
        Vector<const char*> extensionNames;
        if (m_globalScope->isServiceWorkerGlobalScope() && Platform::current()->allowScriptExtensionForServiceWorker(toWorkerGlobalScope(m_globalScope.get())->url())) {
            const V8Extensions& extensions = ScriptController::registeredExtensions();
            extensionNames.reserveInitialCapacity(extensions.size());
            for (const auto* extension : extensions)
                extensionNames.append(extension->name());
        }
        v8::ExtensionConfiguration extensionConfiguration(extensionNames.size(), extensionNames.data());

        context = v8::Context::New(m_isolate, &extensionConfiguration, globalTemplate);
    virtual bool allowScriptExtensionForServiceWorker(const WebURL& scriptUrl) { return false; }
    RouteFunction("CHECK",
        base::Bind(&LoggingNativeHandler::Check, base::Unretained(this)));
  }

  v8::Handle<v8::Value> Check(const v8::Arguments& args) {
    bool check_value;
    std::string error_message;
    ParseArgs(args, &check_value, &error_message);
    CHECK(check_value) << error_message;
    return v8::Undefined();
    bool check_value;
    ParseArgs(args, &check_value, &error_message);
    DCHECK(check_value) << error_message;
    return v8::Undefined();
  }

 private:
  void ParseArgs(const v8::Arguments& args,
                 bool* check_value,
                 std::string* error_message) {
    CHECK_LE(args.Length(), 2);
    *check_value = args[0]->BooleanValue();
      *error_message = "Error: " + std::string(
          *v8::String::AsciiValue(args[1]));
      *error_message += "\n    <no stack trace>";
        *error_message += base::StringPrintf("\n    at %s (%s:%d:%d)",
  // Custom types sources.
  source_map_.RegisterSource("ChromeSetting", IDR_CHROME_SETTING_JS);
  source_map_.RegisterSource("StorageArea", IDR_STORAGE_AREA_JS);
  source_map_.RegisterSource("ContentSetting", IDR_CONTENT_SETTING_JS);

        "    CHECK: function(foo, bar) { return undefined; },"
        "    loadTypeSchema: function(foo) { return undefined; },"
    layer->scrollToOffset(toIntSize(point), ScrollOffsetClamped);
                    innerLayer->scrollToOffset(scrollOffset, ScrollOffsetClamped);
        layer()->scrollToXOffset(newLeft, ScrollOffsetClamped);
        layer()->scrollToYOffset(newTop, ScrollOffsetClamped);
        m_scrollableArea->scrollToOffset(newScrollOffset, clamp);
    m_scrollableArea->scrollToOffset(scrollOffset, clamp);
        IntSize clampedScrollOffset = m_scrollableArea->clampScrollOffset(adjustedScrollOffset() + toIntSize(roundedIntRect(r).location()));
            m_scrollableArea->scrollToOffset(clampedScrollOffset);
    IntSize scrollDimensions = scrollableArea()->maximumScrollPosition() - scrollableArea()->minimumScrollPosition();
    return m_scrollableArea->scrollWidth();
    return m_scrollableArea->scrollHeight();
    bool hasHorizontalOverflow = m_scrollableArea->hasHorizontalOverflow();
    bool hasVerticalOverflow = m_scrollableArea->hasVerticalOverflow();
        m_hBar->setProportion(clientWidth, m_scrollableArea->overflowRect().width());
        m_vBar->setProportion(clientHeight, m_scrollableArea->overflowRect().height());
    updateScrollableAreaSet(m_scrollableArea->hasScrollableHorizontalOverflow() || m_scrollableArea->hasScrollableVerticalOverflow());
    m_scrollableArea->updateAfterLayout();
    m_scrollableArea->updateAfterStyleChange(oldStyle);
            rect.append(m_scrollableArea->overflowRect());
#include "core/editing/FrameSelection.h"
#include "core/inspector/InspectorInstrumentation.h"
#include "core/page/EventHandler.h"
#include "core/rendering/RenderLayerCompositor.h"
#include "core/rendering/RenderView.h"
    , m_scrollDimensionsDirty(true)
void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
    if (!toRenderBox(renderer())->isMarquee()) {
        // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (scrollOffset() == toIntSize(newScrollOffset))
        return;

    setScrollOffset(toIntSize(newScrollOffset));

    Frame* frame = renderer()->frame();
    InspectorInstrumentation::willScrollLayer(renderer());

    RenderView* view = renderer()->view();

    // We should have a RenderView if we're trying to scroll.
    ASSERT(view);

    // Update the positions of our child layers (if needed as only fixed layers should be impacted by a scroll).
    // We don't update compositing layers, because we need to do a deep update from the compositing ancestor.
    bool inLayout = view ? view->frameView()->isInLayout() : false;
    if (!inLayout) {
        // If we're in the middle of layout, we'll just update layers once layout has finished.
        m_layer->updateLayerPositionsAfterOverflowScroll();
        if (view) {
            // Update regions, scrolling may change the clip of a particular region.
            view->frameView()->updateAnnotatedRegions();
            view->updateWidgetPositions();
        }

        m_layer->updateCompositingLayersAfterScroll();
    }

    RenderLayerModelObject* repaintContainer = renderer()->containerForRepaint();
    if (frame) {
        // The caret rect needs to be invalidated after scrolling
        frame->selection().setCaretRectNeedsUpdate();

        FloatQuad quadForFakeMouseMoveEvent = FloatQuad(m_layer->m_repaintRect);
        if (repaintContainer)
            quadForFakeMouseMoveEvent = repaintContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
        frame->eventHandler()->dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
    }

    bool requiresRepaint = true;

    if (m_layer->compositor()->inCompositingMode() && m_layer->usesCompositedScrolling())
        requiresRepaint = false;

    // Just schedule a full repaint of our object.
    if (view && requiresRepaint)
        renderer()->repaintUsingContainer(repaintContainer, pixelSnappedIntRect(m_layer->m_repaintRect));

    // Schedule the scroll DOM event.
    if (renderer()->node())
        renderer()->node()->document().eventQueue()->enqueueOrDispatchScrollEvent(renderer()->node(), DocumentEventQueue::ScrollEventElementTarget);

    InspectorInstrumentation::didScrollLayer(renderer());
    return -scrollOrigin();
    RenderBox* box = toRenderBox(renderer());

    if (!box->hasOverflowClip())
        return -scrollOrigin();

    return -scrollOrigin() + enclosingIntRect(m_overflowRect).size() - enclosingIntRect(box->clientBoxRect()).size();
    return IntSize(scrollWidth(), scrollHeight());
int RenderLayerScrollableArea::scrollWidth() const
{
    RenderBox* box = toRenderBox(renderer());
    if (m_scrollDimensionsDirty)
        const_cast<RenderLayerScrollableArea*>(this)->computeScrollDimensions();
    return snapSizeToPixel(m_overflowRect.width(), box->clientLeft() + box->x());
}

int RenderLayerScrollableArea::scrollHeight() const
{
    RenderBox* box = toRenderBox(renderer());
    if (m_scrollDimensionsDirty)
        const_cast<RenderLayerScrollableArea*>(this)->computeScrollDimensions();
    return snapSizeToPixel(m_overflowRect.height(), box->clientTop() + box->y());
}

void RenderLayerScrollableArea::computeScrollDimensions()
{
    RenderBox* box = toRenderBox(renderer());

    m_scrollDimensionsDirty = false;

    m_overflowRect = box->layoutOverflowRect();
    box->flipForWritingMode(m_overflowRect);

    int scrollableLeftOverflow = m_overflowRect.x() - box->borderLeft();
    int scrollableTopOverflow = m_overflowRect.y() - box->borderTop();
    setScrollOrigin(IntPoint(-scrollableLeftOverflow, -scrollableTopOverflow));
}

void RenderLayerScrollableArea::scrollToOffset(const IntSize& scrollOffset, ScrollOffsetClamping clamp)
{
    IntSize newScrollOffset = clamp == ScrollOffsetClamped ? clampScrollOffset(scrollOffset) : scrollOffset;
    if (newScrollOffset != adjustedScrollOffset())
        scrollToOffsetWithoutAnimation(-scrollOrigin() + newScrollOffset);
}

void RenderLayerScrollableArea::updateAfterLayout()
{
    m_scrollDimensionsDirty = true;
    IntSize originalScrollOffset = adjustedScrollOffset();

    computeScrollDimensions();

    if (!toRenderBox(renderer())->isMarquee()) {
        // Layout may cause us to be at an invalid scroll position. In this case we need
        // to pull our scroll offsets back to the max (or push them up to the min).
        IntSize clampedScrollOffset = clampScrollOffset(adjustedScrollOffset());
        if (clampedScrollOffset != adjustedScrollOffset())
            scrollToOffset(clampedScrollOffset);
    }

    if (originalScrollOffset != adjustedScrollOffset())
        scrollToOffsetWithoutAnimation(-scrollOrigin() + adjustedScrollOffset());
}

bool RenderLayerScrollableArea::hasHorizontalOverflow() const
{
    ASSERT(!m_scrollDimensionsDirty);

    return scrollWidth() > toRenderBox(renderer())->pixelSnappedClientWidth();
}

bool RenderLayerScrollableArea::hasVerticalOverflow() const
{
    ASSERT(!m_scrollDimensionsDirty);

    return scrollHeight() > toRenderBox(renderer())->pixelSnappedClientHeight();
}

bool RenderLayerScrollableArea::hasScrollableHorizontalOverflow() const
{
    return hasHorizontalOverflow() && toRenderBox(renderer())->scrollsOverflowX();
}

bool RenderLayerScrollableArea::hasScrollableVerticalOverflow() const
{
    return hasVerticalOverflow() && toRenderBox(renderer())->scrollsOverflowY();
}

void RenderLayerScrollableArea::updateAfterStyleChange(const RenderStyle*)
{
    if (!m_scrollDimensionsDirty)
        m_layer->updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
}

IntSize RenderLayerScrollableArea::clampScrollOffset(const IntSize& scrollOffset) const
{
    RenderBox* box = toRenderBox(renderer());

    int maxX = scrollWidth() - box->pixelSnappedClientWidth();
    int maxY = scrollHeight() - box->pixelSnappedClientHeight();

    int x = std::max(std::min(scrollOffset.width(), maxX), 0);
    int y = std::max(std::min(scrollOffset.height(), maxY), 0);
    return IntSize(x, y);
}

enum ScrollOffsetClamping {
    ScrollOffsetUnclamped,
    ScrollOffsetClamped
};

    // FIXME: We shouldn't allow access to m_overflowRect outside this class.
    LayoutRect overflowRect() const { return m_overflowRect; }

    void scrollToOffset(const IntSize& scrollOffset, ScrollOffsetClamping = ScrollOffsetUnclamped);

    void updateAfterLayout();
    void updateAfterStyleChange(const RenderStyle*);

    bool hasHorizontalOverflow() const;
    bool hasVerticalOverflow() const;
    bool hasScrollableHorizontalOverflow() const;
    bool hasScrollableVerticalOverflow() const;

    int scrollWidth() const;
    int scrollHeight() const;

    void computeScrollDimensions();

    IntSize clampScrollOffset(const IntSize&) const;
    IntSize adjustedScrollOffset() const { return IntSize(scrollXOffset(), scrollYOffset()); }

    unsigned m_scrollDimensionsDirty : 1;

    // The width/height of our scrolled area.
    LayoutRect m_overflowRect;

#if APPLE_CHANGES
    // We update our widget positions right after doing a layout.
    root->updateWidgetPositions();
#endif
    
    KHTMLAssert( needsLayout() );
    KHTMLAssert( minMaxKnown() );
#if !APPLE_CHANGES
    if ( m_widget )
#endif
#if APPLE_CHANGES
// FIXME: This should not be necessary.  Remove this once WebKit knows to properly schedule
// layouts using WebCore when objects resize.
void RenderPart::updateWidgetPositions()
{
    if (!m_widget)
        return;
    
    int x, y, width, height;
    absolutePosition(x,y);
    x += borderLeft() + paddingLeft();
    y += borderTop() + paddingTop();
    width = m_width - borderLeft() - borderRight() - paddingLeft() - paddingRight();
    height = m_height - borderTop() - borderBottom() - paddingTop() - paddingBottom();
    QRect newBounds(x,y,width,height);
    if (newBounds != m_widget->frameGeometry()) {
        // The widget changed positions.  Update the frame geometry.
        RenderArena *arena = ref();
        element()->ref();
        m_widget->setFrameGeometry(newBounds);
        element()->deref();
        deref(arena);
        
        QScrollView *view = static_cast<QScrollView *>(m_widget);
        if (view && view->inherits("KHTMLView"))
            static_cast<KHTMLView*>(view)->layout();
    }
}
#endif

#if APPLE_CHANGES
    // FIXME: This should not be necessary.  Remove this once WebKit knows to properly schedule
    // layouts using WebCore when objects resize.
    void updateWidgetPositions();
#endif

    // Move our widgets.
    m_object->updateWidgetPositions();
    
void RenderObject::updateWidgetPositions()
{
    for (RenderObject* curr = firstChild(); curr; curr = curr->nextSibling())
        curr->updateWidgetPositions();
}

    // Called recursively to update the absolute positions of all widgets.
    virtual void updateWidgetPositions();
    
void RenderWidget::layout( )
    KHTMLAssert( needsLayout() );
    KHTMLAssert( minMaxKnown() );
#if !APPLE_CHANGES
    if ( m_widget ) {
	resizeWidget( m_widget,
		      m_height-borderLeft()-borderRight()-paddingLeft()-paddingRight() );
#endif
#if APPLE_CHANGES
void RenderWidget::updateWidgetPositions()
{
    if (!m_widget)
        return;
    
    int x, y, width, height;
    absolutePosition(x,y);
    x += borderLeft() + paddingLeft();
    y += borderTop() + paddingTop();
    width = m_width - borderLeft() - borderRight() - paddingLeft() - paddingRight();
    height = m_height - borderTop() - borderBottom() - paddingTop() - paddingBottom();
    QRect newBounds(x,y,width,height);
    QRect oldBounds(m_widget->frameGeometry());
    if (newBounds != oldBounds) {
        // The widget changed positions.  Update the frame geometry.
        if (checkForRepaintDuringLayout()) {
            RenderCanvas* c = canvas();
            if (!c->printingMode()) {
                c->repaintViewRectangle(oldBounds);
                c->repaintViewRectangle(newBounds);
            }
        }

        RenderArena *arena = ref();
        element()->ref();
        m_widget->setFrameGeometry(newBounds);
        element()->deref();
        deref(arena);
    }
}
#endif

    virtual void updateWidgetPositions();
#include "chrome/browser/ui/browser_dialogs.h"
content::ColorChooser* DevToolsWindow::OpenColorChooser(
    WebContents* web_contents, SkColor initial_color) {
  return chrome::ShowColorChooser(web_contents, initial_color);
}

  virtual content::ColorChooser* OpenColorChooser(
      content::WebContents* web_contents,
      SkColor color) OVERRIDE;
#include "chrome/browser/ui/browser_dialogs.h"
content::ColorChooser* ExtensionHost::OpenColorChooser(
    WebContents* web_contents, SkColor initial_color) {
  return chrome::ShowColorChooser(web_contents, initial_color);
}

  virtual content::ColorChooser* OpenColorChooser(
      content::WebContents* web_contents, SkColor color) OVERRIDE;
// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/browser_dialogs.h"

// The actual android color chooser is at
// components/web_contents_delegate_android/color_chooser_android.cc

namespace chrome {

content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
  return NULL;
}

}  // namespace chrome
  if (should_quit_if_last_browser &&
      BrowserList::GetInstance(host_desktop_type_)->size() == 1) {
  }
                                                 SkColor initial_color) {
  return chrome::ShowColorChooser(web_contents, initial_color);
      content::WebContents* web_contents, SkColor color) OVERRIDE;
#include "third_party/skia/include/core/SkColor.h"
class ColorChooser;
// Shows a color chooser that reports to the given WebContents.
content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color);

#include "chrome/browser/ui/browser_dialogs.h"
content::ColorChooser* ShellWindow::OpenColorChooser(WebContents* web_contents,
                                                     SkColor initial_color) {
  return chrome::ShowColorChooser(web_contents, initial_color);
}

  virtual content::ColorChooser* OpenColorChooser(
      content::WebContents* web_contents, SkColor color) OVERRIDE;
#include "chrome/browser/ui/browser_dialogs.h"
class ColorChooserGtk : public content::ColorChooser {
  static ColorChooserGtk* Open(content::WebContents* web_contents,
                               SkColor initial_color);

  ColorChooserGtk(content::WebContents* web_contents, SkColor initial_color);
  static ColorChooserGtk* current_color_chooser_;

  // The web contents invoking the color chooser.  No ownership because it will
  // outlive this class.
  content::WebContents* web_contents_;
ColorChooserGtk* ColorChooserGtk::current_color_chooser_ = NULL;

ColorChooserGtk* ColorChooserGtk::Open(content::WebContents* web_contents,
                                       SkColor initial_color) {
  if (current_color_chooser_)
    current_color_chooser_->End();
  DCHECK(!current_color_chooser_);
  current_color_chooser_ = new ColorChooserGtk(web_contents, initial_color);
  return current_color_chooser_;
ColorChooserGtk::ColorChooserGtk(content::WebContents* web_contents,
                                 SkColor initial_color)
    : web_contents_(web_contents) {
  if (web_contents_)
    web_contents_->DidChooseColorInColorChooser(gfx::GdkColorToSkColor(color));
  DCHECK(current_color_chooser_ == this);
  current_color_chooser_ = NULL;
  if (web_contents_)
    web_contents_->DidEndColorChooser();

namespace chrome {

content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
  return ColorChooserGtk::Open(web_contents, initial_color);
}

}  // namespace chrome
#include "chrome/browser/ui/browser_dialogs.h"
  static ColorChooserAura* Open(content::WebContents* web_contents,
                                SkColor initial_color);

  ColorChooserAura(content::WebContents* web_contents, SkColor initial_color);
  static ColorChooserAura* current_color_chooser_;

  void DidEndColorChooser();
  // The web contents invoking the color chooser.  No ownership because it will
  // outlive this class.
  content::WebContents* web_contents_;

ColorChooserAura* ColorChooserAura::current_color_chooser_ = NULL;

ColorChooserAura::ColorChooserAura(content::WebContents* web_contents,
    : web_contents_(web_contents) {
      view_, web_contents->GetView()->GetNativeView());
  if (web_contents_)
    web_contents_->DidChooseColorInColorChooser(color);
  DidEndColorChooser();
    DidEndColorChooser();
void ColorChooserAura::DidEndColorChooser() {
  DCHECK(current_color_chooser_ == this);
  current_color_chooser_ = NULL;
  if (web_contents_)
    web_contents_->DidEndColorChooser();
}

// static
ColorChooserAura* ColorChooserAura::Open(
    content::WebContents* web_contents, SkColor initial_color) {
  if (current_color_chooser_)
    current_color_chooser_->End();
  DCHECK(current_color_chooser_);
  current_color_chooser_ = new ColorChooserAura(web_contents, initial_color);
  return current_color_chooser_;
}

namespace chrome {

content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
  return ColorChooserAura::Open(web_contents, initial_color);

}  // namespace chrome
#include "chrome/browser/ui/browser_dialogs.h"
  static ColorChooserWin* Open(content::WebContents* web_contents,
                               SkColor initial_color);

  ColorChooserWin(content::WebContents* web_contents,
  static ColorChooserWin* current_color_chooser_;

  content::WebContents* web_contents_;
ColorChooserWin* ColorChooserWin::current_color_chooser_ = NULL;

ColorChooserWin* ColorChooserWin::Open(content::WebContents* web_contents,
                                       SkColor initial_color) {
  if (current_color_chooser_)
    return current_color_chooser_;
  return new ColorChooserWin(web_contents, initial_color);
ColorChooserWin::ColorChooserWin(content::WebContents* web_contents,
    : web_contents_(web_contents) {
      web_contents->GetRenderViewHost()->GetView()->GetNativeView());
  if (web_contents_)
    web_contents_->DidChooseColorInColorChooser(color);
  DCHECK(current_color_chooser_ == this);
  current_color_chooser_ = NULL;
  if (web_contents_)
    web_contents_->DidEndColorChooser();

namespace chrome {

content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
  return ColorChooserWin::Open(web_contents, initial_color);
}

}  // namespace chrome
#include "chrome/browser/ui/browser_dialogs.h"
content::ColorChooser* ExternalTabContainerWin::OpenColorChooser(
    WebContents* web_contents, SkColor initial_color) {
  return chrome::ShowColorChooser(web_contents, initial_color);
}

  virtual content::ColorChooser* OpenColorChooser(
      content::WebContents* web_contents, SkColor color) OVERRIDE;
ColorChooserAndroid::ColorChooserAndroid(content::WebContents* web_contents,
    : web_contents_(web_contents) {
  web_contents_->DidChooseColorInColorChooser(color);
  web_contents_->DidEndColorChooser();
namespace content {
class WebContents;
}  // namespace content

class ColorChooserAndroid : public content::ColorChooser {
  ColorChooserAndroid(content::WebContents* tab,
  // The web contents invoking the color chooser.  No ownership. because it will
  // outlive this class.
  content::WebContents* web_contents_;

#include "components/web_contents_delegate_android/color_chooser_android.h"
ColorChooser* WebContentsDelegateAndroid::OpenColorChooser(WebContents* source,
                                                           SkColor color)  {
  return new ColorChooserAndroid(source, color);
  virtual content::ColorChooser* OpenColorChooser(content::WebContents* source,
                                                  SkColor color) OVERRIDE;
      color_chooser_identifier_(0),
void WebContentsImpl::DidChooseColorInColorChooser(SkColor color) {
      GetRoutingID(), color_chooser_identifier_, color));
void WebContentsImpl::DidEndColorChooser() {
  Send(new ViewMsg_DidEndColorChooser(GetRoutingID(),
                                      color_chooser_identifier_));
  color_chooser_.reset();
  color_chooser_identifier_ = 0;
  ColorChooser* new_color_chooser = delegate_->OpenColorChooser(this, color);
  if (color_chooser_ == new_color_chooser)
    return;
  color_chooser_.reset(new_color_chooser);
  color_chooser_identifier_ = color_chooser_id;
      color_chooser_id == color_chooser_identifier_)
      color_chooser_id == color_chooser_identifier_)
  virtual void DidChooseColorInColorChooser(SkColor color) OVERRIDE;
  virtual void DidEndColorChooser() OVERRIDE;
  scoped_ptr<ColorChooser> color_chooser_;

  // A unique identifier for the current color chooser.  Identifiers are unique
  // across a renderer process.  This avoids race conditions in synchronizing
  // the browser and renderer processes.  For example, if a renderer closes one
  // chooser and opens another, and simultaneously the user picks a color in the
  // first chooser, the IDs can be used to drop the "chose a color" message
  // rather than erroneously tell the renderer that the user picked a color in
  // the second chooser.
  int color_chooser_identifier_;
// Interface for a color chooser.
  virtual void DidChooseColorInColorChooser(SkColor color) = 0;
  virtual void DidEndColorChooser() = 0;
    WebContents* web_contents, SkColor color) {
  virtual ColorChooser* OpenColorChooser(WebContents* web_contents,
                                         SkColor color);
  if (context_->is_valid())
  context_->Invalidate();
// A gin::Runner that delegates to its ScriptContext.
class ScriptContext::Runner : public gin::Runner {
 public:
  explicit Runner(ScriptContext* context);

  // gin::Runner overrides.
  void Run(const std::string& source,
           const std::string& resource_name) override;
  v8::Handle<v8::Value> Call(v8::Handle<v8::Function> function,
                             v8::Handle<v8::Value> receiver,
                             int argc,
                             v8::Handle<v8::Value> argv[]) override;
  gin::ContextHolder* GetContextHolder() override;

 private:
  ScriptContext* context_;
};

      url_(web_frame_ ? GetDataSourceURLForFrame(web_frame_) : GURL()),
      runner_(new Runner(this)) {
  gin::PerContextData::From(v8_context)->set_runner(runner_.get());
  runner_.reset();
ScriptContext::Runner::Runner(ScriptContext* context) : context_(context) {
}
void ScriptContext::Runner::Run(const std::string& source,
                                const std::string& resource_name) {
  context_->module_system()->RunString(source, resource_name);
}

v8::Handle<v8::Value> ScriptContext::Runner::Call(
    v8::Handle<v8::Function> function,
    v8::Handle<v8::Value> receiver,
    int argc,
    v8::Handle<v8::Value> argv[]) {
  return context_->CallFunction(function, argc, argv);
}

gin::ContextHolder* ScriptContext::Runner::GetContextHolder() {
  v8::HandleScope handle_scope(context_->isolate());
  return gin::PerContextData::From(context_->v8_context())->context_holder();
}

class ScriptContext : public RequestSender::Source {
  class Runner;

  scoped_ptr<Runner> runner_;

// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/module_system_test.h"
#include "extensions/renderer/script_context.h"
#include "gin/per_context_data.h"
#include "gin/runner.h"

namespace extensions {

using ScriptContextTest = ModuleSystemTest;

TEST_F(ScriptContextTest, GinRunnerLifetime) {
  ExpectNoAssertionsMade();
  base::WeakPtr<gin::Runner> weak_runner =
      gin::PerContextData::From(env()->context()->v8_context())
          ->runner()
          ->GetWeakPtr();
  env()->ShutdownModuleSystem();
  EXPECT_FALSE(weak_runner);
}

}  // namespace extensions
#include "third_party/WebKit/public/web/WebLocalFrame.h"
  blink::WebLocalFrame* frame = context()->web_frame();
    blink::WebLocalFrame* frame,

namespace blink {
class WebLocalFrame;
}
      blink::WebLocalFrame* frame,
  script_context_set_.reset(
      new ScriptContextSet(&extensions_, &active_extension_ids_));
  ScriptContext* context = script_context_set_->Register(
      frame, v8_context, extension_group, world_id);
  if (context->context_type() == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(context->extension());
  switch (context->context_type()) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  ScriptContext* context = script_context_set_->GetByV8Context(v8_context);
  script_context_set_->Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  if (ScriptContext::IsSandboxedPage(
          extensions_, ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_->ForEach(
  script_context_set_->ForEach(
  MessagingBindings::DeliverMessage(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(*script_context_set_, port_id,
  std::set<ScriptContext*> removed_contexts =
      script_context_set_->OnExtensionUnloaded(id);
  for (ScriptContext* context : removed_contexts) {
    request_sender_->InvalidateSource(context);
#include "base/memory/scoped_ptr.h"
#include "extensions/common/extension.h"
    return *script_context_set_;

  scoped_ptr<ScriptContextSet> script_context_set_;
  ExtensionIdSet active_extension_ids_;
#include "third_party/WebKit/public/web/WebLocalFrame.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
  if (blink::WebLocalFrame* webframe = context->web_frame())
#include "extensions/common/constants.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
                             blink::WebLocalFrame* web_frame,
  gin::PerContextData* gin_data = gin::PerContextData::From(v8_context);
  CHECK(gin_data);  // may fail if the v8::Context hasn't been registered yet
  gin_data->set_runner(runner_.get());
// static
bool ScriptContext::IsSandboxedPage(const ExtensionSet& extensions,
                                    const GURL& url) {
  // TODO(kalman): This is checking for the wrong thing, it should be checking
  // if the frame's security origin is unique. The extension sandbox directive
  // is checked for in extensions/common/manifest_handlers/csp_info.cc.
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

class WebLocalFrame;
class ExtensionSet;
                blink::WebLocalFrame* frame,
  // Returns whether |url| is sandboxed (as declared in any Extension in
  // |extension_set| as sandboxed).
  //
  // Declared in ScriptContext for lack of a better place, but this should
  // become unnecessary at some point as crbug.com/466373 is worked on.
  static bool IsSandboxedPage(const ExtensionSet& extension_set,
                              const GURL& url);

  blink::WebLocalFrame* web_frame() const { return web_frame_; }
  //
  // TODO(kalman): Remove this and replace with a GetOrigin() call which reads
  // of WebDocument::securityOrigin():
  //  - The URL can change (e.g. pushState) but the origin cannot. Luckily it
  //    appears as though callers don't make security decisions based on the
  //    result of GetURL() so it's not a problem... yet.
  //  - Origin is the correct check to be making.
  //  - It might let us remove the about:blank resolving?
  // The WebLocalFrame associated with this context. This can be NULL because
  // this object can outlive is destroyed asynchronously.
  blink::WebLocalFrame* web_frame_;
#include "content/public/common/url_constants.h"
#include "extensions/renderer/extension_groups.h"
#include "extensions/renderer/script_injection.h"
#include "third_party/WebKit/public/web/WebDocument.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
ScriptContextSet::ScriptContextSet(ExtensionSet* extensions,
                                   ExtensionIdSet* active_extension_ids)
    : extensions_(extensions), active_extension_ids_(active_extension_ids) {
ScriptContextSet::~ScriptContextSet() {
ScriptContext* ScriptContextSet::Register(
    blink::WebLocalFrame* frame,
    const v8::Handle<v8::Context>& v8_context,
    int extension_group,
    int world_id) {
  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());

  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  contexts_.insert(context);  // takes ownership
  return context;
                              : nullptr;
  return calling.IsEmpty() ? nullptr : GetByV8Context(calling);
    const v8::Handle<v8::Context>& v8_context) const {
  for (ScriptContext* script_context : contexts_) {
    if (script_context->v8_context() == v8_context)
      return script_context;
  return nullptr;
  std::set<ScriptContext*> contexts_copy = contexts_;
  for (ScriptContext* context : contexts_copy) {
std::set<ScriptContext*> ScriptContextSet::OnExtensionUnloaded(
  std::set<ScriptContext*> removed;
  ForEach(extension_id,
          base::Bind(&ScriptContextSet::DispatchOnUnloadEventAndRemove,
                     base::Unretained(this), &removed));
  return removed;
}

const Extension* ScriptContextSet::GetExtensionFromFrameAndWorld(
    const blink::WebLocalFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.
    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_->GetExtensionOrAppIDByURL(frame_url);
  // There are conditions where despite a context being associated with an
  // extension, no extension actually gets found. Ignore "invalid" because CSP
  // blocks extension page loading by switching the extension ID to "invalid".
  const Extension* extension = extensions_->GetByID(extension_id);
  if (!extension && !extension_id.empty() && extension_id != "invalid") {
    // TODO(kalman): Do something here?
  }
  return extension;
}

Feature::Context ScriptContextSet::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (ScriptContext::IsSandboxedPage(*extensions_, url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && active_extension_ids_->count(extension->id()) > 0) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of ScriptContext::IsSandboxedPage().
  if (!origin.isUnique() && extensions_->ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

void ScriptContextSet::DispatchOnUnloadEventAndRemove(
    std::set<ScriptContext*>* out,
    ScriptContext* context) {
  context->DispatchOnUnloadEvent();
  Remove(context);  // deleted asynchronously
  out->insert(context);
#include "base/macros.h"
#include "base/memory/weak_ptr.h"
#include "extensions/common/extension.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/features/feature.h"
#include "url/gurl.h"
namespace blink {
class WebLocalFrame;
class WebSecurityOrigin;
namespace content {
class RenderView;
// A container of ScriptContexts, responsible for both creating and managing
// them.
//
// Since calling JavaScript within a context can cause any number of contexts
// to be created or destroyed, this has additional smarts to help with the set
// changing underneath callers.
  ScriptContextSet(
      ExtensionSet* extensions,
      // Set of the IDs of extensions that are active in this process.
      // Must outlive this. TODO(kalman): Combine this and |extensions|.
      ExtensionIdSet* active_extension_ids);

  // Returns the number of contexts being tracked by this set.
  // This may also include invalid contexts. TODO(kalman): Useful?
  size_t size() const { return contexts_.size(); }
  // Creates and starts managing a new ScriptContext. Ownership is held.
  // Returns a weak reference to the new ScriptContext.
  ScriptContext* Register(blink::WebLocalFrame* frame,
                          const v8::Handle<v8::Context>& v8_context,
                          int extension_group,
                          int world_id);
  ScriptContext* GetByV8Context(const v8::Handle<v8::Context>& context) const;
  std::set<ScriptContext*> OnExtensionUnloaded(const std::string& extension_id);
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(
      const blink::WebLocalFrame* frame,
      int world_id,
      bool use_effective_url);

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  // Calls Remove on |context| then appends |context| to |out|.
  // This is a helper designed to be used by OnExtensionUnloaded with ForEach.
  void DispatchOnUnloadEventAndRemove(std::set<ScriptContext*>* out,
                                      ScriptContext* context);

  // Weak reference to all installed Extensions.
  ExtensionSet* extensions_;

  // Weak reference to all installed Extensions that are also active in this
  // process.
  ExtensionIdSet* active_extension_ids_;

  // The set of all ScriptContexts we own.
  std::set<ScriptContext*> contexts_;
#include <vector>

#include "extensions/common/extension_set.h"
TEST(ScriptContextSetTest, Lifecycle) {
  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebLocalFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  // Do this after construction of the webview, since it may construct the
  // Isolate.

  v8::Local<v8::Context> v8_context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(v8_context);
  // ScriptContext relies on gin, it just doesn't look like it from here.
  context_holder.SetContext(v8_context);
  ExtensionSet extensions;
  ExtensionIdSet active_extensions;
  ScriptContextSet context_set(&extensions, &active_extensions);
  ScriptContext* context = context_set.Register(
      frame, v8_context, 0, 0);  // no extension group or world ID
  // Context is valid and resembles correctness.
  EXPECT_TRUE(context->is_valid());
  EXPECT_EQ(frame, context->web_frame());
  EXPECT_EQ(v8_context, context->v8_context());
  // Context has been correctly added.
  EXPECT_EQ(1u, context_set.size());
  EXPECT_EQ(context, context_set.GetByV8Context(v8_context));
  // Test context is correctly removed.
  EXPECT_EQ(0u, context_set.size());
  EXPECT_EQ(nullptr, context_set.GetByV8Context(v8_context));
    std::string suffix(&ent->fts_path[from_path.value().size()]);
    // Strip the leading '/' (if any).
    if (!suffix.empty()) {
      DCHECK(suffix[0] == '/');
      suffix.erase(0, 1);
    }
    const FilePath target_path = to_path.Append(suffix);
        if (mkdir(target_path.value().c_str(), 0777) != 0) {
        if (!CopyFile(FilePath(ent->fts_path), target_path))
  EXPECT_TRUE(base::WaitForSingleProcess(handle, 5000));
                                      NULL);
  localized_strings->SetString("deleteCookiesFlashCheckbox",
      l10n_util::GetStringUTF16(IDS_DEL_COOKIES_FLASH_CHKBOX));
    if (*clear_plugin_lso_data_enabled_)
#include "chrome/browser/prefs/pref_member.h"
  // Keeps track of whether clearing LSO data is supported.
  BooleanPrefMember clear_plugin_lso_data_enabled_;
    { "cookies_clear_when_close", IDS_COOKIES_CLEAR_WHEN_CLOSE_CHKBOX },
    { "cookies_lso_clear_when_close", IDS_COOKIES_LSO_CLEAR_WHEN_CLOSE_CHKBOX },
#include "chrome/browser/browser_process.h"
#include "chrome/common/pref_names.h"
void CoreOptionsHandler::Initialize() {
  clear_plugin_lso_data_enabled_.Init(prefs::kClearPluginLSODataEnabled,
                                      g_browser_process->local_state(),
                                      this);
  UpdateClearPluginLSOData();
}

void CoreOptionsHandler::UpdateClearPluginLSOData() {
  scoped_ptr<Value> enabled(
      Value::CreateBooleanValue(clear_plugin_lso_data_enabled_.GetValue()));
  web_ui_->CallJavascriptFunction(
      "OptionsPage.setClearPluginLSODataEnabled", *enabled);
}

  if (*pref_name == prefs::kClearPluginLSODataEnabled) {
    // This preference is stored in Local State, not in the user preferences.
    UpdateClearPluginLSOData();
    return;
  }

#include "chrome/browser/plugin_data_remover_helper.h"
  virtual void Initialize();
  void UpdateClearPluginLSOData();

  // Used for asynchronously updating the preference stating whether clearing
  // LSO data is supported.
  PluginDataRemoverHelper clear_plugin_lso_data_enabled_;

  virtual void SetUpOnMainThread() {
    mock_core_options_handler_.reset(new StrictMock<MockCoreOptionsHandler>());
  }

  virtual void CleanUpOnMainThread() {
    mock_core_options_handler_.reset();
  }

    return mock_core_options_handler_.get();
  scoped_ptr<StrictMock<MockCoreOptionsHandler> > mock_core_options_handler_;
  EXPECT_CALL(*mock_core_options_handler_,
// Whether there is a Flash version installed that supports clearing LSO data.
const char kClearPluginLSODataEnabled[] = "browser.clear_lso_data_enabled";

extern const char kClearPluginLSODataEnabled[];

  // NaCl's memory allocator requires 0mod64K alignment and size for
  // shared memory objects.  To allow passing shared memory to NaCl,
  // therefore we round the size actually created to the nearest 64K unit.
  // To avoid client impact, we continue to retain the size as the
  // actual requested size.
  uint32 rounded_size = (size + 0xffff) & ~0xffff;
      read_only_ ? PAGE_READONLY : PAGE_READWRITE, 0,
      static_cast<DWORD>(rounded_size),
      IPC_MESSAGE_HANDLER(ViewHostMsg_CreateDedicatedWorker,
                          OnCreateDedicatedWorker)
void ResourceMessageFilter::OnCreateDedicatedWorker(const GURL& url,
                                                    int render_view_route_id,
                                                    int* route_id) {
  WorkerService::GetInstance()->CreateDedicatedWorker(
      url, id(), render_view_route_id, this, id(), *route_id);
  void OnCreateDedicatedWorker(const GURL& url,
                               int render_view_route_id,
                               int* route_id);
  Send(new WorkerProcessMsg_CreateWorker(
      instance.url, instance.worker_route_id));
      IPC_MESSAGE_HANDLER(ViewHostMsg_CreateDedicatedWorker,
                          OnCreateDedicatedWorker)
void WorkerProcessHost::OnCreateDedicatedWorker(const GURL& url,
                                                int render_view_route_id,
                                                int* route_id) {
  WorkerService::GetInstance()->CreateDedicatedWorker(
      url, instances_.front().renderer_id,
  void OnCreateDedicatedWorker(const GURL& url,
                               int render_view_route_id,
                               int* route_id);
bool WorkerService::CreateDedicatedWorker(const GURL &url,
                                          int renderer_id,
                                          int render_view_route_id,
                                          IPC::Message::Sender* sender,
                                          int sender_id,
                                          int sender_route_id) {
  bool CreateDedicatedWorker(const GURL &url,
                             int renderer_pid,
                             int render_view_route_id,
                             IPC::Message::Sender* sender,
                             int sender_id,
                             int sender_route_id);
  IPC_SYNC_MESSAGE_CONTROL2_1(ViewHostMsg_CreateDedicatedWorker,
                              GURL /* url */,
                              int /* render_view_route_id */,
                              int /* route_id */)

  // A renderer sends this to the browser process when it wants to create a
  // shared worker.  The browser will create the worker process if necessary,
  // and will return the route id on success.  On error returns
  // MSG_ROUTING_NONE.
  IPC_SYNC_MESSAGE_CONTROL3_1(ViewHostMsg_CreateSharedWorker,
  IPC_MESSAGE_CONTROL2(WorkerProcessMsg_CreateWorker,
#include "chrome/renderer/websharedworker_impl.h"
WebSharedWorkerImpl::WebSharedWorkerImpl(const GURL& url,
                                         const string16& name,
                                         ChildThread* child_thread,
    : WebWorkerBase(child_thread, route_id, render_view_route_id),
      url_(url),
      name_(name) {
bool WebSharedWorkerImpl::isStarted() {
void WebSharedWorkerImpl::startWorkerContext(
  DCHECK(url_ == script_url);
  IPC::Message* create_message = new ViewHostMsg_CreateSharedWorker(
      url_, name_, render_view_route_id_, &route_id_);
  CreateWorkerContext(create_message, script_url, user_agent, source_code);
void WebSharedWorkerImpl::connect(WebKit::WebMessagePortChannel* channel) {
void WebSharedWorkerImpl::OnMessageReceived(const IPC::Message& message) {
  IPC_BEGIN_MESSAGE_MAP(WebSharedWorkerImpl, message)
void WebSharedWorkerImpl::OnWorkerCreated() {
#ifndef CHROME_RENDERER_WEBSHAREDWORKER_IMPL_H_
#define CHROME_RENDERER_WEBSHAREDWORKER_IMPL_H_
class WebSharedWorkerImpl : public WebKit::WebSharedWorker,
                            private WebWorkerBase {
  WebSharedWorkerImpl(const GURL& url,
                      const string16& name,
                      ChildThread* child_thread,
  // IPC::Channel::Listener implementation.
  // The name and URL that uniquely identify this worker.
  GURL url_;
  string16 name_;

  DISALLOW_COPY_AND_ASSIGN(WebSharedWorkerImpl);
#endif  // CHROME_RENDERER_WEBSHAREDWORKER_IMPL_H_
void WebWorkerBase::CreateWorkerContext(IPC::Message* create_message,
                                        const GURL& script_url,
  // create_message is a sync message that sets route_id_
  void CreateWorkerContext(IPC::Message* create_message,
                           const GURL& script_url,
  IPC::Message* create_message = new ViewHostMsg_CreateDedicatedWorker(
      script_url, render_view_route_id_, &route_id_);
  CreateWorkerContext(create_message, script_url, user_agent, source_code);
                        client_,
                        WebWorkerClient::workerContextDestroyed)
#include "chrome/common/child_process.h"
#include "chrome/worker/nativewebworker_impl.h"
static bool UrlIsNativeWorker(const GURL& url) {
  // If the renderer was not passed the switch to enable native workers,
  // then the URL should be treated as a JavaScript worker.
  if (!CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableNativeWebWorkers)) {
    return false;
  }
  // Based on the suffix, decide whether the url should be considered
  // a NativeWebWorker (for .nexe) or a WebWorker (for anything else).
  const std::string kNativeSuffix(".nexe");
  std::string worker_url = url.path();
  // Compute the start index of the suffix.
  std::string::size_type suffix_index =
      worker_url.length() - kNativeSuffix.length();
  std::string::size_type pos = worker_url.find(kNativeSuffix, suffix_index);
  return (suffix_index == pos);
}

WebWorkerClientProxy::WebWorkerClientProxy(const GURL& url, int route_id)
    : url_(url),
      route_id_(route_id),
  if (UrlIsNativeWorker(url)) {
    // Launch a native worker.
    impl_ = NativeWebWorkerImpl::create(this);
  } else {
    // Launch a JavaScript worker.
    impl_ = WebWorker::create(this);
  }
  WorkerThread::current()->AddRoute(route_id_, this);
  ChildProcess::current()->AddRefProcess();
  impl_->clientDestroyed();
  WorkerThread::current()->RemoveRoute(route_id_);
  ChildProcess::current()->ReleaseProcess();

  delete this;
void WebWorkerClientProxy::OnMessageReceived(const IPC::Message& message) {
  if (!impl_)
    return;

  IPC_BEGIN_MESSAGE_MAP(WebWorkerClientProxy, message)
    IPC_MESSAGE_FORWARD(WorkerMsg_StartWorkerContext, impl_,
                        WebWorker::startWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_TerminateWorkerContext,
                        OnTerminateWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_PostMessage, OnPostMessage)
    IPC_MESSAGE_FORWARD(WorkerMsg_WorkerObjectDestroyed, impl_,
                        WebWorker::workerObjectDestroyed)
  IPC_END_MESSAGE_MAP()
}

void WebWorkerClientProxy::OnTerminateWorkerContext() {
  impl_->terminateWorkerContext();

void WebWorkerClientProxy::OnPostMessage(
    const string16& message,
    const std::vector<int>& sent_message_port_ids,
    const std::vector<int>& new_routing_ids) {
  WebMessagePortChannelArray channels(sent_message_port_ids.size());
  for (size_t i = 0; i < sent_message_port_ids.size(); i++) {
    channels[i] = new WebMessagePortChannelImpl(
        new_routing_ids[i], sent_message_port_ids[i]);
  }

  impl_->postMessageToWorkerContext(message, channels);
}
#include "googleurl/src/gurl.h"
class WebWorkerClientProxy : public WebKit::WebWorkerClient,
                             public IPC::Channel::Listener {
  WebWorkerClientProxy(const GURL& url, int route_id);
  // IPC::Channel::Listener implementation.
  virtual void OnMessageReceived(const IPC::Message& message);
  ~WebWorkerClientProxy();

  void OnTerminateWorkerContext();
  void OnPostMessage(const string16& message,
                     const std::vector<int>& sent_message_port_ids,
                     const std::vector<int>& new_routing_ids);

  // The source url for this worker.
  GURL url_;


  WebKit::WebWorker* impl_;

#include "chrome/worker/webworkerclient_proxy.h"
void WorkerThread::OnCreateWorker(const GURL& url, int route_id) {
  // WebWorkerClientProxy owns itself.
  new WebWorkerClientProxy(url, route_id);
  void OnCreateWorker(const GURL& url, int route_id);
        virtual ~WebSharedWorker() {}
        // Sends a connect event to the SharedWorker thread.
    class WebWorkerClient {
        virtual void postExceptionToWorkerObject(
            const WebString& errorString, int lineNumber,
            const WebString& sourceURL) = 0;

        virtual void postConsoleMessageToWorkerObject(
            int destinationIdentifier,
            int sourceIdentifier,
            int messageType,
            int messageLevel,
            const WebString& message,
            int lineNumber,
            const WebString& sourceURL) = 0;

        virtual void workerContextDestroyed() = 0;

        // Returns the notification presenter for this worker context.  Pointer
        // is owned by the object implementing WebWorkerClient.
        virtual WebNotificationPresenter* notificationPresenter() = 0;

        // This can be called on any thread to create a nested worker.
        virtual WebWorker* createWorker(WebWorkerClient* client) = 0;

    SharedWorkerScriptLoader(PassRefPtr<SharedWorker> worker, PassOwnPtr<MessagePortChannel> port, PassOwnPtr<WebSharedWorker> webWorker)
        : m_worker(worker)
        , m_webWorker(webWorker)
        , m_port(port)
    void load(const KURL&);
void SharedWorkerScriptLoader::load(const KURL& url)
    m_scriptLoader.loadAsynchronously(m_worker->scriptExecutionContext(), url, DenyCrossOriginRequests, this);
        m_webWorker->startWorkerContext(m_scriptLoader.url(), m_worker->scriptExecutionContext()->userAgent(m_scriptLoader.url()), m_scriptLoader.script());
        SharedWorkerScriptLoader* loader = new SharedWorkerScriptLoader(worker, port.release(), webWorker.release());
        loader->load(url);
  RenderThread::Get()->RegisterExtension(
      extensions::SafeBuiltins::CreateV8Extension());
#include "extensions/renderer/safe_builtins.h"
  RenderThread::Get()->RegisterExtension(SafeBuiltins::CreateV8Extension());

using v8_helpers::IsEmptyOrUndefied;
  if (!IsEmptyOrUndefied(retval)) {
  if (IsEmptyOrUndefied(has_port))
#include "extensions/renderer/safe_builtins.h"
class V8ExtensionConfigurator {
 public:
  V8ExtensionConfigurator()
      : safe_builtins_(SafeBuiltins::CreateV8Extension()),
        names_(1, safe_builtins_->name()),
        configuration_(
            new v8::ExtensionConfiguration(static_cast<int>(names_.size()),
                                           vector_as_array(&names_))) {
    v8::RegisterExtension(safe_builtins_.get());
  }

  v8::ExtensionConfiguration* GetConfiguration() {
    return configuration_.get();
  }

 private:
  scoped_ptr<v8::Extension> safe_builtins_;
  std::vector<const char*> names_;
  scoped_ptr<v8::ExtensionConfiguration> configuration_;
};

base::LazyInstance<V8ExtensionConfigurator>::Leaky g_v8_extension_configurator =
    LAZY_INSTANCE_INITIALIZER;

  context_holder_->SetContext(v8::Context::New(
      isolate, g_v8_extension_configurator.Get().GetConfiguration()));
  if (handler_function_value.IsEmpty() ||
      handler_function_value->IsUndefined()) {
  v8::Context::Scope context_scope(context_->v8_context());
  data->Set(
      v8::String::NewFromUtf8(isolate, kHandlerFunction),
  v8::Context::Scope context_scope(context_->v8_context());
        data->Get(v8::String::NewFromUtf8(isolate, kHandlerFunction));
    data->Delete(v8::String::NewFromUtf8(isolate, kHandlerFunction));
const char kClassName[] = "extensions::SafeBuiltins";
// Documentation for makeCallback in the JavaScript, out here to reduce the
// (very small) amount of effort that the v8 parser needs to do:
//
// Returns a new object with every function on |obj| configured to call()\n"
// itself with the given arguments.\n"
// E.g. given\n"
//    var result = makeCallable(Function.prototype)\n"
// |result| will be a object including 'bind' such that\n"
//    result.bind(foo, 1, 2, 3);\n"
// is equivalent to Function.prototype.bind.call(foo, 1, 2, 3), and so on.\n"
// This is a convenient way to save functions that user scripts may clobber.\n"
    "(function() {\n"
    "native function Apply();\n"
    "native function Save();\n"
    "      return Apply(\n"
    "  Save(builtin.name, safe);\n"
    "Save('JSON', {\n"
    "}());\n";
                          base::StringPrintf("%s::%s", kClassName, name));
void SaveImpl(const char* name,
              v8::Local<v8::Value> value,
              v8::Local<v8::Context> context) {
  CHECK(!value.IsEmpty() && value->IsObject()) << name;
  context->Global()->SetHiddenValue(MakeKey(name, context->GetIsolate()),
                                    value);
}

v8::Local<v8::Object> Load(const char* name, v8::Local<v8::Context> context) {
  v8::Local<v8::Value> value =
      context->Global()->GetHiddenValue(MakeKey(name, context->GetIsolate()));
  CHECK(!value.IsEmpty() && value->IsObject()) << name;
  return v8::Local<v8::Object>::Cast(value);
}
class ExtensionImpl : public v8::Extension {
 public:
  ExtensionImpl() : v8::Extension(kClassName, kScript) {}
  v8::Local<v8::FunctionTemplate> GetNativeFunctionTemplate(
      v8::Isolate* isolate,
      v8::Local<v8::String> name) override {
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    if (IsTrue(name->Equals(context, ToV8StringUnsafe(isolate, "Apply"))))
      return v8::FunctionTemplate::New(isolate, Apply);
    if (IsTrue(name->Equals(context, ToV8StringUnsafe(isolate, "Save"))))
      return v8::FunctionTemplate::New(isolate, Save);
    NOTREACHED() << *v8::String::Utf8Value(name);
    return v8::Local<v8::FunctionTemplate>();
  }

  static void Apply(const v8::FunctionCallbackInfo<v8::Value>& info) {
    CHECK(info.Length() == 5 && info[0]->IsFunction() &&  // function
          // info[1] could be an object or a string
          info[2]->IsObject() &&  // args
          info[3]->IsInt32() &&   // first_arg_index
          info[4]->IsInt32());    // args_length
    v8::Local<v8::Object> recv;
    if (info[1]->IsObject()) {
      recv = v8::Local<v8::Object>::Cast(info[1]);
    } else if (info[1]->IsString()) {
      recv = v8::StringObject::New(v8::Local<v8::String>::Cast(info[1]))
                 .As<v8::Object>();
    } else {
      info.GetIsolate()->ThrowException(
          v8::Exception::TypeError(ToV8StringUnsafe(
              info.GetIsolate(),
              "The first argument is the receiver and must be an object")));
      return;
    }
    v8::Local<v8::Object> args = v8::Local<v8::Object>::Cast(info[2]);
    v8::Local<v8::Context> context = info.GetIsolate()->GetCurrentContext();
      CHECK(IsTrue(args->Has(context, i + first_arg_index)));
      if (!GetProperty(context, args, i + first_arg_index, &argv[i]))
    if (function->Call(context, recv, argc, argv.get()).ToLocal(&return_value))
  static void Save(const v8::FunctionCallbackInfo<v8::Value>& info) {
    SaveImpl(*v8::String::Utf8Value(info[0]),
             info[1],
             info.GetIsolate()->GetCallingContext());
v8::Extension* SafeBuiltins::CreateV8Extension() { return new ExtensionImpl(); }
SafeBuiltins::SafeBuiltins(ScriptContext* context) : context_(context) {}
SafeBuiltins::~SafeBuiltins() {}
  return Load("Array", context_->v8_context());
  return Load("Function", context_->v8_context());
  return Load("JSON", context_->v8_context());
  return Load("Object", context_->v8_context());
  return Load("RegExp", context_->v8_context());
  return Load("String", context_->v8_context());
  return Load("Error", context_->v8_context());
// A collection of safe builtin objects, in that they won't be tained by
// extensions overriding methods on them.
  // Creates the v8::Extension which manages SafeBuiltins instances.
  static v8::Extension* CreateV8Extension();
  explicit SafeBuiltins(ScriptContext* context);

  virtual ~SafeBuiltins();
      safe_builtins_(this),
#include "extensions/renderer/safe_builtins.h"
  SafeBuiltins* safe_builtins() { return &safe_builtins_; }
  const SafeBuiltins* safe_builtins() const { return &safe_builtins_; }
  SafeBuiltins safe_builtins_;
inline bool IsEmptyOrUndefied(v8::Local<v8::Value> value) {
#include "chrome/browser/autofill_manager.h"
#include "chrome/browser/password_manager/password_manager.h"
#include "chrome/browser/plugin_installer.h"
#include "chrome/browser/tab_contents/tab_contents_view.h"
// static
int TabContents::find_request_id_counter_ = -1;

// TODO(brettw) many of the data members here have casts to WebContents.
// This object is the same as WebContents and is currently being merged.
// When this merge is done, the casts can be removed.
      view_(TabContentsView::Create(static_cast<WebContents*>(this))),
      ALLOW_THIS_IN_INITIALIZER_LIST(render_manager_(
          static_cast<WebContents*>(this),
          static_cast<WebContents*>(this))),
      property_bag_(),
      registrar_(),
      printing_(*static_cast<WebContents*>(this)),
      save_package_(),
      cancelable_consumer_(),
      autofill_manager_(),
      password_manager_(),
      plugin_installer_(),
      ALLOW_THIS_IN_INITIALIZER_LIST(fav_icon_helper_(
          static_cast<WebContents*>(this))),
      select_file_dialog_(),
      pending_install_(),
      current_load_start_(),
      load_state_(net::LOAD_STATE_IDLE),
      load_state_host_(),
      received_page_title_(false),
      is_starred_(false),
      contents_mime_type_(),
      encoding_(),
      download_shelf_(),
      shelf_visible_(false),
      infobar_delegates_(),
      last_download_shelf_show_(),
      find_ui_active_(false),
      find_op_aborted_(false),
      current_find_request_id_(find_request_id_counter_++),
      find_text_(),
      find_prepopulate_text_(NULL),
      find_result_(),
      capturing_contents_(false),
      is_being_destroyed_(false),
      notify_disconnection_(false),
      history_requests_(),
#if defined(OS_WIN)
      message_box_active_(CreateEvent(NULL, TRUE, FALSE, NULL)),
#endif
      last_javascript_message_dismissal_(),
      suppress_javascript_messages_(false) {

void TabContents::OnGearsCreateShortcutDone(
    const GearsShortcutData2& shortcut_data, bool success) {
  NavigationEntry* current_entry = controller_.GetLastCommittedEntry();
  bool same_page =
      current_entry && pending_install_.page_id == current_entry->page_id();

  if (success && same_page) {
    // Only switch to app mode if the user chose to create a shortcut and
    // we're still on the same page that it corresponded to.
    if (delegate())
      delegate()->ConvertContentsToApplication(this);
  }

  // Reset the page id to indicate no requests are pending.
  pending_install_.page_id = 0;
  pending_install_.callback_functor = NULL;
}
#include "base/basictypes.h"
#include "chrome/browser/cancelable_request.h"
#include "chrome/browser/download/save_package.h"
#include "chrome/browser/fav_icon_helper.h"
#include "chrome/browser/find_notification_details.h"
#include "chrome/browser/shell_dialogs.h"
#include "chrome/browser/renderer_host/render_view_host_delegate.h"
#include "chrome/browser/tab_contents/render_view_host_manager.h"
#include "chrome/common/gears_api.h"
#include "net/base/load_states.h"
#include "webkit/glue/password_form.h"
#include "webkit/glue/webpreferences.h"


#if defined(OS_MACOSX) || defined(OS_LINUX)
// Remove when we've finished porting the supporting classes.
#include "chrome/common/temp_scaffolding_stubs.h"
#elif defined(OS_WIN)
#include "chrome/browser/printing/print_view_manager.h"
#endif
class AutofillManager;
class PasswordManager;
class PluginInstaller;
class TabContentsView;
  // When CreateShortcut is invoked RenderViewHost::GetApplicationInfo is
  // invoked. CreateShortcut caches the state of the page needed to create the
  // shortcut in PendingInstall. When OnDidGetApplicationInfo is invoked, it
  // uses the information from PendingInstall and the WebApplicationInfo
  // to create the shortcut.
  class GearsCreateShortcutCallbackFunctor;
  struct PendingInstall {
    int32 page_id;
    SkBitmap icon;
    std::wstring title;
    GURL url;
    // This object receives the GearsCreateShortcutCallback and routes the
    // message back to the WebContents, if we haven't been deleted.
    GearsCreateShortcutCallbackFunctor* callback_functor;
  };

  // TODO(brettw) move thos to tab_contents.cc once WebContents and
  // TabContents are merged.
  class GearsCreateShortcutCallbackFunctor {
   public:
    explicit GearsCreateShortcutCallbackFunctor(TabContents* contents)
       : contents_(contents) {}

    void Run(const GearsShortcutData2& shortcut_data, bool success) {
      if (contents_)
        contents_->OnGearsCreateShortcutDone(shortcut_data, success);
      delete this;
    }
    void Cancel() {
      contents_ = NULL;
    }

   private:
    TabContents* contents_;
  };


  // Called when the user dismisses the shortcut creation dialog.  'success' is
  // true if the shortcut was created.
  void OnGearsCreateShortcutDone(const GearsShortcutData2& shortcut_data,
                                 bool success);

  // Data for core operation ---------------------------------------------------
  // Delegate for notifying our owner about stuff. Not owned by us.

  // Handles the back/forward list and loading.
  // The corresponding view.
  scoped_ptr<TabContentsView> view_;

  // Helper classes ------------------------------------------------------------

  // Manages creation and swapping of render views.
  RenderViewHostManager render_manager_;

  // Stores random bits of data for others to associate with this object.
  // Registers and unregisters us for notifications.
  // Handles print preview and print job for this contents.
  printing::PrintViewManager printing_;

  // SavePackage, lazily created.
  scoped_refptr<SavePackage> save_package_;

  // Tracks our pending CancelableRequests. This maps pending requests to
  // page IDs so that we know whether a given callback still applies. The
  // page ID -1 means no page ID was set.
  CancelableRequestConsumerT<int32, -1> cancelable_consumer_;

  // AutofillManager, lazily created.
  scoped_ptr<AutofillManager> autofill_manager_;

  // PasswordManager, lazily created.
  scoped_ptr<PasswordManager> password_manager_;

  // PluginInstaller, lazily created.
  scoped_ptr<PluginInstaller> plugin_installer_;

  // Handles downloading favicons.
  FavIconHelper fav_icon_helper_;

  // Dialog box used for choosing files to upload from file form fields.
  scoped_refptr<SelectFileDialog> select_file_dialog_;

  // Web app installation.
  PendingInstall pending_install_;

  // Data for loading state ----------------------------------------------------

  // Indicates if the tab is considered crashed.
  bool is_crashed_;
  // TODO(brettw) this seems like it can be removed according to the comment.
  // System time at which the current load was started.
  base::TimeTicks current_load_start_;

  // The current load state and the URL associated with it.
  net::LoadState load_state_;
  std::wstring load_state_host_;

  // Data for current page -----------------------------------------------------

  // Whether we have a (non-empty) title for the current page.
  // Used to prevent subsequent title updates from affecting history. This
  // prevents some weirdness because some AJAXy apps use titles for status
  // messages.
  bool received_page_title_;

  // Whether the current URL is starred
  bool is_starred_;

  // When a navigation occurs, we record its contents MIME type. It can be
  // used to check whether we can do something for some special contents.
  std::string contents_mime_type_;

  // Character encoding. TODO(jungshik) : convert to std::string
  std::wstring encoding_;

  // Data for shelves and stuff ------------------------------------------------

  // The download shelf view (view at the bottom of the page).
  scoped_ptr<DownloadShelf> download_shelf_;

  // Whether the shelf view is visible.
  bool shelf_visible_;
  // popups. This pointer also goes in |child_windows_| for ownership,
  // The last time that the download shelf was made visible.
  base::TimeTicks last_download_shelf_show_;

  // Data for find in page -----------------------------------------------------

  // TODO(brettw) this should be separated into a helper class.

  // Each time a search request comes in we assign it an id before passing it
  // over the IPC so that when the results come in we can evaluate whether we
  // still care about the results of the search (in some cases we don't because
  // the user has issued a new search).
  static int find_request_id_counter_;

  // True if the Find UI is active for this Tab.
  bool find_ui_active_;

  // True if a Find operation was aborted. This can happen if the Find box is
  // closed or if the search term inside the Find box is erased while a search
  // is in progress. This can also be set if a page has been reloaded, and will
  // on FindNext result in a full Find operation so that the highlighting for
  // inactive matches can be repainted.
  bool find_op_aborted_;

  // This variable keeps track of what the most recent request id is.
  int current_find_request_id_;

  // The last string we searched for. This is used to figure out if this is a
  // Find or a FindNext operation (FindNext should not increase the request id).
  string16 find_text_;

  // Keeps track of the last search string that was used to search in any tab.
  string16* find_prepopulate_text_;

  // The last find result. This object contains details about the number of
  // matches, the find selection rectangle, etc. The UI can access this
  // information to build its presentation.
  FindNotificationDetails find_result_;

  // Data for misc internal state ----------------------------------------------

  // See capturing_contents() above.
  bool capturing_contents_;

  // Indicates whether we should notify about disconnection of this
  // TabContents. This is used to ensure disconnection notifications only
  // happen if a connection notification has happened and that they happen only
  // once.
  bool notify_disconnection_;

  // Maps from handle to page_id.
  typedef std::map<HistoryService::Handle, int32> HistoryRequestMap;
  HistoryRequestMap history_requests_;

#if defined(OS_WIN)
  // Handle to an event that's set when the page is showing a message box (or
  // equivalent constrained window).  Plugin processes check this to know if
  // they should pump messages then.
  ScopedHandle message_box_active_;
#endif

  // The time that the last javascript message was dismissed.
  base::TimeTicks last_javascript_message_dismissal_;

  // True if the user has decided to block future javascript messages. This is
  // reset on navigations to false on navigations.
  bool suppress_javascript_messages_;

  // ---------------------------------------------------------------------------

    : TabContents(profile) {
    // Frame navigation can cause a new Document to be attached. Don't allow that, since that will
    // cause a situation where LocalFrame still has a Document attached after this finishes!
    // Normally, it shouldn't actually be possible to trigger navigation here. However, plugins
    // (see below) can cause lots of crazy things to happen, since plugin detach involves nested
    // message loops.
    FrameNavigationDisabler navigationDisabler(*m_frame);
    // Defer widget updates to avoid plugins trying to run script inside ScriptForbiddenScope,
    // which will crash the renderer after https://crrev.com/200984
    // Don't allow script to run in the middle of detach() because a detaching Document is not in a
    // consistent state.
    if (!isNavigationAllowed())
        return;
    , m_navigationDisableCount(0)
FrameNavigationDisabler::FrameNavigationDisabler(LocalFrame& frame)
    : m_frame(&frame)
{
    m_frame->disableNavigation();
}

FrameNavigationDisabler::~FrameNavigationDisabler()
{
    m_frame->enableNavigation();
}

    bool isNavigationAllowed() const { return m_navigationDisableCount == 0; }

    friend class FrameNavigationDisabler;

    void enableNavigation() { --m_navigationDisableCount; }
    void disableNavigation() { ++m_navigationDisableCount; }

    int m_navigationDisableCount;

class FrameNavigationDisabler {
    WTF_MAKE_NONCOPYABLE(FrameNavigationDisabler);
    STACK_ALLOCATED();
public:
    explicit FrameNavigationDisabler(LocalFrame&);
    ~FrameNavigationDisabler();

private:
    RawPtrWillBeMember<LocalFrame> m_frame;
};

        FrameNavigationDisabler navigationDisabler(*m_frame);
    return m_frame->page() && m_frame->isNavigationAllowed() && NavigationDisablerForBeforeUnload::isNavigationAllowed();
    return m_frame->page() && m_frame->isNavigationAllowed() && (protocolIsJavaScript(url) || NavigationDisablerForBeforeUnload::isNavigationAllowed());
#include "extensions/browser/extension_service_worker_message_filter.h"
#include "extensions/common/extensions_client.h"
  if (extensions::ExtensionsClient::Get()
          ->ExtensionAPIEnabledInExtensionServiceWorkers()) {
    host->AddFilter(new ExtensionServiceWorkerMessageFilter(id, profile));
  }
  Profile* profile = Profile::FromBrowserContext(
      web_contents ? web_contents->GetBrowserContext() : browser_context());
  Browser* browser = chrome::FindAnyBrowser(profile, include_incognito_);
  if (browser)
    return browser;
IN_PROC_BROWSER_TEST_F(ServiceWorkerTest, TabsCreate) {
  // Extensions APIs from SW are only enabled on trunk.
  ScopedCurrentChannel current_channel_override(version_info::Channel::UNKNOWN);
  const Extension* extension = LoadExtensionWithFlags(
      test_data_dir_.AppendASCII("service_worker/tabs_create"), kFlagNone);
  ASSERT_TRUE(extension);
  ui_test_utils::NavigateToURL(browser(),
                               extension->GetResourceURL("page.html"));
  content::WebContents* web_contents =
      browser()->tab_strip_model()->GetActiveWebContents();

  int starting_tab_count = browser()->tab_strip_model()->count();
  std::string result;
  ASSERT_TRUE(content::ExecuteScriptAndExtractString(
      web_contents, "window.runServiceWorker()", &result));
  ASSERT_EQ("chrome.tabs.create callback", result);
  EXPECT_EQ(starting_tab_count + 1, browser()->tab_strip_model()->count());

  // Check extension shutdown path.
  UnloadExtension(extension->id());
  EXPECT_EQ(starting_tab_count, browser()->tab_strip_model()->count());
}

bool ChromeContentClient::AllowScriptExtensionForServiceWorker(
    const GURL& script_url) {
#if defined(ENABLE_EXTENSIONS)
  return script_url.SchemeIs(extensions::kExtensionScheme) ||
         script_url.SchemeIs(extensions::kExtensionResourceScheme);
#else
  return false;
#endif
}

  bool AllowScriptExtensionForServiceWorker(const GURL& script_url) override;
bool ChromeExtensionsClient::ExtensionAPIEnabledInExtensionServiceWorkers()
    const {
  return GetCurrentChannel() == version_info::Channel::UNKNOWN;
}

  bool ExtensionAPIEnabledInExtensionServiceWorkers() const override;
void ChromeContentRendererClient::
    DidInitializeServiceWorkerContextOnWorkerThread(
        v8::Local<v8::Context> context,
        int embedded_worker_id,
        const GURL& url) {
  ChromeExtensionsRendererClient::GetInstance()
      ->extension_dispatcher()
      ->DidInitializeServiceWorkerContextOnWorkerThread(
          context, embedded_worker_id, url);
    int embedded_worker_id,
  extensions::Dispatcher::WillDestroyServiceWorkerContextOnWorkerThread(
      context, embedded_worker_id, url);
      int embedded_worker_id,
      int embedded_worker_id,
bool BlinkPlatformImpl::allowScriptExtensionForServiceWorker(
    const blink::WebURL& scriptUrl) {
  return GetContentClient()->AllowScriptExtensionForServiceWorker(scriptUrl);
}

  bool allowScriptExtensionForServiceWorker(
      const blink::WebURL& script_url) override;
bool ContentClient::AllowScriptExtensionForServiceWorker(
    const GURL& script_url) {
  return false;
}

  // Returns whether or not V8 script extensions should be allowed for a
  // service worker.
  virtual bool AllowScriptExtensionForServiceWorker(const GURL& script_url);

      int embedded_worker_id,
      int embedded_worker_id,
      ->DidInitializeServiceWorkerContextOnWorkerThread(
          context, embedded_worker_id_, script_url_);
      context, embedded_worker_id_, script_url_);
  // An extension function from Service Worker does not have a RenderFrameHost.
  if (!render_frame_host)
    return;
#include "base/scoped_observer.h"
#include "content/public/browser/render_process_host_observer.h"
#include "extensions/common/extensions_client.h"
  // The renderer has done validation before sending extension api requests.
  // Therefore, we should never receive a request that is invalid in a way
  // that JSON validation in the renderer should have caught. It could be an
  // attacker trying to exploit the browser, so we crash the renderer instead.
  LOG(ERROR) << "Terminating renderer because of malformed extension message.";
  if (content::RenderProcessHost::run_renderer_in_process()) {
    // In single process mode it is better if we don't suicide but just crash.
    CHECK(false);
    return;
  }

void KillBadMessageSenderRPH(content::RenderProcessHost* sender_process_host,
                             functions::HistogramValue histogram_value) {
  base::Process peer_process =
      content::RenderProcessHost::run_renderer_in_process()
          ? base::Process::Current()
          : base::Process::DeprecatedGetProcessFromHandle(
                sender_process_host->GetHandle());
  KillBadMessageSender(peer_process, histogram_value);
}

    KillBadMessageSender(peer_process, histogram_value);
class ExtensionFunctionDispatcher::UIThreadWorkerResponseCallbackWrapper
    : public content::RenderProcessHostObserver {
 public:
  UIThreadWorkerResponseCallbackWrapper(
      const base::WeakPtr<ExtensionFunctionDispatcher>& dispatcher,
      int render_process_id,
      int worker_thread_id)
      : dispatcher_(dispatcher),
        observer_(this),
        render_process_id_(render_process_id),
        worker_thread_id_(worker_thread_id),
        weak_ptr_factory_(this) {
    observer_.Add(content::RenderProcessHost::FromID(render_process_id_));
    DCHECK(ExtensionsClient::Get()
               ->ExtensionAPIEnabledInExtensionServiceWorkers());
  }

  ~UIThreadWorkerResponseCallbackWrapper() override {}

  // content::RenderProcessHostObserver override.
  void RenderProcessExited(content::RenderProcessHost* rph,
                           base::TerminationStatus status,
                           int exit_code) override {
    CleanUp();
  }

  // content::RenderProcessHostObserver override.
  void RenderProcessHostDestroyed(content::RenderProcessHost* rph) override {
    CleanUp();
  }

  ExtensionFunction::ResponseCallback CreateCallback(int request_id) {
    return base::Bind(
        &UIThreadWorkerResponseCallbackWrapper::OnExtensionFunctionCompleted,
        weak_ptr_factory_.GetWeakPtr(), request_id);
  }

 private:
  void CleanUp() {
    DCHECK_CURRENTLY_ON(BrowserThread::UI);
    if (dispatcher_)
      dispatcher_->RemoveWorkerCallbacksForProcess(render_process_id_);
    // Note: we are deleted here!
  }

  void OnExtensionFunctionCompleted(int request_id,
                                    ExtensionFunction::ResponseType type,
                                    const base::ListValue& results,
                                    const std::string& error,
                                    functions::HistogramValue histogram_value) {
    content::RenderProcessHost* sender =
        content::RenderProcessHost::FromID(render_process_id_);
    if (type == ExtensionFunction::BAD_MESSAGE) {
      KillBadMessageSenderRPH(sender, histogram_value);
      return;
    }
    DCHECK(sender);
    sender->Send(new ExtensionMsg_ResponseWorker(
        worker_thread_id_, request_id, type == ExtensionFunction::SUCCEEDED,
        results, error));
  }

  base::WeakPtr<ExtensionFunctionDispatcher> dispatcher_;
  ScopedObserver<content::RenderProcessHost,
                 UIThreadWorkerResponseCallbackWrapper>
      observer_;
  const int render_process_id_;
  const int worker_thread_id_;
  base::WeakPtrFactory<UIThreadWorkerResponseCallbackWrapper> weak_ptr_factory_;

  DISALLOW_COPY_AND_ASSIGN(UIThreadWorkerResponseCallbackWrapper);
};

struct ExtensionFunctionDispatcher::WorkerResponseCallbackMapKey {
  WorkerResponseCallbackMapKey(int render_process_id, int embedded_worker_id)
      : render_process_id(render_process_id),
        embedded_worker_id(embedded_worker_id) {}

  bool operator<(const WorkerResponseCallbackMapKey& other) const {
    return std::tie(render_process_id, embedded_worker_id) <
           std::tie(other.render_process_id, other.embedded_worker_id);
  }

  int render_process_id;
  int embedded_worker_id;
};

    content::RenderFrameHost* render_frame_host,
    int render_process_id) {
  if (render_frame_host) {
    // Extension API from a non Service Worker context, e.g. extension page,
    // background page, content script.
    UIThreadResponseCallbackWrapperMap::const_iterator iter =
        ui_thread_response_callback_wrappers_.find(render_frame_host);
    UIThreadResponseCallbackWrapper* callback_wrapper = nullptr;
    if (iter == ui_thread_response_callback_wrappers_.end()) {
      callback_wrapper =
          new UIThreadResponseCallbackWrapper(AsWeakPtr(), render_frame_host);
      ui_thread_response_callback_wrappers_[render_frame_host] =
          callback_wrapper;
    } else {
      callback_wrapper = iter->second;
    }
    DispatchWithCallbackInternal(
        params, render_frame_host, render_process_id,
        callback_wrapper->CreateCallback(params.request_id));
    // Extension API from Service Worker.
    DCHECK_GE(params.embedded_worker_id, 0);
    WorkerResponseCallbackMapKey key(render_process_id,
                                     params.embedded_worker_id);
    UIThreadWorkerResponseCallbackWrapperMap::const_iterator iter =
        ui_thread_response_callback_wrappers_for_worker_.find(key);
    UIThreadWorkerResponseCallbackWrapper* callback_wrapper = nullptr;
    if (iter == ui_thread_response_callback_wrappers_for_worker_.end()) {
      callback_wrapper = new UIThreadWorkerResponseCallbackWrapper(
          AsWeakPtr(), render_process_id, params.worker_thread_id);
      ui_thread_response_callback_wrappers_for_worker_[key] =
          base::WrapUnique(callback_wrapper);
    } else {
      callback_wrapper = iter->second.get();
    }
    DispatchWithCallbackInternal(
        params, nullptr, render_process_id,
        callback_wrapper->CreateCallback(params.request_id));
    int render_process_id,
  if (render_frame_host)
    DCHECK_EQ(render_process_id, render_frame_host->GetProcess()->GetID());

  scoped_refptr<ExtensionFunction> function(CreateExtensionFunction(
      params, extension, render_process_id, *process_map,
      ExtensionAPI::GetSharedInstance(), browser_context_, callback));
  // TODO(lazyboy): API functions from extension Service Worker will incorrectly
  // change keepalive count below.
void ExtensionFunctionDispatcher::RemoveWorkerCallbacksForProcess(
    int render_process_id) {
  UIThreadWorkerResponseCallbackWrapperMap& map =
      ui_thread_response_callback_wrappers_for_worker_;
  for (UIThreadWorkerResponseCallbackWrapperMap::iterator it = map.begin();
       it != map.end();) {
    if (it->first.render_process_id == render_process_id) {
      it = map.erase(it);
      continue;
    }
    ++it;
  }
}

  // TODO(lazyboy): API functions from extension Service Worker will incorrectly
  // change keepalive count below.
                content::RenderFrameHost* render_frame_host,
                int render_process_id);
  // Same as UIThreadResponseCallbackWrapper above, but applies to an extension
  // function from an extension Service Worker.
  class UIThreadWorkerResponseCallbackWrapper;

  // Key used to store UIThreadWorkerResponseCallbackWrapper in the map
  // |ui_thread_response_callback_wrappers_for_worker_|.
  struct WorkerResponseCallbackMapKey;

      int render_process_id,
  void RemoveWorkerCallbacksForProcess(int render_process_id);


  using UIThreadWorkerResponseCallbackWrapperMap =
      std::map<WorkerResponseCallbackMapKey,
               std::unique_ptr<UIThreadWorkerResponseCallbackWrapper>>;
  // TODO(lazyboy): The map entries are cleared upon RenderProcessHost shutown,
  // we should really be clearing it on service worker shutdown.
  UIThreadWorkerResponseCallbackWrapperMap
      ui_thread_response_callback_wrappers_for_worker_;
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/browser/extension_service_worker_message_filter.h"

#include "extensions/browser/extension_function_dispatcher.h"
#include "extensions/common/extension_messages.h"

namespace extensions {

ExtensionServiceWorkerMessageFilter::ExtensionServiceWorkerMessageFilter(
    int render_process_id,
    content::BrowserContext* context)
    : content::BrowserMessageFilter(ExtensionWorkerMsgStart),
      render_process_id_(render_process_id),
      browser_context_(context),
      dispatcher_(new ExtensionFunctionDispatcher(context)) {}

ExtensionServiceWorkerMessageFilter::~ExtensionServiceWorkerMessageFilter() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
}

void ExtensionServiceWorkerMessageFilter::OverrideThreadForMessage(
    const IPC::Message& message,
    content::BrowserThread::ID* thread) {
  if (message.type() == ExtensionHostMsg_RequestWorker::ID) {
    *thread = content::BrowserThread::UI;
  }
}

bool ExtensionServiceWorkerMessageFilter::OnMessageReceived(
    const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(ExtensionServiceWorkerMessageFilter, message)
    IPC_MESSAGE_HANDLER(ExtensionHostMsg_RequestWorker, OnRequestWorker)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}

void ExtensionServiceWorkerMessageFilter::OnRequestWorker(
    const ExtensionHostMsg_Request_Params& params) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  dispatcher_->Dispatch(params, nullptr, render_process_id_);
}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_BROWSER_EXTENSION_SERVICE_WORKER_MESSAGE_FILTER_H_
#define EXTENSIONS_BROWSER_EXTENSION_SERVICE_WORKER_MESSAGE_FILTER_H_

#include "base/macros.h"
#include "content/public/browser/browser_message_filter.h"

struct ExtensionHostMsg_Request_Params;

namespace content {
class BrowserContext;
}

namespace extensions {

class ExtensionFunctionDispatcher;

// IPC handler class for extension service worker.
class ExtensionServiceWorkerMessageFilter
    : public content::BrowserMessageFilter {
 public:
  ExtensionServiceWorkerMessageFilter(int render_process_id,
                                      content::BrowserContext* context);

  // content::BrowserMessageFilter:
  bool OnMessageReceived(const IPC::Message& message) override;
  void OverrideThreadForMessage(const IPC::Message& message,
                                content::BrowserThread::ID* thread) override;

 private:
  ~ExtensionServiceWorkerMessageFilter() override;

  void OnRequestWorker(const ExtensionHostMsg_Request_Params& params);

  const int render_process_id_;
  content::BrowserContext* browser_context_;

  std::unique_ptr<ExtensionFunctionDispatcher,
                  content::BrowserThread::DeleteOnUIThread>
      dispatcher_;

  DISALLOW_COPY_AND_ASSIGN(ExtensionServiceWorkerMessageFilter);
};

}  // namespace extensions

#endif  // EXTENSIONS_BROWSER_EXTENSION_SERVICE_WORKER_MESSAGE_FILTER_H_
  dispatcher_.Dispatch(params, render_frame_host,
                       render_frame_host->GetProcess()->GetID());

  // If this API call is for a service worker, then this is the worker thread
  // id. Otherwise, this is -1.
  IPC_STRUCT_MEMBER(int, worker_thread_id)

  // If this API call is for a service worker, then this is the embedded
  // worker id. Otherwise, this is -1.
  IPC_STRUCT_MEMBER(int, embedded_worker_id)

// Messages related to Extension Service Worker.
#undef IPC_MESSAGE_START
#define IPC_MESSAGE_START ExtensionWorkerMsgStart
// A service worker thread sends this message when an extension service worker
// starts an API request. The browser will always respond with a
// ExtensionMsg_ResponseWorker.
IPC_MESSAGE_CONTROL1(ExtensionHostMsg_RequestWorker,
                     ExtensionHostMsg_Request_Params)

// The browser sends this message in response to all service worker extension
// api calls. The response data (if any) is one of the base::Value subclasses,
// wrapped as the first element in a ListValue.
IPC_MESSAGE_CONTROL5(ExtensionMsg_ResponseWorker,
                     int /* thread_id */,
                     int /* request_id */,
                     bool /* success */,
                     base::ListValue /* response wrapper (see comment above) */,
                     std::string /* error */)
bool ExtensionsClient::ExtensionAPIEnabledInExtensionServiceWorkers() const {
  return false;
}

  // Returns whether or not extension APIs are allowed in extension service
  // workers.
  // This is currently disallowed as the code to support this is work in
  // progress.
  // Can be overridden in tests.
  virtual bool ExtensionAPIEnabledInExtensionServiceWorkers() const;

    contexts["extension_service_worker"] = Feature::SERVICE_WORKER_CONTEXT;
  // TODO(lazyboy): This isn't quite right for Extension Service Worker
  // extension API calls, since there's no guarantee that the extension is
  // "active" in current renderer process when the API permission check is
  // done.
  contexts->Append(new base::StringValue("extension_service_worker"));
  EXPECT_EQ(7u, feature->contexts()->size());
#include "content/public/child/worker_thread.h"
  // A worker's ScriptContext neither lives in ScriptContextSet nor it has a
  // RenderFrame associated with it, so early exit in this case.
  // TODO(lazyboy): Fix.
  if (content::WorkerThread::GetCurrentId() > 0)
    return;

#include "extensions/common/features/feature_util.h"
#include "extensions/renderer/worker_thread_dispatcher.h"
#include "third_party/WebKit/public/web/WebScriptController.h"
  // Ideally this should be done after checking
  // ExtensionAPIEnabledInExtensionServiceWorkers(), but the Dispatcher is
  // created so early that sending an IPC from browser/ process to synchronize
  // this enabled-ness is too late.
  WorkerThreadDispatcher::Get()->Init(RenderThread::Get());
  RegisterNativeHandlers(module_system, context, request_sender_.get(),
                         v8_schema_registry_.get());
    int embedded_worker_id,
  if (ExtensionsClient::Get()->ExtensionAPIEnabledInExtensionServiceWorkers()) {
    WorkerThreadDispatcher::Get()->AddWorkerData(embedded_worker_id);
    {
      // TODO(lazyboy): Make sure accessing |source_map_| in worker thread is
      // safe.
      std::unique_ptr<ModuleSystem> module_system(
          new ModuleSystem(context, &source_map_));
      context->set_module_system(std::move(module_system));
    }

    ModuleSystem* module_system = context->module_system();
    // Enable natives in startup.
    ModuleSystem::NativesEnabledScope natives_enabled_scope(module_system);
    RegisterNativeHandlers(
        module_system, context,
        WorkerThreadDispatcher::Get()->GetRequestSender(),
        WorkerThreadDispatcher::Get()->GetV8SchemaRegistry());
    // chrome.Event is part of the public API (although undocumented). Make it
    // lazily evalulate to Event from event_bindings.js.
    v8::Local<v8::Object> chrome = AsObjectOrEmpty(GetOrCreateChrome(context));
    if (!chrome.IsEmpty())
      module_system->SetLazyField(chrome, "Event", kEventBindings, "Event");

    UpdateBindingsForContext(context);
    // TODO(lazyboy): Get rid of RequireGuestViewModules() as this doesn't seem
    // necessary for Extension SW.
    RequireGuestViewModules(context);
    delegate_->RequireAdditionalModules(context,
                                        false /* is_within_platform_app */);
  }

    int embedded_worker_id,
  if (ExtensionsClient::Get()->ExtensionAPIEnabledInExtensionServiceWorkers())
    WorkerThreadDispatcher::Get()->RemoveWorkerData(embedded_worker_id);
// Note: this function runs on multiple threads: main renderer thread and
// service worker threads.
    case Feature::SERVICE_WORKER_CONTEXT:
      DCHECK(ExtensionsClient::Get()
                 ->ExtensionAPIEnabledInExtensionServiceWorkers());
    // Intentional fallthrough.
        if (context->IsAnyFeatureAvailableToContext(*map_entry.second.get())) {
          // TODO(lazyboy): RegisterBinding() uses |source_map_|, any thread
          // safety issue?
        }
                                        ScriptContext* context,
                                        RequestSender* request_sender,
                                        V8SchemaRegistry* v8_schema_registry) {
  RegisterNativeHandlers(module_system, context, this, request_sender,
                         v8_schema_registry);
// static.
// static.
  // Runs on a different thread and should only use thread safe member
  // variables.
  void DidInitializeServiceWorkerContextOnWorkerThread(
      int embedded_worker_id,
      int embedded_worker_id,
                              ScriptContext* context,
                              RequestSender* request_sender,
                              V8SchemaRegistry* v8_schema_registry);
  static v8::Local<v8::Object> GetOrCreateObject(
      const v8::Local<v8::Object>& object,
      const std::string& field,
      v8::Isolate* isolate);
  static v8::Local<v8::Object> GetOrCreateBindObjectIfAvailable(
  // TODO(lazyboy): ScriptContextSet isn't available on worker threads. We
  // should probably use WorkerScriptContextSet somehow.
      content::WorkerThread::GetCurrentId() == 0
          ? ScriptContextSet::GetContextByObject(object)
          : nullptr;
  bool for_service_worker =
      context->context_type() == Feature::SERVICE_WORKER_CONTEXT;
  // Note that |render_frame| would be nullptr for Service Workers. Service
  // Workers use control IPC instead.
  if (!for_service_worker && !render_frame) {
    // It is important to early exit here for non Service Worker contexts so
    // that we do not create orphaned PendingRequests below.
  }

  // Set Service Worker specific params to default values.
  params.worker_thread_id = -1;
  params.embedded_worker_id = -1;

  SendRequest(render_frame, for_io_thread, params);
}

void RequestSender::SendRequest(content::RenderFrame* render_frame,
                                bool for_io_thread,
                                ExtensionHostMsg_Request_Params& params) {
struct ExtensionHostMsg_Request_Params;

namespace content {
class RenderFrame;
}

  virtual ~RequestSender();
  // Sends the IPC to extension host for the API function that is described
  // in |params|.
  virtual void SendRequest(content::RenderFrame* render_frame,
                           bool for_io_thread,
                           ExtensionHostMsg_Request_Params& params);

  // TODO(lazyboy): Decide what we should do for SERVICE_WORKER_CONTEXT.
  GURL url = context_type() == Feature::SERVICE_WORKER_CONTEXT
                 ? url_
                 : GetDataSourceURLForFrame(web_frame());
      api, extension(), context_type(), url);
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/service_worker_data.h"

#include "extensions/renderer/service_worker_request_sender.h"
#include "extensions/renderer/worker_thread_dispatcher.h"

namespace extensions {

ServiceWorkerData::ServiceWorkerData(WorkerThreadDispatcher* dispatcher,
                                     int embedded_worker_id)
    : embedded_worker_id_(embedded_worker_id),
      v8_schema_registry_(new V8SchemaRegistry),
      request_sender_(
          new ServiceWorkerRequestSender(dispatcher, embedded_worker_id)) {}

ServiceWorkerData::~ServiceWorkerData() {}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_BROWSER_SERVICE_WORKER_DATA_H_
#define EXTENSIONS_BROWSER_SERVICE_WORKER_DATA_H_

#include <memory>

#include "base/macros.h"
#include "extensions/renderer/service_worker_request_sender.h"
#include "extensions/renderer/v8_schema_registry.h"

namespace extensions {
class WorkerThreadDispatcher;

// Per ServiceWorker data in worker thread.
// Contains: RequestSender, V8SchemaRegistry.
// TODO(lazyboy): Also put worker ScriptContexts in this.
class ServiceWorkerData {
 public:
  ServiceWorkerData(WorkerThreadDispatcher* dispatcher, int embedded_worker_id);
  ~ServiceWorkerData();

  V8SchemaRegistry* v8_schema_registry() { return v8_schema_registry_.get(); }
  RequestSender* request_sender() { return request_sender_.get(); }
  int embedded_worker_id() const { return embedded_worker_id_; }

 private:
  const int embedded_worker_id_;

  std::unique_ptr<V8SchemaRegistry> v8_schema_registry_;
  std::unique_ptr<ServiceWorkerRequestSender> request_sender_;

  DISALLOW_COPY_AND_ASSIGN(ServiceWorkerData);
};

}  // namespace extensions

#endif  // EXTENSIONS_BROWSER_SERVICE_WORKER_DATA_H_
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/service_worker_request_sender.h"

#include "content/public/child/worker_thread.h"
#include "extensions/common/extension_messages.h"
#include "extensions/renderer/worker_thread_dispatcher.h"

namespace extensions {

ServiceWorkerRequestSender::ServiceWorkerRequestSender(
    WorkerThreadDispatcher* dispatcher,
    int embedded_worker_id)
    : dispatcher_(dispatcher), embedded_worker_id_(embedded_worker_id) {}

ServiceWorkerRequestSender::~ServiceWorkerRequestSender() {}

void ServiceWorkerRequestSender::SendRequest(
    content::RenderFrame* render_frame,
    bool for_io_thread,
    ExtensionHostMsg_Request_Params& params) {
  DCHECK(!render_frame && !for_io_thread);
  int worker_thread_id = content::WorkerThread::GetCurrentId();
  DCHECK_GT(worker_thread_id, 0);
  params.worker_thread_id = worker_thread_id;
  params.embedded_worker_id = embedded_worker_id_;

  dispatcher_->Send(new ExtensionHostMsg_RequestWorker(params));
}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_RENDERER_SERVICE_WORKER_REQUEST_SENDER_H_
#define EXTENSIONS_RENDERER_SERVICE_WORKER_REQUEST_SENDER_H_

#include "extensions/renderer/request_sender.h"

namespace extensions {
class WorkerThreadDispatcher;

// A RequestSender variant for Extension Service Worker.
class ServiceWorkerRequestSender : public RequestSender {
 public:
  ServiceWorkerRequestSender(WorkerThreadDispatcher* dispatcher,
                             int embedded_worker_id);
  ~ServiceWorkerRequestSender() override;

  void SendRequest(content::RenderFrame* render_frame,
                   bool for_io_thread,
                   ExtensionHostMsg_Request_Params& params) override;

 private:
  WorkerThreadDispatcher* const dispatcher_;
  const int embedded_worker_id_;

  DISALLOW_COPY_AND_ASSIGN(ServiceWorkerRequestSender);
};

}  // namespace extensions

#endif  // EXTENSIONS_RENDERER_SERVICE_WORKER_REQUEST_SENDER_H_
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/worker_thread_dispatcher.h"

#include "base/threading/thread_local.h"
#include "base/values.h"
#include "content/public/child/worker_thread.h"
#include "content/public/renderer/render_thread.h"
#include "extensions/common/extension_messages.h"
#include "extensions/renderer/service_worker_data.h"

namespace extensions {

namespace {

base::LazyInstance<WorkerThreadDispatcher> g_instance =
    LAZY_INSTANCE_INITIALIZER;
base::LazyInstance<base::ThreadLocalPointer<extensions::ServiceWorkerData>>
    g_data_tls = LAZY_INSTANCE_INITIALIZER;

void OnResponseOnWorkerThread(int request_id,
                              bool succeeded,
                              const std::unique_ptr<base::ListValue>& response,
                              const std::string& error) {
  WorkerThreadDispatcher::GetRequestSender()->HandleResponse(
      request_id, succeeded, *response, error);
}

}  // namespace

WorkerThreadDispatcher::WorkerThreadDispatcher() {}
WorkerThreadDispatcher::~WorkerThreadDispatcher() {}

WorkerThreadDispatcher* WorkerThreadDispatcher::Get() {
  return g_instance.Pointer();
}

void WorkerThreadDispatcher::Init(content::RenderThread* render_thread) {
  DCHECK(render_thread);
  DCHECK_EQ(content::RenderThread::Get(), render_thread);
  DCHECK(!message_filter_);
  message_filter_ = render_thread->GetSyncMessageFilter();
  render_thread->AddObserver(this);
}

V8SchemaRegistry* WorkerThreadDispatcher::GetV8SchemaRegistry() {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  DCHECK(data);
  return data->v8_schema_registry();
}

// static
RequestSender* WorkerThreadDispatcher::GetRequestSender() {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  DCHECK(data);
  return data->request_sender();
}

bool WorkerThreadDispatcher::OnControlMessageReceived(
    const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(WorkerThreadDispatcher, message)
    IPC_MESSAGE_HANDLER(ExtensionMsg_ResponseWorker, OnResponseWorker)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}

bool WorkerThreadDispatcher::Send(IPC::Message* message) {
  return message_filter_->Send(message);
}

void WorkerThreadDispatcher::OnResponseWorker(int worker_thread_id,
                                              int request_id,
                                              bool succeeded,
                                              const base::ListValue& response,
                                              const std::string& error) {
  content::WorkerThread::PostTask(
      worker_thread_id,
      base::Bind(&OnResponseOnWorkerThread, request_id, succeeded,
                 // TODO(lazyboy): Can we avoid CreateDeepCopy()?
                 base::Passed(response.CreateDeepCopy()), error));
}

void WorkerThreadDispatcher::AddWorkerData(int embedded_worker_id) {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  if (!data) {
    ServiceWorkerData* new_data =
        new ServiceWorkerData(this, embedded_worker_id);
    g_data_tls.Pointer()->Set(new_data);
  }
}

void WorkerThreadDispatcher::RemoveWorkerData(int embedded_worker_id) {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  if (data) {
    DCHECK_EQ(embedded_worker_id, data->embedded_worker_id());
    delete data;
    g_data_tls.Pointer()->Set(nullptr);
  }
}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_RENDERER_WORKER_THREAD_DISPATCHER_H_
#define EXTENSIONS_RENDERER_WORKER_THREAD_DISPATCHER_H_

#include "base/synchronization/lock.h"
#include "content/public/renderer/render_thread_observer.h"
#include "ipc/ipc_sync_message_filter.h"

namespace base {
class ListValue;
}

namespace content {
class RenderThread;
}

namespace extensions {
class RequestSender;
class V8SchemaRegistry;

// Sends and receives IPC in an extension Service Worker.
// TODO(lazyboy): This class should really be a combination of the following
// two:
// 1) A content::WorkerThreadMessageFilter, so that we can receive IPC directly
// on worker thread.
// 2) A content::ThreadSafeSender, so we can safely send IPC from worker thread.
class WorkerThreadDispatcher : public content::RenderThreadObserver {
 public:
  WorkerThreadDispatcher();
  ~WorkerThreadDispatcher() override;

  // Thread safe.
  static WorkerThreadDispatcher* Get();
  static RequestSender* GetRequestSender();

  void Init(content::RenderThread* render_thread);
  bool Send(IPC::Message* message);
  void AddWorkerData(int embedded_worker_id);
  void RemoveWorkerData(int embedded_worker_id);
  V8SchemaRegistry* GetV8SchemaRegistry();

 private:
  // content::RenderThreadObserver:
  bool OnControlMessageReceived(const IPC::Message& message) override;

  // IPC handlers.
  void OnResponseWorker(int worker_thread_id,
                        int request_id,
                        bool succeeded,
                        const base::ListValue& response,
                        const std::string& error);

  // IPC sender. Belongs to the render thread, but thread safe.
  scoped_refptr<IPC::SyncMessageFilter> message_filter_;

  DISALLOW_COPY_AND_ASSIGN(WorkerThreadDispatcher);
};

}  // namespace extensions

#endif  // EXTENSIONS_RENDERER_WORKER_THREAD_DISPATCHER_H_
  ExtensionWorkerMsgStart,
#include "bindings/core/v8/ScriptController.h"
        // Initialize V8 extensions before creating the context.
        Vector<const char*> extensionNames;
        if (m_globalScope->isServiceWorkerGlobalScope() && Platform::current()->allowScriptExtensionForServiceWorker(toWorkerGlobalScope(m_globalScope.get())->url())) {
            const V8Extensions& extensions = ScriptController::registeredExtensions();
            extensionNames.reserveInitialCapacity(extensions.size());
            for (const auto* extension : extensions)
                extensionNames.append(extension->name());
        }
        v8::ExtensionConfiguration extensionConfiguration(extensionNames.size(), extensionNames.data());

        context = v8::Context::New(m_isolate, &extensionConfiguration, globalTemplate);
    virtual bool allowScriptExtensionForServiceWorker(const WebURL& scriptUrl) { return false; }
IN_PROC_BROWSER_TEST_F(MAYBE_WebRtcBrowserTest, CallInsideIframe) {
  MakeTypicalPeerConnectionCall("callInsideIframe({video: true, audio:true});");
}

#include "core/frame/UseCounter.h"
        if (resource && resource->mimeType().lower().startsWith("image/")) {
            contextDocument->addConsoleMessage(ConsoleMessage::create(SecurityMessageSource, ErrorMessageLevel, "Refused to execute script from '" + resource->url().elidedString() + "' because its MIME type ('" + resource->mimeType() + "') is not executable."));
            UseCounter::count(frame, UseCounter::BlockedSniffingImageToScript);
            return;
        }

        BlockedSniffingImageToScript = 674,
const KURL& WebDataSourceImpl::endOfRedirectChain() const
void WebDataSourceImpl::appendRedirect(const KURL& url)
#include "KURL.h"
        const WebCore::KURL& endOfRedirectChain() const;
        void appendRedirect(const WebCore::KURL& url);
        Vector<WebCore::KURL> m_redirectChain;
  if (webview_->client()) {
    webview_->client()->setWindowRect(
  if (webview_->client()) {
    rect = webview_->client()->rootWindowRect();
  if (!webview_->client())
    return;
  webview_->client()->didFocus();
  // If accessibility is enabled, we should notify assistive technology that
  // the active AccessibilityObject changed.
  const WebCore::Frame* frame = webview_->GetFocusedWebCoreFrame();
  if (!frame)
    return;
  WebCore::Document* doc = frame->document();
  if (doc && doc->axObjectCache()->accessibilityEnabled()) {
    WebCore::Node* focused_node = webview_->GetFocusedNode();
    if (!focused_node) {
      // Could not retrieve focused Node.
      return;

    // Retrieve the focused AccessibilityObject.
    WebCore::AccessibilityObject* focused_acc_obj =
        doc->axObjectCache()->getOrCreate(focused_node->renderer());

    // Alert assistive technology that focus changed.
    if (focused_acc_obj)
      webview_->delegate()->FocusAccessibilityObject(focused_acc_obj);
  if (webview_->client())
    webview_->client()->didBlur();
  return webview_->client() != NULL;
  if (webview_->client())
    webview_->client()->runModal();
  return webview_->client() != NULL;
  if (webview_->client()) {
        webview_->client()->windowResizerRect());
  if (webview_->client()) {
    webview_->client()->didInvalidateRect(
        webkit_glue::IntRectToWebRect(paint_rect));
  }
  if (webview_->client()) {
    webview_->client()->didScrollRect(
  if (webview_->client()) {
    WebRect window_rect = webview_->client()->windowRect();
  if (webview_->client())
    webview_->client()->didChangeCursor(cursor);
    // Got a server redirect when there is no provisional DS!
    ASSERT_NOT_REACHED();
  ASSERT(ds->hasRedirectChain());
  ds->appendRedirect(webkit_glue::WebURLToKURL(ds->request().url()));
    expected_client_redirect_src_ = KURL();
    expected_client_redirect_dest_ = KURL();
  expected_client_redirect_src_ = webkit_glue::WebURLToKURL(webframe_->url());
  expected_client_redirect_dest_ = url;
  if (expected_client_redirect_dest_.isLocalFile() &&
      expected_client_redirect_src_.protocolInHTTPFamily()) {
    expected_client_redirect_src_ = KURL();
    expected_client_redirect_dest_ = KURL();
        webkit_glue::KURLToWebURL(expected_client_redirect_src_),
        webkit_glue::KURLToWebURL(expected_client_redirect_dest_),
  ASSERT(ds);  // Should not be null when navigating to a reference fragment!
    KURL url = webkit_glue::WebURLToKURL(ds->request().url());
    KURL chain_end = ds->endOfRedirectChain();
      if (webframe_->client()) {
        webframe_->client()->didCompleteClientRedirect(
            webframe_, webkit_glue::KURLToWebURL(chain_end));
      }
      expected_client_redirect_src_ = KURL();
      expected_client_redirect_dest_ = KURL();
    ASSERT_NOT_REACHED();
  KURL url = webkit_glue::WebURLToKURL(ds->request().url());
  ASSERT(!ds->hasRedirectChain());
  if (expected_client_redirect_src_.isValid()) {
    ASSERT(expected_client_redirect_dest_.protocolIs("javascript") ||
          webframe_, webkit_glue::KURLToWebURL(expected_client_redirect_src_));
  ASSERT(next_navigation_policy_ != WebKit::WebNavigationPolicyIgnore);
  if (webview && webview->client())
    webview->client()->show(webview->initial_navigation_policy());
      KURL url = webkit_glue::WebURLToKURL(ds->request().url());
      if (url.protocolIs(webkit_glue::kBackForwardNavigationScheme)) {
  // The page cache should be disabled.
  ASSERT_NOT_REACHED();
  ASSERT_NOT_REACHED();
  ASSERT(plugin_widget_.get());
  return String();
void WebFrameLoaderClient::HandleBackForwardNavigation(const KURL& url) {
  ASSERT(url.protocolIs(webkit_glue::kBackForwardNavigationScheme));
  bool ok;
  int offset = url.lastPathComponent().toIntStrict(&ok);
  if (!ok)
#include "KURL.h"
  void HandleBackForwardNavigation(const WebCore::KURL&);
  WebCore::KURL expected_client_redirect_src_;
  WebCore::KURL expected_client_redirect_dest_;
    // current is the source path, including from_path, so paste
    // the suffix after from_path onto to_path to create the target_path.
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    // Strip the leading '/' (if any).
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
    const FilePath target_path = to_path.Append(suffix);
class RelayGetFileInfoFromPlatformFile : public MessageLoopRelay {
 public:
  RelayGetFileInfoFromPlatformFile(
      base::PlatformFile file,
      base::FileUtilProxy::GetFileInfoCallback* callback)
      : callback_(callback),
        file_(file) {
    DCHECK(callback);
  }

 protected:
  virtual void RunWork() {
    if (!base::GetPlatformFileInfo(file_, &file_info_))
      set_error_code(base::PLATFORM_FILE_ERROR_FAILED);
  }

  virtual void RunCallback() {
    callback_->Run(error_code(), file_info_);
    delete callback_;
  }

 private:
  base::FileUtilProxy::GetFileInfoCallback* callback_;
  base::PlatformFile file_;
  base::PlatformFileInfo file_info_;
};

class RelayRead : public MessageLoopRelay {
 public:
  RelayRead(base::PlatformFile file,
            int64 offset,
            char* buffer,
            int bytes_to_read,
            base::FileUtilProxy::ReadWriteCallback* callback)
      : file_(file),
        offset_(offset),
        buffer_(buffer),
        bytes_to_read_(bytes_to_read),
        callback_(callback),
        bytes_read_(0) {
  }

 protected:
  virtual void RunWork() {
    bytes_read_ = base::ReadPlatformFile(file_, offset_, buffer_,
                                         bytes_to_read_);
    if (bytes_read_ < 0)
      set_error_code(base::PLATFORM_FILE_ERROR_FAILED);
  }

  virtual void RunCallback() {
    if (callback_) {
      callback_->Run(error_code(), bytes_read_);
      delete callback_;
    }
  }

 private:
  base::PlatformFile file_;
  int64 offset_;
  char* buffer_;
  int bytes_to_read_;
  base::FileUtilProxy::ReadWriteCallback* callback_;
  int bytes_read_;
};

class RelayWrite : public MessageLoopRelay {
 public:
  RelayWrite(base::PlatformFile file,
             long long offset,
             const char* buffer,
             int bytes_to_write,
             base::FileUtilProxy::ReadWriteCallback* callback)
      : file_(file),
        offset_(offset),
        buffer_(buffer),
        bytes_to_write_(bytes_to_write),
        callback_(callback) {
  }

 protected:
  virtual void RunWork() {
    bytes_written_ = base::WritePlatformFile(file_, offset_, buffer_,
                                             bytes_to_write_);
    if (bytes_written_ < 0)
      set_error_code(base::PLATFORM_FILE_ERROR_FAILED);
  }

  virtual void RunCallback() {
    if (callback_) {
      callback_->Run(error_code(), bytes_written_);
      delete callback_;
    }
  }

 private:
  base::PlatformFile file_;
  int64 offset_;
  const char* buffer_;
  int bytes_to_write_;
  base::FileUtilProxy::ReadWriteCallback* callback_;
  int bytes_written_;
};

class RelayTouch : public RelayWithStatusCallback {
 public:
  RelayTouch(base::PlatformFile file,
             const base::Time& last_access_time,
             const base::Time& last_modified_time,
             base::FileUtilProxy::StatusCallback* callback)
      : RelayWithStatusCallback(callback),
        file_(file),
        last_access_time_(last_access_time),
        last_modified_time_(last_modified_time) {
  }

 protected:
  virtual void RunWork() {
    if (!base::TouchPlatformFile(file_, last_access_time_, last_modified_time_))
      set_error_code(base::PLATFORM_FILE_ERROR_FAILED);
  }

 private:
  base::PlatformFile file_;
  base::Time last_access_time_;
  base::Time last_modified_time_;
};

class RelayTruncate : public RelayWithStatusCallback {
 public:
  RelayTruncate(base::PlatformFile file,
                int64 length,
                base::FileUtilProxy::StatusCallback* callback)
      : RelayWithStatusCallback(callback),
        file_(file),
        length_(length) {
  }

 protected:
  virtual void RunWork() {
    if (!base::TruncatePlatformFile(file_, length_))
      set_error_code(base::PLATFORM_FILE_ERROR_FAILED);
  }

 private:
  base::PlatformFile file_;
  int64 length_;
};

class RelayFlush : public RelayWithStatusCallback {
 public:
  RelayFlush(base::PlatformFile file,
             base::FileUtilProxy::StatusCallback* callback)
      : RelayWithStatusCallback(callback),
        file_(file) {
  }

 protected:
  virtual void RunWork() {
    if (!base::FlushPlatformFile(file_))
      set_error_code(base::PLATFORM_FILE_ERROR_FAILED);
  }

 private:
  base::PlatformFile file_;
};

// static
bool FileUtilProxy::GetFileInfoFromPlatformFile(
    scoped_refptr<MessageLoopProxy> message_loop_proxy,
    PlatformFile file,
    GetFileInfoCallback* callback) {
  return Start(FROM_HERE, message_loop_proxy,
               new RelayGetFileInfoFromPlatformFile(file, callback));
}

// static
bool FileUtilProxy::Read(
    scoped_refptr<MessageLoopProxy> message_loop_proxy,
    PlatformFile file,
    int64 offset,
    char* buffer,
    int bytes_to_read,
    ReadWriteCallback* callback) {
  return Start(FROM_HERE, message_loop_proxy,
               new RelayRead(file, offset, buffer, bytes_to_read, callback));
}

// static
bool FileUtilProxy::Write(
    scoped_refptr<MessageLoopProxy> message_loop_proxy,
    PlatformFile file,
    int64 offset,
    const char* buffer,
    int bytes_to_write,
    ReadWriteCallback* callback) {
  return Start(FROM_HERE, message_loop_proxy,
               new RelayWrite(file, offset, buffer, bytes_to_write, callback));
}

// static
bool FileUtilProxy::Touch(
    scoped_refptr<MessageLoopProxy> message_loop_proxy,
    PlatformFile file,
    const base::Time& last_access_time,
    const base::Time& last_modified_time,
    StatusCallback* callback) {
  return Start(FROM_HERE, message_loop_proxy,
               new RelayTouch(file, last_access_time, last_modified_time,
                              callback));
}

// static
bool FileUtilProxy::Truncate(
    scoped_refptr<MessageLoopProxy> message_loop_proxy,
    PlatformFile file,
    long long length,
    StatusCallback* callback) {
  return Start(FROM_HERE, message_loop_proxy,
               new RelayTruncate(file, length, callback));
}

// static
bool FileUtilProxy::Flush(
    scoped_refptr<MessageLoopProxy> message_loop_proxy,
    PlatformFile file,
    StatusCallback* callback) {
  return Start(FROM_HERE, message_loop_proxy, new RelayFlush(file, callback));
}

  static bool GetFileInfoFromPlatformFile(
      scoped_refptr<MessageLoopProxy> message_loop_proxy,
      base::PlatformFile file,
      GetFileInfoCallback* callback);

  // Reads from a file. On success, the file pointer is moved to position
  // |offset + bytes_to_read| in the file. The callback can be NULL.
  typedef Callback2<base::PlatformFileError /* error code */,
                    int /* bytes read/written */>::Type ReadWriteCallback;
  static bool Read(
      scoped_refptr<MessageLoopProxy> message_loop_proxy,
      base::PlatformFile file,
      int64 offset,
      char* buffer,
      int bytes_to_read,
      ReadWriteCallback* callback);

  // Writes to a file. If |offset| is greater than the length of the file,
  // |false| is returned. On success, the file pointer is moved to position
  // |offset + bytes_to_write| in the file. If The callback can be NULL.
  static bool Write(
      scoped_refptr<MessageLoopProxy> message_loop_proxy,
      base::PlatformFile file,
      int64 offset,
      const char* buffer,
      int bytes_to_write,
      ReadWriteCallback* callback);

  // Touches a file. The callback can be NULL.
  static bool Touch(
      scoped_refptr<MessageLoopProxy> message_loop_proxy,
      base::PlatformFile file,
      const base::Time& last_access_time,
      const base::Time& last_modified_time,
      StatusCallback* callback);

  // Truncates a file to the given length. If |length| is greater than the
  // current length of the file, the file will be extended with zeroes.
  // The callback can be NULL.
  static bool Truncate(
      scoped_refptr<MessageLoopProxy> message_loop_proxy,
      base::PlatformFile file,
      long long length,
      StatusCallback* callback);

  // Flushes a file. The callback can be NULL.
  static bool Flush(
      scoped_refptr<MessageLoopProxy> message_loop_proxy,
      base::PlatformFile file,
      StatusCallback* callback);

  PLATFORM_FILE_TRUNCATE = 4096,
  PLATFORM_FILE_WRITE_ATTRIBUTES = 8192 // Used on Windows only
// Reads the given number of bytes (or until EOF is reached) starting with the
// given offset. Returns the number of bytes read, or -1 on error.
int ReadPlatformFile(PlatformFile file, int64 offset, char* data, int size);

// Writes the given buffer into the file at the given offset, overwritting any
// data that was previously there. Returns the number of bytes written, or -1
// on error.
int WritePlatformFile(PlatformFile file, int64 offset,
                      const char* data, int size);

// Truncates the given file to the given length. If |length| is greater than
// the current size of the file, the file is extended with zeros. If the file
// doesn't exist, |false| is returned.
bool TruncatePlatformFile(PlatformFile file, int64 length);

// Flushes the buffers of the given file.
bool FlushPlatformFile(PlatformFile file);

// Touches the given file.
bool TouchPlatformFile(PlatformFile file, const Time& last_access_time,
                       const Time& last_modified_time);

// Returns some information for the given file.
bool GetPlatformFileInfo(PlatformFile file, PlatformFileInfo* info);

#include "base/eintr_wrapper.h"
#if defined(OS_OPENBSD) || defined(OS_FREEBSD) || \
    (defined(OS_MACOSX) && \
     MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5)
typedef struct stat stat_wrapper_t;
static int CallFstat(int fd, stat_wrapper_t *sb) {
  return fstat(fd, sb);
}
#else
typedef struct stat64 stat_wrapper_t;
static int CallFstat(int fd, stat_wrapper_t *sb) {
  return fstat64(fd, sb);
}
#endif

  if (created && (descriptor > 0) && (flags & PLATFORM_FILE_CREATE_ALWAYS))
    *created = true;

  if ((descriptor > 0) && (flags & PLATFORM_FILE_DELETE_ON_CLOSE)) {
  if (error_code) {
    if (descriptor >= 0)
      *error_code = PLATFORM_FILE_OK;
    else {
      switch (errno) {
        case EACCES:
        case EISDIR:
        case EROFS:
        case EPERM:
          *error_code = PLATFORM_FILE_ERROR_ACCESS_DENIED;
          break;
        case ETXTBSY:
          *error_code = PLATFORM_FILE_ERROR_IN_USE;
          break;
        case EEXIST:
          *error_code = PLATFORM_FILE_ERROR_EXISTS;
          break;
        case ENOENT:
          *error_code = PLATFORM_FILE_ERROR_NOT_FOUND;
          break;
        case EMFILE:
          *error_code = PLATFORM_FILE_ERROR_TOO_MANY_OPENED;
          break;
        case ENOMEM:
          *error_code = PLATFORM_FILE_ERROR_NO_MEMORY;
          break;
        case ENOSPC:
          *error_code = PLATFORM_FILE_ERROR_NO_SPACE;
          break;
        case ENOTDIR:
          *error_code = PLATFORM_FILE_ERROR_NOT_A_DIRECTORY;
          break;
        default:
          *error_code = PLATFORM_FILE_ERROR_FAILED;
      }
  return !close(file);
}

int ReadPlatformFile(PlatformFile file, int64 offset, char* data, int size) {
  if (file < 0)
    return -1;

  return HANDLE_EINTR(pread(file, data, size, offset));
}

int WritePlatformFile(PlatformFile file, int64 offset,
                      const char* data, int size) {
  if (file < 0)
    return -1;

  return HANDLE_EINTR(pwrite(file, data, size, offset));
}

bool TruncatePlatformFile(PlatformFile file, int64 length) {
  return ((file >= 0) && !HANDLE_EINTR(ftruncate(file, length)));
}

bool FlushPlatformFile(PlatformFile file) {
  return !fsync(file);
}

bool TouchPlatformFile(PlatformFile file, const base::Time& last_access_time,
                       const base::Time& last_modified_time) {
  if (file < 0)
    return false;

  timeval times[2];
  times[0] = last_access_time.ToTimeVal();
  times[1] = last_modified_time.ToTimeVal();
  return !futimes(file, times);
}

bool GetPlatformFileInfo(PlatformFile file, PlatformFileInfo* info) {
  if (!info)
    return false;

  stat_wrapper_t file_info;
  if (CallFstat(file, &file_info))
    return false;

  info->is_directory = S_ISDIR(file_info.st_mode);
  info->size = file_info.st_size;
  info->last_modified = base::Time::FromTimeT(file_info.st_mtime);
  info->last_accessed = base::Time::FromTimeT(file_info.st_atime);
  info->creation_time = base::Time::FromTimeT(file_info.st_ctime);
  return true;
// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "base/file_util.h"
#include "base/platform_file.h"
#include "base/scoped_temp_dir.h"
#include "base/time.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace {

// Reads from a file the given number of bytes, or until EOF is reached.
// Returns the number of bytes read.
int ReadFully(base::PlatformFile file, int64 offset, char* data, int size) {
  int total_bytes_read = 0;
  int bytes_read;
  while (total_bytes_read < size) {
    bytes_read = base::ReadPlatformFile(
        file, offset + total_bytes_read, &data[total_bytes_read],
        size - total_bytes_read);

    // If we reached EOF, bytes_read will be 0.
    if (bytes_read == 0)
      return total_bytes_read;

    if ((bytes_read < 0) || (bytes_read > size - total_bytes_read))
      return -1;

    total_bytes_read += bytes_read;
  }

  return total_bytes_read;
}

// Writes the given number of bytes to a file.
// Returns the number of bytes written.
int WriteFully(base::PlatformFile file, int64 offset,
               const char* data, int size) {
  int total_bytes_written = 0;
  int bytes_written;
  while (total_bytes_written < size) {
    bytes_written = base::WritePlatformFile(
        file, offset + total_bytes_written, &data[total_bytes_written],
        size - total_bytes_written);

    if ((bytes_written == 0) && (size == 0))
      return 0;

    if ((bytes_written <= 0) || (bytes_written > size - total_bytes_written))
      return -1;

    total_bytes_written += bytes_written;
  }

  return total_bytes_written;
}

} // namespace

TEST(PlatformFile, CreatePlatformFile) {
  ScopedTempDir temp_dir;
  ASSERT_TRUE(temp_dir.CreateUniqueTempDir());
  FilePath file_path = temp_dir.path().AppendASCII("create_file_1");

  // Open a file that doesn't exist.
  base::PlatformFileError error_code = base::PLATFORM_FILE_OK;
  base::PlatformFile file = base::CreatePlatformFile(
      file_path, base::PLATFORM_FILE_OPEN | base::PLATFORM_FILE_READ,
      NULL, &error_code);
  EXPECT_EQ(base::kInvalidPlatformFileValue, file);
  EXPECT_EQ(base::PLATFORM_FILE_ERROR_NOT_FOUND, error_code);

  // Open or create a file.
  bool created = false;
  error_code = base::PLATFORM_FILE_OK;
  file = base::CreatePlatformFile(
      file_path, base::PLATFORM_FILE_OPEN_ALWAYS | base::PLATFORM_FILE_READ,
      &created, &error_code);
  EXPECT_NE(base::kInvalidPlatformFileValue, file);
  EXPECT_TRUE(created);
  EXPECT_EQ(base::PLATFORM_FILE_OK, error_code);
  base::ClosePlatformFile(file);

  // Open an existing file.
  created = false;
  file = base::CreatePlatformFile(
      file_path, base::PLATFORM_FILE_OPEN | base::PLATFORM_FILE_READ,
      &created, &error_code);
  EXPECT_NE(base::kInvalidPlatformFileValue, file);
  EXPECT_FALSE(created);
  EXPECT_EQ(base::PLATFORM_FILE_OK, error_code);
  base::ClosePlatformFile(file);

  // Create a file that exists.
  file = base::CreatePlatformFile(
      file_path, base::PLATFORM_FILE_CREATE | base::PLATFORM_FILE_READ,
      &created, &error_code);
  EXPECT_EQ(base::kInvalidPlatformFileValue, file);
  EXPECT_FALSE(created);
  EXPECT_EQ(base::PLATFORM_FILE_ERROR_EXISTS, error_code);

  // Create or overwrite a file.
  error_code = base::PLATFORM_FILE_OK;
  file = base::CreatePlatformFile(
      file_path, base::PLATFORM_FILE_CREATE_ALWAYS | base::PLATFORM_FILE_READ,
      &created, &error_code);
  EXPECT_NE(base::kInvalidPlatformFileValue, file);
  EXPECT_TRUE(created);
  EXPECT_EQ(base::PLATFORM_FILE_OK, error_code);
  base::ClosePlatformFile(file);

  // Create a delete-on-close file.
  created = false;
  file_path = temp_dir.path().AppendASCII("create_file_2");
  file = base::CreatePlatformFile(
      file_path,
      base::PLATFORM_FILE_OPEN_ALWAYS |
      base::PLATFORM_FILE_DELETE_ON_CLOSE |
      base::PLATFORM_FILE_READ,
      &created, &error_code);
  EXPECT_NE(base::kInvalidPlatformFileValue, file);
  EXPECT_TRUE(created);
  EXPECT_EQ(base::PLATFORM_FILE_OK, error_code);

  EXPECT_TRUE(base::ClosePlatformFile(file));
  EXPECT_FALSE(file_util::PathExists(file_path));
}

TEST(PlatformFile, ReadWritePlatformFile) {
  ScopedTempDir temp_dir;
  ASSERT_TRUE(temp_dir.CreateUniqueTempDir());
  FilePath file_path = temp_dir.path().AppendASCII("read_write_file");
  base::PlatformFile file = base::CreatePlatformFile(
      file_path,
      base::PLATFORM_FILE_CREATE |
      base::PLATFORM_FILE_READ |
      base::PLATFORM_FILE_WRITE,
      NULL, NULL);
  EXPECT_NE(base::kInvalidPlatformFileValue, file);

  char data_to_write[] = "test";
  const int kTestDataSize = 4;

  // Write 0 bytes to the file.
  int bytes_written = WriteFully(file, 0, data_to_write, 0);
  EXPECT_EQ(0, bytes_written);

  // Write "test" to the file.
  bytes_written = WriteFully(file, 0, data_to_write, kTestDataSize);
  EXPECT_EQ(kTestDataSize, bytes_written);

  // Read from EOF.
  char data_read_1[32];
  int bytes_read = ReadFully(file, kTestDataSize, data_read_1, kTestDataSize);
  EXPECT_EQ(0, bytes_read);

  // Read from somewhere in the middle of the file.
  const int kPartialReadOffset = 1;
  bytes_read = ReadFully(file, kPartialReadOffset, data_read_1, kTestDataSize);
  EXPECT_EQ(kTestDataSize - kPartialReadOffset, bytes_read);
  for (int i = 0; i < bytes_read; i++)
    EXPECT_EQ(data_to_write[i + kPartialReadOffset], data_read_1[i]);

  // Read 0 bytes.
  bytes_read = ReadFully(file, 0, data_read_1, 0);
  EXPECT_EQ(0, bytes_read);

  // Read the entire file.
  bytes_read = ReadFully(file, 0, data_read_1, kTestDataSize);
  EXPECT_EQ(kTestDataSize, bytes_read);
  for (int i = 0; i < bytes_read; i++)
    EXPECT_EQ(data_to_write[i], data_read_1[i]);

  // Write past the end of the file.
  const int kOffsetBeyondEndOfFile = 10;
  const int kPartialWriteLength = 2;
  bytes_written = WriteFully(file, kOffsetBeyondEndOfFile,
                             data_to_write, kPartialWriteLength);
  EXPECT_EQ(kPartialWriteLength, bytes_written);

  // Make sure the file was extended.
  int64 file_size = 0;
  EXPECT_TRUE(file_util::GetFileSize(file_path, &file_size));
  EXPECT_EQ(kOffsetBeyondEndOfFile + kPartialWriteLength, file_size);

  // Make sure the file was zero-padded.
  char data_read_2[32];
  bytes_read = ReadFully(file, 0, data_read_2, static_cast<int>(file_size));
  EXPECT_EQ(file_size, bytes_read);
  for (int i = 0; i < kTestDataSize; i++)
    EXPECT_EQ(data_to_write[i], data_read_2[i]);
  for (int i = kTestDataSize; i < kOffsetBeyondEndOfFile; i++)
    EXPECT_EQ(0, data_read_2[i]);
  for (int i = kOffsetBeyondEndOfFile; i < file_size; i++)
    EXPECT_EQ(data_to_write[i - kOffsetBeyondEndOfFile], data_read_2[i]);

  // Close the file handle to allow the temp directory to be deleted.
  base::ClosePlatformFile(file);
}

TEST(PlatformFile, TruncatePlatformFile) {
  ScopedTempDir temp_dir;
  ASSERT_TRUE(temp_dir.CreateUniqueTempDir());
  FilePath file_path = temp_dir.path().AppendASCII("truncate_file");
  base::PlatformFile file = base::CreatePlatformFile(
      file_path,
      base::PLATFORM_FILE_CREATE |
      base::PLATFORM_FILE_READ |
      base::PLATFORM_FILE_WRITE,
      NULL, NULL);
  EXPECT_NE(base::kInvalidPlatformFileValue, file);

  // Write "test" to the file.
  char data_to_write[] = "test";
  int kTestDataSize = 4;
  int bytes_written = WriteFully(file, 0, data_to_write, kTestDataSize);
  EXPECT_EQ(kTestDataSize, bytes_written);

  // Extend the file.
  const int kExtendedFileLength = 10;
  int64 file_size = 0;
  EXPECT_TRUE(base::TruncatePlatformFile(file, kExtendedFileLength));
  EXPECT_TRUE(file_util::GetFileSize(file_path, &file_size));
  EXPECT_EQ(kExtendedFileLength, file_size);

  // Make sure the file was zero-padded.
  char data_read[32];
  int bytes_read = ReadFully(file, 0, data_read, static_cast<int>(file_size));
  EXPECT_EQ(file_size, bytes_read);
  for (int i = 0; i < kTestDataSize; i++)
    EXPECT_EQ(data_to_write[i], data_read[i]);
  for (int i = kTestDataSize; i < file_size; i++)
    EXPECT_EQ(0, data_read[i]);

  // Truncate the file.
  const int kTruncatedFileLength = 2;
  EXPECT_TRUE(base::TruncatePlatformFile(file, kTruncatedFileLength));
  EXPECT_TRUE(file_util::GetFileSize(file_path, &file_size));
  EXPECT_EQ(kTruncatedFileLength, file_size);

  // Make sure the file was truncated.
  bytes_read = ReadFully(file, 0, data_read, kTestDataSize);
  EXPECT_EQ(file_size, bytes_read);
  for (int i = 0; i < file_size; i++)
    EXPECT_EQ(data_to_write[i], data_read[i]);

  // Close the file handle to allow the temp directory to be deleted.
  base::ClosePlatformFile(file);
}

TEST(PlatformFile, TouchGetInfoPlatformFile) {
  ScopedTempDir temp_dir;
  ASSERT_TRUE(temp_dir.CreateUniqueTempDir());
  base::PlatformFile file = base::CreatePlatformFile(
      temp_dir.path().AppendASCII("touch_get_info_file"),
      base::PLATFORM_FILE_CREATE |
      base::PLATFORM_FILE_WRITE |
      base::PLATFORM_FILE_WRITE_ATTRIBUTES,
      NULL, NULL);
  EXPECT_NE(base::kInvalidPlatformFileValue, file);

  // Get info for a newly created file.
  base::PlatformFileInfo info;
  EXPECT_TRUE(base::GetPlatformFileInfo(file, &info));

  // Add 2 seconds to account for possible rounding errors on
  // filesystems that use a 1s or 2s timestamp granularity.
  base::Time now = base::Time::Now() + base::TimeDelta::FromSeconds(2);
  EXPECT_EQ(0, info.size);
  EXPECT_FALSE(info.is_directory);
  EXPECT_TRUE(info.last_accessed <= now);
  EXPECT_TRUE(info.last_modified <= now);
  EXPECT_TRUE(info.creation_time <= now);
  base::Time creation_time = info.creation_time;

  // Write "test" to the file.
  char data[] = "test";
  const int kTestDataSize = 4;
  int bytes_written = WriteFully(file, 0, data, kTestDataSize);
  EXPECT_EQ(kTestDataSize, bytes_written);

  // Change the last_accessed and last_modified dates.
  // It's best to add values that are multiples of 2 (in seconds)
  // to the current last_accessed and last_modified times, because
  // FATxx uses a 2s timestamp granularity.
  base::Time new_last_accessed =
      info.last_accessed + base::TimeDelta::FromSeconds(234);
  base::Time new_last_modified =
      info.last_modified + base::TimeDelta::FromMinutes(567);

  EXPECT_TRUE(base::TouchPlatformFile(file, new_last_accessed,
                                      new_last_modified));

  // Make sure the file info was updated accordingly.
  EXPECT_TRUE(base::GetPlatformFileInfo(file, &info));
  EXPECT_EQ(info.size, kTestDataSize);
  EXPECT_FALSE(info.is_directory);

  // ext2/ext3 and HPS/HPS+ seem to have a timestamp granularity of 1s.
#if defined(OS_POSIX)
  EXPECT_EQ(info.last_accessed.ToTimeVal().tv_sec,
            new_last_accessed.ToTimeVal().tv_sec);
  EXPECT_EQ(info.last_modified.ToTimeVal().tv_sec,
            new_last_modified.ToTimeVal().tv_sec);
#else
  EXPECT_TRUE(info.last_accessed == new_last_accessed);
  EXPECT_TRUE(info.last_modified == new_last_modified);
#endif

  EXPECT_TRUE(info.creation_time == creation_time);

  // Close the file handle to allow the temp directory to be deleted.
  base::ClosePlatformFile(file);
}
  if (flags & PLATFORM_FILE_WRITE_ATTRIBUTES)
    create_flags |= FILE_WRITE_ATTRIBUTES;
  if (created && (INVALID_HANDLE_VALUE != file)) {
    if (flags & PLATFORM_FILE_OPEN_ALWAYS)
      *created = (ERROR_ALREADY_EXISTS != GetLastError());
    else if (flags & PLATFORM_FILE_CREATE_ALWAYS)
      *created = true;
  if (error_code) {
    if (file != kInvalidPlatformFileValue)
      *error_code = PLATFORM_FILE_OK;
    else {
      DWORD last_error = GetLastError();
      switch (last_error) {
        case ERROR_SHARING_VIOLATION:
          *error_code = PLATFORM_FILE_ERROR_IN_USE;
          break;
        case ERROR_FILE_EXISTS:
          *error_code = PLATFORM_FILE_ERROR_EXISTS;
          break;
        case ERROR_FILE_NOT_FOUND:
          *error_code = PLATFORM_FILE_ERROR_NOT_FOUND;
          break;
        case ERROR_ACCESS_DENIED:
          *error_code = PLATFORM_FILE_ERROR_ACCESS_DENIED;
          break;
        default:
          *error_code = PLATFORM_FILE_ERROR_FAILED;
      }
  return (CloseHandle(file) != 0);
}

int ReadPlatformFile(PlatformFile file, int64 offset, char* data, int size) {
  if (file == kInvalidPlatformFileValue)
    return -1;

  LARGE_INTEGER offset_li;
  offset_li.QuadPart = offset;

  OVERLAPPED overlapped = {0};
  overlapped.Offset = offset_li.LowPart;
  overlapped.OffsetHigh = offset_li.HighPart;

  DWORD bytes_read;
  if (::ReadFile(file, data, size, &bytes_read, &overlapped) != 0)
    return bytes_read;
  else if (ERROR_HANDLE_EOF == GetLastError())
    return 0;

  return -1;
}

int WritePlatformFile(PlatformFile file, int64 offset,
                      const char* data, int size) {
  if (file == kInvalidPlatformFileValue)
    return -1;

  LARGE_INTEGER offset_li;
  offset_li.QuadPart = offset;

  OVERLAPPED overlapped = {0};
  overlapped.Offset = offset_li.LowPart;
  overlapped.OffsetHigh = offset_li.HighPart;

  DWORD bytes_written;
  if (::WriteFile(file, data, size, &bytes_written, &overlapped) != 0)
    return bytes_written;

  return -1;
}

bool TruncatePlatformFile(PlatformFile file, int64 length) {
  if (file == kInvalidPlatformFileValue)
    return false;

  // Get the current file pointer.
  LARGE_INTEGER file_pointer;
  LARGE_INTEGER zero;
  zero.QuadPart = 0;
  if (::SetFilePointerEx(file, zero, &file_pointer, FILE_CURRENT) == 0)
    return false;

  LARGE_INTEGER length_li;
  length_li.QuadPart = length;
  // If length > file size, SetFilePointerEx() should extend the file
  // with zeroes on all Windows standard file systems (NTFS, FATxx).
  if (!::SetFilePointerEx(file, length_li, NULL, FILE_BEGIN))
    return false;

  // Set the new file length and move the file pointer to its old position.
  // This is consistent with ftruncate()'s behavior, even when the file
  // pointer points to a location beyond the end of the file.
  return ((::SetEndOfFile(file) != 0) &&
          (::SetFilePointerEx(file, file_pointer, NULL, FILE_BEGIN) != 0));
}

bool FlushPlatformFile(PlatformFile file) {
  return ((file != kInvalidPlatformFileValue) && ::FlushFileBuffers(file));
}

bool TouchPlatformFile(PlatformFile file, const base::Time& last_access_time,
                       const base::Time& last_modified_time) {
  if (file == kInvalidPlatformFileValue)
    return false;

  FILETIME last_access_filetime = last_access_time.ToFileTime();
  FILETIME last_modified_filetime = last_modified_time.ToFileTime();
  return (::SetFileTime(file, NULL, &last_access_filetime,
                        &last_modified_filetime) != 0);
}

bool GetPlatformFileInfo(PlatformFile file, PlatformFileInfo* info) {
  if (!info)
    return false;

  BY_HANDLE_FILE_INFORMATION file_info;
  if (GetFileInformationByHandle(file, &file_info) == 0)
    return false;

  LARGE_INTEGER size;
  size.HighPart = file_info.nFileSizeHigh;
  size.LowPart = file_info.nFileSizeLow;
  info->size = size.QuadPart;
  info->is_directory =
      file_info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY != 0;
  info->last_modified = base::Time::FromFileTime(file_info.ftLastWriteTime);
  info->last_accessed = base::Time::FromFileTime(file_info.ftLastAccessTime);
  info->creation_time = base::Time::FromFileTime(file_info.ftCreationTime);
  return true;
  virtual void StartPageScaleAnimation(const gfx::Vector2d& target_offset,
void Layer::SetScrollOffsetFromImplSide(const gfx::Vector2d& scroll_offset) {
  void SetScrollOffsetFromImplSide(const gfx::Vector2d& scroll_offset);
void LayerImpl::SetSentScrollDelta(const gfx::Vector2d& sent_scroll_delta) {
void LayerImpl::SetScrollOffset(const gfx::Vector2d& scroll_offset) {
void LayerImpl::SetScrollOffsetAndDelta(const gfx::Vector2d& scroll_offset,
  void SetScrollOffset(const gfx::Vector2d& scroll_offset);
  void SetScrollOffsetAndDelta(const gfx::Vector2d& scroll_offset,
  void SetSentScrollDelta(const gfx::Vector2d& sent_scroll_delta);
gfx::Rect ExpandRectByDelta(const gfx::Rect& rect, const gfx::Vector2d& delta) {
    const gfx::Vector2d& amount) {
  void SetEnlargePassTextureAmountForTesting(const gfx::Vector2d& amount);
void SoftwareOutputDevice::Scroll(const gfx::Vector2d& delta,
                                  const gfx::Rect& clip_rect) {
  virtual void Scroll(const gfx::Vector2d& delta, const gfx::Rect& clip_rect);
void BitmapContentLayerUpdater::Resource::Update(
    ResourceUpdateQueue* queue,
    const gfx::Rect& source_rect,
    const gfx::Vector2d& dest_offset,
    bool partial_update) {
                                              const gfx::Vector2d& dest_offset,
                        const gfx::Vector2d& dest_offset,
                     const gfx::Vector2d& dest_offset,
    const gfx::Vector2d& dest_offset,
                        const gfx::Vector2d& dest_offset,
                                         const gfx::Vector2d& dest_offset,
                                      const gfx::Vector2d& dest_offset,
                        const gfx::Vector2d& dest_offset,
                     const gfx::Vector2d& dest_offset,
                        const gfx::Vector2d& dest_offset,

                                    const gfx::Vector2d& dest_offset) {
                 const gfx::Vector2d& dest_offset);
                                 const gfx::Vector2d& dest_offset) {
                 const gfx::Vector2d& dest_offset);
                                      const gfx::Vector2d& dest_offset) {
                               const gfx::Vector2d& dest_offset);
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
                                   float scale) {}
void PixelTest::ForceViewportOffset(const gfx::Vector2d& viewport_offset) {
  void ForceViewportOffset(const gfx::Vector2d& viewport_offset);
                                        const gfx::Vector2d& dest_offset,
                        const gfx::Vector2d& dest_offset,
void LayerTreeHost::StartPageScaleAnimation(const gfx::Vector2d& target_offset,
  void StartPageScaleAnimation(const gfx::Vector2d& target_offset,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
void LayerTreeHostImpl::StartPageScaleAnimation(
    const gfx::Vector2d& target_offset,
    bool anchor_point,
    float page_scale,
    base::TimeDelta duration) {
  virtual void StartPageScaleAnimation(const gfx::Vector2d& target_offset,
                             const gfx::Vector2d& scroll_delta) {
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
void RenderWidgetCompositor::ApplyScrollAndScale(
    const gfx::Vector2d& scroll_delta,
    float page_scale) {
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void StartPageScaleAnimation(const gfx::Vector2d& target_offset,
    const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
                                   float page_scale) OVERRIDE;
void CompositorHost::ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
  virtual void ApplyScrollAndScale(const gfx::Vector2d& scroll_delta,
#include "chrome/browser/pref_service.h"
#include "chrome/browser/profile.h"
#include "chrome/common/pref_names.h"
#include "grit/locale_settings.h"
  localized_strings->SetString(L"clearBrowsingDataLabel",
      l10n_util::GetString(IDS_CLEAR_BROWSING_DATA_LABEL));
  localized_strings->SetString(L"clearBrowsingDataTimeLabel",
      l10n_util::GetString(IDS_CLEAR_BROWSING_DATA_TIME_LABEL));
  localized_strings->SetString(L"deleteBrowsingHistoryCheckbox",
      l10n_util::GetString(IDS_DEL_BROWSING_HISTORY_CHKBOX));
  localized_strings->SetString(L"deleteDownloadHistoryCheckbox",
      l10n_util::GetString(IDS_DEL_DOWNLOAD_HISTORY_CHKBOX));
  localized_strings->SetString(L"deleteCacheCheckbox",
      l10n_util::GetString(IDS_DEL_CACHE_CHKBOX));
  localized_strings->SetString(L"deleteCookiesCheckbox",
      l10n_util::GetString(IDS_DEL_COOKIES_CHKBOX));
  localized_strings->SetString(L"deletePasswordsCheckbox",
      l10n_util::GetString(IDS_DEL_PASSWORDS_CHKBOX));
  localized_strings->SetString(L"deleteFormDataCheckbox",
      l10n_util::GetString(IDS_DEL_FORM_DATA_CHKBOX));
  localized_strings->SetString(L"clearBrowsingDataCommit",
      l10n_util::GetString(IDS_CLEAR_BROWSING_DATA_COMMIT));
  localized_strings->SetString(L"flashStorageSettings",
      l10n_util::GetString(IDS_FLASH_STORAGE_SETTINGS));
  localized_strings->SetString(L"flash_storage_url",
      l10n_util::GetString(IDS_FLASH_STORAGE_URL));
  localized_strings->SetString(L"clearDataDeleting",
      l10n_util::GetString(IDS_CLEAR_DATA_DELETING));

  ListValue* time_list = new ListValue;
  for (int i = 0; i < 5; i++) {
    std::wstring label_string;
    switch (i) {
      case 0:
        label_string = l10n_util::GetString(IDS_CLEAR_DATA_HOUR);
        break;
      case 1:
        label_string = l10n_util::GetString(IDS_CLEAR_DATA_DAY);
        break;
      case 2:
        label_string = l10n_util::GetString(IDS_CLEAR_DATA_WEEK);
        break;
      case 3:
        label_string = l10n_util::GetString(IDS_CLEAR_DATA_4WEEKS);
        break;
      case 4:
        label_string = l10n_util::GetString(IDS_CLEAR_DATA_EVERYTHING);
        break;
    }
    ListValue* option = new ListValue();
    option->Append(Value::CreateIntegerValue(i));
    option->Append(Value::CreateStringValue(label_string));
    time_list->Append(option);
  }
  localized_strings->Set(L"clearBrowsingDataTimeList", time_list);
}

void ClearBrowserDataHandler::RegisterMessages() {
  // Setup handlers specific to this panel.
  DCHECK(dom_ui_);
  dom_ui_->RegisterMessageCallback("performClearBrowserData",
      NewCallback(this, &ClearBrowserDataHandler::HandleClearBrowserData));
}

void ClearBrowserDataHandler::HandleClearBrowserData(const Value* value) {
  Profile *profile = dom_ui_->GetProfile();
  PrefService *prefs = profile->GetPrefs();

  int remove_mask = 0;
  if (prefs->GetBoolean(prefs::kDeleteBrowsingHistory))
    remove_mask |= BrowsingDataRemover::REMOVE_HISTORY;
  if (prefs->GetBoolean(prefs::kDeleteDownloadHistory))
    remove_mask |= BrowsingDataRemover::REMOVE_DOWNLOADS;
  if (prefs->GetBoolean(prefs::kDeleteCache))
    remove_mask |= BrowsingDataRemover::REMOVE_CACHE;
  if (prefs->GetBoolean(prefs::kDeleteCookies))
    remove_mask |= BrowsingDataRemover::REMOVE_COOKIES;
  if (prefs->GetBoolean(prefs::kDeletePasswords))
    remove_mask |= BrowsingDataRemover::REMOVE_PASSWORDS;
  if (prefs->GetBoolean(prefs::kDeleteFormData))
    remove_mask |= BrowsingDataRemover::REMOVE_FORM_DATA;

  int period_selected = prefs->GetInteger(prefs::kDeleteTimePeriod);

  FundamentalValue state(true);
  dom_ui_->CallJavascriptFunction(L"clearBrowserDataSetClearingState", state);

  // BrowsingDataRemover deletes itself when done.
  remover_ = new BrowsingDataRemover(profile,
      static_cast<BrowsingDataRemover::TimePeriod>(period_selected),
      base::Time());
  remover_->AddObserver(this);
  remover_->Remove(remove_mask);
}

void ClearBrowserDataHandler::OnBrowsingDataRemoverDone() {
  // No need to remove ourselves as an observer as BrowsingDataRemover deletes
  // itself after we return.
  remover_ = NULL;
  DCHECK(dom_ui_);
  dom_ui_->CallJavascriptFunction(L"clearBrowserDataDismiss");
#include "chrome/browser/browsing_data_remover.h"
// Clear browser data handler page UI handler.
class ClearBrowserDataHandler : public OptionsPageUIHandler,
                                public BrowsingDataRemover::Observer {
  // DOMMessageHandler implementation.
  virtual void RegisterMessages();

  void HandleClearBrowserData(const Value* value);

  // Callback from BrowsingDataRemover. Closes the dialog.
  virtual void OnBrowsingDataRemoverDone();

  // If non-null it means removal is in progress. BrowsingDataRemover takes care
  // of deleting itself when done.
  BrowsingDataRemover* remover_;


  localized_strings->SetString(L"ok",
      l10n_util::GetString(IDS_OK));
  localized_strings->SetString(L"cancel",
      l10n_util::GetString(IDS_CANCEL));
  localized_strings->SetString(L"delete",
      l10n_util::GetString(IDS_DELETE));
  localized_strings->SetString(L"edit",
      l10n_util::GetString(IDS_EDIT));
  localized_strings->SetString(L"learnMore",
      l10n_util::GetString(IDS_LEARN_MORE));
  localized_strings->SetString(L"abort",
      l10n_util::GetString(IDS_ABORT));
  localized_strings->SetString(L"close",
      l10n_util::GetString(IDS_CLOSE));
  localized_strings->SetString(L"done",
      l10n_util::GetString(IDS_DONE));
#include "third_party/WebKit/public/web/WebLocalFrame.h"
  blink::WebLocalFrame* frame = context()->web_frame();
    blink::WebLocalFrame* frame,

namespace blink {
class WebLocalFrame;
}
      blink::WebLocalFrame* frame,
  script_context_set_.reset(
      new ScriptContextSet(&extensions_, &active_extension_ids_));
  ScriptContext* context = script_context_set_->Register(
      frame, v8_context, extension_group, world_id);
  if (context->context_type() == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(context->extension());
  switch (context->context_type()) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  ScriptContext* context = script_context_set_->GetByV8Context(v8_context);
  script_context_set_->Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  if (ScriptContext::IsSandboxedPage(
          extensions_, ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_->ForEach(
  script_context_set_->ForEach(
  MessagingBindings::DeliverMessage(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(*script_context_set_, port_id,
  std::set<ScriptContext*> removed_contexts =
      script_context_set_->OnExtensionUnloaded(id);
  for (ScriptContext* context : removed_contexts) {
    request_sender_->InvalidateSource(context);
#include "base/memory/scoped_ptr.h"
#include "extensions/common/extension.h"
    return *script_context_set_;

  scoped_ptr<ScriptContextSet> script_context_set_;
  ExtensionIdSet active_extension_ids_;
#include "third_party/WebKit/public/web/WebLocalFrame.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
  if (blink::WebLocalFrame* webframe = context->web_frame())
#include "extensions/common/constants.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
                             blink::WebLocalFrame* web_frame,
  gin::PerContextData* gin_data = gin::PerContextData::From(v8_context);
  CHECK(gin_data);  // may fail if the v8::Context hasn't been registered yet
  gin_data->set_runner(runner_.get());
// static
bool ScriptContext::IsSandboxedPage(const ExtensionSet& extensions,
                                    const GURL& url) {
  // TODO(kalman): This is checking for the wrong thing, it should be checking
  // if the frame's security origin is unique. The extension sandbox directive
  // is checked for in extensions/common/manifest_handlers/csp_info.cc.
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

class WebLocalFrame;
class ExtensionSet;
                blink::WebLocalFrame* frame,
  // Returns whether |url| is sandboxed (as declared in any Extension in
  // |extension_set| as sandboxed).
  //
  // Declared in ScriptContext for lack of a better place, but this should
  // become unnecessary at some point as crbug.com/466373 is worked on.
  static bool IsSandboxedPage(const ExtensionSet& extension_set,
                              const GURL& url);

  blink::WebLocalFrame* web_frame() const { return web_frame_; }
  //
  // TODO(kalman): Remove this and replace with a GetOrigin() call which reads
  // of WebDocument::securityOrigin():
  //  - The URL can change (e.g. pushState) but the origin cannot. Luckily it
  //    appears as though callers don't make security decisions based on the
  //    result of GetURL() so it's not a problem... yet.
  //  - Origin is the correct check to be making.
  //  - It might let us remove the about:blank resolving?
  // The WebLocalFrame associated with this context. This can be NULL because
  // this object can outlive is destroyed asynchronously.
  blink::WebLocalFrame* web_frame_;
#include "content/public/common/url_constants.h"
#include "extensions/renderer/extension_groups.h"
#include "extensions/renderer/script_injection.h"
#include "third_party/WebKit/public/web/WebDocument.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
ScriptContextSet::ScriptContextSet(ExtensionSet* extensions,
                                   ExtensionIdSet* active_extension_ids)
    : extensions_(extensions), active_extension_ids_(active_extension_ids) {
ScriptContextSet::~ScriptContextSet() {
ScriptContext* ScriptContextSet::Register(
    blink::WebLocalFrame* frame,
    const v8::Handle<v8::Context>& v8_context,
    int extension_group,
    int world_id) {
  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());

  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  contexts_.insert(context);  // takes ownership
  return context;
                              : nullptr;
  return calling.IsEmpty() ? nullptr : GetByV8Context(calling);
    const v8::Handle<v8::Context>& v8_context) const {
  for (ScriptContext* script_context : contexts_) {
    if (script_context->v8_context() == v8_context)
      return script_context;
  return nullptr;
  std::set<ScriptContext*> contexts_copy = contexts_;
  for (ScriptContext* context : contexts_copy) {
std::set<ScriptContext*> ScriptContextSet::OnExtensionUnloaded(
  std::set<ScriptContext*> removed;
  ForEach(extension_id,
          base::Bind(&ScriptContextSet::DispatchOnUnloadEventAndRemove,
                     base::Unretained(this), &removed));
  return removed;
}

const Extension* ScriptContextSet::GetExtensionFromFrameAndWorld(
    const blink::WebLocalFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.
    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_->GetExtensionOrAppIDByURL(frame_url);
  // There are conditions where despite a context being associated with an
  // extension, no extension actually gets found. Ignore "invalid" because CSP
  // blocks extension page loading by switching the extension ID to "invalid".
  const Extension* extension = extensions_->GetByID(extension_id);
  if (!extension && !extension_id.empty() && extension_id != "invalid") {
    // TODO(kalman): Do something here?
  }
  return extension;
}

Feature::Context ScriptContextSet::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (ScriptContext::IsSandboxedPage(*extensions_, url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && active_extension_ids_->count(extension->id()) > 0) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of ScriptContext::IsSandboxedPage().
  if (!origin.isUnique() && extensions_->ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

void ScriptContextSet::DispatchOnUnloadEventAndRemove(
    std::set<ScriptContext*>* out,
    ScriptContext* context) {
  context->DispatchOnUnloadEvent();
  Remove(context);  // deleted asynchronously
  out->insert(context);
#include "base/macros.h"
#include "base/memory/weak_ptr.h"
#include "extensions/common/extension.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/features/feature.h"
#include "url/gurl.h"
namespace blink {
class WebLocalFrame;
class WebSecurityOrigin;
namespace content {
class RenderView;
// A container of ScriptContexts, responsible for both creating and managing
// them.
//
// Since calling JavaScript within a context can cause any number of contexts
// to be created or destroyed, this has additional smarts to help with the set
// changing underneath callers.
  ScriptContextSet(
      ExtensionSet* extensions,
      // Set of the IDs of extensions that are active in this process.
      // Must outlive this. TODO(kalman): Combine this and |extensions|.
      ExtensionIdSet* active_extension_ids);

  // Returns the number of contexts being tracked by this set.
  // This may also include invalid contexts. TODO(kalman): Useful?
  size_t size() const { return contexts_.size(); }
  // Creates and starts managing a new ScriptContext. Ownership is held.
  // Returns a weak reference to the new ScriptContext.
  ScriptContext* Register(blink::WebLocalFrame* frame,
                          const v8::Handle<v8::Context>& v8_context,
                          int extension_group,
                          int world_id);
  ScriptContext* GetByV8Context(const v8::Handle<v8::Context>& context) const;
  std::set<ScriptContext*> OnExtensionUnloaded(const std::string& extension_id);
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(
      const blink::WebLocalFrame* frame,
      int world_id,
      bool use_effective_url);

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  // Calls Remove on |context| then appends |context| to |out|.
  // This is a helper designed to be used by OnExtensionUnloaded with ForEach.
  void DispatchOnUnloadEventAndRemove(std::set<ScriptContext*>* out,
                                      ScriptContext* context);

  // Weak reference to all installed Extensions.
  ExtensionSet* extensions_;

  // Weak reference to all installed Extensions that are also active in this
  // process.
  ExtensionIdSet* active_extension_ids_;

  // The set of all ScriptContexts we own.
  std::set<ScriptContext*> contexts_;
#include <vector>

#include "extensions/common/extension_set.h"
TEST(ScriptContextSetTest, Lifecycle) {
  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebLocalFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  // Do this after construction of the webview, since it may construct the
  // Isolate.

  v8::Local<v8::Context> v8_context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(v8_context);
  // ScriptContext relies on gin, it just doesn't look like it from here.
  context_holder.SetContext(v8_context);
  ExtensionSet extensions;
  ExtensionIdSet active_extensions;
  ScriptContextSet context_set(&extensions, &active_extensions);
  ScriptContext* context = context_set.Register(
      frame, v8_context, 0, 0);  // no extension group or world ID
  // Context is valid and resembles correctness.
  EXPECT_TRUE(context->is_valid());
  EXPECT_EQ(frame, context->web_frame());
  EXPECT_EQ(v8_context, context->v8_context());
  // Context has been correctly added.
  EXPECT_EQ(1u, context_set.size());
  EXPECT_EQ(context, context_set.GetByV8Context(v8_context));
  // Test context is correctly removed.
  EXPECT_EQ(0u, context_set.size());
  EXPECT_EQ(nullptr, context_set.GetByV8Context(v8_context));
bool GetFileUrl(IDataObject* data_object, std::wstring* url,
                std::wstring* title) {
  STGMEDIUM store;
  if (SUCCEEDED(data_object->GetData(ClipboardUtil::GetFilenameWFormat(),
                                     &store))) {
    bool success = false;
    {
      // filename using unicode
      ScopedHGlobal<wchar_t> data(store.hGlobal);
      if (data.get() && data.get()[0] &&
          (PathFileExists(data.get()) || PathIsUNC(data.get()))) {
        wchar_t file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathW(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(file_url);
          title->assign(file_url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }

  if (SUCCEEDED(data_object->GetData(ClipboardUtil::GetFilenameFormat(),
                                     &store))) {
    bool success = false;
    {
      // filename using ascii
      ScopedHGlobal<char> data(store.hGlobal);
      if (data.get() && data.get()[0] && (PathFileExistsA(data.get()) ||
                                          PathIsUNCA(data.get()))) {
        char file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathA(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(UTF8ToWide(file_url));
          title->assign(*url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }
  return false;
}

    std::wstring* url, std::wstring* title, bool convert_filenames) {
  if (convert_filenames) {
    return GetFileUrl(data_object, url, title);
  } else {
    return false;
  return GetUrl(data_object, plain_text, &title, false);
      std::wstring* url, std::wstring* title, bool convert_filenames);
  bool success = ClipboardUtil::GetUrl(source_object_, &url_str, title, true);
      ClipboardUtil::GetUrl(data_object, &url, &title, true);
  if (ClipboardUtil::GetUrl(data_object, &url_str, &drop_data->url_title,
                            false)) {
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/public/browser/color_chooser.h"

#include "base/logging.h"

// static
content::ColorChooser* content::ColorChooser::Create(
    int identifier, content::WebContents* tab, SkColor initial_color) {
  NOTIMPLEMENTED();
  return NULL;
}
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_UI_BASE_SHELL_DIALOG_H_
#define CHROME_BROWSER_UI_BASE_SHELL_DIALOG_H_
#pragma once

#include "ui/gfx/native_widget_types.h"

// A base class for shell dialogs.
class BaseShellDialog {
 public:
  // Returns true if a shell dialog box is currently being shown modally
  // to the specified owner.
  virtual bool IsRunning(gfx::NativeWindow owning_window) const = 0;

  // Notifies the dialog box that the listener has been destroyed and it should
  // no longer be sent notifications.
  virtual void ListenerDestroyed() = 0;

 protected:
  virtual ~BaseShellDialog() {}
};

#endif  // CHROME_BROWSER_UI_BASE_SHELL_DIALOG_H_
#include "content/public/browser/color_chooser.h"
content::ColorChooser* Browser::OpenColorChooser(WebContents* tab,
                                                 int color_chooser_id,
                                                 const SkColor& color) {
#if defined(OS_WIN)
  // On Windows, only create a color chooser if one doesn't exist, because we
  // can't close the old color chooser dialog.
  if (!color_chooser_.get())
    color_chooser_.reset(content::ColorChooser::Create(color_chooser_id, tab,
                                                       color));
#else
  if (color_chooser_.get())
    color_chooser_->End();
  color_chooser_.reset(content::ColorChooser::Create(color_chooser_id, tab,
                                                     color));
#endif
  return color_chooser_.get();
}

void Browser::DidEndColorChooser() {
  color_chooser_.reset();
}

  virtual content::ColorChooser* OpenColorChooser(
      content::WebContents* tab,
      int color_chooser_id,
      const SkColor& color) OVERRIDE;
  virtual void DidEndColorChooser() OVERRIDE;
  // Currently open color chooser. Non-NULL after OpenColorChooser is called and
  // before DidEndColorChooser is called.
  scoped_ptr<content::ColorChooser> color_chooser_;

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <gtk/gtk.h>

#include "content/public/browser/color_chooser.h"

#include "content/public/browser/web_contents.h"
#include "content/public/browser/web_contents_observer.h"
#include "grit/generated_resources.h"
#include "ui/base/gtk/gtk_signal.h"
#include "ui/base/l10n/l10n_util.h"
#include "ui/gfx/skia_utils_gtk.h"

class ColorChooserGtk : public content::ColorChooser,
                        public content::WebContentsObserver {
 public:
  ColorChooserGtk(
      int identifier, content::WebContents* tab, SkColor initial_color);
  virtual ~ColorChooserGtk();

  virtual void End() OVERRIDE;
  virtual void SetSelectedColor(SkColor color) OVERRIDE;

 private:
  CHROMEGTK_CALLBACK_0(ColorChooserGtk, void, OnColorChooserOk);
  CHROMEGTK_CALLBACK_0(ColorChooserGtk, void, OnColorChooserCancel);
  CHROMEGTK_CALLBACK_0(ColorChooserGtk, void, OnColorChooserDestroy);

  GtkWidget* color_selection_dialog_;
};

content::ColorChooser* content::ColorChooser::Create(
    int identifier, content::WebContents* tab, SkColor initial_color) {
  return new ColorChooserGtk(identifier, tab, initial_color);
}

ColorChooserGtk::ColorChooserGtk(
    int identifier, content::WebContents* tab, SkColor initial_color)
    : content::ColorChooser(identifier),
      content::WebContentsObserver(tab) {
  color_selection_dialog_ = gtk_color_selection_dialog_new(
      l10n_util::GetStringUTF8(IDS_SELECT_COLOR_DIALOG_TITLE).c_str());
  GtkWidget* cancel_button;
  GtkColorSelection* color_selection;
  GtkWidget* ok_button;
  g_object_get(color_selection_dialog_,
               "cancel-button", &cancel_button,
               "color-selection", &color_selection,
               "ok-button", &ok_button,
               NULL);
  gtk_color_selection_set_has_opacity_control(color_selection, FALSE);
  g_signal_connect(ok_button, "clicked",
                   G_CALLBACK(OnColorChooserOkThunk), this);
  g_signal_connect(cancel_button, "clicked",
                   G_CALLBACK(OnColorChooserCancelThunk), this);
  g_signal_connect(color_selection_dialog_, "destroy",
                   G_CALLBACK(OnColorChooserDestroyThunk), this);
  GdkColor gdk_color = gfx::SkColorToGdkColor(initial_color);
  gtk_color_selection_set_previous_color(color_selection, &gdk_color);
  gtk_color_selection_set_current_color(color_selection, &gdk_color);
  gtk_window_present(GTK_WINDOW(color_selection_dialog_));
  g_object_unref(cancel_button);
  g_object_unref(color_selection);
  g_object_unref(ok_button);
}

ColorChooserGtk::~ColorChooserGtk() {
  // Always call End() before destroying.
  DCHECK(!color_selection_dialog_);
}

void ColorChooserGtk::OnColorChooserOk(GtkWidget* widget) {
  GdkColor color;
  GtkColorSelection* color_selection;
  g_object_get(color_selection_dialog_,
               "color-selection", &color_selection, NULL);
  gtk_color_selection_get_current_color(color_selection, &color);
  web_contents()->DidChooseColorInColorChooser(identifier(),
                                               gfx::GdkColorToSkColor(color));
  g_object_unref(color_selection);
  gtk_widget_destroy(color_selection_dialog_);
}

void ColorChooserGtk::OnColorChooserCancel(GtkWidget* widget) {
  gtk_widget_destroy(color_selection_dialog_);
}

void ColorChooserGtk::OnColorChooserDestroy(GtkWidget* widget) {
  color_selection_dialog_ = NULL;
  if (web_contents())
    web_contents()->DidEndColorChooser(identifier());
}

void ColorChooserGtk::End() {
  if (!color_selection_dialog_)
    return;

  gtk_widget_destroy(color_selection_dialog_);
}

void ColorChooserGtk::SetSelectedColor(SkColor color) {
  if (!color_selection_dialog_)
    return;

  GdkColor gdk_color = gfx::SkColorToGdkColor(color);
  GtkColorSelection* color_selection;
  g_object_get(color_selection_dialog_,
               "color-selection", &color_selection, NULL);
  gtk_color_selection_set_previous_color(color_selection, &gdk_color);
  gtk_color_selection_set_current_color(color_selection, &gdk_color);
  g_object_unref(color_selection);
}
#include "chrome/browser/ui/base_shell_dialog.h"
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/public/browser/color_chooser.h"

#include "base/logging.h"

// static
content::ColorChooser* content::ColorChooser::Create(
    int identifier, content::WebContents* tab, SkColor initial_color) {
  NOTIMPLEMENTED();
  return NULL;
}
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/views/base_shell_dialog_win.h"

#include <algorithm>

#include "base/threading/thread.h"

// Helpers to show certain types of Windows shell dialogs in a way that doesn't
// block the UI of the entire app.

class ShellDialogThread : public base::Thread {
 public:
  ShellDialogThread() : base::Thread("Chrome_ShellDialogThread") { }
  ~ShellDialogThread();

 protected:
   void Init();

   void CleanUp();

 private:
  DISALLOW_COPY_AND_ASSIGN(ShellDialogThread);
};

ShellDialogThread::~ShellDialogThread() {
  Stop();
}

void ShellDialogThread::Init() {
  // Initializes the COM library on the current thread.
  CoInitialize(NULL);
}

void ShellDialogThread::CleanUp() {
  // Closes the COM library on the current thread. CoInitialize must
  // be balanced by a corresponding call to CoUninitialize.
  CoUninitialize();
}

// static
BaseShellDialogImpl::Owners BaseShellDialogImpl::owners_;
int BaseShellDialogImpl::instance_count_ = 0;

BaseShellDialogImpl::BaseShellDialogImpl() {
  ++instance_count_;
}

BaseShellDialogImpl::~BaseShellDialogImpl() {
  // All runs should be complete by the time this is called!
  if (--instance_count_ == 0)
    DCHECK(owners_.empty());
}

BaseShellDialogImpl::RunState BaseShellDialogImpl::BeginRun(HWND owner) {
  // Cannot run a modal shell dialog if one is already running for this owner.
  DCHECK(!IsRunningDialogForOwner(owner));
  // The owner must be a top level window, otherwise we could end up with two
  // entries in our map for the same top level window.
  DCHECK(!owner || owner == GetAncestor(owner, GA_ROOT));
  RunState run_state;
  run_state.dialog_thread = CreateDialogThread();
  run_state.owner = owner;
  if (owner) {
    owners_.insert(owner);
    DisableOwner(owner);
  }
  return run_state;
}

void BaseShellDialogImpl::EndRun(RunState run_state) {
  if (run_state.owner) {
    DCHECK(IsRunningDialogForOwner(run_state.owner));
    EnableOwner(run_state.owner);
    DCHECK(owners_.find(run_state.owner) != owners_.end());
    owners_.erase(run_state.owner);
  }
  DCHECK(run_state.dialog_thread);
  delete run_state.dialog_thread;
}

bool BaseShellDialogImpl::IsRunningDialogForOwner(HWND owner) const {
  return (owner && owners_.find(owner) != owners_.end());
}

void BaseShellDialogImpl::DisableOwner(HWND owner) {
  if (IsWindow(owner))
    EnableWindow(owner, FALSE);
}

// static
base::Thread* BaseShellDialogImpl::CreateDialogThread() {
  base::Thread* thread = new ShellDialogThread;
  bool started = thread->Start();
  DCHECK(started);
  return thread;
}

void BaseShellDialogImpl::EnableOwner(HWND owner) {
  if (IsWindow(owner))
    EnableWindow(owner, TRUE);
}
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_UI_VIEWS_BASE_SHELL_DIALOG_WIN_H_
#define CHROME_BROWSER_UI_VIEWS_BASE_SHELL_DIALOG_WIN_H_
#pragma once

#include <shlobj.h>
#include <set>

#include "chrome/browser/ui/base_shell_dialog.h"

namespace base {
class Thread;
}

///////////////////////////////////////////////////////////////////////////////
// A base class for all shell dialog implementations that handles showing a
// shell dialog modally on its own thread.
class BaseShellDialogImpl {
 public:
  BaseShellDialogImpl();
  virtual ~BaseShellDialogImpl();

 protected:
  // Represents a run of a dialog.
  struct RunState {
    // Owning HWND, may be null.
    HWND owner;

    // Thread dialog is run on.
    base::Thread* dialog_thread;
  };

  // Called at the beginning of a modal dialog run. Disables the owner window
  // and tracks it. Returns the message loop of the thread that the dialog will
  // be run on.
  RunState BeginRun(HWND owner);

  // Cleans up after a dialog run. If the run_state has a valid HWND this makes
  // sure that the window is enabled. This is essential because BeginRun
  // aggressively guards against multiple modal dialogs per HWND. Must be called
  // on the UI thread after the result of the dialog has been determined.
  //
  // In addition this deletes the Thread in RunState.
  void EndRun(RunState run_state);

  // Returns true if a modal shell dialog is currently active for the specified
  // owner. Must be called on the UI thread.
  bool IsRunningDialogForOwner(HWND owner) const;

  // Disables the window |owner|. Can be run from either the ui or the dialog
  // thread. Can be called on either the UI or the dialog thread. This function
  // is called on the dialog thread after the modal Windows Common dialog
  // functions return because Windows automatically re-enables the owning
  // window when those functions return, but we don't actually want them to be
  // re-enabled until the response of the dialog propagates back to the UI
  // thread, so we disable the owner manually after the Common dialog function
  // returns.
  void DisableOwner(HWND owner);

 private:
  typedef std::set<HWND> Owners;

  // Creates a thread to run a shell dialog on. Each dialog requires its own
  // thread otherwise in some situations where a singleton owns a single
  // instance of this object we can have a situation where a modal dialog in
  // one window blocks the appearance of a modal dialog in another.
  static base::Thread* CreateDialogThread();

  // Enables the window |owner_|. Can only be run from the ui thread.
  void EnableOwner(HWND owner);

  // A list of windows that currently own active shell dialogs for this
  // instance. For example, if the DownloadManager owns an instance of this
  // object and there are two browser windows open both with Save As dialog
  // boxes active, this list will consist of the two browser windows' HWNDs.
  // The derived class must call EndRun once the dialog is done showing to
  // remove the owning HWND from this list.
  // This object is static since it is maintained for all instances of this
  // object - i.e. you can't have two file pickers open for the
  // same owner, even though they might be represented by different instances
  // of this object.
  // This set only contains non-null HWNDs. NULL hwnds are not added to this
  // list.
  static Owners owners_;
  static int instance_count_;

  DISALLOW_COPY_AND_ASSIGN(BaseShellDialogImpl);
};

#endif  // CHROME_BROWSER_UI_VIEWS_BASE_SHELL_DIALOG_WIN_H_
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/ui/views/color_chooser_dialog.h"

#include <commdlg.h>

#include "base/bind.h"
#include "base/message_loop.h"
#include "base/threading/thread.h"
#include "content/public/browser/browser_thread.h"
#include "skia/ext/skia_utils_win.h"

using content::BrowserThread;

// static
COLORREF ColorChooserDialog::g_custom_colors[16];

ColorChooserDialog::ExecuteOpenParams::ExecuteOpenParams(SkColor color,
                                                         RunState run_state,
                                                         HWND owner)
    : color(color),
      run_state(run_state),
      owner(owner) {
}

ColorChooserDialog::ColorChooserDialog(Listener* listener,
                                       SkColor initial_color,
                                       gfx::NativeWindow owning_window)
    : listener_(listener) {
  DCHECK(listener_);
  CopyCustomColors(g_custom_colors, custom_colors_);
  ExecuteOpenParams execute_params(initial_color, BeginRun(owning_window),
                                   owning_window);
  execute_params.run_state.dialog_thread->message_loop()->PostTask(FROM_HERE,
      base::Bind(&ColorChooserDialog::ExecuteOpen, this, execute_params));
}

ColorChooserDialog::~ColorChooserDialog() {
}

bool ColorChooserDialog::IsRunning(HWND owning_hwnd) const {
  return listener_ && IsRunningDialogForOwner(owning_hwnd);
}

void ColorChooserDialog::ListenerDestroyed() {
  // Our associated listener has gone away, so we shouldn't call back to it if
  // our worker thread returns after the listener is dead.
  listener_ = NULL;
}

void ColorChooserDialog::ExecuteOpen(const ExecuteOpenParams& params) {
  CHOOSECOLOR cc;
  cc.lStructSize = sizeof(CHOOSECOLOR);
  cc.hwndOwner = params.owner;
  cc.rgbResult = skia::SkColorToCOLORREF(params.color);
  cc.lpCustColors = custom_colors_;
  cc.Flags = CC_ANYCOLOR | CC_FULLOPEN | CC_RGBINIT;
  bool success = !!ChooseColor(&cc);
  DisableOwner(cc.hwndOwner);
  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
      base::Bind(&ColorChooserDialog::DidCloseDialog, this, success,
                 skia::COLORREFToSkColor(cc.rgbResult), params.run_state));
}

void ColorChooserDialog::DidCloseDialog(bool chose_color,
                                        SkColor color,
                                        RunState run_state) {
  if (!listener_)
    return;
  EndRun(run_state);
  CopyCustomColors(custom_colors_, g_custom_colors);
  if (chose_color)
    listener_->DidChooseColor(color);
  listener_->DidEnd();
}

void ColorChooserDialog::CopyCustomColors(COLORREF* src, COLORREF* dst) {
  memcpy(dst, src, sizeof(COLORREF) * arraysize(g_custom_colors));
}
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_UI_VIEWS_COLOR_CHOOSER_DIALOG_H_
#define CHROME_BROWSER_UI_VIEWS_COLOR_CHOOSER_DIALOG_H_
#pragma once

#include "base/memory/ref_counted.h"
#include "chrome/browser/ui/base_shell_dialog.h"
#include "chrome/browser/ui/views/color_chooser_dialog.h"
#include "chrome/browser/ui/views/base_shell_dialog_win.h"
#include "third_party/skia/include/core/SkColor.h"

class ColorChooserDialog
    : public base::RefCountedThreadSafe<ColorChooserDialog>,
      public BaseShellDialog,
      public BaseShellDialogImpl {
 public:
  // An interface implemented by a Listener object wishing to know about the
  // the results from the color chooser dialog.
  class Listener {
   public:
    virtual ~Listener() {}
    virtual void DidChooseColor(SkColor color) = 0;
    virtual void DidEnd() = 0;
  };

  ColorChooserDialog(Listener* listener,
                     SkColor initial_color,
                     gfx::NativeWindow owning_window);
  virtual ~ColorChooserDialog();

  // BaseShellDialog:
  virtual bool IsRunning(HWND owning_hwnd) const OVERRIDE;
  virtual void ListenerDestroyed() OVERRIDE;

 private:
  struct ExecuteOpenParams {
    ExecuteOpenParams(SkColor color, RunState run_state, HWND owner);
    SkColor color;
    RunState run_state;
    HWND owner;
  };

  // Called on the dialog thread to show the actual color chooser.  This is
  // shown modal to |params.owner|.  Once it's closed, calls back to
  // DidCloseDialog() on the UI thread.
  void ExecuteOpen(const ExecuteOpenParams& params);

  // Called on the UI thread when a color chooser is closed.  |chose_color| is
  // true if the user actually chose a color, in which case |color| is the
  // chosen color.  Calls back to the |listener_| (if applicable) to notify it
  // of the results, and copies the modified array of |custom_colors_| back to
  // |g_custom_colors| so future dialogs will see the changes.
  void DidCloseDialog(bool chose_color, SkColor color, RunState run_state);

  // Copies the array of colors in |src| to |dst|.
  void CopyCustomColors(COLORREF*, COLORREF*);

  // The user's custom colors.  Kept process-wide so that they can be persisted
  // from one dialog invocation to the next.
  static COLORREF g_custom_colors[16];

  // A copy of the custom colors for the current dialog to display and modify.
  // This allows us to safely access the colors even if multiple windows are
  // simultaneously showing color choosers (which would cause thread safety
  // problems if we gave them direct handles to |g_custom_colors|).
  COLORREF custom_colors_[16];

  // The listener to notify when the user closes the dialog.  This may be set to
  // NULL before the color chooser is closed, signalling that the listener no
  // longer cares about the outcome.
  Listener* listener_;

  DISALLOW_COPY_AND_ASSIGN(ColorChooserDialog);
};

#endif  // CHROME_BROWSER_UI_VIEWS_COLOR_CHOOSER_DIALOG_H_
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <windows.h>

#include "chrome/browser/platform_util.h"
#include "chrome/browser/ui/views/color_chooser_dialog.h"
#include "content/public/browser/render_view_host.h"
#include "content/public/browser/color_chooser.h"
#include "content/public/browser/render_widget_host_view.h"
#include "content/public/browser/web_contents.h"
#include "content/public/browser/web_contents_observer.h"

class ColorChooserWin : public content::ColorChooser,
                        public ColorChooserDialog::Listener,
                        public content::WebContentsObserver {
 public:
  ColorChooserWin(int identifier,
                  content::WebContents* tab,
                  SkColor initial_color);
  ~ColorChooserWin();

  // content::ColorChooser:
  virtual void End() OVERRIDE {}
  virtual void SetSelectedColor(SkColor color) OVERRIDE {}

  // ColorChooserDialog::Listener:
  virtual void DidChooseColor(SkColor color);
  virtual void DidEnd();

 private:
  scoped_refptr<ColorChooserDialog> color_chooser_dialog_;
};

content::ColorChooser* content::ColorChooser::Create(int identifier,
                                                     content::WebContents* tab,
                                                     SkColor initial_color) {
  return new ColorChooserWin(identifier, tab, initial_color);
}

ColorChooserWin::ColorChooserWin(int identifier,
                                 content::WebContents* tab,
                                 SkColor initial_color)
    : content::ColorChooser(identifier),
      content::WebContentsObserver(tab) {
  gfx::NativeWindow owning_window = platform_util::GetTopLevel(
      web_contents()->GetRenderViewHost()->GetView()->GetNativeView());
  color_chooser_dialog_ = new ColorChooserDialog(this,
                                                 initial_color,
                                                 owning_window);
}

ColorChooserWin::~ColorChooserWin() {
  // Always call End() before destroying.
  DCHECK(!color_chooser_dialog_);
}

void ColorChooserWin::DidChooseColor(SkColor color) {
  if (web_contents())
    web_contents()->DidChooseColorInColorChooser(identifier(), color);
}

void ColorChooserWin::DidEnd() {
  if (color_chooser_dialog_.get()) {
    color_chooser_dialog_->ListenerDestroyed();
    color_chooser_dialog_ = NULL;
  }
  if (web_contents())
    web_contents()->DidEndColorChooser(identifier());
}
#include "chrome/browser/ui/views/base_shell_dialog_win.h"
#include "content/public/browser/color_chooser.h"
      has_opener_(false),
      color_chooser_(NULL) {
  if (color_chooser_)
    color_chooser_->End();

    IPC_MESSAGE_HANDLER(ViewHostMsg_OpenColorChooser, OnOpenColorChooser)
    IPC_MESSAGE_HANDLER(ViewHostMsg_EndColorChooser, OnEndColorChooser)
    IPC_MESSAGE_HANDLER(ViewHostMsg_SetSelectedColorInColorChooser,
                        OnSetSelectedColorInColorChooser)
void TabContents::DidChooseColorInColorChooser(int color_chooser_id,
                                               const SkColor& color) {
  GetRenderViewHost()->Send(new ViewMsg_DidChooseColorResponse(
      GetRenderViewHost()->GetRoutingID(), color_chooser_id, color));
}

void TabContents::DidEndColorChooser(int color_chooser_id) {
  GetRenderViewHost()->Send(new ViewMsg_DidEndColorChooser(
      GetRenderViewHost()->GetRoutingID(), color_chooser_id));
  if (delegate_)
    delegate_->DidEndColorChooser();
  color_chooser_ = NULL;
}

void TabContents::OnOpenColorChooser(int color_chooser_id,
                                     const SkColor& color) {
  color_chooser_ = delegate_->OpenColorChooser(this, color_chooser_id, color);
}

void TabContents::OnEndColorChooser(int color_chooser_id) {
  if (color_chooser_ &&
      color_chooser_id == color_chooser_->identifier())
    color_chooser_->End();
}

void TabContents::OnSetSelectedColorInColorChooser(int color_chooser_id,
                                                   const SkColor& color) {
  if (color_chooser_ &&
      color_chooser_id == color_chooser_->identifier())
    color_chooser_->SetSelectedColor(color);
}

class ColorChooser;
  virtual void DidChooseColorInColorChooser(int color_chooser_id,
                                            const SkColor&) OVERRIDE;
  virtual void DidEndColorChooser(int color_chooser_id) OVERRIDE;
  void OnOpenColorChooser(int color_chooser_id,
                          const SkColor& color);
  void OnEndColorChooser(int color_chooser_id);
  void OnSetSelectedColorInColorChooser(int color_chooser_id,
                                        const SkColor& color);
  // Color chooser that was opened by this tab.
  content::ColorChooser* color_chooser_;

// Notifies the color chooser client that the user selected a color.
IPC_MESSAGE_ROUTED2(ViewMsg_DidChooseColorResponse, unsigned, SkColor)

// Notifies the color chooser client that the color chooser has ended.
IPC_MESSAGE_ROUTED1(ViewMsg_DidEndColorChooser, unsigned)

// Asks the browser to open the color chooser.
IPC_MESSAGE_ROUTED2(ViewHostMsg_OpenColorChooser,
                    int /* id */,
                    SkColor /* color */)

// Asks the browser to end the color chooser.
IPC_MESSAGE_ROUTED1(ViewHostMsg_EndColorChooser, int /* id */)

// Change the selected color in the color chooser.
IPC_MESSAGE_ROUTED2(ViewHostMsg_SetSelectedColorInColorChooser,
                    int /* id */,
                    SkColor /* color */)

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_PUBLIC_BROWSER_COLOR_CHOOSER_H_
#define CONTENT_PUBLIC_BROWSER_COLOR_CHOOSER_H_
#pragma once

#include "third_party/skia/include/core/SkColor.h"

namespace content {

class RenderViewHost;
class WebContents;

// Abstraction object for color choosers for each platform.
class ColorChooser {
 public:
  static ColorChooser* Create(int identifier,
                              WebContents* tab,
                              SkColor initial_color);
  ColorChooser(int identifier) : identifier_(identifier) {}
  virtual ~ColorChooser() {}

  // Returns a unique identifier for this chooser.  Identifiers are unique
  // across a renderer process.  This avoids race conditions in synchronizing
  // the browser and renderer processes.  For example, if a renderer closes one
  // chooser and opens another, and simultaneously the user picks a color in the
  // first chooser, the IDs can be used to drop the "chose a color" message
  // rather than erroneously tell the renderer that the user picked a color in
  // the second chooser.
  int identifier() const { return identifier_; }

  // Ends connection with color chooser. Closes color chooser depending on the
  // platform.
  virtual void End() = 0;

  // Sets the selected color.
  virtual void SetSelectedColor(SkColor color) = 0;

private:
  int identifier_;
};

}

#endif  // CONTENT_PUBLIC_BROWSER_COLOR_CHOOSER_H_
#include "third_party/skia/include/core/SkColor.h"
  // Called when the user has selected a color in the color chooser.
  virtual void DidChooseColorInColorChooser(int color_chooser_id,
                                            const SkColor&) = 0;

  // Called when the color chooser has ended.
  virtual void DidEndColorChooser(int color_chooser_id) = 0;

content::ColorChooser* WebContentsDelegate::OpenColorChooser(WebContents* tab,
    int color_chooser_id,
    const SkColor& color) {
  return NULL;
}

#include "third_party/skia/include/core/SkColor.h"
class ColorChooser;
  // Called when color chooser should open. Returns the opened color chooser.
  virtual content::ColorChooser* OpenColorChooser(WebContents* tab,
                                                  int color_chooser_id,
                                                  const SkColor& color);

  virtual void DidEndColorChooser() {}

#include "content/renderer/renderer_webcolorchooser_impl.h"
WebKit::WebColorChooser* RenderViewImpl::createColorChooser(
    WebKit::WebColorChooserClient* client,
    const WebKit::WebColor& initial_color) {
  RendererWebColorChooserImpl* color_chooser =
      new RendererWebColorChooserImpl(this, client);
  color_chooser->Open(static_cast<SkColor>(initial_color));
  return color_chooser;
}

class RendererWebColorChooserImpl;
  virtual WebKit::WebColorChooser* createColorChooser(
      WebKit::WebColorChooserClient*, const WebKit::WebColor& initial_color);
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/renderer/renderer_webcolorchooser_impl.h"

#include "content/common/view_messages.h"
#include "content/renderer/render_view_impl.h"

static int GenerateColorChooserIdentifier() {
  static int next = 0;
  return ++next;
}

RendererWebColorChooserImpl::RendererWebColorChooserImpl(
    RenderViewImpl* render_view,
    WebKit::WebColorChooserClient* client)
    : content::RenderViewObserver(render_view),
      identifier_(GenerateColorChooserIdentifier()),
      client_(client) {
}

RendererWebColorChooserImpl::~RendererWebColorChooserImpl() {
}

bool RendererWebColorChooserImpl::OnMessageReceived(
    const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(RendererWebColorChooserImpl, message)
    IPC_MESSAGE_HANDLER(ViewMsg_DidChooseColorResponse,
                        OnDidChooseColorResponse)
    IPC_MESSAGE_HANDLER(ViewMsg_DidEndColorChooser,
                        OnDidEndColorChooser)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}

void RendererWebColorChooserImpl::FrameWillClose(WebKit::WebFrame* frame) {
  endChooser();
  client_->didEndChooser();
}

void RendererWebColorChooserImpl::setSelectedColor(WebKit::WebColor color) {
  Send(new ViewHostMsg_SetSelectedColorInColorChooser(routing_id(), identifier_,
      static_cast<SkColor>(color)));
}

void RendererWebColorChooserImpl::endChooser() {
  Send(new ViewHostMsg_EndColorChooser(routing_id(), identifier_));
}

void RendererWebColorChooserImpl::Open(SkColor initial_color) {
  Send(new ViewHostMsg_OpenColorChooser(routing_id(), identifier_,
                                        initial_color));
}

void RendererWebColorChooserImpl::OnDidChooseColorResponse(
    int color_chooser_id,
    const SkColor& color) {
  DCHECK(identifier_ == color_chooser_id);

  client_->didChooseColor(static_cast<WebKit::WebColor>(color));
}

void RendererWebColorChooserImpl::OnDidEndColorChooser(int color_chooser_id) {
  if (identifier_ != color_chooser_id)
    return;
  client_->didEndChooser();
}
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_RENDERER_RENDERER_WEBCOLORCHOOSER_IMPL_H_
#define CONTENT_RENDERER_RENDERER_WEBCOLORCHOOSER_IMPL_H_
#pragma once

#include "base/memory/scoped_ptr.h"
#include "content/public/renderer/render_view_observer.h"
#include "third_party/WebKit/Source/WebKit/chromium/public/WebColorChooser.h"
#include "third_party/WebKit/Source/WebKit/chromium/public/WebColorChooserClient.h"
#include "third_party/skia/include/core/SkColor.h"

namespace WebKit {
class WebFrame;
}

class RenderViewImpl;

class RendererWebColorChooserImpl : public WebKit::WebColorChooser,
                                    public content::RenderViewObserver {
 public:
  explicit RendererWebColorChooserImpl(RenderViewImpl* sender,
                                       WebKit::WebColorChooserClient*);
  virtual ~RendererWebColorChooserImpl();

  virtual void setSelectedColor(const WebKit::WebColor);
  virtual void endChooser();

  void Open(SkColor initial_color);

  WebKit::WebColorChooserClient* client() { return client_; }

 private:
  // RenderViewObserver implementation.
  virtual bool OnMessageReceived(const IPC::Message& message) OVERRIDE;
  virtual void FrameWillClose(WebKit::WebFrame* frame) OVERRIDE;

  void OnDidChooseColorResponse(int color_chooser_id,
                                const SkColor& color);
  void OnDidEndColorChooser(int color_chooser_id);

  int identifier_;
  WebKit::WebColorChooserClient* client_;

  DISALLOW_COPY_AND_ASSIGN(RendererWebColorChooserImpl);
};

#endif  // CONTENT_RENDERER_RENDERER_WEBCOLORCHOOSER_IMPL_H_
// Converts NSColor to ARGB. Returns raw rgb values and does no colorspace
// conversion. Only valid for colors in calibrated and device color spaces.
SK_API SkColor NSDeviceColorToSkColor(NSColor* color);

SK_API NSColor* SkColorToDeviceNSColor(SkColor color);
using WebKit::WebFindOptions;
bool RenderView::canHandleRequest(
    WebFrame* frame, const WebURLRequest& request) {
  // We allow WebKit to think that everything can be handled even though
  // browser-side we limit what we load.
WebURLError RenderView::cannotHandleRequestError(
    WebFrame* frame, const WebURLRequest& request) {
  NOTREACHED();  // Since we said we can handle all requests.
  return WebURLError();
}

WebURLError RenderView::cancelledError(
    WebFrame* frame, const WebURLRequest& request) {
  WebURLError error;
  error.domain = WebString::fromUTF8(net::kErrorDomain);
  error.reason = net::ERR_ABORTED;
  error.unreachableURL = request.url();
  return error;
    WebFrame*, const WebURLError&) {
  NOTREACHED();  // Since we said we can handle all requests.
void RenderView::didDisplayInsecureContent(WebFrame* frame) {
void RenderView::OnFind(int request_id, const string16& search_text,
                        const WebFindOptions& options) {
  WebVector<WebString> ws_file_names(file_names.size());
  virtual bool canHandleRequest(
      WebKit::WebFrame* frame, const WebKit::WebURLRequest& request);
  virtual WebKit::WebURLError cannotHandleRequestError(
      WebKit::WebFrame* frame, const WebKit::WebURLRequest& request);
  virtual WebKit::WebURLError cancelledError(
      WebKit::WebFrame* frame, const WebKit::WebURLRequest& request);
        virtual bool canHandleRequest(
            WebFrame*, const WebURLRequest& request) = 0;
        // Returns an error corresponding to canHandledRequest() returning false.
        virtual WebURLError cannotHandleRequestError(
            WebFrame*, const WebURLRequest& request) = 0;

        // Returns an error corresponding to a user cancellation event.
        virtual WebURLError cancelledError(
            WebFrame*, const WebURLRequest& request) = 0;

} // WebKit
  virtual bool canHandleRequest(
      WebKit::WebFrame*, const WebKit::WebURLRequest&) { return true; }
  virtual WebKit::WebURLError cannotHandleRequestError(
      WebKit::WebFrame*, const WebKit::WebURLRequest& request) {
    return WebKit::WebURLError();
  }
  virtual WebKit::WebURLError cancelledError(
      WebKit::WebFrame*, const WebKit::WebURLRequest& request) {
    return WebKit::WebURLError();
  }
  if (!webframe_->client())
    return ResourceError();

  return webkit_glue::WebURLErrorToResourceError(
      webframe_->client()->cancelledError(
          webframe_, WrappedResourceRequest(request)));
  if (!webframe_->client())
    return ResourceError();

      webframe_->client()->cannotHandleRequestError(
          webframe_, WrappedResourceRequest(request)));
  ResourceError cancelled_error = cancelledError(ResourceRequest());
  return error.errorCode() != cancelled_error.errorCode() ||
         error.domain() != cancelled_error.domain();
  return webframe_->client()->canHandleRequest(
      webframe_, WrappedResourceRequest(request));
bool TestWebViewDelegate::canHandleRequest(
    WebFrame* frame, const WebURLRequest& request) {
WebURLError TestWebViewDelegate::cannotHandleRequestError(
    WebFrame* frame, const WebURLRequest& request) {
WebURLError TestWebViewDelegate::cancelledError(
    WebFrame* frame, const WebURLRequest& request) {
  WebURLError error;
  error.domain = WebString::fromUTF8(net::kErrorDomain);
  error.reason = net::ERR_ABORTED;
  error.unreachableURL = request.url();
  return error;
}

  virtual bool canHandleRequest(
      WebKit::WebFrame*, const WebKit::WebURLRequest&);
  virtual WebKit::WebURLError cannotHandleRequestError(
      WebKit::WebFrame*, const WebKit::WebURLRequest& request);
  virtual WebKit::WebURLError cancelledError(
      WebKit::WebFrame*, const WebKit::WebURLRequest& request);
    case GL_BOOL_VEC3:
    case GL_BOOL_VEC4:
      return sizeof(GLint) * 4;            // NOLINT
  // Checks if the current program exists and is valid. If not generates the
  // appropriate GL error.  Returns true if the current program is in a usable
  // state.
  bool CheckCurrentProgram(const char* function_name);

  // Checks if the current program exists and is valid and that location is not
  // -1. If the current program is not valid generates the appropriate GL
  // error. Returns true if the current program is in a usable state and
  // location is not -1.
  bool CheckCurrentProgramForUniform(GLint location, const char* function_name);

  // Gets the type of a uniform for a location in the current program. Sets GL
  // errors if the current program is not valid. Returns true if the current
  // program is valid and the location exists.
  bool GetUniformTypeByLocation(
      GLint location, const char* function_name, GLenum* type);

  void DoUniform1iv(GLint location, GLsizei count, const GLint* value);

  // Wrappers for glUniformfv because some drivers don't correctly accept
  // bool uniforms.
  void DoUniform1fv(GLint location, GLsizei count, const GLfloat* value);
  void DoUniform2fv(GLint location, GLsizei count, const GLfloat* value);
  void DoUniform3fv(GLint location, GLsizei count, const GLfloat* value);
  void DoUniform4fv(GLint location, GLsizei count, const GLfloat* value);
      error::Error* error, GLuint* service_id, void** result,
      GLenum* result_type);
bool GLES2DecoderImpl::CheckCurrentProgram(const char* function_name) {
      // The program does not exist.
      SetGLError(GL_INVALID_OPERATION,
                 (std::string(function_name) + ": no program in use").c_str());
      return false;
  }
  if (!current_program_->IsValid()) {
    SetGLError(GL_INVALID_OPERATION,
               (std::string(function_name) + ": program not linked").c_str());
    return false;
  }
  return true;
}

bool GLES2DecoderImpl::CheckCurrentProgramForUniform(
    GLint location, const char* function_name) {
  if (!CheckCurrentProgram(function_name)) {
    return false;
  }
  return location != -1;
}

bool GLES2DecoderImpl::GetUniformTypeByLocation(
    GLint location, const char* function_name, GLenum* type) {
  if (!CheckCurrentProgramForUniform(location, function_name)) {
    return false;
  }
  if (!current_program_->GetUniformTypeByLocation(location, type)) {
    SetGLError(GL_INVALID_OPERATION,
               (std::string(function_name) + ": program not linked").c_str());
    return false;
  }
  return true;
}


void GLES2DecoderImpl::DoUniform1i(GLint location, GLint v0) {
  if (!CheckCurrentProgramForUniform(location, "glUniform1i")) {
  if (!CheckCurrentProgramForUniform(location, "glUniform1iv")) {
void GLES2DecoderImpl::DoUniform1fv(
    GLint location, GLsizei count, const GLfloat* value) {
  GLenum type;
  if (!GetUniformTypeByLocation(location, "glUniform1fv", &type)) {
    return;
  }
  if (type == GL_BOOL) {
    scoped_array<GLint> temp(new GLint[count]);
    for (GLsizei ii = 0; ii < count; ++ii) {
      temp[ii] = static_cast<GLint>(value[ii]);
    }
    DoUniform1iv(location, count, temp.get());
  } else {
    glUniform1fv(location, count, value);
  }
}

void GLES2DecoderImpl::DoUniform2fv(
    GLint location, GLsizei count, const GLfloat* value) {
  GLenum type;
  if (!GetUniformTypeByLocation(location, "glUniform2fv", &type)) {
    return;
  }
  if (type == GL_BOOL_VEC2) {
    GLsizei num_values = count * 2;
    scoped_array<GLint> temp(new GLint[num_values]);
    for (GLsizei ii = 0; ii < num_values; ++ii) {
      temp[ii] = static_cast<GLint>(value[ii]);
    }
    glUniform2iv(location, count, temp.get());
  } else {
    glUniform2fv(location, count, value);
  }
}

void GLES2DecoderImpl::DoUniform3fv(
    GLint location, GLsizei count, const GLfloat* value) {
  GLenum type;
  if (!GetUniformTypeByLocation(location, "glUniform3fv", &type)) {
    return;
  }
  if (type == GL_BOOL_VEC3) {
    GLsizei num_values = count * 3;
    scoped_array<GLint> temp(new GLint[num_values]);
    for (GLsizei ii = 0; ii < num_values; ++ii) {
      temp[ii] = static_cast<GLint>(value[ii]);
    }
    glUniform3iv(location, count, temp.get());
  } else {
    glUniform3fv(location, count, value);
  }
}

void GLES2DecoderImpl::DoUniform4fv(
    GLint location, GLsizei count, const GLfloat* value) {
  GLenum type;
  if (!GetUniformTypeByLocation(location, "glUniform4fv", &type)) {
    return;
  }
  if (type == GL_BOOL_VEC4) {
    GLsizei num_values = count * 4;
    scoped_array<GLint> temp(new GLint[num_values]);
    for (GLsizei ii = 0; ii < num_values; ++ii) {
      temp[ii] = static_cast<GLint>(value[ii]);
    }
    glUniform4iv(location, count, temp.get());
  } else {
    glUniform4fv(location, count, value);
  }
}

  if (!current_program_ || current_program_->IsDeleted() ||
      !current_program_->IsValid()) {
  shader_src = info->source().c_str();
    error::Error* error, GLuint* service_id, void** result_pointer,
    GLenum* result_type) {
  DCHECK(error);
  DCHECK(service_id);
  DCHECK(result_pointer);
  DCHECK(result_type);
  *result_type = type;
  GLenum result_type;
      &error, &service_id, &result, &result_type)) {
  Result* result;
  GLenum result_type;
      &error, &service_id, reinterpret_cast<void**>(&result), &result_type)) {
    if (result_type == GL_BOOL || result_type == GL_BOOL_VEC2 ||
        result_type == GL_BOOL_VEC3 || result_type == GL_BOOL_VEC4) {
      GLsizei num_values = result->GetNumResults();
      scoped_array<GLint> temp(new GLint[num_values]);
      glGetUniformiv(service_id, location, temp.get());
      GLfloat* dst = result->GetData();
      for (GLsizei ii = 0; ii < num_values; ++ii) {
        dst[ii] = (temp[ii] != 0);
      }
    } else {
      glGetUniformfv(service_id, location, result->GetData());
    }
  GLfloat temp[1] = { x, };
  DoUniform1fv(location, 1, &temp[0]);
  DoUniform1fv(location, count, v);
  DoUniform1fv(location, count, v);
  GLfloat temp[2] = { x, y, };
  DoUniform2fv(location, 1, &temp[0]);
  DoUniform2fv(location, count, v);
  DoUniform2fv(location, count, v);
  GLfloat temp[3] = { x, y, z, };
  DoUniform3fv(location, 1, &temp[0]);
  DoUniform3fv(location, count, v);
  DoUniform3fv(location, count, v);
  GLfloat temp[4] = { x, y, z, w, };
  DoUniform4fv(location, 1, &temp[0]);
  DoUniform4fv(location, count, v);
  DoUniform4fv(location, count, v);
template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform1f, 0>() {
  SetupShaderForUniform();
};

template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform1fv, 0>() {
  SetupShaderForUniform();
};

template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform1fvImmediate, 0>() {
  SetupShaderForUniform();
};

template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform2f, 0>() {
  SetupShaderForUniform();
};

template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform2fv, 0>() {
  SetupShaderForUniform();
};

template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform2fvImmediate, 0>() {
  SetupShaderForUniform();
};

template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform3f, 0>() {
  SetupShaderForUniform();
};

template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform3fv, 0>() {
  SetupShaderForUniform();
};

template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform3fvImmediate, 0>() {
  SetupShaderForUniform();
};

template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform4f, 0>() {
  SetupShaderForUniform();
};

template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform4fv, 0>() {
  SetupShaderForUniform();
};

template <>
void GLES2DecoderTestBase::SpecializedSetup<Uniform4fvImmediate, 0>() {
  SetupShaderForUniform();
};

  EXPECT_CALL(*gl_, Uniform1fv(1, 1, _));
  EXPECT_CALL(*gl_, Uniform2fv(1, 1, _));
  EXPECT_CALL(*gl_, Uniform3fv(1, 1, _));
  EXPECT_CALL(*gl_, Uniform4fv(1, 1, _));
void GLES2DecoderTestBase::SetupShaderForUniform() {
  static AttribInfo attribs[] = {
    { "foo", 1, GL_FLOAT, 1, },
  };
  static UniformInfo uniforms[] = {
    { "bar", 1, GL_INT, 1, },
  };
  SetupShader(attribs, arraysize(attribs), uniforms, arraysize(uniforms),
              client_program_id_, kServiceProgramId);

  EXPECT_CALL(*gl_, UseProgram(kServiceProgramId))
      .Times(1)
      .RetiresOnSaturation();
  UseProgram cmd;
  cmd.Init(client_program_id_);
  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
}

void GLES2DecoderTestBase::SetupShader(
    GLES2DecoderTestBase::AttribInfo* attribs, size_t num_attribs,
    GLES2DecoderTestBase::UniformInfo* uniforms, size_t num_uniforms,
    size_t max_attrib_len = 0;
    for (size_t ii = 0; ii < num_attribs; ++ii) {
      size_t len = strlen(attribs[ii].name) + 1;
      max_attrib_len = std::max(max_attrib_len, len);
    }
        .WillOnce(SetArgumentPointee<2>(max_attrib_len))
          GetActiveAttrib(service_id, ii, max_attrib_len, _, _, _, _))
    size_t max_uniform_len = 0;
    for (size_t ii = 0; ii < num_uniforms; ++ii) {
      size_t len = strlen(uniforms[ii].name) + 1;
      max_uniform_len = std::max(max_uniform_len, len);
    }
        .WillOnce(SetArgumentPointee<2>(max_uniform_len))
          GetActiveUniform(service_id, ii, max_uniform_len, _, _, _, _))
  struct AttribInfo {
    const char* name;
    GLint size;
    GLenum type;
    GLint location;
  };

  struct UniformInfo {
    const char* name;
    GLint size;
    GLenum type;
    GLint location;
  };

  void SetupShader(AttribInfo* attribs, size_t num_attribs,
                   UniformInfo* uniforms, size_t num_uniforms,
                   GLuint client_id, GLuint service_id);

  // Setups up a shader for testing glUniform.
  void SetupShaderForUniform();

#include "chrome/browser/extensions/sandboxed_extension_unpacker.h"
  SandboxedExtensionUnpacker::ExtensionHeader header;
  memcpy(&header.magic, SandboxedExtensionUnpacker::kExtensionHeaderMagic,
         SandboxedExtensionUnpacker::kExtensionHeaderMagicSize);
  header.version = SandboxedExtensionUnpacker::kCurrentVersion;
  fwrite(&header, sizeof(SandboxedExtensionUnpacker::ExtensionHeader), 1,
// This class hosts a SandboxedExtensionUnpacker task and routes the results
// back to ExtensionsService. The unpack process is started immediately on
// construction of this object.
    : public SandboxedExtensionUnpackerClient {
      expected_id_(expected_id), silent_(silent), from_gallery_(from_gallery) {
    unpacker_ = new SandboxedExtensionUnpacker(extension_path,
            backend->resource_dispatcher_host_, this);
    unpacker_->Start();
  // SandboxedExtensionUnpackerClient
  virtual void OnUnpackSuccess(const FilePath& temp_dir,
                               const FilePath& extension_dir,
                               Extension* extension) {
    backend_->OnExtensionUnpacked(extension_path_, extension_dir, extension,
                                  expected_id_, silent_, from_gallery_);
    file_util::Delete(temp_dir, true);
    delete this;
  virtual void OnUnpackFailure(const std::string& error_message) {
    delete this;
  scoped_refptr<SandboxedExtensionUnpacker> unpacker_;
  // NOTE: We don't need to keep a reference to this, it deletes itself when it
  // is done.
  new UnpackerClient(this, extension_path, expected_id, silent, from_gallery);
    const FilePath& crx_path, const FilePath& unpacked_path,
    Extension* extension, const std::string expected_id, bool silent,
    bool from_gallery) {
  // Take ownership of the extension object.
  scoped_ptr<Extension> extension_deleter(extension);
  LookupExternalExtension(extension->id(), NULL, &location);
  extension->set_location(location);
  if (extension->IsTheme())
    ReportExtensionInstallError(crx_path, "Extensions are not enabled.");
  if (extension->IsTheme())
      ReportExtensionInstallError(crx_path,
  if (!expected_id.empty() && expected_id != extension->id()) {
    error_msg += extension->id();
    ReportExtensionInstallError(crx_path, error_msg);
  FilePath dest_dir = install_directory_.AppendASCII(extension->id());
  std::string version = extension->VersionString();
      CompareToInstalledVersion(extension->id(), version, &current_version);
    ReportExtensionInstallError(crx_path,
    if (NeedsReinstall(extension->id(), current_version)) {
      ReportExtensionOverinstallAttempted(extension->id(), crx_path);
  extension->set_path(version_dir);
  if (!InstallDirSafely(unpacked_path, version_dir))
      frontend_, &ExtensionsService::OnExtensionInstalled, crx_path,
      extension, install_type));
  ExtensionList* extensions = new ExtensionList;
  // Hand off ownership of the extension to the frontend.
  extensions->push_back(extension_deleter.release());
  ReportExtensionsLoaded(extensions);
#include "chrome/browser/extensions/sandboxed_extension_unpacker.h"
  // Finish installing the extension in |crx_path| after it has been unpacked to
  // |unpacked_path|.  If |expected_id| is not empty, it's verified against the
  // extension's manifest before installation. If |silent| is true, there will
  // be no install confirmation dialog. |from_gallery| indicates whether the
  // crx was installed from our gallery, which results in different UI.
  //
  // Note: We take ownership of |extension|.
      const FilePath& crx_path,
      const FilePath& unpacked_path,
      Extension* extension,
      const std::string expected_id,
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/extensions/sandboxed_extension_unpacker.h"

#include <set>

#include "base/crypto/signature_verifier.h"
#include "base/file_util.h"
#include "base/gfx/png_encoder.h"
#include "base/message_loop.h"
#include "base/scoped_handle.h"
#include "base/task.h"
#include "chrome/browser/chrome_thread.h"
#include "chrome/browser/extensions/extensions_service.h"
#include "chrome/browser/renderer_host/resource_dispatcher_host.h"
#include "chrome/common/extensions/extension.h"
#include "chrome/common/extensions/extension_constants.h"
#include "chrome/common/extensions/extension_unpacker.h"
#include "chrome/common/json_value_serializer.h"
#include "net/base/base64.h"

#include "third_party/skia/include/core/SkBitmap.h"

const char SandboxedExtensionUnpacker::kExtensionHeaderMagic[] = "Cr24";

SandboxedExtensionUnpacker::SandboxedExtensionUnpacker(
    const FilePath& crx_path, ResourceDispatcherHost* rdh,
    SandboxedExtensionUnpackerClient* client)
      : crx_path_(crx_path), client_loop_(MessageLoop::current()), rdh_(rdh),
        client_(client), got_response_(false) {

  AddRef();
}

void SandboxedExtensionUnpacker::Start() {
  // Create a temporary directory to work in.
  if (!temp_dir_.CreateUniqueTempDir()) {
    ReportFailure("Could not create temporary directory.");
    return;
  }

  // Initialize the path that will eventually contain the unpacked extension.
  extension_root_ = temp_dir_.path().AppendASCII("TEMP_INSTALL");

  // Extract the public key and validate the package.
  if (!ValidateSignature())
    return;  // ValidateSignature() already reported the error.

  // Copy the crx file into our working directory.
  FilePath temp_crx_path = temp_dir_.path().Append(crx_path_.BaseName());
  if (!file_util::CopyFile(crx_path_, temp_crx_path)) {
    ReportFailure("Failed to copy extension file to temporary directory.");
    return;
  }

  // If we are supposed to use a subprocess, copy the crx to the temp directory
  // and kick off the subprocess.
  if (rdh_) {
    ChromeThread::GetMessageLoop(ChromeThread::IO)->PostTask(FROM_HERE,
        NewRunnableMethod(this,
            &SandboxedExtensionUnpacker::StartProcessOnIOThread,
            temp_crx_path));
  } else {
    // Otherwise, unpack the extension in this process.
    ExtensionUnpacker unpacker(temp_crx_path);
    if (unpacker.Run() && unpacker.DumpImagesToFile())
      OnUnpackExtensionSucceeded(*unpacker.parsed_manifest());
    else
      OnUnpackExtensionFailed(unpacker.error_message());
  }
}

void SandboxedExtensionUnpacker::StartProcessOnIOThread(
    const FilePath& temp_crx_path) {
  UtilityProcessHost* host = new UtilityProcessHost(rdh_, this,
                                                    MessageLoop::current());
  host->StartExtensionUnpacker(temp_crx_path);
}

void SandboxedExtensionUnpacker::OnUnpackExtensionSucceeded(
    const DictionaryValue& manifest) {
  got_response_ = true;

  ExtensionUnpacker::DecodedImages images;
  if (!ExtensionUnpacker::ReadImagesFromFile(temp_dir_.path(), &images)) {
    ReportFailure("Couldn't read image data from disk.");
    return;
  }

  // Add the public key extracted earlier to the parsed manifest and overwrite
  // the original manifest. We do this to ensure the manifest doesn't contain an
  // exploitable bug that could be used to compromise the browser.
  scoped_ptr<DictionaryValue> final_manifest(
      static_cast<DictionaryValue*>(manifest.DeepCopy()));
  final_manifest->SetString(extension_manifest_keys::kPublicKey, public_key_);

  std::string manifest_json;
  JSONStringValueSerializer serializer(&manifest_json);
  serializer.set_pretty_print(true);
  if (!serializer.Serialize(*final_manifest)) {
    ReportFailure("Error serializing manifest.json.");
    return;
  }

  FilePath manifest_path =
      extension_root_.AppendASCII(Extension::kManifestFilename);
  if (!file_util::WriteFile(manifest_path,
                            manifest_json.data(), manifest_json.size())) {
    ReportFailure("Error saving manifest.json.");
    return;
  }

  // Delete any images that may be used by the browser.  We're going to write
  // out our own versions of the parsed images, and we want to make sure the
  // originals are gone for good.
  extension_.reset(new Extension);
  std::string manifest_error;
  if (!extension_->InitFromValue(*final_manifest, true,  // require id
                                 &manifest_error)) {
    ReportFailure(std::string("Manifest is invalid: ") +
                              manifest_error);
    return;
  }

  std::set<FilePath> image_paths = extension_->GetBrowserImages();
  if (image_paths.size() != images.size()) {
    ReportFailure("Decoded images don't match what's in the manifest.");
    return;
  }

  for (std::set<FilePath>::iterator it = image_paths.begin();
       it != image_paths.end(); ++it) {
    if (!file_util::Delete(extension_root_.Append(*it), false)) {
      ReportFailure("Error removing old image file.");
      return;
    }
  }

  // Write our parsed images back to disk as well.
  for (size_t i = 0; i < images.size(); ++i) {
    const SkBitmap& image = images[i].a;
    FilePath path = extension_root_.Append(images[i].b);

    std::vector<unsigned char> image_data;
    // TODO(mpcomplete): It's lame that we're encoding all images as PNG, even
    // though they may originally be .jpg, etc.  Figure something out.
    // http://code.google.com/p/chromium/issues/detail?id=12459
    if (!PNGEncoder::EncodeBGRASkBitmap(image, false, &image_data)) {
      ReportFailure("Error re-encoding theme image.");
      return;
    }

    // Note: we're overwriting existing files that the utility process wrote,
    // so we can be sure the directory exists.
    const char* image_data_ptr = reinterpret_cast<const char*>(&image_data[0]);
    if (!file_util::WriteFile(path, image_data_ptr, image_data.size())) {
      ReportFailure("Error saving theme image.");
      return;
    }
  }

  ReportSuccess();
}

void SandboxedExtensionUnpacker::OnUnpackExtensionFailed(
    const std::string& error) {
  got_response_ = true;
  ReportFailure(error);
}

void SandboxedExtensionUnpacker::OnProcessCrashed() {
  // Don't report crashes if they happen after we got a response.
  if (got_response_)
    return;

  ReportFailure("Utility process crashed while trying to install.");
}

bool SandboxedExtensionUnpacker::ValidateSignature() {
  ScopedStdioHandle file(file_util::OpenFile(crx_path_, "rb"));
  if (!file.get()) {
    ReportFailure("Could not open crx file for reading");
    return false;
  }

  // Read and verify the header.
  ExtensionHeader header;
  size_t len;

  // TODO(erikkay): Yuck.  I'm not a big fan of this kind of code, but it
  // appears that we don't have any endian/alignment aware serialization
  // code in the code base.  So for now, this assumes that we're running
  // on a little endian machine with 4 byte alignment.
  len = fread(&header, 1, sizeof(ExtensionHeader),
      file.get());
  if (len < sizeof(ExtensionHeader)) {
    ReportFailure("Invalid crx header");
    return false;
  }
  if (strncmp(kExtensionHeaderMagic, header.magic,
      sizeof(header.magic))) {
    ReportFailure("Bad magic number");
    return false;
  }
  if (header.version != kCurrentVersion) {
    ReportFailure("Bad version number");
    return false;
  }
  if (header.key_size > kMaxPublicKeySize ||
      header.signature_size > kMaxSignatureSize) {
    ReportFailure("Excessively large key or signature");
    return false;
  }

  std::vector<uint8> key;
  key.resize(header.key_size);
  len = fread(&key.front(), sizeof(uint8), header.key_size, file.get());
  if (len < header.key_size) {
    ReportFailure("Invalid public key");
    return false;
  }

  std::vector<uint8> signature;
  signature.resize(header.signature_size);
  len = fread(&signature.front(), sizeof(uint8), header.signature_size,
      file.get());
  if (len < header.signature_size) {
    ReportFailure("Invalid signature");
    return false;
  }

  // Note: this structure is an ASN.1 which encodes the algorithm used
  // with its parameters. This is defined in PKCS #1 v2.1 (RFC 3447).
  // It is encoding: { OID sha1WithRSAEncryption      PARAMETERS NULL }
  // TODO(aa): This needs to be factored away someplace common.
  const uint8 signature_algorithm[15] = {
    0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
    0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00
  };

  base::SignatureVerifier verifier;
  if (!verifier.VerifyInit(signature_algorithm,
                           sizeof(signature_algorithm),
                           &signature.front(),
                           signature.size(),
                           &key.front(),
                           key.size())) {
    ReportFailure("Signature verification initialization failed. "
                  "This is most likely caused by a public key in "
                  "the wrong format (should encode algorithm).");
    return false;
  }

  unsigned char buf[1 << 12];
  while ((len = fread(buf, 1, sizeof(buf), file.get())) > 0)
    verifier.VerifyUpdate(buf, len);

  if (!verifier.VerifyFinal()) {
    ReportFailure("Signature verification failed");
    return false;
  }

  net::Base64Encode(std::string(reinterpret_cast<char*>(&key.front()),
      key.size()), &public_key_);
  return true;
}

void SandboxedExtensionUnpacker::ReportFailure(const std::string& error) {
  client_->OnUnpackFailure(error);
  Release();
}

void SandboxedExtensionUnpacker::ReportSuccess() {
  // Client takes ownership of temporary directory and extension.
  client_->OnUnpackSuccess(temp_dir_.Take(), extension_root_,
                           extension_.release());
  Release();
}
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_EXTENSIONS_SANDBOXED_EXTENSION_UNPACKER_H_
#define CHROME_BROWSER_EXTENSIONS_SANDBOXED_EXTENSION_UNPACKER_H_

#include <string>

#include "base/file_path.h"
#include "base/ref_counted.h"
#include "base/scoped_temp_dir.h"
#include "base/values.h"
#include "chrome/browser/utility_process_host.h"

class Extension;
class MessageLoop;
class ResourceDispatcherHost;

class SandboxedExtensionUnpackerClient {
 public:
  // temp_dir - A temporary directoy containing the results of the extension
  // unpacking. The client is responsible for deleting this directory.
  //
  // extension_root - The path to the extension root inside of temp_dir.
  //
  // extension - The extension that was unpacked. The client is responsible
  // for deleting this memory.
  virtual void OnUnpackSuccess(const FilePath& temp_dir,
                               const FilePath& extension_root,
                               Extension* extension) = 0;
  virtual void OnUnpackFailure(const std::string& error) = 0;
};

// SandboxedExtensionUnpacker unpacks extensions from the CRX format into a
// directory. This is done in a sandboxed subprocess to protect the browser
// process from parsing complex formats like JPEG or JSON from untrusted
// sources.
//
// Unpacking an extension using this class makes minor changes to its source,
// such as transcoding all images to PNG and rewriting the manifest JSON. As
// such, it should not be used when the output is not intended to be given back
// to the author.
//
// NOTE: This class should only be used on the file thread.


class SandboxedExtensionUnpacker : public UtilityProcessHost::Client {
 public:
  // The size of the magic character sequence at the beginning of each crx
  // file, in bytes. This should be a multiple of 4.
  static const size_t kExtensionHeaderMagicSize = 4;

  // This header is the first data at the beginning of an extension. Its
  // contents are purposely 32-bit aligned so that it can just be slurped into
  // a struct without manual parsing.
  struct ExtensionHeader {
    char magic[kExtensionHeaderMagicSize];
    uint32 version;
    size_t key_size;  // The size of the public key, in bytes.
    size_t signature_size;  // The size of the signature, in bytes.
    // An ASN.1-encoded PublicKeyInfo structure follows.
    // The signature follows.
  };

  // The maximum size the crx parser will tolerate for a public key.
  static const size_t kMaxPublicKeySize = 1 << 16;

  // The maximum size the crx parser will tolerate for a signature.
  static const size_t kMaxSignatureSize = 1 << 16;

  // The magic character sequence at the beginning of each crx file.
  static const char kExtensionHeaderMagic[];

  // The current version of the crx format.
  static const uint32 kCurrentVersion = 2;

  // Unpacks the extension in |crx_path| into a temporary directory and calls
  // |client| with the result. If |rdh| is provided, unpacking is done in a
  // sandboxed subprocess. Otherwise, it is done in-process.
  SandboxedExtensionUnpacker(const FilePath& crx_path,
                             ResourceDispatcherHost* rdh,
                             SandboxedExtensionUnpackerClient* cilent);

  // Start unpacking the extension. The client is called with the results.
  void Start();

 private:
  class ProcessHostClient;
  friend class ProcessHostClient;

  // Validates the signature of the extension and extract the key to
  // |public_key_|. Returns true if the signature validates, false otherwise.
  //
  // NOTE: Having this method here is a bit ugly. This code should really live
  // in ExtensionUnpacker as it is not specific to sandboxed unpacking. It was
  // put here because we cannot run windows crypto code in the sandbox. But we
  // could still have this method statically on ExtensionUnpacker so that code
  // just for unpacking is there and code just for sandboxing of unpacking is
  // here.
  bool ValidateSignature();

  // Starts the utility process that unpacks our extension.
  void StartProcessOnIOThread(const FilePath& temp_crx_path);

  // SandboxedExtensionUnpacker
  void OnUnpackExtensionSucceeded(const DictionaryValue& manifest);
  void OnUnpackExtensionFailed(const std::string& error_message);
  void OnProcessCrashed();

  void ReportFailure(const std::string& message);
  void ReportSuccess();

  FilePath crx_path_;
  MessageLoop* client_loop_;
  ResourceDispatcherHost* rdh_;
  SandboxedExtensionUnpackerClient* client_;
  ScopedTempDir temp_dir_;
  FilePath extension_root_;
  scoped_ptr<Extension> extension_;
  bool got_response_;
  std::string public_key_;
};

#endif  // CHROME_BROWSER_EXTENSIONS_SANDBOXED_EXTENSION_UNPACKER_H_
  void set_path(const FilePath& path) { path_ = path; }

  FilePath path = extension_path.AppendASCII(kDecodedImagesFilename);
    RuntimeEnabledFeatures::setStableFeaturesEnabled(enable);
    // FIXME: enableMediaPlayer does not use RuntimeEnabledFeatures
    // and does not belong as part of WebRuntimeFeatures.
    RuntimeEnabledFeatures::setExperimentalFeaturesEnabled(enable);
    RuntimeEnabledFeatures::setTestFeaturesEnabled(enable);
    "            ['indexOf', 'slice', 'split', 'substr', 'toUpperCase',\n"
    "             'replace']);\n"
    if (m_isExternalScript) {
        const KURL resourceUrl = sourceCode.resource()->resourceRequest().url();
        if (!SubresourceIntegrity::CheckSubresourceIntegrity(*m_element, sourceCode.source(), sourceCode.resource()->url(), sourceCode.resource()->mimeType(), *sourceCode.resource())) {
            return;
        }
    }

bool Resource::passesAccessControlCheck(ExecutionContext* context, SecurityOrigin* securityOrigin) const
bool Resource::passesAccessControlCheck(ExecutionContext* context, SecurityOrigin* securityOrigin, String& errorDescription) const
bool Resource::isEligibleForIntegrityCheck(ExecutionContext* source) const
{
    String errorDescription;
    return source->securityOrigin()->canRequest(resourceRequest().url()) || passesAccessControlCheck(source, source->securityContext().securityOrigin(), errorDescription);
}

    bool passesAccessControlCheck(ExecutionContext*, SecurityOrigin*) const;
    bool passesAccessControlCheck(ExecutionContext*, SecurityOrigin*, String& errorDescription) const;

    bool isEligibleForIntegrityCheck(ExecutionContext*) const;
bool ResourceFetcher::canAccessResource(Resource* resource, SecurityOrigin* sourceOrigin, const KURL& url, AccessControlLoggingDecision logErrorsDecision) const
        if (!forPreload && (logErrorsDecision == ShouldLogAccessControlErrors) && frame() && frame()->document()) {
    virtual bool canAccessResource(Resource*, SecurityOrigin*, const KURL&, AccessControlLoggingDecision) const override;
#include "core/fetch/CSSStyleSheetResource.h"
            if (!m_host->canAccessResource(resource, m_options.securityOrigin.get(), response.url(), ResourceLoaderHost::ShouldLogAccessControlErrors)) {
    enum AccessControlLoggingDecision {
        ShouldLogAccessControlErrors,
        ShouldNotLogAccessControlErrors
    };
    virtual bool canAccessResource(Resource*, SecurityOrigin* sourceOrigin, const KURL&, AccessControlLoggingDecision) const = 0;
#include "core/fetch/Resource.h"
bool SubresourceIntegrity::CheckSubresourceIntegrity(const Element& element, const String& source, const KURL& resourceUrl, const String& resourceType, const Resource& resource)
    if (!resource.isEligibleForIntegrityCheck(&document)) {
        logErrorToConsole("Subresource Integrity: The resource '" + resourceUrl.elidedString() + "' has an integrity attribute, but the resource requires CORS to be enabled to check the integrity, and it is not. The resource has been blocked.", document);
        return false;
    }

class Resource;
    static bool CheckSubresourceIntegrity(const Element&, const WTF::String& content, const KURL& resourceUrl, const WTF::String& mimeType, const Resource&);
#include "core/fetch/Resource.h"
#include "core/fetch/ResourcePtr.h"
    enum CorsStatus {
        WithCors,
        NoCors
    };

    void expectIntegrity(const char* integrity, const char* script, const KURL& url, const KURL& requestorUrl, const String& mimeType = String(), CorsStatus corsStatus = WithCors)
        EXPECT_TRUE(SubresourceIntegrity::CheckSubresourceIntegrity(*scriptElement, script, url, mimeType, *createTestResource(url, requestorUrl, corsStatus).get()));
    void expectIntegrityFailure(const char* integrity, const char* script, const KURL& url, const KURL& requestorUrl, const String& mimeType = String(), CorsStatus corsStatus = WithCors)
        EXPECT_FALSE(SubresourceIntegrity::CheckSubresourceIntegrity(*scriptElement, script, url, mimeType, *createTestResource(url, requestorUrl, corsStatus).get()));
    }

    ResourcePtr<Resource> createTestResource(const KURL& url, const KURL& allowOriginUrl, CorsStatus corsStatus)
    {
        OwnPtr<ResourceResponse> response = adoptPtr(new ResourceResponse);
        response->setURL(url);
        response->setHTTPStatusCode(200);
        if (corsStatus == WithCors) {
            response->setHTTPHeaderField("access-control-allow-origin", SecurityOrigin::create(allowOriginUrl)->toAtomicString());
            response->setHTTPHeaderField("access-control-allow-credentials", "true");
        }
        ResourcePtr<Resource> resource = new Resource(ResourceRequest(response->url()), Resource::Raw);
        resource->setResponse(*response);
        return resource;
    expectIntegrity(kSha256Integrity, kBasicScript, secureURL, secureURL);
    expectIntegrity(kSha384Integrity, kBasicScript, secureURL, secureURL);
    expectIntegrity(kSha512Integrity, kBasicScript, secureURL, secureURL);
    expectIntegrityFailure(kSha384IntegrityLabeledAs256, kBasicScript, secureURL, secureURL);
    expectIntegrityFailure(kUnsupportedHashFunctionIntegrity, kBasicScript, secureURL, secureURL);

    // All parameters are fine, and because this is not cross origin, CORS is
    // not needed.
    expectIntegrity(kSha256Integrity, kBasicScript, secureURL, secureURL, String(), NoCors);
    // The same checks as CheckSubresourceIntegrityInSecureOrigin should pass
    // here, with the expection of the NoCors check at the end.
    expectIntegrity(kSha256Integrity, kBasicScript, secureURL, insecureURL);
    expectIntegrity(kSha384Integrity, kBasicScript, secureURL, insecureURL);
    expectIntegrity(kSha512Integrity, kBasicScript, secureURL, insecureURL);
    expectIntegrityFailure(kSha384IntegrityLabeledAs256, kBasicScript, secureURL, insecureURL);
    expectIntegrityFailure(kUnsupportedHashFunctionIntegrity, kBasicScript, secureURL, insecureURL);

    // This check should fail because, unlike in the
    // CheckSubresourceIntegirtyInSecureOrigin case, this is cross origin
    // (secure origin requesting a resource on an insecure origin)
    expectIntegrityFailure(kSha256Integrity, kBasicScript, secureURL, insecureURL, String(), NoCors);
    if (!cachedStyleSheet->errorOccurred() && !SubresourceIntegrity::CheckSubresourceIntegrity(*m_owner, cachedStyleSheet->sheetText(), KURL(baseURL, href), cachedStyleSheet->mimeType(), *cachedStyleSheet)) {
#include "net/base/net_util.h"
  // Grant navigation to a file but not the file:// scheme in general.
  void GrantRequestOfSpecificFile(const FilePath &file) {
    request_file_set_.insert(file.StripTrailingSeparators());
  }

    FilePath stripped = file.StripTrailingSeparators();
    file_permissions_.erase(stripped);
    request_file_set_.erase(stripped);
  // Determine whether permission has been granted to request |url|.
    // Having permission to a scheme implies permssion to all of its URLs.
    if (judgment != scheme_policy_.end())
      return judgment->second;

    // file:// URLs are more granular.  The child may have been given
    // permission to a specific file but not the file:// scheme in general.
    if (url.SchemeIs(chrome::kFileScheme)) {
      FilePath path;
      if (net::FileURLToFilePath(url, &path))
        return request_file_set_.find(path) != request_file_set_.end();
    }
    return false;  // Unmentioned schemes are disallowed.
  typedef std::set<FilePath> FileSet;
  // The set of files the child process is permitted to load.
  FileSet request_file_set_;

    // When the child process has been commanded to request this scheme,
    // we grant it the capability to request all URLs of that scheme.
void ChildProcessSecurityPolicyImpl::GrantRequestSpecificFileURL(
    int child_id,
    const GURL& url) {
  if (!url.SchemeIs(chrome::kFileScheme))
    return;

  {
    base::AutoLock lock(lock_);
    SecurityStateMap::iterator state = security_state_.find(child_id);
    if (state == security_state_.end())
      return;

    // When the child process has been commanded to request a file:// URL,
    // then we grant it the capability for that URL only.
    FilePath path;
    if (net::FileURLToFilePath(url, &path))
        state->second->GrantRequestOfSpecificFile(path);
  }
}

  // request the URL, along with permission to request all URLs of the same
  // scheme.
  // Whenever the browser process drops a file icon on a tab, it should call
  // this method to grant the child process the capability to request this one
  // file:// URL, but not all urls of the file:// scheme.
  void GrantRequestSpecificFileURL(int child_id, const GURL& url);

TEST_F(ChildProcessSecurityPolicyTest, SpecificFile) {
  ChildProcessSecurityPolicyImpl* p =
      ChildProcessSecurityPolicyImpl::GetInstance();

  p->Add(kRendererID);

  GURL icon_url("file:///tmp/foo.png");
  GURL sensitive_url("file:///etc/passwd");
  EXPECT_FALSE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_FALSE(p->CanRequestURL(kRendererID, sensitive_url));

  p->GrantRequestSpecificFileURL(kRendererID, icon_url);
  EXPECT_TRUE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_FALSE(p->CanRequestURL(kRendererID, sensitive_url));

  p->GrantRequestURL(kRendererID, icon_url);
  EXPECT_TRUE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_TRUE(p->CanRequestURL(kRendererID, sensitive_url));

  p->Remove(kRendererID);
}

    // A dragged file may wind up as the value of an input element, or it
    // may be used as the target of a navigation instead.  We don't know
    // which will happen at this point, so generously grant both access
    // and request permissions to the specific file to cover both cases.
    // We do not give it the permission to request all file:// URLs.
    policy->GrantRequestSpecificFileURL(renderer_id,
                                        net::FilePathToFileURL(path));
#include "base/utf_string_conversions.h"
  FilePath highlighted_file_path(FILE_PATH_LITERAL("/tmp/foo.html"));
  FilePath dragged_file_path(FILE_PATH_LITERAL("/tmp/image.jpg"));
  FilePath sensitive_file_path(FILE_PATH_LITERAL("/etc/passwd"));
  GURL highlighted_file_url = net::FilePathToFileURL(highlighted_file_path);
  GURL dragged_file_url = net::FilePathToFileURL(dragged_file_path);
  GURL sensitive_file_url = net::FilePathToFileURL(sensitive_file_path);
  dropped_data.url = highlighted_file_url;
  dropped_data.filenames.push_back(WebDropData::FileInfo(
      UTF8ToUTF16(dragged_file_path.AsUTF8Unsafe()), string16()));

                              WebKit::WebDragOperationNone, 0);

  int id = process()->GetID();
  ChildProcessSecurityPolicyImpl* policy =
      ChildProcessSecurityPolicyImpl::GetInstance();

  EXPECT_FALSE(policy->CanRequestURL(id, highlighted_file_url));
  EXPECT_FALSE(policy->CanReadFile(id, highlighted_file_path));
  EXPECT_TRUE(policy->CanRequestURL(id, dragged_file_url));
  EXPECT_TRUE(policy->CanReadFile(id, dragged_file_path));
  EXPECT_FALSE(policy->CanRequestURL(id, sensitive_file_url));
  EXPECT_FALSE(policy->CanReadFile(id, sensitive_file_path));
  // Use the frame's original request's URL rather than the document's URL for
  // subsequent checks.  For a popup, the document's URL may become the opener
  // window's URL if the opener has called document.write().
  // See http://crbug.com/93517.
  GURL old_url(frame->dataSource()->request().url());

    // Lastly, access to file:// URLs from non-file:// URL pages must be
    // handled by the browser so that ordinary renderer processes don't get
    // blessed with file permissions.
    int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
    bool is_initial_navigation = page_id_ == -1;
    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      // Fork non-file to file opens.  Check the opener URL if this is the
      // initial navigation in a newly opened window.
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

#include "chrome/browser/autofill_manager.h"
#include "chrome/browser/password_manager/password_manager.h"
#include "chrome/browser/plugin_installer.h"
#include "chrome/browser/tab_contents/tab_contents_view.h"
// static
int TabContents::find_request_id_counter_ = -1;

// TODO(brettw) many of the data members here have casts to WebContents.
// This object is the same as WebContents and is currently being merged.
// When this merge is done, the casts can be removed.
      view_(TabContentsView::Create(static_cast<WebContents*>(this))),
      ALLOW_THIS_IN_INITIALIZER_LIST(render_manager_(
          static_cast<WebContents*>(this),
          static_cast<WebContents*>(this))),
      property_bag_(),
      registrar_(),
      printing_(*static_cast<WebContents*>(this)),
      save_package_(),
      cancelable_consumer_(),
      autofill_manager_(),
      password_manager_(),
      plugin_installer_(),
      ALLOW_THIS_IN_INITIALIZER_LIST(fav_icon_helper_(
          static_cast<WebContents*>(this))),
      select_file_dialog_(),
      pending_install_(),
      current_load_start_(),
      load_state_(net::LOAD_STATE_IDLE),
      load_state_host_(),
      received_page_title_(false),
      is_starred_(false),
      contents_mime_type_(),
      encoding_(),
      download_shelf_(),
      shelf_visible_(false),
      infobar_delegates_(),
      last_download_shelf_show_(),
      find_ui_active_(false),
      find_op_aborted_(false),
      current_find_request_id_(find_request_id_counter_++),
      find_text_(),
      find_prepopulate_text_(NULL),
      find_result_(),
      capturing_contents_(false),
      is_being_destroyed_(false),
      notify_disconnection_(false),
      history_requests_(),
#if defined(OS_WIN)
      message_box_active_(CreateEvent(NULL, TRUE, FALSE, NULL)),
#endif
      last_javascript_message_dismissal_(),
      suppress_javascript_messages_(false) {

void TabContents::OnGearsCreateShortcutDone(
    const GearsShortcutData2& shortcut_data, bool success) {
  NavigationEntry* current_entry = controller_.GetLastCommittedEntry();
  bool same_page =
      current_entry && pending_install_.page_id == current_entry->page_id();

  if (success && same_page) {
    // Only switch to app mode if the user chose to create a shortcut and
    // we're still on the same page that it corresponded to.
    if (delegate())
      delegate()->ConvertContentsToApplication(this);
  }

  // Reset the page id to indicate no requests are pending.
  pending_install_.page_id = 0;
  pending_install_.callback_functor = NULL;
}
#include "base/basictypes.h"
#include "chrome/browser/cancelable_request.h"
#include "chrome/browser/download/save_package.h"
#include "chrome/browser/fav_icon_helper.h"
#include "chrome/browser/find_notification_details.h"
#include "chrome/browser/shell_dialogs.h"
#include "chrome/browser/renderer_host/render_view_host_delegate.h"
#include "chrome/browser/tab_contents/render_view_host_manager.h"
#include "chrome/common/gears_api.h"
#include "net/base/load_states.h"
#include "webkit/glue/password_form.h"
#include "webkit/glue/webpreferences.h"


#if defined(OS_MACOSX) || defined(OS_LINUX)
// Remove when we've finished porting the supporting classes.
#include "chrome/common/temp_scaffolding_stubs.h"
#elif defined(OS_WIN)
#include "chrome/browser/printing/print_view_manager.h"
#endif
class AutofillManager;
class PasswordManager;
class PluginInstaller;
class TabContentsView;
  // When CreateShortcut is invoked RenderViewHost::GetApplicationInfo is
  // invoked. CreateShortcut caches the state of the page needed to create the
  // shortcut in PendingInstall. When OnDidGetApplicationInfo is invoked, it
  // uses the information from PendingInstall and the WebApplicationInfo
  // to create the shortcut.
  class GearsCreateShortcutCallbackFunctor;
  struct PendingInstall {
    int32 page_id;
    SkBitmap icon;
    std::wstring title;
    GURL url;
    // This object receives the GearsCreateShortcutCallback and routes the
    // message back to the WebContents, if we haven't been deleted.
    GearsCreateShortcutCallbackFunctor* callback_functor;
  };

  // TODO(brettw) move thos to tab_contents.cc once WebContents and
  // TabContents are merged.
  class GearsCreateShortcutCallbackFunctor {
   public:
    explicit GearsCreateShortcutCallbackFunctor(TabContents* contents)
       : contents_(contents) {}

    void Run(const GearsShortcutData2& shortcut_data, bool success) {
      if (contents_)
        contents_->OnGearsCreateShortcutDone(shortcut_data, success);
      delete this;
    }
    void Cancel() {
      contents_ = NULL;
    }

   private:
    TabContents* contents_;
  };


  // Called when the user dismisses the shortcut creation dialog.  'success' is
  // true if the shortcut was created.
  void OnGearsCreateShortcutDone(const GearsShortcutData2& shortcut_data,
                                 bool success);

  // Data for core operation ---------------------------------------------------
  // Delegate for notifying our owner about stuff. Not owned by us.

  // Handles the back/forward list and loading.
  // The corresponding view.
  scoped_ptr<TabContentsView> view_;

  // Helper classes ------------------------------------------------------------

  // Manages creation and swapping of render views.
  RenderViewHostManager render_manager_;

  // Stores random bits of data for others to associate with this object.
  // Registers and unregisters us for notifications.
  // Handles print preview and print job for this contents.
  printing::PrintViewManager printing_;

  // SavePackage, lazily created.
  scoped_refptr<SavePackage> save_package_;

  // Tracks our pending CancelableRequests. This maps pending requests to
  // page IDs so that we know whether a given callback still applies. The
  // page ID -1 means no page ID was set.
  CancelableRequestConsumerT<int32, -1> cancelable_consumer_;

  // AutofillManager, lazily created.
  scoped_ptr<AutofillManager> autofill_manager_;

  // PasswordManager, lazily created.
  scoped_ptr<PasswordManager> password_manager_;

  // PluginInstaller, lazily created.
  scoped_ptr<PluginInstaller> plugin_installer_;

  // Handles downloading favicons.
  FavIconHelper fav_icon_helper_;

  // Dialog box used for choosing files to upload from file form fields.
  scoped_refptr<SelectFileDialog> select_file_dialog_;

  // Web app installation.
  PendingInstall pending_install_;

  // Data for loading state ----------------------------------------------------

  // Indicates if the tab is considered crashed.
  bool is_crashed_;
  // TODO(brettw) this seems like it can be removed according to the comment.
  // System time at which the current load was started.
  base::TimeTicks current_load_start_;

  // The current load state and the URL associated with it.
  net::LoadState load_state_;
  std::wstring load_state_host_;

  // Data for current page -----------------------------------------------------

  // Whether we have a (non-empty) title for the current page.
  // Used to prevent subsequent title updates from affecting history. This
  // prevents some weirdness because some AJAXy apps use titles for status
  // messages.
  bool received_page_title_;

  // Whether the current URL is starred
  bool is_starred_;

  // When a navigation occurs, we record its contents MIME type. It can be
  // used to check whether we can do something for some special contents.
  std::string contents_mime_type_;

  // Character encoding. TODO(jungshik) : convert to std::string
  std::wstring encoding_;

  // Data for shelves and stuff ------------------------------------------------

  // The download shelf view (view at the bottom of the page).
  scoped_ptr<DownloadShelf> download_shelf_;

  // Whether the shelf view is visible.
  bool shelf_visible_;
  // popups. This pointer also goes in |child_windows_| for ownership,
  // The last time that the download shelf was made visible.
  base::TimeTicks last_download_shelf_show_;

  // Data for find in page -----------------------------------------------------

  // TODO(brettw) this should be separated into a helper class.

  // Each time a search request comes in we assign it an id before passing it
  // over the IPC so that when the results come in we can evaluate whether we
  // still care about the results of the search (in some cases we don't because
  // the user has issued a new search).
  static int find_request_id_counter_;

  // True if the Find UI is active for this Tab.
  bool find_ui_active_;

  // True if a Find operation was aborted. This can happen if the Find box is
  // closed or if the search term inside the Find box is erased while a search
  // is in progress. This can also be set if a page has been reloaded, and will
  // on FindNext result in a full Find operation so that the highlighting for
  // inactive matches can be repainted.
  bool find_op_aborted_;

  // This variable keeps track of what the most recent request id is.
  int current_find_request_id_;

  // The last string we searched for. This is used to figure out if this is a
  // Find or a FindNext operation (FindNext should not increase the request id).
  string16 find_text_;

  // Keeps track of the last search string that was used to search in any tab.
  string16* find_prepopulate_text_;

  // The last find result. This object contains details about the number of
  // matches, the find selection rectangle, etc. The UI can access this
  // information to build its presentation.
  FindNotificationDetails find_result_;

  // Data for misc internal state ----------------------------------------------

  // See capturing_contents() above.
  bool capturing_contents_;

  // Indicates whether we should notify about disconnection of this
  // TabContents. This is used to ensure disconnection notifications only
  // happen if a connection notification has happened and that they happen only
  // once.
  bool notify_disconnection_;

  // Maps from handle to page_id.
  typedef std::map<HistoryService::Handle, int32> HistoryRequestMap;
  HistoryRequestMap history_requests_;

#if defined(OS_WIN)
  // Handle to an event that's set when the page is showing a message box (or
  // equivalent constrained window).  Plugin processes check this to know if
  // they should pump messages then.
  ScopedHandle message_box_active_;
#endif

  // The time that the last javascript message was dismissed.
  base::TimeTicks last_javascript_message_dismissal_;

  // True if the user has decided to block future javascript messages. This is
  // reset on navigations to false on navigations.
  bool suppress_javascript_messages_;

  // ---------------------------------------------------------------------------

    : TabContents(profile) {
        descriptor->PrototypeTemplate()->SetInternalFieldCount(V8Custom::kDOMWindowInternalFieldCount);
    globalTemplate->SetInternalFieldCount(V8Custom::kDOMWindowInternalFieldCount);
    V8DOMWrapper::setDOMWrapper(v8::Handle<v8::Object>::Cast(jsWindow->GetPrototype()), V8ClassIndex::ToInt(V8ClassIndex::DOMWINDOW), window);
    V8DOMWrapper::setDOMWrapper(v8::Handle<v8::Object>::Cast(v8Global->GetPrototype()), V8ClassIndex::ToInt(V8ClassIndex::DOMWINDOW), window);
    DOMWindow* imp = V8DOMWrapper::convertToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, info.Holder());
    DOMWindow* window = V8DOMWrapper::convertToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, info.Holder());
    // TODO(antonm): investigate what convertToNativeObject does for the case of DOMWINDOW.
    DOMWindow* window = V8DOMWrapper::convertToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, info.Holder());
    v8::Handle<v8::Value> result = info.Holder()->GetRealNamedProperty(name);
DevToolsManager::DevToolsManager() : tab_contents_listeners_(NULL) {
  DCHECK(!tab_contents_listeners_.get()) <<
    Source<TabContents> src(source);
    const TabContents& tab_contents) {
  const NavigationController& navigation_controller = tab_contents.controller();
    TabContents& tab_contents,
  DCHECK(!GetDevToolsClientHostFor(tab_contents));
  NavigationController* navigation_controller = &tab_contents.controller();
  SendAttachToAgent(tab_contents, tab_contents.render_view_host());
  RenderViewHost* target_host = tc->render_view_host();
  TabContents* wc = from.delegate()->GetAsWebContents();
void DevToolsManager::OpenDevToolsWindow(TabContents* wc) {
void DevToolsManager::InspectElement(TabContents* wc, int x, int y) {
  SendDetachToAgent(*tab_contents);
  if (!tab_contents_listeners_.get()) {
    tab_contents_listeners_.reset(new NotificationRegistrar);
    tab_contents_listeners_->Add(
  DCHECK(tab_contents_listeners_.get());
    tab_contents_listeners_.reset();
void DevToolsManager::SendAttachToAgent(const TabContents& wc,
void DevToolsManager::SendDetachToAgent(const TabContents& wc) {
class TabContents;
  // Returns DevToolsClientHost registered for |tab_contents| or NULL if
  // there is no alive DevToolsClientHost registered for |tab_contents|.
  DevToolsClientHost* GetDevToolsClientHostFor(const TabContents& tab_contents);
  // Registers new DevToolsClientHost for |tab_contents|. There must be no
  // other DevToolsClientHosts registered for the TabContents at the moment.
  void RegisterDevToolsClientHostFor(TabContents& tab_contents,
  void OpenDevToolsWindow(TabContents* wc);
  void InspectElement(TabContents* tab_contents, int x, int y);
  // there is a DevToolsClientHost registered for the |tab_contents|.
      const TabContents& tab_contents,
  void SendDetachToAgent(const TabContents& tab_contents);
  scoped_ptr<NotificationRegistrar> tab_contents_listeners_;
#include "base/string16.h"
#include "base/time.h"
#include "chrome/browser/browser_process.h"
#include "chrome/browser/debugger/devtools_manager.h"
#include "chrome/browser/dom_ui/dom_ui.h"
#include "chrome/browser/dom_ui/dom_ui_factory.h"
#include "chrome/browser/renderer_host/render_widget_host_view.h"
#include "chrome/browser/renderer_host/web_cache_manager.h"
#include "chrome/common/url_constants.h"
const string16& TabContents::GetTitle() const {
  DOMUI* our_dom_ui = render_manager_.pending_dom_ui() ?
      render_manager_.pending_dom_ui() : render_manager_.dom_ui();
  if (our_dom_ui) {
    // Don't override the title in view source mode.
    NavigationEntry* entry = controller_.GetActiveEntry();
    if (!(entry && entry->IsViewSourceMode())) {
      // Give the DOM UI the chance to override our title.
      const string16& title = our_dom_ui->overridden_title();
      if (!title.empty())
        return title;
    }
  }

  // We use the title for the last committed entry rather than a pending
  // navigation entry. For example, when the user types in a URL, we want to
  // keep the old page's title until the new load has committed and we get a new
  // title.
  // The exception is with transient pages, for which we really want to use
  // their title, as they are not committed.
  NavigationEntry* entry = controller_.GetTransientEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);

  entry = controller_.GetLastCommittedEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);
  else if (controller_.LoadingURLLazily())
    return controller_.GetLazyTitle();
  return EmptyString16();
}

SiteInstance* TabContents::GetSiteInstance() const {
  return render_manager_.current_host()->site_instance();
}

bool TabContents::ShouldDisplayURL() {
  // Don't hide the url in view source mode.
  NavigationEntry* entry = controller_.GetActiveEntry();
  if (entry && entry->IsViewSourceMode())
    return true;
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->should_hide_url();
  return true;
}

bool TabContents::ShouldDisplayFavIcon() {
  // Always display a throbber during pending loads.
  if (controller_.GetLastCommittedEntry() && controller_.pending_entry())
    return true;

  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->hide_favicon();
  return true;
}

std::wstring TabContents::GetStatusText() const {
  if (!is_loading() || load_state_ == net::LOAD_STATE_IDLE)
    return std::wstring();

  switch (load_state_) {
    case net::LOAD_STATE_WAITING_FOR_CACHE:
      return l10n_util::GetString(IDS_LOAD_STATE_WAITING_FOR_CACHE);
    case net::LOAD_STATE_RESOLVING_PROXY_FOR_URL:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_PROXY_FOR_URL);
    case net::LOAD_STATE_RESOLVING_HOST:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_HOST);
    case net::LOAD_STATE_CONNECTING:
      return l10n_util::GetString(IDS_LOAD_STATE_CONNECTING);
    case net::LOAD_STATE_SENDING_REQUEST:
      return l10n_util::GetString(IDS_LOAD_STATE_SENDING_REQUEST);
    case net::LOAD_STATE_WAITING_FOR_RESPONSE:
      return l10n_util::GetStringF(IDS_LOAD_STATE_WAITING_FOR_RESPONSE,
                                   load_state_host_);
    // Ignore net::LOAD_STATE_READING_RESPONSE and net::LOAD_STATE_IDLE
    case net::LOAD_STATE_IDLE:
    case net::LOAD_STATE_READING_RESPONSE:
      break;
  }

  return std::wstring();
}

void TabContents::DidBecomeSelected() {
  controller_.SetActive(true);

  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // If pid() is -1, that means the RenderProcessHost still hasn't been
  // initialized.  It'll register with CacheManagerHost when it is.
  if (process()->pid() != -1)
    WebCacheManager::GetInstance()->ObserveActivity(process()->pid());
}

void TabContents::WasHidden() {
  if (!capturing_contents()) {
    // |render_view_host()| can be NULL if the user middle clicks a link to open
    // a tab in then background, then closes the tab before selecting it.  This
    // is because closing the tab calls TabContents::Destroy(), which removes
    // the |render_view_host()|; then when we actually destroy the window,
    // OnWindowPosChanged() notices and calls HideContents() (which calls us).
    if (render_widget_host_view())
      render_widget_host_view()->WasHidden();

    // Loop through children and send WasHidden to them, too.
    int count = static_cast<int>(child_windows_.size());
    for (int i = count - 1; i >= 0; --i) {
      ConstrainedWindow* window = child_windows_.at(i);
      window->WasHidden();
    }
  }

  NotificationService::current()->Notify(
      NotificationType::TAB_CONTENTS_HIDDEN,
      Source<TabContents>(this),
      NotificationService::NoDetails());
}

void TabContents::ShowContents() {
  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // Loop through children and send DidBecomeSelected to them, too.
  int count = static_cast<int>(child_windows_.size());
  for (int i = count - 1; i >= 0; --i) {
    ConstrainedWindow* window = child_windows_.at(i);
    window->DidBecomeSelected();
  }
}

void TabContents::HideContents() {
  // TODO(pkasting): http://b/1239839  Right now we purposefully don't call
  // our superclass HideContents(), because some callers want to be very picky
  // about the order in which these get called.  In addition to making the code
  // here practically impossible to understand, this also means we end up
  // calling TabContents::WasHidden() twice if callers call both versions of
  // HideContents() on a WebContents.
  WasHidden();
}

  const NavigationEntry& entry = *controller_.pending_entry();

  RenderViewHost* dest_render_view_host = render_manager_.Navigate(entry);
  if (!dest_render_view_host)
    return false;  // Unable to create the desired render view host.

  // Tell DevTools agent that it is attached prior to the navigation.
  DevToolsManager* dev_tools_manager = g_browser_process->devtools_manager();
  if (dev_tools_manager)  // NULL in unit tests.
    dev_tools_manager->SendAttachToAgent(*this, dest_render_view_host);

  // Used for page load time metrics.
  current_load_start_ = base::TimeTicks::Now();

  // Navigate in the desired RenderViewHost.
  dest_render_view_host->NavigateToEntry(entry, reload);

  if (entry.page_id() == -1) {
    // HACK!!  This code suppresses javascript: URLs from being added to
    // session history, which is what we want to do for javascript: URLs that
    // do not generate content.  What we really need is a message from the
    // renderer telling us that a new page was not created.  The same message
    // could be used for mailto: URLs and the like.
    if (entry.url().SchemeIs(chrome::kJavaScriptScheme))
      return false;
  }

  // Clear any provisional password saves - this stops password infobars
  // showing up on pages the user navigates to while the right page is
  // loading.
  GetPasswordManager()->ClearProvisionalSave();

  if (reload && !profile()->IsOffTheRecord()) {
    HistoryService* history =
        profile()->GetHistoryService(Profile::IMPLICIT_ACCESS);
    if (history)
      history->SetFavIconOutOfDateForPage(entry.url());
  }

void TabContents::Stop() {
  render_manager_.Stop();
  printing_.Stop();
}

void TabContents::Cut() {
  render_view_host()->Cut();
}

void TabContents::Copy() {
  render_view_host()->Copy();
}

void TabContents::Paste() {
  render_view_host()->Paste();
}

void TabContents::DisassociateFromPopupCount() {
  render_view_host()->DisassociateFromPopupCount();
}

TabContents* TabContents::Clone() {
  // We create a new SiteInstance so that the new tab won't share processes
  // with the old one. This can be changed in the future if we need it to share
  // processes for some reason.
  TabContents* tc = new WebContents(profile(),
                                    SiteInstance::CreateSiteInstance(profile()),
                                    MSG_ROUTING_NONE, NULL);
  tc->controller().CopyStateFrom(controller_);
  return tc;
}

void TabContents::PopupNotificationVisibilityChanged(bool visible) {
  render_view_host()->PopupNotificationVisibilityChanged(visible);
}

gfx::NativeView TabContents::GetContentNativeView() {
  return view_->GetContentNativeView();
}

gfx::NativeView TabContents::GetNativeView() const {
  return view_->GetNativeView();
}

void TabContents::GetContainerBounds(gfx::Rect *out) const {
  view_->GetContainerBounds(out);
}

void TabContents::Focus() {
  view_->Focus();
}

void TabContents::SetInitialFocus(bool reverse) {
  render_view_host()->SetInitialFocus(reverse);
}

bool TabContents::FocusLocationBarByDefault() {
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return dom_ui->focus_location_bar_by_default();
  return false;
}

bool TabContents::IsBookmarkBarAlwaysVisible() {
  // See GetDOMUIForCurrentState() comment for more info. This case is very
  // similar, but for non-first loads, we want to use the committed entry. This
  // is so the bookmarks bar disappears at the same time the page does.
  if (controller_.GetLastCommittedEntry()) {
    // Not the first load, always use the committed DOM UI.
    if (render_manager_.dom_ui())
      return render_manager_.dom_ui()->force_bookmark_bar_visible();
    return false;  // Default.
  }

  // When it's the first load, we know either the pending one or the committed
  // one will have the DOM UI in it (see GetDOMUIForCurrentState), and only one
  // of them will be valid, so we can just check both.
  if (render_manager_.pending_dom_ui())
    return render_manager_.pending_dom_ui()->force_bookmark_bar_visible();
  if (render_manager_.dom_ui())
    return render_manager_.dom_ui()->force_bookmark_bar_visible();
  return false;  // Default.
}

void TabContents::SetDownloadShelfVisible(bool visible) {
  if (shelf_visible_ != visible) {
    if (visible) {
      // Invoke GetDownloadShelf to force the shelf to be created.
      GetDownloadShelf();
    }
    shelf_visible_ = visible;

    if (delegate_)
      delegate_->ContentsStateChanged(this);
  }

  // SetShelfVisible can force-close the shelf, so make sure we lay out
  // everything correctly, as if the animation had finished. This doesn't
  // matter for showing the shelf, as the show animation will do it.
  ToolbarSizeChanged(false);

  if (visible) {
    // Always set this value as it reflects the last time the download shelf
    // was made visible (even if it was already visible).
    last_download_shelf_show_ = base::TimeTicks::Now();
  }
}

// Notifies the RenderWidgetHost instance about the fact that the page is
// loading, or done loading and calls the base implementation.
void TabContents::SetIsLoading(bool is_loading,
                               LoadNotificationDetails* details) {
  if (is_loading == is_loading_)
    return;

  if (!is_loading) {
    load_state_ = net::LOAD_STATE_IDLE;
    load_state_host_.clear();
  }

  render_manager_.SetIsLoading(is_loading);

  is_loading_ = is_loading;
  waiting_for_response_ = is_loading;

  if (delegate_)
    delegate_->LoadingStateChanged(this);

  NotificationType type = is_loading ? NotificationType::LOAD_START :
      NotificationType::LOAD_STOP;
  NotificationDetails det = NotificationService::NoDetails();;
  if (details)
      det = Details<LoadNotificationDetails>(details);
  NotificationService::current()->Notify(type,
      Source<NavigationController>(&controller_),
      det);
}


DOMUI* TabContents::GetDOMUIForCurrentState() {
  // When there is a pending navigation entry, we want to use the pending DOMUI
  // that goes along with it to control the basic flags. For example, we want to
  // show the pending URL in the URL bar, so we want the display_url flag to
  // be from the pending entry.
  //
  // The confusion comes because there are multiple possibilities for the
  // initial load in a tab as a side effect of the way the RenderViewHostManager
  // works.
  //
  //  - For the very first tab the load looks "normal". The new tab DOM UI is
  //    the pending one, and we want it to apply here.
  //
  //  - For subsequent new tabs, they'll get a new SiteInstance which will then
  //    get switched to the one previously associated with the new tab pages.
  //    This switching will cause the manager to commit the RVH/DOMUI. So we'll
  //    have a committed DOM UI in this case.
  //
  // This condition handles all of these cases:
  //
  //  - First load in first tab: no committed nav entry + pending nav entry +
  //    pending dom ui:
  //    -> Use pending DOM UI if any.
  //
  //  - First load in second tab: no committed nav entry + pending nav entry +
  //    no pending DOM UI:
  //    -> Use the committed DOM UI if any.
  //
  //  - Second navigation in any tab: committed nav entry + pending nav entry:
  //    -> Use pending DOM UI if any.
  //
  //  - Normal state with no load: committed nav entry + no pending nav entry:
  //    -> Use committed DOM UI.
  if (controller_.pending_entry() &&
      (controller_.GetLastCommittedEntry() ||
       render_manager_.pending_dom_ui()))
    return render_manager_.pending_dom_ui();
  return render_manager_.dom_ui();
}
  virtual const string16& GetTitle() const;
  virtual SiteInstance* GetSiteInstance() const;
  virtual bool ShouldDisplayURL();
  virtual bool ShouldDisplayFavIcon();
  virtual std::wstring GetStatusText() const;
  virtual void DidBecomeSelected();
  virtual void WasHidden();
  // TODO(brettw) document these.
  virtual void ShowContents();
  virtual void HideContents();

  virtual bool NavigateToPendingEntry(bool reload);
  virtual void Stop();
  virtual void Cut();
  virtual void Copy();
  virtual void Paste();
  virtual void DisassociateFromPopupCount();
  virtual TabContents* Clone();
  virtual void PopupNotificationVisibilityChanged(bool visible);
  // TODO(brettw): Most of these should be removed and the caller should call
  // the view directly.
  gfx::NativeView GetContentNativeView();
  gfx::NativeView GetNativeView() const;
  void GetContainerBounds(gfx::Rect *out) const;
  void Focus();
  void SetInitialFocus(bool reverse);

  // Returns true if the location bar should be focused by default rather than
  // the page contents. The view will call this function when the tab is
  // to see what it should do.
  bool FocusLocationBarByDefault();
  virtual bool IsBookmarkBarAlwaysVisible();
  virtual void SetDownloadShelfVisible(bool visible);
  RenderWidgetHostView* render_widget_host_view() const {
    return render_manager_.current_view();
  }

  void SetIsLoading(bool is_loading,
                    LoadNotificationDetails* details);

  // Returns the DOMUI for the current state of the tab. This will either be
  // the pending DOMUI, the committed DOMUI, or NULL.
  DOMUI* GetDOMUIForCurrentState();

#include "chrome/browser/automation/automation_provider_list.h"
#include "chrome/browser/automation/automation_provider_list.h"
ResourceDispatcherHost* BrowserProcessImpl::resource_dispatcher_host() {
  DCHECK(CalledOnValidThread());
  if (!created_resource_dispatcher_host_)
    CreateResourceDispatcherHost();
  return resource_dispatcher_host_.get();
}

MetricsService* BrowserProcessImpl::metrics_service() {
  DCHECK(CalledOnValidThread());
  if (!created_metrics_service_)
    CreateMetricsService();
  return metrics_service_.get();
}

IOThread* BrowserProcessImpl::io_thread() {
  DCHECK(CalledOnValidThread());
  if (!created_io_thread_)
    CreateIOThread();
  return io_thread_.get();
}

base::Thread* BrowserProcessImpl::file_thread() {
  DCHECK(CalledOnValidThread());
  if (!created_file_thread_)
    CreateFileThread();
  return file_thread_.get();
}

base::Thread* BrowserProcessImpl::db_thread() {
  DCHECK(CalledOnValidThread());
  if (!created_db_thread_)
    CreateDBThread();
  return db_thread_.get();
}

base::Thread* BrowserProcessImpl::process_launcher_thread() {
  DCHECK(CalledOnValidThread());
  if (!created_process_launcher_thread_)
    CreateProcessLauncherThread();
  return process_launcher_thread_.get();
}

base::Thread* BrowserProcessImpl::cache_thread() {
  DCHECK(CalledOnValidThread());
  if (!created_cache_thread_)
    CreateCacheThread();
  return cache_thread_.get();
}

#if defined(USE_X11)
base::Thread* BrowserProcessImpl::background_x11_thread() {
  DCHECK(CalledOnValidThread());
  // The BACKGROUND_X11 thread is created when the IO thread is created.
  if (!created_io_thread_)
    CreateIOThread();
  return background_x11_thread_.get();
}
#endif

ProfileManager* BrowserProcessImpl::profile_manager() {
  DCHECK(CalledOnValidThread());
  if (!created_profile_manager_)
    CreateProfileManager();
  return profile_manager_.get();
}

PrefService* BrowserProcessImpl::local_state() {
  DCHECK(CalledOnValidThread());
  if (!created_local_state_)
    CreateLocalState();
  return local_state_.get();
}

DevToolsManager* BrowserProcessImpl::devtools_manager() {
  DCHECK(CalledOnValidThread());
  if (!created_devtools_manager_)
    CreateDevToolsManager();
  return devtools_manager_.get();
}

Clipboard* BrowserProcessImpl::clipboard() {
  DCHECK(CalledOnValidThread());
  return clipboard_.get();
}

NotificationUIManager* BrowserProcessImpl::notification_ui_manager() {
  DCHECK(CalledOnValidThread());
  if (!created_notification_ui_manager_)
    CreateNotificationUIManager();
  return notification_ui_manager_.get();
}

StatusTrayManager* BrowserProcessImpl::status_tray_manager() {
  DCHECK(CalledOnValidThread());
  if (!status_tray_manager_.get())
    CreateStatusTrayManager();
  return status_tray_manager_.get();
}

IconManager* BrowserProcessImpl::icon_manager() {
  DCHECK(CalledOnValidThread());
  if (!created_icon_manager_)
    CreateIconManager();
  return icon_manager_.get();
}

ThumbnailGenerator* BrowserProcessImpl::GetThumbnailGenerator() {
  return &thumbnail_generator_;
}

AutomationProviderList* BrowserProcessImpl::InitAutomationProviderList() {
  DCHECK(CalledOnValidThread());
  if (automation_provider_list_.get() == NULL) {
    automation_provider_list_.reset(AutomationProviderList::GetInstance());
  }
  return automation_provider_list_.get();
}

void BrowserProcessImpl::InitDebuggerWrapper(int port, bool useHttp) {
  DCHECK(CalledOnValidThread());
  if (!created_debugger_wrapper_)
    CreateDebuggerWrapper(port, useHttp);
}

bool BrowserProcessImpl::IsShuttingDown() {
  DCHECK(CalledOnValidThread());
  return did_start_ && 0 == module_ref_count_;
}

GoogleURLTracker* BrowserProcessImpl::google_url_tracker() {
  DCHECK(CalledOnValidThread());
  if (!google_url_tracker_.get())
    CreateGoogleURLTracker();
  return google_url_tracker_.get();
}

IntranetRedirectDetector* BrowserProcessImpl::intranet_redirect_detector() {
  DCHECK(CalledOnValidThread());
  if (!intranet_redirect_detector_.get())
    CreateIntranetRedirectDetector();
  return intranet_redirect_detector_.get();
}

const std::string& BrowserProcessImpl::GetApplicationLocale() {
  DCHECK(!locale_.empty());
  return locale_;
}

void BrowserProcessImpl::SetApplicationLocale(const std::string& locale) {
  locale_ = locale;
  extension_l10n_util::SetProcessLocale(locale);
}

base::WaitableEvent* BrowserProcessImpl::shutdown_event() {
  return shutdown_event_.get();
}

TabCloseableStateWatcher* BrowserProcessImpl::tab_closeable_state_watcher() {
  DCHECK(CalledOnValidThread());
  if (!tab_closeable_state_watcher_.get())
    CreateTabCloseableStateWatcher();
  return tab_closeable_state_watcher_.get();
}

void BrowserProcessImpl::CheckForInspectorFiles() {
  file_thread()->message_loop()->PostTask
      (FROM_HERE,
       NewRunnableMethod(this, &BrowserProcessImpl::DoInspectorFilesCheck));
}

#if (defined(OS_WIN) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
void BrowserProcessImpl::StartAutoupdateTimer() {
  autoupdate_timer_.Start(
      base::TimeDelta::FromHours(kUpdateCheckIntervalHours),
      this,
      &BrowserProcessImpl::OnAutoupdateTimer);
}
#endif

bool BrowserProcessImpl::have_inspector_files() const {
  return have_inspector_files_;
}

  virtual ResourceDispatcherHost* resource_dispatcher_host();
  virtual MetricsService* metrics_service();
  virtual IOThread* io_thread();
  virtual base::Thread* file_thread();
  virtual base::Thread* db_thread();
  virtual base::Thread* process_launcher_thread();
  virtual base::Thread* cache_thread();
  virtual base::Thread* background_x11_thread();
  virtual ProfileManager* profile_manager();
  virtual PrefService* local_state();
  virtual DevToolsManager* devtools_manager();
  virtual Clipboard* clipboard();
  virtual NotificationUIManager* notification_ui_manager();
  virtual StatusTrayManager* status_tray_manager();
  virtual IconManager* icon_manager();
  virtual ThumbnailGenerator* GetThumbnailGenerator();
  virtual AutomationProviderList* InitAutomationProviderList();
  virtual void InitDebuggerWrapper(int port, bool useHttp);
  virtual bool IsShuttingDown();
  virtual GoogleURLTracker* google_url_tracker();
  virtual IntranetRedirectDetector* intranet_redirect_detector();
  virtual const std::string& GetApplicationLocale();
  virtual base::WaitableEvent* shutdown_event();
  virtual TabCloseableStateWatcher* tab_closeable_state_watcher();
  virtual bool have_inspector_files() const;
#include "chrome/browser/browser_process.h"
#include "googleurl/src/gurl.h"
bool VisitedLinkCommon::IsVisited(const GURL& url) const {
  return IsVisited(url.spec().data(), url.spec().size());
}


class GURL;
  bool IsVisited(const GURL& url) const;
#include "chrome/common/dom_storage_common.h"
#include "chrome/common/extensions/extension_extent.h"
#include "chrome/renderer/gpu_channel_host.h"
#include "chrome/renderer/renderer_histogram_snapshots.h"
// Contains extension-related data that the renderer needs to know about.
// TODO(mpcomplete): this doesn't feel like it belongs here. Find a better
// place.
struct RenderThread::ExtensionInfo {
  std::string extension_id;
  ExtensionExtent web_extent;
  ExtensionExtent browse_extent;
};

class GpuChannelHost;
class RendererHistogramSnapshots;
  struct ExtensionInfo;
#include "chrome/browser/automation/automation_provider_list.h"
#include "core/rendering/RenderWidget.h"
            updateWidgetPositions();

void FrameView::addWidget(RenderWidget* object)
{
    m_widgets.add(object);
}

void FrameView::removeWidget(RenderWidget* object)
{
    m_widgets.remove(object);
}

void FrameView::updateWidgetPositions()
{
    Vector<RefPtr<RenderWidget> > widgets;
    copyToVector(m_widgets, widgets);

    // Script or plugins could detach the frame so abort processing if that happens.

    for (size_t i = 0; i < widgets.size() && renderView(); ++i)
        widgets[i]->updateWidgetPosition();

    for (size_t i = 0; i < widgets.size() && renderView(); ++i)
        widgets[i]->widgetPositionsUpdated();
}

    RefPtr<FrameView> protect(this);
        updateWidgetPositions();
        if (RenderView* renderView = this->renderView())
    updateWidgetPositions();

    // Plugins could have torn down the page inside updateWidgetPositions().
    if (!renderView())
        return;
class RenderWidget;
    void addWidget(RenderWidget*);
    void removeWidget(RenderWidget*);
    void updateWidgetPositions();

    // FIXME: These are just "children" of the FrameView and should be RefPtr<Widget> instead.
    HashSet<RefPtr<RenderWidget> > m_widgets;

    ASSERT(frame);
    RefPtr<FrameView> frameView = m_box->frameView();
    InspectorInstrumentation::willScrollLayer(m_box);
    if (!frameView->isInLayout()) {
        // Update regions, scrolling may change the clip of a particular region.
        frameView->updateAnnotatedRegions();
        // FIXME: We shouldn't call updateWidgetPositions() here since it might tear down the render tree,
        // for now we just crash to avoid allowing an attacker to use after free.
        frameView->updateWidgetPositions();
        RELEASE_ASSERT(frameView->renderView());
    // The caret rect needs to be invalidated after scrolling
    frame->selection().setCaretRectNeedsUpdate();

    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->repainter().repaintRect());
    if (repaintContainer)
        quadForFakeMouseMoveEvent = repaintContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
    if (requiresRepaint)
    ASSERT(element);
    frameView()->addWidget(this);
    frameView()->removeWidget(this);
        moveWidgetToParentSoon(m_widget.get(), frameView());
    if (paintInfo.phase != PaintPhaseForeground)
    RefPtr<FrameView> view = mainFrameImpl()->frameView();
    RefPtr<FrameView> view = frame->view();
    bool terminationRequested;
    {
        MutexLocker lock(m_terminationRequestedMutex);
        terminationRequested = m_terminationRequested;
    }
    if (!terminationRequested)
    MutexLocker lock(m_terminationRequestedMutex);
    MutexLocker lock(m_terminationRequestedMutex);
#ifndef ASSERT_DISABLED
    MutexLocker lock(m_terminationRequestedMutex);
#endif
    MutexLocker lock(m_terminationRequestedMutex);
#include "wtf/ThreadingPrimitives.h"

    mutable Mutex m_terminationRequestedMutex;
#include "net/base/net_util.h"
  // Grant navigation to a file but not the file:// scheme in general.
  void GrantRequestOfSpecificFile(const FilePath &file) {
    request_file_set_.insert(file.StripTrailingSeparators());
  }

    FilePath stripped = file.StripTrailingSeparators();
    file_permissions_.erase(stripped);
    request_file_set_.erase(stripped);
  // Determine whether permission has been granted to request |url|.
    // Having permission to a scheme implies permssion to all of its URLs.
    if (judgment != scheme_policy_.end())
      return judgment->second;

    // file:// URLs are more granular.  The child may have been given
    // permission to a specific file but not the file:// scheme in general.
    if (url.SchemeIs(chrome::kFileScheme)) {
      FilePath path;
      if (net::FileURLToFilePath(url, &path))
        return request_file_set_.find(path) != request_file_set_.end();
    }
    return false;  // Unmentioned schemes are disallowed.
  typedef std::set<FilePath> FileSet;
  // The set of files the child process is permitted to load.
  FileSet request_file_set_;

    // When the child process has been commanded to request this scheme,
    // we grant it the capability to request all URLs of that scheme.
void ChildProcessSecurityPolicyImpl::GrantRequestSpecificFileURL(
    int child_id,
    const GURL& url) {
  if (!url.SchemeIs(chrome::kFileScheme))
    return;

  {
    base::AutoLock lock(lock_);
    SecurityStateMap::iterator state = security_state_.find(child_id);
    if (state == security_state_.end())
      return;

    // When the child process has been commanded to request a file:// URL,
    // then we grant it the capability for that URL only.
    FilePath path;
    if (net::FileURLToFilePath(url, &path))
        state->second->GrantRequestOfSpecificFile(path);
  }
}

  // request the URL, along with permission to request all URLs of the same
  // scheme.
  // Whenever the browser process drops a file icon on a tab, it should call
  // this method to grant the child process the capability to request this one
  // file:// URL, but not all urls of the file:// scheme.
  void GrantRequestSpecificFileURL(int child_id, const GURL& url);

TEST_F(ChildProcessSecurityPolicyTest, SpecificFile) {
  ChildProcessSecurityPolicyImpl* p =
      ChildProcessSecurityPolicyImpl::GetInstance();

  p->Add(kRendererID);

  GURL icon_url("file:///tmp/foo.png");
  GURL sensitive_url("file:///etc/passwd");
  EXPECT_FALSE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_FALSE(p->CanRequestURL(kRendererID, sensitive_url));

  p->GrantRequestSpecificFileURL(kRendererID, icon_url);
  EXPECT_TRUE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_FALSE(p->CanRequestURL(kRendererID, sensitive_url));

  p->GrantRequestURL(kRendererID, icon_url);
  EXPECT_TRUE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_TRUE(p->CanRequestURL(kRendererID, sensitive_url));

  p->Remove(kRendererID);
}

    // A dragged file may wind up as the value of an input element, or it
    // may be used as the target of a navigation instead.  We don't know
    // which will happen at this point, so generously grant both access
    // and request permissions to the specific file to cover both cases.
    // We do not give it the permission to request all file:// URLs.
    policy->GrantRequestSpecificFileURL(renderer_id,
                                        net::FilePathToFileURL(path));
#include "base/utf_string_conversions.h"
  FilePath highlighted_file_path(FILE_PATH_LITERAL("/tmp/foo.html"));
  FilePath dragged_file_path(FILE_PATH_LITERAL("/tmp/image.jpg"));
  FilePath sensitive_file_path(FILE_PATH_LITERAL("/etc/passwd"));
  GURL highlighted_file_url = net::FilePathToFileURL(highlighted_file_path);
  GURL dragged_file_url = net::FilePathToFileURL(dragged_file_path);
  GURL sensitive_file_url = net::FilePathToFileURL(sensitive_file_path);
  dropped_data.url = highlighted_file_url;
  dropped_data.filenames.push_back(WebDropData::FileInfo(
      UTF8ToUTF16(dragged_file_path.AsUTF8Unsafe()), string16()));

                              WebKit::WebDragOperationNone, 0);

  int id = process()->GetID();
  ChildProcessSecurityPolicyImpl* policy =
      ChildProcessSecurityPolicyImpl::GetInstance();

  EXPECT_FALSE(policy->CanRequestURL(id, highlighted_file_url));
  EXPECT_FALSE(policy->CanReadFile(id, highlighted_file_path));
  EXPECT_TRUE(policy->CanRequestURL(id, dragged_file_url));
  EXPECT_TRUE(policy->CanReadFile(id, dragged_file_path));
  EXPECT_FALSE(policy->CanRequestURL(id, sensitive_file_url));
  EXPECT_FALSE(policy->CanReadFile(id, sensitive_file_path));
  // Use the frame's original request's URL rather than the document's URL for
  // subsequent checks.  For a popup, the document's URL may become the opener
  // window's URL if the opener has called document.write().
  // See http://crbug.com/93517.
  GURL old_url(frame->dataSource()->request().url());

    // Lastly, access to file:// URLs from non-file:// URL pages must be
    // handled by the browser so that ordinary renderer processes don't get
    // blessed with file permissions.
    int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
    bool is_initial_navigation = page_id_ == -1;
    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      // Fork non-file to file opens.  Check the opener URL if this is the
      // initial navigation in a newly opened window.
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

#include "chrome/browser/automation/automation_provider_list.h"
#include "chrome/browser/automation/automation_provider_list.h"
ResourceDispatcherHost* BrowserProcessImpl::resource_dispatcher_host() {
  DCHECK(CalledOnValidThread());
  if (!created_resource_dispatcher_host_)
    CreateResourceDispatcherHost();
  return resource_dispatcher_host_.get();
}

MetricsService* BrowserProcessImpl::metrics_service() {
  DCHECK(CalledOnValidThread());
  if (!created_metrics_service_)
    CreateMetricsService();
  return metrics_service_.get();
}

IOThread* BrowserProcessImpl::io_thread() {
  DCHECK(CalledOnValidThread());
  if (!created_io_thread_)
    CreateIOThread();
  return io_thread_.get();
}

base::Thread* BrowserProcessImpl::file_thread() {
  DCHECK(CalledOnValidThread());
  if (!created_file_thread_)
    CreateFileThread();
  return file_thread_.get();
}

base::Thread* BrowserProcessImpl::db_thread() {
  DCHECK(CalledOnValidThread());
  if (!created_db_thread_)
    CreateDBThread();
  return db_thread_.get();
}

base::Thread* BrowserProcessImpl::process_launcher_thread() {
  DCHECK(CalledOnValidThread());
  if (!created_process_launcher_thread_)
    CreateProcessLauncherThread();
  return process_launcher_thread_.get();
}

base::Thread* BrowserProcessImpl::cache_thread() {
  DCHECK(CalledOnValidThread());
  if (!created_cache_thread_)
    CreateCacheThread();
  return cache_thread_.get();
}

#if defined(USE_X11)
base::Thread* BrowserProcessImpl::background_x11_thread() {
  DCHECK(CalledOnValidThread());
  // The BACKGROUND_X11 thread is created when the IO thread is created.
  if (!created_io_thread_)
    CreateIOThread();
  return background_x11_thread_.get();
}
#endif

ProfileManager* BrowserProcessImpl::profile_manager() {
  DCHECK(CalledOnValidThread());
  if (!created_profile_manager_)
    CreateProfileManager();
  return profile_manager_.get();
}

PrefService* BrowserProcessImpl::local_state() {
  DCHECK(CalledOnValidThread());
  if (!created_local_state_)
    CreateLocalState();
  return local_state_.get();
}

DevToolsManager* BrowserProcessImpl::devtools_manager() {
  DCHECK(CalledOnValidThread());
  if (!created_devtools_manager_)
    CreateDevToolsManager();
  return devtools_manager_.get();
}

Clipboard* BrowserProcessImpl::clipboard() {
  DCHECK(CalledOnValidThread());
  return clipboard_.get();
}

NotificationUIManager* BrowserProcessImpl::notification_ui_manager() {
  DCHECK(CalledOnValidThread());
  if (!created_notification_ui_manager_)
    CreateNotificationUIManager();
  return notification_ui_manager_.get();
}

StatusTrayManager* BrowserProcessImpl::status_tray_manager() {
  DCHECK(CalledOnValidThread());
  if (!status_tray_manager_.get())
    CreateStatusTrayManager();
  return status_tray_manager_.get();
}

IconManager* BrowserProcessImpl::icon_manager() {
  DCHECK(CalledOnValidThread());
  if (!created_icon_manager_)
    CreateIconManager();
  return icon_manager_.get();
}

ThumbnailGenerator* BrowserProcessImpl::GetThumbnailGenerator() {
  return &thumbnail_generator_;
}

AutomationProviderList* BrowserProcessImpl::InitAutomationProviderList() {
  DCHECK(CalledOnValidThread());
  if (automation_provider_list_.get() == NULL) {
    automation_provider_list_.reset(AutomationProviderList::GetInstance());
  }
  return automation_provider_list_.get();
}

void BrowserProcessImpl::InitDebuggerWrapper(int port, bool useHttp) {
  DCHECK(CalledOnValidThread());
  if (!created_debugger_wrapper_)
    CreateDebuggerWrapper(port, useHttp);
}

bool BrowserProcessImpl::IsShuttingDown() {
  DCHECK(CalledOnValidThread());
  return did_start_ && 0 == module_ref_count_;
}

GoogleURLTracker* BrowserProcessImpl::google_url_tracker() {
  DCHECK(CalledOnValidThread());
  if (!google_url_tracker_.get())
    CreateGoogleURLTracker();
  return google_url_tracker_.get();
}

IntranetRedirectDetector* BrowserProcessImpl::intranet_redirect_detector() {
  DCHECK(CalledOnValidThread());
  if (!intranet_redirect_detector_.get())
    CreateIntranetRedirectDetector();
  return intranet_redirect_detector_.get();
}

const std::string& BrowserProcessImpl::GetApplicationLocale() {
  DCHECK(!locale_.empty());
  return locale_;
}

void BrowserProcessImpl::SetApplicationLocale(const std::string& locale) {
  locale_ = locale;
  extension_l10n_util::SetProcessLocale(locale);
}

base::WaitableEvent* BrowserProcessImpl::shutdown_event() {
  return shutdown_event_.get();
}

TabCloseableStateWatcher* BrowserProcessImpl::tab_closeable_state_watcher() {
  DCHECK(CalledOnValidThread());
  if (!tab_closeable_state_watcher_.get())
    CreateTabCloseableStateWatcher();
  return tab_closeable_state_watcher_.get();
}

void BrowserProcessImpl::CheckForInspectorFiles() {
  file_thread()->message_loop()->PostTask
      (FROM_HERE,
       NewRunnableMethod(this, &BrowserProcessImpl::DoInspectorFilesCheck));
}

#if (defined(OS_WIN) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
void BrowserProcessImpl::StartAutoupdateTimer() {
  autoupdate_timer_.Start(
      base::TimeDelta::FromHours(kUpdateCheckIntervalHours),
      this,
      &BrowserProcessImpl::OnAutoupdateTimer);
}
#endif

bool BrowserProcessImpl::have_inspector_files() const {
  return have_inspector_files_;
}

  virtual ResourceDispatcherHost* resource_dispatcher_host();
  virtual MetricsService* metrics_service();
  virtual IOThread* io_thread();
  virtual base::Thread* file_thread();
  virtual base::Thread* db_thread();
  virtual base::Thread* process_launcher_thread();
  virtual base::Thread* cache_thread();
  virtual base::Thread* background_x11_thread();
  virtual ProfileManager* profile_manager();
  virtual PrefService* local_state();
  virtual DevToolsManager* devtools_manager();
  virtual Clipboard* clipboard();
  virtual NotificationUIManager* notification_ui_manager();
  virtual StatusTrayManager* status_tray_manager();
  virtual IconManager* icon_manager();
  virtual ThumbnailGenerator* GetThumbnailGenerator();
  virtual AutomationProviderList* InitAutomationProviderList();
  virtual void InitDebuggerWrapper(int port, bool useHttp);
  virtual bool IsShuttingDown();
  virtual GoogleURLTracker* google_url_tracker();
  virtual IntranetRedirectDetector* intranet_redirect_detector();
  virtual const std::string& GetApplicationLocale();
  virtual base::WaitableEvent* shutdown_event();
  virtual TabCloseableStateWatcher* tab_closeable_state_watcher();
  virtual bool have_inspector_files() const;
#include "chrome/browser/browser_process.h"
#include "googleurl/src/gurl.h"
bool VisitedLinkCommon::IsVisited(const GURL& url) const {
  return IsVisited(url.spec().data(), url.spec().size());
}


class GURL;
  bool IsVisited(const GURL& url) const;
#include "chrome/common/dom_storage_common.h"
#include "chrome/common/extensions/extension_extent.h"
#include "chrome/renderer/gpu_channel_host.h"
#include "chrome/renderer/renderer_histogram_snapshots.h"
// Contains extension-related data that the renderer needs to know about.
// TODO(mpcomplete): this doesn't feel like it belongs here. Find a better
// place.
struct RenderThread::ExtensionInfo {
  std::string extension_id;
  ExtensionExtent web_extent;
  ExtensionExtent browse_extent;
};

class GpuChannelHost;
class RendererHistogramSnapshots;
  struct ExtensionInfo;
#include "chrome/browser/automation/automation_provider_list.h"
  if (!current_color_chooser_)
    current_color_chooser_ = new ColorChooserWin(web_contents, initial_color);
  return current_color_chooser_;
bool BitReader::SkipBits(int num_bits) {
  DCHECK_GE(num_bits, 0);
  DLOG_IF(INFO, num_bits > 100)
      << "BitReader::SkipBits inefficient for large skips";

  // Skip any bits in the current byte waiting to be processed, then
  // process full bytes until less than 8 bits remaining.
  while (num_bits > 0 && num_bits > num_remaining_bits_in_curr_byte_) {
    num_bits -= num_remaining_bits_in_curr_byte_;
    num_remaining_bits_in_curr_byte_ = 0;
    UpdateCurrByte();

    // If there is no more data remaining, only return true if we
    // skipped all that were requested.
    if (num_remaining_bits_in_curr_byte_ == 0)
      return (num_bits == 0);
  }

  // Less than 8 bits remaining to skip. Use ReadBitsInternal to verify
  // that the remaining bits we need exist, and adjust them as necessary
  // for subsequent operations.
  uint64 not_needed;
  return ReadBitsInternal(num_bits, &not_needed);
}

  // Skip |num_bits| next bits from stream. Return false if the given number of
  // bits cannot be skipped (not enough bits in the stream), true otherwise.
  // When return false, the stream will enter a state where further ReadBits/
  // SkipBits operations will always return false unless |num_bits| is 0.
  bool SkipBits(int num_bits);

TEST(BitReaderTest, SkipBitsTest) {
  uint8 value8;
  uint8 buffer[] = { 0x0a, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
  BitReader reader1(buffer, sizeof(buffer));

  EXPECT_TRUE(reader1.SkipBits(2));
  EXPECT_TRUE(reader1.ReadBits(3, &value8));
  EXPECT_EQ(value8, 1);
  EXPECT_TRUE(reader1.SkipBits(11));
  EXPECT_TRUE(reader1.ReadBits(8, &value8));
  EXPECT_EQ(value8, 3);
  EXPECT_TRUE(reader1.SkipBits(76));
  EXPECT_TRUE(reader1.ReadBits(4, &value8));
  EXPECT_EQ(value8, 13);
  EXPECT_FALSE(reader1.SkipBits(100));
  EXPECT_TRUE(reader1.SkipBits(0));
  EXPECT_FALSE(reader1.SkipBits(1));
}

// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "media/base/container_names.h"

#include <cctype>
#include <limits>

#include "base/basictypes.h"
#include "base/logging.h"
#include "media/base/bit_reader.h"

namespace media {

namespace container_names {

#define TAG(a, b, c, d) \
    ((static_cast<uint8>(a) << 24) | (static_cast<uint8>(b) << 16) | \
     (static_cast<uint8>(c) << 8) | (static_cast<uint8>(d)))

#define RCHECK(x)     \
    do {              \
      if (!(x))       \
        return false; \
    } while (0)

#define UTF8_BYTE_ORDER_MARK "\xef\xbb\xbf"

// Helper function to read 2 bytes (16 bits, big endian) from a buffer.
static int Read16(const uint8* p) {
  return p[0] << 8 | p[1];
}

// Helper function to read 3 bytes (24 bits, big endian) from a buffer.
static uint32 Read24(const uint8* p) {
  return p[0] << 16 | p[1] << 8 | p[2];
}

// Helper function to read 4 bytes (32 bits, big endian) from a buffer.
static uint32 Read32(const uint8* p) {
  return p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3];
}

// Helper function to read 4 bytes (32 bits, little endian) from a buffer.
static uint32 Read32LE(const uint8* p) {
  return p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
}

// Helper function to do buffer comparisons with a string without going off the
// end of the buffer.
static bool StartsWith(const uint8* buffer,
                       size_t buffer_size,
                       const char* prefix) {
  size_t prefix_size = strlen(prefix);
  return (prefix_size <= buffer_size &&
          memcmp(buffer, prefix, prefix_size) == 0);
}

// Helper function to do buffer comparisons with another buffer (to allow for
// embedded \0 in the comparison) without going off the end of the buffer.
static bool StartsWith(const uint8* buffer,
                       size_t buffer_size,
                       const uint8* prefix,
                       size_t prefix_size) {
  return (prefix_size <= buffer_size &&
          memcmp(buffer, prefix, prefix_size) == 0);
}

// Helper function to read up to 64 bits from a bit stream.
static uint64 ReadBits(BitReader* reader, int num_bits) {
  DCHECK_GE(reader->bits_available(), num_bits);
  DCHECK((num_bits > 0) && (num_bits <= 64));
  uint64 value;
  reader->ReadBits(num_bits, &value);
  return value;
}

const int kAc3FrameSizeTable[38][3] = {
  { 128, 138, 192 }, { 128, 140, 192 }, { 160, 174, 240 }, { 160, 176, 240 },
  { 192, 208, 288 }, { 192, 210, 288 }, { 224, 242, 336 }, { 224, 244, 336 },
  { 256, 278, 384 }, { 256, 280, 384 }, { 320, 348, 480 }, { 320, 350, 480 },
  { 384, 416, 576 }, { 384, 418, 576 }, { 448, 486, 672 }, { 448, 488, 672 },
  { 512, 556, 768 }, { 512, 558, 768 }, { 640, 696, 960 }, { 640, 698, 960 },
  { 768, 834, 1152 }, { 768, 836, 1152 }, { 896, 974, 1344 },
  { 896, 976, 1344 }, { 1024, 1114, 1536 }, { 1024, 1116, 1536 },
  { 1280, 1392, 1920 }, { 1280, 1394, 1920 }, { 1536, 1670, 2304 },
  { 1536, 1672, 2304 }, { 1792, 1950, 2688 }, { 1792, 1952, 2688 },
  { 2048, 2228, 3072 }, { 2048, 2230, 3072 }, { 2304, 2506, 3456 },
  { 2304, 2508, 3456 }, { 2560, 2768, 3840 }, { 2560, 2770, 3840 }
};

// Checks for an ADTS AAC container.
static bool CheckAac(const uint8* buffer, int buffer_size) {
  // Audio Data Transport Stream (ADTS) header is 7 or 9 bytes
  // (from http://wiki.multimedia.cx/index.php?title=ADTS)
  RCHECK(buffer_size > 6);

  int offset = 0;
  while (offset + 6 < buffer_size) {
    BitReader reader(buffer + offset, 6);

    // Syncword must be 0xfff.
    RCHECK(ReadBits(&reader, 12) == 0xfff);

    // Skip MPEG version.
    reader.SkipBits(1);

    // Layer is always 0.
    RCHECK(ReadBits(&reader, 2) == 0);

    // Skip protection + profile.
    reader.SkipBits(1 + 2);

    // Check sampling frequency index.
    RCHECK(ReadBits(&reader, 4) != 15);  // Forbidden.

    // Skip private stream, channel configuration, originality, home,
    // copyrighted stream, and copyright_start.
    reader.SkipBits(1 + 3 + 1 + 1 + 1 + 1);

    // Get frame length (includes header).
    int size = ReadBits(&reader, 13);
    RCHECK(size > 0);
    offset += size;
  }
  return true;
}

const uint16 kAc3SyncWord = 0x0b77;

// Checks for an AC3 container.
static bool CheckAc3(const uint8* buffer, int buffer_size) {
  // Reference: ATSC Standard: Digital Audio Compression (AC-3, E-AC-3)
  //            Doc. A/52:2012
  // (http://www.atsc.org/cms/standards/A52-2012(12-17).pdf)

  // AC3 container looks like syncinfo | bsi | audblk * 6 | aux | check.
  RCHECK(buffer_size > 6);

  int offset = 0;
  while (offset + 6 < buffer_size) {
    BitReader reader(buffer + offset, 6);

    // Check syncinfo.
    RCHECK(ReadBits(&reader, 16) == kAc3SyncWord);

    // Skip crc1.
    reader.SkipBits(16);

    // Verify fscod.
    int sample_rate_code = ReadBits(&reader, 2);
    RCHECK(sample_rate_code != 3);  // Reserved.

    // Verify frmsizecod.
    int frame_size_code = ReadBits(&reader, 6);
    RCHECK(frame_size_code < 38);  // Undefined.

    // Verify bsid.
    RCHECK(ReadBits(&reader, 5) < 10);  // Normally 8 or 6, 16 used by EAC3.

    offset += kAc3FrameSizeTable[frame_size_code][sample_rate_code];
  }
  return true;
}

// Checks for an EAC3 container (very similar to AC3)
static bool CheckEac3(const uint8* buffer, int buffer_size) {
  // Reference: ATSC Standard: Digital Audio Compression (AC-3, E-AC-3)
  //            Doc. A/52:2012
  // (http://www.atsc.org/cms/standards/A52-2012(12-17).pdf)

  // EAC3 container looks like syncinfo | bsi | audfrm | audblk* | aux | check.
  RCHECK(buffer_size > 6);

  int offset = 0;
  while (offset + 6 < buffer_size) {
    BitReader reader(buffer + offset, 6);

    // Check syncinfo.
    RCHECK(ReadBits(&reader, 16) == kAc3SyncWord);

    // Verify strmtyp.
    RCHECK(ReadBits(&reader, 2) != 3);

    // Skip substreamid.
    reader.SkipBits(3);

    // Get frmsize. Include syncinfo size and convert to bytes.
    int frame_size = (ReadBits(&reader, 11) + 1) * 2;
    RCHECK(frame_size >= 7);

    // Skip fscod, fscod2, acmod, and lfeon.
    reader.SkipBits(2 + 2 + 3 + 1);

    // Verify bsid.
    int bit_stream_id = ReadBits(&reader, 5);
    RCHECK(bit_stream_id >= 11 && bit_stream_id <= 16);

    offset += frame_size;
  }
  return true;
}

// Additional checks for a BINK container.
static bool CheckBink(const uint8* buffer, int buffer_size) {
  // Reference: http://wiki.multimedia.cx/index.php?title=Bink_Container
  RCHECK(buffer_size >= 44);

  // Verify number of frames specified.
  RCHECK(Read32LE(buffer + 8) > 0);

  // Verify width in range.
  int width = Read32LE(buffer + 20);
  RCHECK(width > 0 && width <= 32767);

  // Verify height in range.
  int height = Read32LE(buffer + 24);
  RCHECK(height > 0 && height <= 32767);

  // Verify frames per second specified.
  RCHECK(Read32LE(buffer + 28) > 0);

  // Verify video frames per second specified.
  RCHECK(Read32LE(buffer + 32) > 0);

  // Number of audio tracks must be 256 or less.
  return (Read32LE(buffer + 40) <= 256);
}

// Additional checks for a CAF container.
static bool CheckCaf(const uint8* buffer, int buffer_size) {
  // Reference: Apple Core Audio Format Specification 1.0
  // (http://goo.gl/Vgb9r)
  RCHECK(buffer_size >= 52);
  BitReader reader(buffer, buffer_size);

  // mFileType should be "caff".
  RCHECK(ReadBits(&reader, 32) == TAG('c', 'a', 'f', 'f'));

  // mFileVersion should be 1.
  RCHECK(ReadBits(&reader, 16) == 1);

  // Skip mFileFlags.
  reader.SkipBits(16);

  // First chunk should be Audio Description chunk, size 32l.
  RCHECK(ReadBits(&reader, 32) == TAG('d', 'e', 's', 'c'));
  RCHECK(ReadBits(&reader, 64) == 32);

  // CAFAudioFormat.mSampleRate(float64) not 0
  RCHECK(ReadBits(&reader, 64) != 0);

  // CAFAudioFormat.mFormatID not 0
  RCHECK(ReadBits(&reader, 32) != 0);

  // Skip CAFAudioFormat.mBytesPerPacket and mFramesPerPacket.
  reader.SkipBits(32 + 32);

  // CAFAudioFormat.mChannelsPerFrame not 0
  RCHECK(ReadBits(&reader, 32) != 0);
  return true;
}

static bool kSamplingFrequencyValid[16] = { false, true, true, true, false,
                                            false, true, true, true, false,
                                            false, true, true, true, false,
                                            false };
static bool kExtAudioIdValid[8] = { true, false, true, false, false, false,
                                    true, false };

// Additional checks for a DTS container.
static bool CheckDts(const uint8* buffer, int buffer_size) {
  // Reference: ETSI TS 102 114 V1.3.1 (2011-08)
  // (http://goo.gl/FhHrk)
  RCHECK(buffer_size > 11);

  int offset = 0;
  while (offset + 11 < buffer_size) {
    BitReader reader(buffer + offset, 11);

    // Verify sync word.
    RCHECK(ReadBits(&reader, 32) == 0x7ffe8001);

    // Skip frame type and deficit sample count.
    reader.SkipBits(1 + 5);

    // Verify CRC present flag.
    RCHECK(ReadBits(&reader, 1) == 0);  // CPF must be 0.

    // Verify number of PCM sample blocks.
    RCHECK(ReadBits(&reader, 7) >= 5);

    // Verify primary frame byte size.
    int frame_size = ReadBits(&reader, 14);
    RCHECK(frame_size >= 95);

    // Skip audio channel arrangement.
    reader.SkipBits(6);

    // Verify core audio sampling frequency is an allowed value.
    RCHECK(kSamplingFrequencyValid[ReadBits(&reader, 4)]);

    // Verify transmission bit rate is valid.
    RCHECK(ReadBits(&reader, 5) <= 25);

    // Verify reserved field is 0.
    RCHECK(ReadBits(&reader, 1) == 0);

    // Skip dynamic range flag, time stamp flag, auxiliary data flag, and HDCD.
    reader.SkipBits(1 + 1 + 1 + 1);

    // Verify extension audio descriptor flag is an allowed value.
    RCHECK(kExtAudioIdValid[ReadBits(&reader, 3)]);

    // Skip extended coding flag and audio sync word insertion flag.
    reader.SkipBits(1 + 1);

    // Verify low frequency effects flag is an allowed value.
    RCHECK(ReadBits(&reader, 2) != 3);

    offset += frame_size + 1;
  }
  return true;
}

// Checks for a DV container.
static bool CheckDV(const uint8* buffer, int buffer_size) {
  // Reference: SMPTE 314M (Annex A has differences with IEC 61834).
  // (http://goo.gl/kMn6p)
  RCHECK(buffer_size > 11);

  int offset = 0;
  int current_sequence_number = -1;
  int last_block_number[6];
  while (offset + 11 < buffer_size) {
    BitReader reader(buffer + offset, 11);

    // Decode ID data. Sections 5, 6, and 7 are reserved.
    int section = ReadBits(&reader, 3);
    RCHECK(section < 5);

    // Next bit must be 1.
    RCHECK(ReadBits(&reader, 1) == 1);

    // Skip arbitrary bits.
    reader.SkipBits(4);

    int sequence_number = ReadBits(&reader, 4);

    // Skip FSC.
    reader.SkipBits(1);

    // Next 3 bits must be 1.
    RCHECK(ReadBits(&reader, 3) == 7);

    int block_number = ReadBits(&reader, 8);

    if (section == 0) {  // Header.
      // Validate the reserved bits in the next 8 bytes.
      reader.SkipBits(1);
      RCHECK(ReadBits(&reader, 1) == 0);
      RCHECK(ReadBits(&reader, 11) == 0x7ff);
      reader.SkipBits(4);
      RCHECK(ReadBits(&reader, 4) == 0xf);
      reader.SkipBits(4);
      RCHECK(ReadBits(&reader, 4) == 0xf);
      reader.SkipBits(4);
      RCHECK(ReadBits(&reader, 4) == 0xf);
      reader.SkipBits(3);
      RCHECK(ReadBits(&reader, 24) == 0xffffff);
      current_sequence_number = sequence_number;
      for (size_t i = 0; i < arraysize(last_block_number); ++i)
        last_block_number[i] = -1;
    } else {
      // Sequence number must match (this will also fail if no header seen).
      RCHECK(sequence_number == current_sequence_number);
      // Block number should be increasing.
      RCHECK(block_number > last_block_number[section]);
      last_block_number[section] = block_number;
    }

    // Move to next block.
    offset += 80;
  }
  return true;
}


// Checks for a GSM container.
static bool CheckGsm(const uint8* buffer, int buffer_size) {
  // Reference: ETSI EN 300 961 V8.1.1
  // (http://goo.gl/h2VDS)
  // also http://tools.ietf.org/html/rfc3551#page-24
  // GSM files have a 33 byte block, only first 4 bits are fixed.
  RCHECK(buffer_size >= 1024);  // Need enough data to do a decent check.

  int offset = 0;
  while (offset < buffer_size) {
    // First 4 bits of each block are xD.
    RCHECK((buffer[offset] & 0xf0) == 0xd0);
    offset += 33;
  }
  return true;
}

// Advance to the first set of |num_bits| bits that match |start_code|. |offset|
// is the current location in the buffer, and is updated. |bytes_needed| is the
// number of bytes that must remain in the buffer when |start_code| is found.
// Returns true if start_code found (and enough space in the buffer after it),
// false otherwise.
static bool AdvanceToStartCode(const uint8* buffer,
                               int buffer_size,
                               int* offset,
                               int bytes_needed,
                               int num_bits,
                               uint32 start_code) {
  DCHECK_GE(bytes_needed, 3);
  DCHECK_LE(num_bits, 24);  // Only supports up to 24 bits.

  // Create a mask to isolate |num_bits| bits, once shifted over.
  uint32 bits_to_shift = 24 - num_bits;
  uint32 mask = (1 << num_bits) - 1;
  while (*offset + bytes_needed < buffer_size) {
    uint32 next = Read24(buffer + *offset);
    if (((next >> bits_to_shift) & mask) == start_code)
      return true;
    ++(*offset);
  }
  return false;
}

// Checks for an H.261 container.
static bool CheckH261(const uint8* buffer, int buffer_size) {
  // Reference: ITU-T Recommendation H.261 (03/1993)
  // (http://www.itu.int/rec/T-REC-H.261-199303-I/en)
  RCHECK(buffer_size > 16);

  int offset = 0;
  bool seen_start_code = false;
  while (true) {
    // Advance to picture_start_code, if there is one.
    if (!AdvanceToStartCode(buffer, buffer_size, &offset, 4, 20, 0x10)) {
      // No start code found (or off end of buffer), so success if
      // there was at least one valid header.
      return seen_start_code;
    }

    // Now verify the block. AdvanceToStartCode() made sure that there are
    // at least 4 bytes remaining in the buffer.
    BitReader reader(buffer + offset, buffer_size - offset);
    RCHECK(ReadBits(&reader, 20) == 0x10);

    // Skip the temporal reference and PTYPE.
    reader.SkipBits(5 + 6);

    // Skip any extra insertion information. Since this is open-ended, if we run
    // out of bits assume that the buffer is correctly formatted.
    int extra = ReadBits(&reader, 1);
    while (extra == 1) {
      if (!reader.SkipBits(8))
        return seen_start_code;
      if (!reader.ReadBits(1, &extra))
        return seen_start_code;
    }

    // Next should be a Group of Blocks start code. Again, if we run out of
    // bits, then assume that the buffer up to here is correct, and the buffer
    // just happened to end in the middle of a header.
    int next;
    if (!reader.ReadBits(16, &next))
      return seen_start_code;
    RCHECK(next == 1);

    // Move to the next block.
    seen_start_code = true;
    offset += 4;
  }
}

// Checks for an H.263 container.
static bool CheckH263(const uint8* buffer, int buffer_size) {
  // Reference: ITU-T Recommendation H.263 (01/2005)
  // (http://www.itu.int/rec/T-REC-H.263-200501-I/en)
  // header is PSC(22b) + TR(8b) + PTYPE(8+b).
  RCHECK(buffer_size > 16);

  int offset = 0;
  bool seen_start_code = false;
  while (true) {
    // Advance to picture_start_code, if there is one.
    if (!AdvanceToStartCode(buffer, buffer_size, &offset, 9, 22, 0x20)) {
      // No start code found (or off end of buffer), so success if
      // there was at least one valid header.
      return seen_start_code;
    }

    // Now verify the block. AdvanceToStartCode() made sure that there are
    // at least 9 bytes remaining in the buffer.
    BitReader reader(buffer + offset, 9);
    RCHECK(ReadBits(&reader, 22) == 0x20);

    // Skip the temporal reference.
    reader.SkipBits(8);

    // Verify that the first 2 bits of PTYPE are 10b.
    RCHECK(ReadBits(&reader, 2) == 2);

    // Skip the split screen indicator, document camera indicator, and full
    // picture freeze release.
    reader.SkipBits(1 + 1 + 1);

    // Verify Source Format.
    int format = ReadBits(&reader, 3);
    RCHECK(format != 0 && format != 6);  // Forbidden or reserved.

    if (format == 7) {
      // Verify full extended PTYPE.
      int ufep = ReadBits(&reader, 3);
      if (ufep == 1) {
        // Verify the optional part of PLUSPTYPE.
        format = ReadBits(&reader, 3);
        RCHECK(format != 0 && format != 7);  // Reserved.
        reader.SkipBits(11);
        // Next 4 bits should be b1000.
        RCHECK(ReadBits(&reader, 4) == 8);  // Not allowed.
      } else {
        RCHECK(ufep == 0);  // Only 0 and 1 allowed.
      }

      // Verify picture type code is not a reserved value.
      int picture_type_code = ReadBits(&reader, 3);
      RCHECK(picture_type_code != 6 && picture_type_code != 7);  // Reserved.

      // Skip picture resampling mode, reduced resolution mode,
      // and rounding type.
      reader.SkipBits(1 + 1 + 1);

      // Next 3 bits should be b001.
      RCHECK(ReadBits(&reader, 3) == 1);  // Not allowed.
    }

    // Move to the next block.
    seen_start_code = true;
    offset += 9;
  }
}

// Checks for an H.264 container.
static bool CheckH264(const uint8* buffer, int buffer_size) {
  // Reference: ITU-T Recommendation H.264 (01/2012)
  // (http://www.itu.int/rec/T-REC-H.264)
  // Section B.1: Byte stream NAL unit syntax and semantics.
  RCHECK(buffer_size > 4);

  int offset = 0;
  int parameter_count = 0;
  while (true) {
    // Advance to picture_start_code, if there is one.
    if (!AdvanceToStartCode(buffer, buffer_size, &offset, 4, 24, 1)) {
      // No start code found (or off end of buffer), so success if
      // there was at least one valid header.
      return parameter_count > 0;
    }

    // Now verify the block. AdvanceToStartCode() made sure that there are
    // at least 4 bytes remaining in the buffer.
    BitReader reader(buffer + offset, 4);
    RCHECK(ReadBits(&reader, 24) == 1);

    // Verify forbidden_zero_bit.
    RCHECK(ReadBits(&reader, 1) == 0);

    // Extract nal_ref_idc and nal_unit_type.
    int nal_ref_idc = ReadBits(&reader, 2);
    int nal_unit_type = ReadBits(&reader, 5);

    switch (nal_unit_type) {
      case 5:  // Coded slice of an IDR picture.
        RCHECK(nal_ref_idc != 0);
        break;
      case 6:   // Supplemental enhancement information (SEI).
      case 9:   // Access unit delimiter.
      case 10:  // End of sequence.
      case 11:  // End of stream.
      case 12:  // Filler data.
        RCHECK(nal_ref_idc == 0);
        break;
      case 7:  // Sequence parameter set.
      case 8:  // Picture parameter set.
        ++parameter_count;
        break;
    }

    // Skip the current start_code_prefix and move to the next.
    offset += 4;
  }
}

static const char kHlsSignature[] = "#EXTM3U";
static const char kHls1[] = "#EXT-X-STREAM-INF:";
static const char kHls2[] = "#EXT-X-TARGETDURATION:";
static const char kHls3[] = "#EXT-X-MEDIA-SEQUENCE:";

// Additional checks for a HLS container.
static bool CheckHls(const uint8* buffer, int buffer_size) {
  // HLS is simply a play list used for Apple HTTP Live Streaming.
  // Reference: Apple HTTP Live Streaming Overview
  // (http://goo.gl/MIwxj)

  if (StartsWith(buffer, buffer_size, kHlsSignature)) {
    // Need to find "#EXT-X-STREAM-INF:", "#EXT-X-TARGETDURATION:", or
    // "#EXT-X-MEDIA-SEQUENCE:" somewhere in the buffer. Other playlists (like
    // WinAmp) only have additional lines with #EXTINF
    // (http://en.wikipedia.org/wiki/M3U).
    int offset = strlen(kHlsSignature);
    while (offset < buffer_size) {
      if (buffer[offset] == '#') {
        if (StartsWith(buffer + offset, buffer_size - offset, kHls1) ||
            StartsWith(buffer + offset, buffer_size - offset, kHls2) ||
            StartsWith(buffer + offset, buffer_size - offset, kHls3)) {
          return true;
        }
      }
      ++offset;
    }
  }
  return false;
}

// Checks for a MJPEG stream.
static bool CheckMJpeg(const uint8* buffer, int buffer_size) {
  // Reference: ISO/IEC 10918-1 : 1993(E), Annex B
  // (http://www.w3.org/Graphics/JPEG/itu-t81.pdf)
  RCHECK(buffer_size >= 16);

  int offset = 0;
  int last_restart = -1;
  int num_codes = 0;
  while (offset + 5 < buffer_size) {
    // Marker codes are always a two byte code with the first byte xFF.
    RCHECK(buffer[offset] == 0xff);
    uint8 code = buffer[offset + 1];
    RCHECK(code >= 0xc0 || code == 1);

    // Skip sequences of xFF.
    if (code == 0xff) {
      ++offset;
      continue;
    }

    // Success if the next marker code is EOI (end of image)
    if (code == 0xd9)
      return true;

    // Check remaining codes.
    if (code == 0xd8 || code == 1) {
      // SOI (start of image) / TEM (private use). No other data with header.
      offset += 2;
    } else if (code >= 0xd0 && code <= 0xd7) {
      // RST (restart) codes must be in sequence. No other data with header.
      int restart = code & 0x07;
      if (last_restart >= 0)
        RCHECK(restart == (last_restart + 1) % 8);
      last_restart = restart;
      offset += 2;
    } else {
      // All remaining marker codes are followed by a length of the header.
      int length = Read16(buffer + offset + 2) + 2;

      // Special handling of SOS (start of scan) marker since the entropy
      // coded data follows the SOS. Any xFF byte in the data block must be
      // followed by x00 in the data.
      if (code == 0xda) {
        int number_components = buffer[offset + 4];
        RCHECK(length == 8 + 2 * number_components);

        // Advance to the next marker.
        offset += length;
        while (offset + 2 < buffer_size) {
          if (buffer[offset] == 0xff && buffer[offset + 1] != 0)
            break;
          ++offset;
        }
      } else {
        // Skip over the marker data for the other marker codes.
        offset += length;
      }
    }
    ++num_codes;
  }
  return (num_codes > 1);
}

enum Mpeg2StartCodes {
  PROGRAM_END_CODE = 0xb9,
  PACK_START_CODE = 0xba
};

// Checks for a MPEG2 Program Stream.
static bool CheckMpeg2ProgramStream(const uint8* buffer, int buffer_size) {
  // Reference: ISO/IEC 13818-1 : 2000 (E) / ITU-T Rec. H.222.0 (2000 E).
  RCHECK(buffer_size > 14);

  int offset = 0;
  while (offset + 14 < buffer_size) {
    BitReader reader(buffer + offset, 14);

    // Must start with pack_start_code.
    RCHECK(ReadBits(&reader, 24) == 1);
    RCHECK(ReadBits(&reader, 8) == PACK_START_CODE);

    // Determine MPEG version (MPEG1 has b0010, while MPEG2 has b01).
    int mpeg_version = ReadBits(&reader, 2);
    if (mpeg_version == 0) {
      // MPEG1, 10 byte header
      // Validate rest of version code
      RCHECK(ReadBits(&reader, 2) == 2);
    } else {
      RCHECK(mpeg_version == 1);
    }

    // Skip system_clock_reference_base [32..30].
    reader.SkipBits(3);

    // Verify marker bit.
    RCHECK(ReadBits(&reader, 1) == 1);

    // Skip system_clock_reference_base [29..15].
    reader.SkipBits(15);

    // Verify next marker bit.
    RCHECK(ReadBits(&reader, 1) == 1);

    // Skip system_clock_reference_base [14..0].
    reader.SkipBits(15);

    // Verify next marker bit.
    RCHECK(ReadBits(&reader, 1) == 1);

    if (mpeg_version == 0) {
      // Verify second marker bit.
      RCHECK(ReadBits(&reader, 1) == 1);

      // Skip mux_rate.
      reader.SkipBits(22);

      // Verify next marker bit.
      RCHECK(ReadBits(&reader, 1) == 1);

      // Update offset to be after this header.
      offset += 12;
    } else {
      // Must be MPEG2.
      // Skip program_mux_rate.
      reader.SkipBits(22);

      // Verify pair of marker bits.
      RCHECK(ReadBits(&reader, 2) == 3);

      // Skip reserved.
      reader.SkipBits(5);

      // Update offset to be after this header.
      int pack_stuffing_length = ReadBits(&reader, 3);
      offset += 14 + pack_stuffing_length;
    }

    // Check for system headers and PES_packets.
    while (offset + 6 < buffer_size && Read24(buffer + offset) == 1) {
      // Next 8 bits determine stream type.
      int stream_id = buffer[offset + 3];

      // Some stream types are reserved and shouldn't occur.
      if (mpeg_version == 0)
        RCHECK(stream_id != 0xbc && stream_id < 0xf0);
      else
        RCHECK(stream_id != 0xfc && stream_id != 0xfd && stream_id != 0xfe);

      // Some stream types are used for pack headers.
      if (stream_id == PACK_START_CODE)  // back to outer loop.
        break;
      if (stream_id == PROGRAM_END_CODE)  // end of stream.
        return true;

      int pes_length = Read16(buffer + offset + 4);
      RCHECK(pes_length > 0);
      offset = offset + 6 + pes_length;
    }
  }
  // Success as we are off the end of the buffer and liked everything
  // in the buffer.
  return true;
}

const uint8 kMpeg2SyncWord = 0x47;

// Checks for a MPEG2 Transport Stream.
static bool CheckMpeg2TransportStream(const uint8* buffer, int buffer_size) {
  // Spec: ISO/IEC 13818-1 : 2000 (E) / ITU-T Rec. H.222.0 (2000 E).
  // Normal packet size is 188 bytes. However, some systems add various error
  // correction data at the end, resulting in packet of length 192/204/208
  // (https://en.wikipedia.org/wiki/MPEG_transport_stream). Determine the
  // length with the first packet.
  RCHECK(buffer_size >= 250);  // Want more than 1 packet to check.

  int offset = 0;
  int packet_length = -1;
  while (buffer[offset] != kMpeg2SyncWord && offset < 20) {
    // Skip over any header in the first 20 bytes.
    ++offset;
  }

  while (offset + 6 < buffer_size) {
    BitReader reader(buffer + offset, 6);

    // Must start with sync byte.
    RCHECK(ReadBits(&reader, 8) == kMpeg2SyncWord);

    // Skip transport_error_indicator, payload_unit_start_indicator, and
    // transport_priority.
    reader.SkipBits(1 + 1 + 1);

    // Verify the pid is not a reserved value.
    int pid = ReadBits(&reader, 13);
    RCHECK(pid < 3 || pid > 15);

    // Skip transport_scrambling_control.
    reader.SkipBits(2);

    // Adaptation_field_control can not be 0.
    int adaptation_field_control = ReadBits(&reader, 2);
    RCHECK(adaptation_field_control != 0);

    // If there is an adaptation_field, verify it.
    if (adaptation_field_control >= 2) {
      // Skip continuity_counter.
      reader.SkipBits(4);

      // Get adaptation_field_length and verify it.
      int adaptation_field_length = ReadBits(&reader, 8);
      if (adaptation_field_control == 2)
        RCHECK(adaptation_field_length == 183);
      else
        RCHECK(adaptation_field_length <= 182);
    }

    // Attempt to determine the packet length on the first packet.
    if (packet_length < 0) {
      if (buffer[offset + 188] == kMpeg2SyncWord)
        packet_length = 188;
      else if (buffer[offset + 192] == kMpeg2SyncWord)
        packet_length = 192;
      else if (buffer[offset + 204] == kMpeg2SyncWord)
        packet_length = 204;
      else
        packet_length = 208;
    }
    offset += packet_length;
  }
  return true;
}

enum Mpeg4StartCodes {
  VISUAL_OBJECT_SEQUENCE_START_CODE = 0xb0,
  VISUAL_OBJECT_SEQUENCE_END_CODE = 0xb1,
  VISUAL_OBJECT_START_CODE = 0xb5,
  VOP_START_CODE = 0xb6
};

// Checks for a raw MPEG4 bitstream container.
static bool CheckMpeg4BitStream(const uint8* buffer, int buffer_size) {
  // Defined in ISO/IEC 14496-2:2001.
  // However, no length ... simply scan for start code values.
  // Note tags are very similar to H.264.
  RCHECK(buffer_size > 4);

  int offset = 0;
  int sequence_start_count = 0;
  int sequence_end_count = 0;
  int visual_object_count = 0;
  int vop_count = 0;
  while (true) {
    // Advance to start_code, if there is one.
    if (!AdvanceToStartCode(buffer, buffer_size, &offset, 6, 24, 1)) {
      // Not a complete sequence in memory, so return true if we've seen a
      // visual_object_sequence_start_code and a visual_object_start_code.
      return (sequence_start_count > 0 && visual_object_count > 0);
    }

    // Now verify the block. AdvanceToStartCode() made sure that there are
    // at least 6 bytes remaining in the buffer.
    BitReader reader(buffer + offset, 6);
    RCHECK(ReadBits(&reader, 24) == 1);

    int start_code = ReadBits(&reader, 8);
    RCHECK(start_code < 0x30 || start_code > 0xaf);  // 30..AF and
    RCHECK(start_code < 0xb7 || start_code > 0xb9);  // B7..B9 reserved

    switch (start_code) {
      case VISUAL_OBJECT_SEQUENCE_START_CODE: {
        ++sequence_start_count;
        // Verify profile in not one of many reserved values.
        int profile = ReadBits(&reader, 8);
        RCHECK(profile > 0);
        RCHECK(profile < 0x04 || profile > 0x10);
        RCHECK(profile < 0x13 || profile > 0x20);
        RCHECK(profile < 0x23 || profile > 0x31);
        RCHECK(profile < 0x35 || profile > 0x41);
        RCHECK(profile < 0x43 || profile > 0x60);
        RCHECK(profile < 0x65 || profile > 0x70);
        RCHECK(profile < 0x73 || profile > 0x80);
        RCHECK(profile < 0x83 || profile > 0x90);
        RCHECK(profile < 0x95 || profile > 0xa0);
        RCHECK(profile < 0xa4 || profile > 0xb0);
        RCHECK(profile < 0xb5 || profile > 0xc0);
        RCHECK(profile < 0xc3 || profile > 0xd0);
        RCHECK(profile < 0xe4);
        break;
      }

      case VISUAL_OBJECT_SEQUENCE_END_CODE:
        RCHECK(++sequence_end_count == sequence_start_count);
        break;

      case VISUAL_OBJECT_START_CODE: {
        ++visual_object_count;
        if (ReadBits(&reader, 1) == 1) {
          int visual_object_verid = ReadBits(&reader, 4);
          RCHECK(visual_object_verid > 0 && visual_object_verid < 3);
          RCHECK(ReadBits(&reader, 3) != 0);
        }
        int visual_object_type = ReadBits(&reader, 4);
        RCHECK(visual_object_type > 0 && visual_object_type < 6);
        break;
      }

      case VOP_START_CODE:
        RCHECK(++vop_count <= visual_object_count);
        break;
    }
    // Skip this block.
    offset += 6;
  }
}

// Additional checks for a MOV/QuickTime/MPEG4 container.
static bool CheckMov(const uint8* buffer, int buffer_size) {
  // Reference: ISO/IEC 14496-12:2005(E).
  // (http://goo.gl/OWH0Q)
  RCHECK(buffer_size > 8);

  int offset = 0;
  while (offset + 8 < buffer_size) {
    int atomsize = Read32(buffer + offset);
    uint32 atomtype = Read32(buffer + offset + 4);
    // Only need to check for ones that are valid at the top level.
    switch (atomtype) {
      case TAG('f','t','y','p'):
      case TAG('p','d','i','n'):
      case TAG('m','o','o','v'):
      case TAG('m','o','o','f'):
      case TAG('m','f','r','a'):
      case TAG('m','d','a','t'):
      case TAG('f','r','e','e'):
      case TAG('s','k','i','p'):
      case TAG('m','e','t','a'):
      case TAG('m','e','c','o'):
      case TAG('s','t','y','p'):
      case TAG('s','i','d','x'):
      case TAG('s','s','i','x'):
      case TAG('p','r','f','t'):
      case TAG('b','l','o','c'):
        break;
      default:
        return false;
    }
    if (atomsize <= 0)
      break;  // Indicates the last atom or length too big.
    if (atomsize == 1) {
      // Indicates that the length is the next 64bits.
      if (offset + 16 > buffer_size)
        break;
      if (Read32(buffer + offset + 8) != 0)
        break;  // Offset is way past buffer size.
      atomsize = Read32(buffer + offset + 12);
    }
    offset += atomsize;
  }
  return true;
}

enum MPEGVersion {
  VERSION_25 = 0,
  VERSION_RESERVED,
  VERSION_2,
  VERSION_1
};
enum MPEGLayer {
  L_RESERVED = 0,
  LAYER_3,
  LAYER_2,
  LAYER_1
};

static int kSampleRateTable[4][4] = { { 11025, 12000, 8000, 0 },   // v2.5
                                      { 0, 0, 0, 0 },              // not used
                                      { 22050, 24000, 16000, 0 },  // v2
                                      { 44100, 48000, 32000, 0 }   // v1
};

static int kBitRateTableV1L1[16] = { 0, 32, 64, 96, 128, 160, 192, 224, 256,
                                     288, 320, 352, 384, 416, 448, 0 };
static int kBitRateTableV1L2[16] = { 0, 32, 48, 56, 64, 80, 96, 112, 128, 160,
                                     192, 224, 256, 320, 384, 0 };
static int kBitRateTableV1L3[16] = { 0, 32, 40, 48, 56, 64, 80, 96, 112, 128,
                                     160, 192, 224, 256, 320, 0 };
static int kBitRateTableV2L1[16] = { 0, 32, 48, 56, 64, 80, 96, 112, 128, 144,
                                     160, 176, 192, 224, 256, 0 };
static int kBitRateTableV2L23[16] = { 0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96,
                                      112, 128, 144, 160, 0 };

static bool ValidMpegAudioFrameHeader(const uint8* header,
                                      int header_size,
                                      int* framesize) {
  // Reference: http://mpgedit.org/mpgedit/mpeg_format/mpeghdr.htm.
  DCHECK_GE(header_size, 4);
  *framesize = 0;
  BitReader reader(header, 4);  // Header can only be 4 bytes long.

  // Verify frame sync (11 bits) are all set.
  RCHECK(ReadBits(&reader, 11) == 0x7ff);

  // Verify MPEG audio version id.
  int version = ReadBits(&reader, 2);
  RCHECK(version != 1);  // Reserved.

  // Verify layer.
  int layer = ReadBits(&reader, 2);
  RCHECK(layer != 0);

  // Skip protection bit.
  reader.SkipBits(1);

  // Verify bitrate index.
  int bitrate_index = ReadBits(&reader, 4);
  RCHECK(bitrate_index != 0xf);

  // Verify sampling rate frequency index.
  int sampling_index = ReadBits(&reader, 2);
  RCHECK(sampling_index != 3);

  // Get padding bit.
  int padding = ReadBits(&reader, 1);

  // Frame size:
  // For Layer I files = (12 * BitRate / SampleRate + Padding) * 4
  // For others = 144 * BitRate / SampleRate + Padding
  // Unfortunately, BitRate and SampleRate are coded.
  int sampling_rate = kSampleRateTable[version][sampling_index];
  int bitrate;
  if (version == VERSION_1) {
    if (layer == LAYER_1)
      bitrate = kBitRateTableV1L1[bitrate_index];
    else if (layer == LAYER_2)
      bitrate = kBitRateTableV1L2[bitrate_index];
    else
      bitrate = kBitRateTableV1L3[bitrate_index];
  } else {
    if (layer == LAYER_1)
      bitrate = kBitRateTableV2L1[bitrate_index];
    else
      bitrate = kBitRateTableV2L23[bitrate_index];
  }
  if (layer == LAYER_1)
    *framesize = ((12000 * bitrate) / sampling_rate + padding) * 4;
  else
    *framesize = (144000 * bitrate) / sampling_rate + padding;
  return (bitrate > 0 && sampling_rate > 0);
}

// Extract a size encoded the MP3 way.
static int GetMp3HeaderSize(const uint8* buffer, int buffer_size) {
  DCHECK_GE(buffer_size, 9);
  int size = ((buffer[6] & 0x7f) << 21) + ((buffer[7] & 0x7f) << 14) +
             ((buffer[8] & 0x7f) << 7) + (buffer[9] & 0x7f) + 10;
  if (buffer[5] & 0x10)  // Footer added?
    size += 10;
  return size;
}

// Additional checks for a MP3 container.
static bool CheckMp3(const uint8* buffer, int buffer_size, bool seenHeader) {
  RCHECK(buffer_size >= 10);  // Must be enough to read the initial header.

  int framesize;
  int numSeen = 0;
  int offset = 0;
  if (seenHeader) {
    offset = GetMp3HeaderSize(buffer, buffer_size);
  } else {
    // Skip over leading 0's.
    while (offset < buffer_size && buffer[offset] == 0)
      ++offset;
  }

  while (offset + 3 < buffer_size) {
    RCHECK(ValidMpegAudioFrameHeader(
        buffer + offset, buffer_size - offset, &framesize));

    // Have we seen enough valid headers?
    if (++numSeen > 10)
      return true;
    offset += framesize;
  }
  // Off the end of the buffer, return success if a few valid headers seen.
  return numSeen > 2;
}

// Check that the next characters in |buffer| represent a number. The format
// accepted is optional whitespace followed by 1 or more digits. |max_digits|
// specifies the maximum number of digits to process. Returns true if a valid
// number is found, false otherwise.
static bool VerifyNumber(const uint8* buffer,
                         int buffer_size,
                         int* offset,
                         int max_digits) {
  RCHECK(*offset < buffer_size);

  // Skip over any leading space.
  while (isspace(buffer[*offset])) {
    ++(*offset);
    RCHECK(*offset < buffer_size);
  }

  // Need to process up to max_digits digits.
  int numSeen = 0;
  while (--max_digits >= 0 && isdigit(buffer[*offset])) {
    ++numSeen;
    ++(*offset);
    if (*offset >= buffer_size)
      return true;  // Out of space but seen a digit.
  }

  // Success if at least one digit seen.
  return (numSeen > 0);
}

// Check that the next character in |buffer| is one of |c1| or |c2|. |c2| is
// optional. Returns true if there is a match, false if no match or out of
// space.
static inline bool VerifyCharacters(const uint8* buffer,
                                    int buffer_size,
                                    int* offset,
                                    char c1,
                                    char c2) {
  RCHECK(*offset < buffer_size);
  char c = static_cast<char>(buffer[(*offset)++]);
  return (c == c1 || (c == c2 && c2 != 0));
}

// Checks for a SRT container.
static bool CheckSrt(const uint8* buffer, int buffer_size) {
  // Reference: http://en.wikipedia.org/wiki/SubRip
  RCHECK(buffer_size > 20);

  // First line should just be the subtitle sequence number.
  int offset = StartsWith(buffer, buffer_size, UTF8_BYTE_ORDER_MARK) ? 3 : 0;
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 100));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '\n', '\r'));

  // Skip any additional \n\r.
  while (VerifyCharacters(buffer, buffer_size, &offset, '\n', '\r')) {}
  --offset;  // Since VerifyCharacters() gobbled up the next non-CR/LF.

  // Second line should look like the following:
  //   00:00:10,500 --> 00:00:13,000
  // Units separator can be , or .
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 100));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ',', '.'));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 3));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ' ', 0));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '-', 0));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '-', 0));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '>', 0));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ' ', 0));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 100));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));
  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ',', '.'));
  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 3));
  return true;
}

// Read a Matroska Element Id.
static int GetElementId(BitReader* reader) {
  // Element ID is coded with the leading zero bits (max 3) determining size.
  // If it is an invalid encoding or the end of the buffer is reached,
  // return -1 as a tag that won't be expected.
  if (reader->bits_available() >= 8) {
    int num_bits_to_read = 0;
    static int prefix[] = { 0x80, 0x4000, 0x200000, 0x10000000 };
    for (int i = 0; i < 4; ++i) {
      num_bits_to_read += 7;
      if (ReadBits(reader, 1) == 1) {
        if (reader->bits_available() < num_bits_to_read)
          break;
        // prefix[] adds back the bits read individually.
        return ReadBits(reader, num_bits_to_read) | prefix[i];
      }
    }
  }
  // Invalid encoding, return something not expected.
  return -1;
}

// Read a Matroska Unsigned Integer (VINT).
static uint64 GetVint(BitReader* reader) {
  // Values are coded with the leading zero bits (max 7) determining size.
  // If it is an invalid coding or the end of the buffer is reached,
  // return something that will go off the end of the buffer.
  if (reader->bits_available() >= 8) {
    int num_bits_to_read = 0;
    for (int i = 0; i < 8; ++i) {
      num_bits_to_read += 7;
      if (ReadBits(reader, 1) == 1) {
        if (reader->bits_available() < num_bits_to_read)
          break;
        return ReadBits(reader, num_bits_to_read);
      }
    }
  }
  // Incorrect format (more than 7 leading 0's) or off the end of the buffer.
  // Since the return value is used as a byte size, return a value that will
  // cause a failure when used.
  return (reader->bits_available() / 8) + 2;
}

// Additional checks for a WEBM container.
static bool CheckWebm(const uint8* buffer, int buffer_size) {
  // Reference: http://www.matroska.org/technical/specs/index.html
  RCHECK(buffer_size > 12);

  BitReader reader(buffer, buffer_size);

  // Verify starting Element Id.
  RCHECK(GetElementId(&reader) == 0x1a45dfa3);

  // Get the header size, and ensure there are enough bits to check.
  int header_size = GetVint(&reader);
  RCHECK(reader.bits_available() / 8 >= header_size);

  // Loop through the header.
  while (reader.bits_available() > 0) {
    int tag = GetElementId(&reader);
    int tagsize = GetVint(&reader);
    switch (tag) {
      case 0x4286:  // EBMLVersion
      case 0x42f7:  // EBMLReadVersion
      case 0x42f2:  // EBMLMaxIdLength
      case 0x42f3:  // EBMLMaxSizeLength
      case 0x4287:  // DocTypeVersion
      case 0x4285:  // DocTypeReadVersion
      case 0xec:    // void
      case 0xbf:    // CRC32
        RCHECK(reader.SkipBits(tagsize * 8));
        break;

      case 0x4282:  // EBMLDocType
        // Need to see "webm" or "matroska" next.
        switch (ReadBits(&reader, 32)) {
          case TAG('w', 'e', 'b', 'm') :
            return true;
          case TAG('m', 'a', 't', 'r') :
            return (ReadBits(&reader, 32) == TAG('o', 's', 'k', 'a'));
        }
        return false;

      default:  // Unrecognized tag
        return false;
    }
  }
  return false;
}

enum VC1StartCodes {
  VC1_FRAME_START_CODE = 0x0d,
  VC1_ENTRY_POINT_START_CODE = 0x0e,
  VC1_SEQUENCE_START_CODE = 0x0f
};

// Checks for a VC1 bitstream container.
static bool CheckVC1(const uint8* buffer, int buffer_size) {
  // Reference: SMPTE 421M
  // (http://goo.gl/fLvaE)
  // However, no length ... simply scan for start code values.
  // Expect to see SEQ | [ [ ENTRY ] PIC* ]*
  // Note tags are very similar to H.264.

  RCHECK(buffer_size >= 24);

  // First check for Bitstream Metadata Serialization (Annex L)
  if (buffer[0] == 0xc5 &&
      Read32(buffer + 4) == 0x04 &&
      Read32(buffer + 20) == 0x0c) {
    // Verify settings in STRUCT_C and STRUCT_A
    BitReader reader(buffer + 8, 12);

    int profile = ReadBits(&reader, 4);
    if (profile == 0 || profile == 4) {  // simple or main
      // Skip FRMRTQ_POSTPROC, BITRTQ_POSTPROC, and LOOPFILTER.
      reader.SkipBits(3 + 5 + 1);

      // Next bit must be 0.
      RCHECK(ReadBits(&reader, 1) == 0);

      // Skip MULTIRES.
      reader.SkipBits(1);

      // Next bit must be 1.
      RCHECK(ReadBits(&reader, 1) == 1);

      // Skip FASTUVMC, EXTENDED_MV, DQUANT, and VSTRANSFORM.
      reader.SkipBits(1 + 1 + 2 + 1);

      // Next bit must be 0.
      RCHECK(ReadBits(&reader, 1) == 0);

      // Skip OVERLAP, SYNCMARKER, RANGERED, MAXBFRAMES, QUANTIZER, and
      // FINTERPFLAG.
      reader.SkipBits(1 + 1 + 1 + 3 + 2 + 1);

      // Next bit must be 1.
      RCHECK(ReadBits(&reader, 1) == 1);

    } else {
      RCHECK(profile == 12);  // Other profile values not allowed.
      RCHECK(ReadBits(&reader, 28) == 0);
    }

    // Now check HORIZ_SIZE and VERT_SIZE, which must be 8192 or less.
    RCHECK(ReadBits(&reader, 32) <= 8192);
    RCHECK(ReadBits(&reader, 32) <= 8192);
    return true;
  }

  // Buffer isn't Bitstream Metadata, so scan for start codes.
  int offset = 0;
  int sequence_start_code = 0;
  int frame_start_code = 0;
  while (true) {
    // Advance to start_code, if there is one.
    if (!AdvanceToStartCode(buffer, buffer_size, &offset, 5, 24, 1)) {
      // Not a complete sequence in memory, so return true if we've seen a
      // sequence start and a frame start (not checking entry points since
      // they only occur in advanced profiles).
      return (sequence_start_code > 0 && frame_start_code > 0);
    }

    // Now verify the block. AdvanceToStartCode() made sure that there are
    // at least 5 bytes remaining in the buffer.
    BitReader reader(buffer + offset, 5);
    RCHECK(ReadBits(&reader, 24) == 1);

    // Keep track of the number of certain types received.
    switch (ReadBits(&reader, 8)) {
      case VC1_SEQUENCE_START_CODE: {
        ++sequence_start_code;
        switch (ReadBits(&reader, 2)) {
          case 0:  // simple
          case 1:  // main
            RCHECK(ReadBits(&reader, 2) == 0);
            break;
          case 2:  // complex
            return false;
          case 3:  // advanced
            RCHECK(ReadBits(&reader, 3) <= 4);  // Verify level = 0..4
            RCHECK(ReadBits(&reader, 2) == 1);  // Verify colordiff_format = 1
            break;
        }
        break;
      }

      case VC1_ENTRY_POINT_START_CODE:
        // No fields in entry data to check. However, it must occur after
        // sequence header.
        RCHECK(sequence_start_code > 0);
        break;

      case VC1_FRAME_START_CODE:
        ++frame_start_code;
        break;
    }
    offset += 5;
  }
}

// For some formats the signature is a bunch of characters. They are defined
// below. Note that the first 4 characters of the string may be used as a TAG
// in LookupContainerByFirst4. For signatures that contain embedded \0, use
// uint8[].
static const char kAmrSignature[] = "#!AMR";
static const uint8 kAsfSignature[] = { 0x30, 0x26, 0xb2, 0x75, 0x8e, 0x66, 0xcf,
                                       0x11, 0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62,
                                       0xce, 0x6c };
static const char kAssSignature[] = "[Script Info]";
static const char kAssBomSignature[] = UTF8_BYTE_ORDER_MARK "[Script Info]";
static const uint8 kWtvSignature[] = { 0xb7, 0xd8, 0x00, 0x20, 0x37, 0x49, 0xda,
                                       0x11, 0xa6, 0x4e, 0x00, 0x07, 0xe9, 0x5e,
                                       0xad, 0x8d };

// Attempt to determine the container type from the buffer provided. This is
// a simple pass, that uses the first 4 bytes of the buffer as an index to get
// a rough idea of the container format.
static MediaContainerName LookupContainerByFirst4(const uint8* buffer,
                                                  int buffer_size) {
  // Minimum size that the code expects to exist without checking size.
  if (buffer_size < 12)
    return CONTAINER_UNKNOWN;

  uint32 first4 = Read32(buffer);
  switch (first4) {
    case 0x1a45dfa3:
      if (CheckWebm(buffer, buffer_size))
        return CONTAINER_WEBM;
      break;

    case 0x3026b275:
      if (StartsWith(buffer,
                     buffer_size,
                     kAsfSignature,
                     sizeof(kAsfSignature))) {
        return CONTAINER_ASF;
      }
      break;

    case TAG('#','!','A','M'):
      if (StartsWith(buffer, buffer_size, kAmrSignature))
        return CONTAINER_AMR;
      break;

    case TAG('#','E','X','T'):
      if (CheckHls(buffer, buffer_size))
        return CONTAINER_HLS;
      break;

    case TAG('.','R','M','F'):
      if (buffer[4] == 0 && buffer[5] == 0)
        return CONTAINER_RM;
      break;

    case TAG('.','r','a','\xfd'):
      return CONTAINER_RM;

    case TAG('B','I','K','b'):
    case TAG('B','I','K','d'):
    case TAG('B','I','K','f'):
    case TAG('B','I','K','g'):
    case TAG('B','I','K','h'):
    case TAG('B','I','K','i'):
      if (CheckBink(buffer, buffer_size))
        return CONTAINER_BINK;
      break;

    case TAG('c','a','f','f'):
      if (CheckCaf(buffer, buffer_size))
        return CONTAINER_CAF;
      break;

    case TAG('D','E','X','A'):
      if (buffer_size > 15 &&
          Read16(buffer + 11) <= 2048 &&
          Read16(buffer + 13) <= 2048) {
        return CONTAINER_DXA;
      }
      break;

    case TAG('D','T','S','H'):
      if (Read32(buffer + 4) == TAG('D','H','D','R'))
        return CONTAINER_DTSHD;
      break;

    case 0x64a30100:
    case 0x64a30200:
    case 0x64a30300:
    case 0x64a30400:
    case 0x0001a364:
    case 0x0002a364:
    case 0x0003a364:
      if (Read32(buffer + 4) != 0 && Read32(buffer + 8) != 0)
        return CONTAINER_IRCAM;
      break;

    case TAG('f','L','a','C'):
      return CONTAINER_FLAC;

    case TAG('F','L','V',0):
    case TAG('F','L','V',1):
    case TAG('F','L','V',2):
    case TAG('F','L','V',3):
    case TAG('F','L','V',4):
      if (buffer[5] == 0 && Read32(buffer + 5) > 8)
        return CONTAINER_FLV;
      break;

    case TAG('F','O','R','M'):
      switch (Read32(buffer + 8)) {
        case TAG('A','I','F','F'):
        case TAG('A','I','F','C'):
          return CONTAINER_AIFF;
      }
      break;

    case TAG('M','A','C',' '):
      return CONTAINER_APE;

    case TAG('O','N','2',' '):
      if (Read32(buffer + 8) == TAG('O','N','2','f'))
        return CONTAINER_AVI;
      break;

    case TAG('O','g','g','S'):
      if (buffer[5] <= 7)
        return CONTAINER_OGG;
      break;

    case TAG('R','F','6','4'):
      if (buffer_size > 16 && Read32(buffer + 12) == TAG('d','s','6','4'))
        return CONTAINER_WAV;
      break;

    case TAG('R','I','F','F'):
      switch (Read32(buffer + 8)) {
        case TAG('A','V','I',' '):
        case TAG('A','V','I','X'):
        case TAG('A','V','I','\x19'):
        case TAG('A','M','V',' '):
          return CONTAINER_AVI;
        case TAG('W','A','V','E'):
          return CONTAINER_WAV;
      }
      break;

    case TAG('[','S','c','r'):
      if (StartsWith(buffer, buffer_size, kAssSignature))
        return CONTAINER_ASS;
      break;

    case TAG('\xef','\xbb','\xbf','['):
      if (StartsWith(buffer, buffer_size, kAssBomSignature))
        return CONTAINER_ASS;
      break;

    case 0x7ffe8001:
    case 0xfe7f0180:
    case 0x1fffe800:
    case 0xff1f00e8:
      if (CheckDts(buffer, buffer_size))
        return CONTAINER_DTS;
      break;

    case 0xb7d80020:
      if (StartsWith(buffer,
                     buffer_size,
                     kWtvSignature,
                     sizeof(kWtvSignature))) {
        return CONTAINER_WTV;
      }
      break;
  }

  // Now try a few different ones that look at something other
  // than the first 4 bytes.
  uint32 first3 = first4 & 0xffffff00;
  switch (first3) {
    case TAG('C','W','S',0):
    case TAG('F','W','S',0):
      return CONTAINER_SWF;

    case TAG('I','D','3',0):
      if (CheckMp3(buffer, buffer_size, true))
        return CONTAINER_MP3;
      break;
  }

  // Maybe the first 2 characters are something we can use.
  uint32 first2 = Read16(buffer);
  switch (first2) {
    case kAc3SyncWord:
      if (CheckAc3(buffer, buffer_size))
        return CONTAINER_AC3;
      if (CheckEac3(buffer, buffer_size))
        return CONTAINER_EAC3;
      break;

    case 0xfff0:
    case 0xfff1:
    case 0xfff8:
    case 0xfff9:
      if (CheckAac(buffer, buffer_size))
        return CONTAINER_AAC;
      break;
  }

  // Check if the file is in MP3 format without the header.
  if (CheckMp3(buffer, buffer_size, false))
    return CONTAINER_MP3;

  return CONTAINER_UNKNOWN;
}

// Attempt to determine the container name from the buffer provided.
MediaContainerName DetermineContainer(const uint8* buffer, int buffer_size) {
  DCHECK(buffer);

  // Since MOV/QuickTime/MPEG4 streams are common, check for them first.
  if (CheckMov(buffer, buffer_size))
    return CONTAINER_MOV;

  // Next attempt the simple checks, that typically look at just the
  // first few bytes of the file.
  MediaContainerName result = LookupContainerByFirst4(buffer, buffer_size);
  if (result != CONTAINER_UNKNOWN)
    return result;

  // Additional checks that may scan a portion of the buffer.
  if (CheckMpeg2ProgramStream(buffer, buffer_size))
    return CONTAINER_MPEG2PS;
  if (CheckMpeg2TransportStream(buffer, buffer_size))
    return CONTAINER_MPEG2TS;
  if (CheckMJpeg(buffer, buffer_size))
    return CONTAINER_MJPEG;
  if (CheckDV(buffer, buffer_size))
    return CONTAINER_DV;
  if (CheckH261(buffer, buffer_size))
    return CONTAINER_H261;
  if (CheckH263(buffer, buffer_size))
    return CONTAINER_H263;
  if (CheckH264(buffer, buffer_size))
    return CONTAINER_H264;
  if (CheckMpeg4BitStream(buffer, buffer_size))
    return CONTAINER_MPEG4BS;
  if (CheckVC1(buffer, buffer_size))
    return CONTAINER_VC1;
  if (CheckSrt(buffer, buffer_size))
    return CONTAINER_SRT;
  if (CheckGsm(buffer, buffer_size))
    return CONTAINER_GSM;

  // AC3/EAC3 might not start at the beginning of the stream,
  // so scan for a start code.
  int offset = 1;  // No need to start at byte 0 due to First4 check.
  if (AdvanceToStartCode(buffer, buffer_size, &offset, 4, 16, kAc3SyncWord)) {
    if (CheckAc3(buffer + offset, buffer_size - offset))
      return CONTAINER_AC3;
    if (CheckEac3(buffer + offset, buffer_size - offset))
      return CONTAINER_EAC3;
  }

  return CONTAINER_UNKNOWN;
}

}  // namespace container_names

}  // namespace media
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_BASE_CONTAINER_NAMES_H_
#define MEDIA_BASE_CONTAINER_NAMES_H_

#include "base/basictypes.h"
#include "media/base/media_export.h"

namespace media {

namespace container_names {

// This is the set of input container formats detected for logging purposes. Not
// all of these are enabled (and it varies by product). Any additions need to be
// done at the end of the list (before CONTAINER_MAX). This list must be kept in
// sync with the enum definition "MediaContainers" in
// tools/metrics/histograms/histograms.xml.
enum MediaContainerName {
  CONTAINER_UNKNOWN,          // Unknown
  CONTAINER_AAC,              // AAC (Advanced Audio Coding)
  CONTAINER_AC3,              // AC-3
  CONTAINER_AIFF,             // AIFF (Audio Interchange File Format)
  CONTAINER_AMR,              // AMR (Adaptive Multi-Rate Audio)
  CONTAINER_APE,              // APE (Monkey's Audio)
  CONTAINER_ASF,              // ASF (Advanced / Active Streaming Format)
  CONTAINER_ASS,              // SSA (SubStation Alpha) subtitle
  CONTAINER_AVI,              // AVI (Audio Video Interleaved)
  CONTAINER_BINK,             // Bink
  CONTAINER_CAF,              // CAF (Apple Core Audio Format)
  CONTAINER_DTS,              // DTS
  CONTAINER_DTSHD,            // DTS-HD
  CONTAINER_DV,               // DV (Digital Video)
  CONTAINER_DXA,              // DXA
  CONTAINER_EAC3,             // Enhanced AC-3
  CONTAINER_FLAC,             // FLAC (Free Lossless Audio Codec)
  CONTAINER_FLV,              // FLV (Flash Video)
  CONTAINER_GSM,              // GSM (Global System for Mobile Audio)
  CONTAINER_H261,             // H.261
  CONTAINER_H263,             // H.263
  CONTAINER_H264,             // H.264
  CONTAINER_HLS,              // HLS (Apple HTTP Live Streaming PlayList)
  CONTAINER_IRCAM,            // Berkeley/IRCAM/CARL Sound Format
  CONTAINER_MJPEG,            // MJPEG video
  CONTAINER_MOV,              // QuickTime / MOV / MPEG4
  CONTAINER_MP3,              // MP3 (MPEG audio layer 2/3)
  CONTAINER_MPEG2PS,          // MPEG-2 Program Stream
  CONTAINER_MPEG2TS,          // MPEG-2 Transport Stream
  CONTAINER_MPEG4BS,          // MPEG-4 Bitstream
  CONTAINER_OGG,              // Ogg
  CONTAINER_RM,               // RM (RealMedia)
  CONTAINER_SRT,              // SRT (SubRip subtitle)
  CONTAINER_SWF,              // SWF (ShockWave Flash)
  CONTAINER_VC1,              // VC-1
  CONTAINER_WAV,              // WAV / WAVE (Waveform Audio)
  CONTAINER_WEBM,             // Matroska / WebM
  CONTAINER_WTV,              // WTV (Windows Television)
  CONTAINER_MAX               // Must be last
};

// Determine the container type.
MEDIA_EXPORT MediaContainerName DetermineContainer(const uint8* buffer,
                                                   int buffer_size);

}  // namespace container_names

}  // namespace media

#endif  // MEDIA_BASE_CONTAINER_NAMES_H_
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "base/file_util.h"
#include "media/base/container_names.h"
#include "media/base/test_data_util.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace media {

namespace container_names {

// Using a macros to simplify tests. Since EXPECT_EQ outputs the second argument
// as a string when it fails, this lets the output identify what item actually
// failed.
#define VERIFY(buffer, name)                                           \
  EXPECT_EQ(name,                                                      \
            DetermineContainer(reinterpret_cast<const uint8*>(buffer), \
                               sizeof(buffer)))

// Test that small buffers are handled correctly.
TEST(ContainerNamesTest, CheckSmallBuffer) {
  // Empty buffer.
  char buffer[1];  // ([0] not allowed on win)
  VERIFY(buffer, CONTAINER_UNKNOWN);

  // Try a simple SRT file.
  char buffer1[] =
      "1\n"
      "00:03:23,550 --> 00:03:24,375\n"
      "You always had a hard time finding your place in this world.\n"
      "\n"
      "2\n"
      "00:03:24,476 --> 00:03:25,175\n"
      "What are you talking about?\n";
  VERIFY(buffer1, CONTAINER_SRT);

  // HLS has it's own loop.
  char buffer2[] = "#EXTM3U"
                   "some other random stuff"
                   "#EXT-X-MEDIA-SEQUENCE:";
  VERIFY(buffer2, CONTAINER_HLS);

  // Try a large buffer all zeros.
  char buffer3[4096];
  memset(buffer3, 0, sizeof(buffer3));
  VERIFY(buffer3, CONTAINER_UNKNOWN);

  // Reuse buffer, but all \n this time.
  memset(buffer3, '\n', sizeof(buffer3));
  VERIFY(buffer3, CONTAINER_UNKNOWN);
}

#define BYTE_ORDER_MARK "\xef\xbb\xbf"

// Note that the comparisons need at least 12 bytes, so make sure the buffer is
// at least that size.
const char kAmrBuffer[12] = "#!AMR";
uint8 kAsfBuffer[] = { 0x30, 0x26, 0xb2, 0x75, 0x8e, 0x66, 0xcf, 0x11, 0xa6,
                       0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c };
const char kAss1Buffer[] = "[Script Info]";
const char kAss2Buffer[] = BYTE_ORDER_MARK "[Script Info]";
uint8 kCafBuffer[] = { 'c', 'a', 'f', 'f', 0, 1, 0, 0, 'd', 'e', 's', 'c', 0, 0,
                       0, 0, 0, 0, 0, 32, 64, 229, 136, 128, 0, 0, 0, 0, 'a',
                       'a', 'c', ' ', 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
                       0, 2, 0, 0, 0, 0 };
const char kDtshdBuffer[12] = "DTSHDHDR";
const char kDxaBuffer[16] = "DEXA";
const char kFlacBuffer[12] = "fLaC";
uint8 kFlvBuffer[12] = { 'F', 'L', 'V', 0, 0, 0, 0, 1, 0, 0, 0, 0 };
uint8 kIrcamBuffer[] = { '\x64', '\xa3', 1, 0, 0, 0, 0, 1, 0, 0, 0, 1 };
const char kRm1Buffer[12] = ".RMF\0\0";
const char kRm2Buffer[12] = ".ra\xfd";
uint8 kWtvBuffer[] = { 0xb7, 0xd8, 0x00, 0x20, 0x37, 0x49, 0xda, 0x11, 0xa6,
                       0x4e, 0x00, 0x07, 0xe9, 0x5e, 0xad, 0x8d };

// Test that containers that start with fixed strings are handled correctly.
// This is to verify that the TAG matches the first 4 characters of the string.
TEST(ContainerNamesTest, CheckFixedStrings) {
  VERIFY(kAmrBuffer, CONTAINER_AMR);
  VERIFY(kAsfBuffer, CONTAINER_ASF);
  VERIFY(kAss1Buffer, CONTAINER_ASS);
  VERIFY(kAss2Buffer, CONTAINER_ASS);
  VERIFY(kCafBuffer, CONTAINER_CAF);
  VERIFY(kDtshdBuffer, CONTAINER_DTSHD);
  VERIFY(kDxaBuffer, CONTAINER_DXA);
  VERIFY(kFlacBuffer, CONTAINER_FLAC);
  VERIFY(kFlvBuffer, CONTAINER_FLV);
  VERIFY(kIrcamBuffer, CONTAINER_IRCAM);
  VERIFY(kRm1Buffer, CONTAINER_RM);
  VERIFY(kRm2Buffer, CONTAINER_RM);
  VERIFY(kWtvBuffer, CONTAINER_WTV);
}

// Determine the container type of a specified file.
void TestFile(MediaContainerName expected, const base::FilePath& filename) {
  char buffer[8192];

  // Windows implementation of ReadFile fails if file smaller than desired size,
  // so use file length if file less than 8192 bytes (http://crbug.com/243885).
  int read_size = sizeof(buffer);
  int64 actual_size;
  if (file_util::GetFileSize(filename, &actual_size) && actual_size < read_size)
    read_size = actual_size;
  int read = file_util::ReadFile(filename, buffer, read_size);

  // Now verify the type.
  EXPECT_EQ(expected,
            DetermineContainer(reinterpret_cast<const uint8*>(buffer), read))
      << "Failure with file " << filename.value();
}

// Test several OGG files to ensure that the container is detected properly.
TEST(ContainerNamesTest, FileCheckOGG) {
  TestFile(CONTAINER_OGG, GetTestDataFilePath("bear.ogv"));
  TestFile(CONTAINER_OGG, GetTestDataFilePath("9ch.ogg"));
}

// Test several WAV files to ensure that the container is detected properly.
TEST(ContainerNamesTest, FileCheckWAV) {
  TestFile(CONTAINER_WAV, GetTestDataFilePath("4ch.wav"));
  TestFile(CONTAINER_WAV, GetTestDataFilePath("sfx_f32le.wav"));
  TestFile(CONTAINER_WAV, GetTestDataFilePath("sfx_s16le.wav"));
}

// Test several MOV files to ensure that the container is detected properly.
TEST(ContainerNamesTest, FileCheckMOV) {
  TestFile(CONTAINER_MOV, GetTestDataFilePath("bear-1280x720.mp4"));
  TestFile(CONTAINER_MOV, GetTestDataFilePath("sfx.m4a"));
}

// Test several WEBM files to ensure that the container is detected properly.
TEST(ContainerNamesTest, FileCheckWEBM) {
  TestFile(CONTAINER_WEBM, GetTestDataFilePath("bear-320x240.webm"));
  TestFile(CONTAINER_WEBM, GetTestDataFilePath("no_streams.webm"));
  TestFile(CONTAINER_WEBM, GetTestDataFilePath("webm_ebml_element"));
}

// Test several MP3 files to ensure that the container is detected properly.
TEST(ContainerNamesTest, FileCheckMP3) {
  TestFile(CONTAINER_MP3, GetTestDataFilePath("id3_test.mp3"));
  TestFile(CONTAINER_MP3, GetTestDataFilePath("sfx.mp3"));
}

// Try a few non containers.
TEST(ContainerNamesTest, FileCheckUNKNOWN) {
  TestFile(CONTAINER_UNKNOWN, GetTestDataFilePath("ten_byte_file"));
  TestFile(CONTAINER_UNKNOWN, GetTestDataFilePath("README"));
  TestFile(CONTAINER_UNKNOWN, GetTestDataFilePath("bali_640x360_P422.yuv"));
  TestFile(CONTAINER_UNKNOWN, GetTestDataFilePath("bali_640x360_RGB24.rgb"));
  TestFile(CONTAINER_UNKNOWN, GetTestDataFilePath("webm_vp8_track_entry"));
}

}  // namespace container_names

}  // namespace media
#include "base/metrics/sparse_histogram.h"
#include "media/base/container_names.h"
  // Attempt to recognize the container by looking at the first few bytes of the
  // stream. The stream position is left unchanged.
  scoped_ptr<std::vector<uint8> > buffer(new std::vector<uint8>(8192));

  int64 pos = AVIOSeekOperation(avio_context_.get()->opaque, 0, SEEK_CUR);
  AVIOSeekOperation(avio_context_.get()->opaque, 0, SEEK_SET);
  int numRead = AVIOReadOperation(
      avio_context_.get()->opaque, buffer.get()->data(), buffer.get()->size());
  AVIOSeekOperation(avio_context_.get()->opaque, pos, SEEK_SET);
  if (numRead > 0) {
    // < 0 means Read failed
    container_names::MediaContainerName container =
        container_names::DetermineContainer(buffer.get()->data(), numRead);
    UMA_HISTOGRAM_SPARSE_SLOWLY("Media.DetectedContainer", container);
  }

#include "net/base/net_util.h"
  // Grant navigation to a file but not the file:// scheme in general.
  void GrantRequestOfSpecificFile(const FilePath &file) {
    request_file_set_.insert(file.StripTrailingSeparators());
  }

    FilePath stripped = file.StripTrailingSeparators();
    file_permissions_.erase(stripped);
    request_file_set_.erase(stripped);
  // Determine whether permission has been granted to request |url|.
    // Having permission to a scheme implies permssion to all of its URLs.
    if (judgment != scheme_policy_.end())
      return judgment->second;

    // file:// URLs are more granular.  The child may have been given
    // permission to a specific file but not the file:// scheme in general.
    if (url.SchemeIs(chrome::kFileScheme)) {
      FilePath path;
      if (net::FileURLToFilePath(url, &path))
        return request_file_set_.find(path) != request_file_set_.end();
    }
    return false;  // Unmentioned schemes are disallowed.
  typedef std::set<FilePath> FileSet;
  // The set of files the child process is permitted to load.
  FileSet request_file_set_;

    // When the child process has been commanded to request this scheme,
    // we grant it the capability to request all URLs of that scheme.
void ChildProcessSecurityPolicyImpl::GrantRequestSpecificFileURL(
    int child_id,
    const GURL& url) {
  if (!url.SchemeIs(chrome::kFileScheme))
    return;

  {
    base::AutoLock lock(lock_);
    SecurityStateMap::iterator state = security_state_.find(child_id);
    if (state == security_state_.end())
      return;

    // When the child process has been commanded to request a file:// URL,
    // then we grant it the capability for that URL only.
    FilePath path;
    if (net::FileURLToFilePath(url, &path))
        state->second->GrantRequestOfSpecificFile(path);
  }
}

  // request the URL, along with permission to request all URLs of the same
  // scheme.
  // Whenever the browser process drops a file icon on a tab, it should call
  // this method to grant the child process the capability to request this one
  // file:// URL, but not all urls of the file:// scheme.
  void GrantRequestSpecificFileURL(int child_id, const GURL& url);

TEST_F(ChildProcessSecurityPolicyTest, SpecificFile) {
  ChildProcessSecurityPolicyImpl* p =
      ChildProcessSecurityPolicyImpl::GetInstance();

  p->Add(kRendererID);

  GURL icon_url("file:///tmp/foo.png");
  GURL sensitive_url("file:///etc/passwd");
  EXPECT_FALSE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_FALSE(p->CanRequestURL(kRendererID, sensitive_url));

  p->GrantRequestSpecificFileURL(kRendererID, icon_url);
  EXPECT_TRUE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_FALSE(p->CanRequestURL(kRendererID, sensitive_url));

  p->GrantRequestURL(kRendererID, icon_url);
  EXPECT_TRUE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_TRUE(p->CanRequestURL(kRendererID, sensitive_url));

  p->Remove(kRendererID);
}

    // A dragged file may wind up as the value of an input element, or it
    // may be used as the target of a navigation instead.  We don't know
    // which will happen at this point, so generously grant both access
    // and request permissions to the specific file to cover both cases.
    // We do not give it the permission to request all file:// URLs.
    policy->GrantRequestSpecificFileURL(renderer_id,
                                        net::FilePathToFileURL(path));
#include "base/utf_string_conversions.h"
  FilePath highlighted_file_path(FILE_PATH_LITERAL("/tmp/foo.html"));
  FilePath dragged_file_path(FILE_PATH_LITERAL("/tmp/image.jpg"));
  FilePath sensitive_file_path(FILE_PATH_LITERAL("/etc/passwd"));
  GURL highlighted_file_url = net::FilePathToFileURL(highlighted_file_path);
  GURL dragged_file_url = net::FilePathToFileURL(dragged_file_path);
  GURL sensitive_file_url = net::FilePathToFileURL(sensitive_file_path);
  dropped_data.url = highlighted_file_url;
  dropped_data.filenames.push_back(WebDropData::FileInfo(
      UTF8ToUTF16(dragged_file_path.AsUTF8Unsafe()), string16()));

                              WebKit::WebDragOperationNone, 0);

  int id = process()->GetID();
  ChildProcessSecurityPolicyImpl* policy =
      ChildProcessSecurityPolicyImpl::GetInstance();

  EXPECT_FALSE(policy->CanRequestURL(id, highlighted_file_url));
  EXPECT_FALSE(policy->CanReadFile(id, highlighted_file_path));
  EXPECT_TRUE(policy->CanRequestURL(id, dragged_file_url));
  EXPECT_TRUE(policy->CanReadFile(id, dragged_file_path));
  EXPECT_FALSE(policy->CanRequestURL(id, sensitive_file_url));
  EXPECT_FALSE(policy->CanReadFile(id, sensitive_file_path));
  // Use the frame's original request's URL rather than the document's URL for
  // subsequent checks.  For a popup, the document's URL may become the opener
  // window's URL if the opener has called document.write().
  // See http://crbug.com/93517.
  GURL old_url(frame->dataSource()->request().url());

    // Lastly, access to file:// URLs from non-file:// URL pages must be
    // handled by the browser so that ordinary renderer processes don't get
    // blessed with file permissions.
    int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
    bool is_initial_navigation = page_id_ == -1;
    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      // Fork non-file to file opens.  Check the opener URL if this is the
      // initial navigation in a newly opened window.
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (equalIgnoringCase(m_scheme, "http"))
        return equalIgnoringCase(url.protocol(), "http") || equalIgnoringCase(url.protocol(), "https");
    if (equalIgnoringCase(m_scheme, "ws"))
        return equalIgnoringCase(url.protocol(), "ws") || equalIgnoringCase(url.protocol(), "wss");
    EXPECT_TRUE(sourceList.matches(KURL(base, "https://example1.com/foo/")));
    EXPECT_TRUE(sourceList.matches(KURL(base, "https://example1.com:8000/foo/")));
    EXPECT_TRUE(sourceList.matches(KURL(base, "https://example1.com:9000/foo/")));
    EXPECT_TRUE(sourceList.matches(KURL(base, "https://foo.test/")));
    EXPECT_TRUE(sourceList.matches(KURL(base, "https://foo.bar.test/")));
    EXPECT_TRUE(sourceList.matches(KURL(base, "https://example1.com/foo/"), ContentSecurityPolicy::DidRedirect));
    EXPECT_TRUE(sourceList.matches(KURL(base, "https://example1.com/bar/"), ContentSecurityPolicy::DidRedirect));
    EXPECT_TRUE(source.matches(KURL(base, "https://example.com:8000/foo"), ContentSecurityPolicy::DidRedirect));
TEST_F(CSPSourceTest, InsecureSourceMatchesSecure)
{
    KURL base;
    CSPSource source(csp.get(), "http", "", 0, "/", CSPSource::NoWildcard, CSPSource::HasWildcard);

    EXPECT_TRUE(source.matches(KURL(base, "http://example.com:8000/")));
    EXPECT_TRUE(source.matches(KURL(base, "https://example.com:8000/")));
    EXPECT_TRUE(source.matches(KURL(base, "http://not-example.com:8000/")));
    EXPECT_TRUE(source.matches(KURL(base, "https://not-example.com:8000/")));
    EXPECT_FALSE(source.matches(KURL(base, "ftp://example.com:8000/")));
}

TEST_F(CSPSourceTest, InsecureHostMatchesSecure)
{
    KURL base;
    CSPSource source(csp.get(), "http", "example.com", 0, "/", CSPSource::NoWildcard, CSPSource::HasWildcard);

    EXPECT_TRUE(source.matches(KURL(base, "http://example.com:8000/")));
    EXPECT_FALSE(source.matches(KURL(base, "http://not-example.com:8000/")));
    EXPECT_TRUE(source.matches(KURL(base, "https://example.com:8000/")));
    EXPECT_FALSE(source.matches(KURL(base, "https://not-example.com:8000/")));
}

    ((static_cast<uint32>(static_cast<uint8>(a)) << 24) | \
     (static_cast<uint32>(static_cast<uint8>(b)) << 16) | \
     (static_cast<uint32>(static_cast<uint8>(c)) << 8) | \
     (static_cast<uint32>(static_cast<uint8>(d))))
    RuntimeEnabledFeatures::setStableFeaturesEnabled(enable);
    // FIXME: enableMediaPlayer does not use RuntimeEnabledFeatures
    // and does not belong as part of WebRuntimeFeatures.
    RuntimeEnabledFeatures::setExperimentalFeaturesEnabled(enable);
    RuntimeEnabledFeatures::setTestFeaturesEnabled(enable);
    return currentSpeechUtterance();
void SpeechSynthesis::startSpeakingImmediately()
    SpeechSynthesisUtterance* utterance = currentSpeechUtterance();
    ASSERT(utterance);

    // If the queue was empty, speak this immediately.
        startSpeakingImmediately();
    // Remove all the items from the utterance queue. The platform
    // may still have references to some of these utterances and may
    // fire events on them asynchronously.
    if (!currentSpeechUtterance())
    bool didJustFinishCurrentUtterance = false;
    // If the utterance that completed was the one we're currently speaking,
    // remove it from the queue and start speaking the next one.
    if (utterance == currentSpeechUtterance()) {
        m_utteranceQueue.removeFirst();
        didJustFinishCurrentUtterance = true;
    }
    // Always fire the event, because the platform may have asynchronously
    // sent an event on an utterance before it got the message that we
    // canceled it, and we should always report to the user what actually
    // happened.
    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());
    // Start the next utterance if we just finished one and one was pending.
    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
SpeechSynthesisUtterance* SpeechSynthesis::currentSpeechUtterance() const
{
    if (!m_utteranceQueue.isEmpty())
        return m_utteranceQueue.first().get();
    return nullptr;
}

    void startSpeakingImmediately();
    // Returns the utterance at the front of the queue.
    SpeechSynthesisUtterance* currentSpeechUtterance() const;

    , m_speakingErrorOccurredTimer(this, &PlatformSpeechSynthesizerMock::speakingErrorOccurred)
    m_speakingErrorOccurredTimer.stop();
void PlatformSpeechSynthesizerMock::speakingErrorOccurred(Timer<PlatformSpeechSynthesizerMock>*)
{
    ASSERT(m_utterance.get());
    client()->speakingErrorOccurred(m_utterance);
    m_utterance = nullptr;
}

    m_speakingErrorOccurredTimer.startOneShot(.1);
    void speakingErrorOccurred(Timer<PlatformSpeechSynthesizerMock>*);
    Timer<PlatformSpeechSynthesizerMock> m_speakingErrorOccurredTimer;
  AppWindow* app_window = registry->GetAppWindowForWebContents(contents);
          ->GetAppWindowForWebContents(web_contents);
  // Returns the RenderFrame given a routing id.
  static RenderFrame* FromRoutingID(int routing_id);

RenderFrame* RenderFrame::FromRoutingID(int routing_id) {
  return RenderFrameImpl::FromRoutingID(routing_id);
}

// static
RenderFrameImpl* RenderFrameImpl::FromRoutingID(int routing_id) {
  // TODO(devlin): Investigate if this is still used. If not, kill it dead!
        AppWindow* existing_window =
            AppWindowRegistry::Get(browser_context())
                ->GetAppWindowForAppAndKey(extension_id(),
                                           create_params.window_key);
        if (existing_window) {
          content::RenderFrameHost* existing_frame =
              existing_window->web_contents()->GetMainFrame();
          int frame_id = MSG_ROUTING_NONE;
              existing_frame->GetProcess()->GetID()) {
            frame_id = existing_frame->GetRoutingID();
              existing_window->Show(AppWindow::SHOW_INACTIVE);
              existing_window->Show(AppWindow::SHOW_ACTIVE);
          result->Set("frameId", new base::FundamentalValue(frame_id));
          existing_window->GetSerializedState(result);
  content::RenderFrameHost* created_frame =
      app_window->web_contents()->GetMainFrame();
  int frame_id = MSG_ROUTING_NONE;
  if (create_params.creator_process_id == created_frame->GetProcess()->GetID())
    frame_id = created_frame->GetRoutingID();
  result->Set("frameId", new base::FundamentalValue(frame_id));
          ->HadDevToolsAttached(app_window->web_contents())) {
  if (web_contents_->GetMainFrame()->GetProcess()->GetID() ==
    SuspendRenderFrameHost(web_contents_->GetMainFrame());
            << web_contents_->GetMainFrame()->GetProcess()->GetID()
void AppWindowContentsImpl::SuspendRenderFrameHost(
    content::RenderFrameHost* rfh) {
  DCHECK(rfh);
                 rfh->GetProcess()->GetID(), rfh->GetRoutingID()));
class RenderFrameHost;
  void SuspendRenderFrameHost(content::RenderFrameHost* rfh);
#include "base/strings/stringprintf.h"
    const content::WebContents* web_contents) const {
    content::WebContents* web_contents) const {
  std::string key = GetWindowKeyForWebContents(web_contents);
  std::string key = GetWindowKeyForWebContents(web_contents);
std::string AppWindowRegistry::GetWindowKeyForWebContents(
    content::WebContents* web_contents) const {
  AppWindow* app_window = GetAppWindowForWebContents(web_contents);
  if (!app_window)
    return std::string();  // Not an AppWindow.

  if (app_window->window_key().empty())
    return web_contents->GetURL().possibly_invalid_spec();

  return base::StringPrintf("%s:%s", app_window->extension_id().c_str(),
                            app_window->window_key().c_str());
}

      const content::WebContents* web_contents) const;
  // newly created |web_contents|.
  bool HadDevToolsAttached(content::WebContents* web_contents) const;
  // Create a key that identifies an AppWindow across App reloads. If the window
  // was given an id in CreateParams, the key is the extension id, a colon
  // separator, and the AppWindow's |id|. If there is no |id|, the
  // chrome-extension://extension-id/page.html URL will be used. If the
  // WebContents is not for a AppWindow, return an empty string.
  std::string GetWindowKeyForWebContents(
      content::WebContents* web_contents) const;

#include "content/public/renderer/render_frame_observer.h"
class DidCreateDocumentElementObserver : public content::RenderFrameObserver {
  DidCreateDocumentElementObserver(content::RenderFrame* frame,
                                   const ScriptContextSet* script_context_set)
      : content::RenderFrameObserver(frame),
        script_context_set_(script_context_set) {
    DCHECK(script_context_set_);
  }
  void DidCreateDocumentElement() override {
    blink::WebLocalFrame* web_frame = render_frame()->GetWebFrame();
    if (web_frame->parent())
    ScriptContext* script_context = script_context_set_->GetByV8Context(
        web_frame->mainWorldScriptContext());
  const ScriptContextSet* script_context_set_;

  DISALLOW_COPY_AND_ASSIGN(DidCreateDocumentElementObserver);
AppWindowCustomBindings::AppWindowCustomBindings(
    const ScriptContextSet* script_context_set,
    ScriptContext* context)
    : ObjectBackedNativeHandler(context),
      script_context_set_(script_context_set) {
  RouteFunction("GetFrame", base::Bind(&AppWindowCustomBindings::GetFrame,
                                       base::Unretained(this)));
void AppWindowCustomBindings::GetFrame(
  int frame_id = args[0]->Int32Value();
  if (frame_id == MSG_ROUTING_NONE)
  content::RenderFrame* app_frame =
      content::RenderFrame::FromRoutingID(frame_id);
  if (!app_frame)
  content::RenderFrame* context_render_frame = context()->GetRenderFrame();
  if (!context_render_frame)

  if (inject_titlebar)
    new DidCreateDocumentElementObserver(app_frame, script_context_set_);

  blink::WebFrame* opener = context_render_frame->GetWebFrame();
  blink::WebLocalFrame* app_web_frame = app_frame->GetWebFrame();
  app_web_frame->setOpener(opener);
      new ExtensionHostMsg_ResumeRequests(app_frame->GetRoutingID()));
  v8::Local<v8::Value> window =
      app_web_frame->mainWorldScriptContext()->Global();
class ScriptContextSet;
  AppWindowCustomBindings(const ScriptContextSet* script_context_set,
                          ScriptContext* context);
  void GetFrame(const v8::FunctionCallbackInfo<v8::Value>& args);
  // ScriptContextSet handle. Not owned.
  const ScriptContextSet* script_context_set_;
#include "extensions/renderer/render_frame_observer_natives.h"
      "renderFrameObserverNatives",
      scoped_ptr<NativeHandler>(new RenderFrameObserverNatives(context)));
  // |dispatcher| is null in unit tests.
  const ScriptContextSet* script_context_set = dispatcher ?
      &dispatcher->script_context_set() : nullptr;
      scoped_ptr<NativeHandler>(new AppWindowCustomBindings(
          script_context_set, context)));
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/render_frame_observer_natives.h"

#include "content/public/renderer/render_frame.h"
#include "content/public/renderer/render_frame_observer.h"
#include "extensions/renderer/script_context.h"

namespace extensions {

namespace {

// Deletes itself when done.
class LoadWatcher : public content::RenderFrameObserver {
 public:
  LoadWatcher(ScriptContext* context,
              content::RenderFrame* frame,
              v8::Local<v8::Function> cb)
      : content::RenderFrameObserver(frame),
        context_(context),
        callback_(context->isolate(), cb) {}

  void DidCreateDocumentElement() override { CallbackAndDie(true); }

  void DidFailProvisionalLoad(const blink::WebURLError& error) override {
    CallbackAndDie(false);
  }

 private:
  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
    delete this;
  }

  ScriptContext* context_;
  v8::Global<v8::Function> callback_;

  DISALLOW_COPY_AND_ASSIGN(LoadWatcher);
};

}  // namespace

RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
  RouteFunction(
      "OnDocumentElementCreated",
      base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                 base::Unretained(this)));
}

void RenderFrameObserverNatives::OnDocumentElementCreated(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK(args.Length() == 2);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsFunction());

  int frame_id = args[0]->Int32Value();

  content::RenderFrame* frame = content::RenderFrame::FromRoutingID(frame_id);
  if (!frame) {
    LOG(WARNING) << "No render frame found to register LoadWatcher.";
    return;
  }

  new LoadWatcher(context(), frame, args[1].As<v8::Function>());

  args.GetReturnValue().Set(true);
}

}  // namespace extensions
#ifndef EXTENSIONS_RENDERER_RENDER_FRAME_OBSERVER_NATIVES_H_
#define EXTENSIONS_RENDERER_RENDER_FRAME_OBSERVER_NATIVES_H_
// Native functions for JS to run callbacks upon RenderFrame events.
class RenderFrameObserverNatives : public ObjectBackedNativeHandler {
  explicit RenderFrameObserverNatives(ScriptContext* context);
  // Runs a callback upon creation of new document element inside a render frame

  DISALLOW_COPY_AND_ASSIGN(RenderFrameObserverNatives);
#endif  // EXTENSIONS_RENDERER_RENDER_FRAME_OBSERVER_NATIVES_H_
      DCHECK_EQ('/', suffix[0]);
        // Rely on the user's umask to produce correct permissions.
        LOG(WARNING) << "CopyDirectory() skipping symbolic link: " <<
            ent->fts_path;
        LOG(WARNING) << "CopyDirectory() skipping file of unknown type: " <<
            ent->fts_path;
      DCHECK_EQ('/', suffix[0]);
        // Rely on the user's umask to produce correct permissions.
        LOG(WARNING) << "skipping symbolic link: " << ent->fts_path;
        LOG(WARNING) << "skipping file of unknown type: " << ent->fts_path;
  GetUserMediaRequestFailed(&request_info->request, result, "");
    GetUserMediaRequestFailed(&request->request, result, result_name);
    MediaStreamRequestResult result,
    const blink::WebString& result_name) {
    case NUM_MEDIA_REQUEST_RESULTS:
      return;
      return;
      return;
      return;
      return;
      return;
      return;
      return;
      return;
      return;
      return;
    case MEDIA_DEVICE_NOT_SUPPORTED:
      request_info->requestFailedUASpecific("MediaDeviceNotSupported");
      return;
    case MEDIA_DEVICE_FAILED_DUE_TO_SHUTDOWN:
      request_info->requestFailedUASpecific("MediaDeviceFailedDueToShutdown");
      return;
  NOTREACHED();
  request_info->requestFailed();
      content::MediaStreamRequestResult result,

  if (hardware_initialized_) {
    DCHECK(compositor_);

    ScopedAppGLStateRestore state_restore;
    compositor_->ReleaseHwDraw();
    hardware_initialized_ = false;
  }


  // This can fail if Apps call destroy while the webview is still attached
  // to the view tree. This is an illegal operation that will lead to leaks.
  // Log for now. Consider a proper fix if this becomes a problem.
  LOG_IF(ERROR, hardware_initialized_)
      << "Destroy called before OnDetachedFromWindow. May Leak GL resources";
  if (!success)
    ResetContext3D();
void OutputSurface::ReleaseGL() {
  DCHECK(client_);
  DCHECK(context3d_);
  client_->ReleaseGL();
  ResetContext3D();
}

void OutputSurface::ResetContext3D() {
  context3d_.reset();
  callbacks_.reset();
}

  void ReleaseGL();
  void ResetContext3D();
  virtual void ReleaseGL() = 0;
#include "cc/test/fake_output_surface.h"
#include "cc/test/fake_output_surface_client.h"
  using OutputSurface::ReleaseGL;


  output_surface_.ReleaseGL();
  EXPECT_FALSE(output_surface_.context3d());
    case ResourceProvider::InvalidType:
      break;
      new ResourceProvider(output_surface, highp_threshold_min));

  bool success = false;
  if (output_surface->context3d()) {
    success = resource_provider->InitializeGL();
  } else {
    resource_provider->InitializeSoftware();
    success = true;
  }

  if (!success)

  DCHECK_NE(InvalidType, resource_provider->default_resource_type());
  CleanUpGLIfNeeded();
    case InvalidType:
      break;
    case InvalidType:
      break;
ResourceProvider::ResourceProvider(OutputSurface* output_surface,
                                   int highp_threshold_min)
      highp_threshold_min_(highp_threshold_min),
      default_resource_type_(InvalidType),
      best_texture_format_(0) {}

void ResourceProvider::InitializeSoftware() {
  DCHECK(thread_checker_.CalledOnValidThread());
  DCHECK_NE(Bitmap, default_resource_type_);

  CleanUpGLIfNeeded();

  default_resource_type_ = Bitmap;
  max_texture_size_ = INT_MAX / 2;
  best_texture_format_ = GL_RGBA;
bool ResourceProvider::InitializeGL() {
  DCHECK(!texture_uploader_);
  DCHECK_NE(GLTexture, default_resource_type_);

  DCHECK(context3d);

void ResourceProvider::CleanUpGLIfNeeded() {
  WebGraphicsContext3D* context3d = output_surface_->context3d();
  if (default_resource_type_ != GLTexture) {
    // We are not in GL mode, but double check before returning.
    DCHECK(!context3d);
    DCHECK(!texture_uploader_);
    return;
  }
  DCHECK(context3d);
  context3d->makeContextCurrent();
  texture_uploader_.reset();
  Finish();
    InvalidType = 0,
  void InitializeSoftware();
  bool InitializeGL();
  explicit ResourceProvider(OutputSurface* output_surface,
                            int highp_threshold_min);

  void CleanUpGLIfNeeded();
  int highp_threshold_min_;
#include "cc/test/fake_output_surface_client.h"
void GetResourcePixels(ResourceProvider* resource_provider,
                       ResourceProviderContext* context,
                       ResourceProvider::ResourceId id,
                       gfx::Size size,
                       WGC3Denum format,
                       uint8_t* pixels) {
  switch (resource_provider->default_resource_type()) {
    case ResourceProvider::GLTexture: {
      ResourceProvider::ScopedReadLockGL lock_gl(resource_provider, id);
      ASSERT_NE(0U, lock_gl.texture_id());
      context->bindTexture(GL_TEXTURE_2D, lock_gl.texture_id());
      context->GetPixels(size, format, pixels);
      break;
    }
    case ResourceProvider::Bitmap: {
      ResourceProvider::ScopedReadLockSoftware lock_software(resource_provider,
                                                             id);
      memcpy(pixels,
             lock_software.sk_bitmap()->getPixels(),
             lock_software.sk_bitmap()->getSize());
      break;
    }
    case ResourceProvider::InvalidType:
      NOTREACHED();
      break;
  }
}

      : shared_data_(ContextSharedData::Create()) {
    switch (GetParam()) {
      case ResourceProvider::GLTexture:
        output_surface_ =
            FakeOutputSurface::Create3d(ResourceProviderContext::Create(
                shared_data_.get()).PassAs<WebKit::WebGraphicsContext3D>());
        break;
      case ResourceProvider::Bitmap:
        output_surface_ = FakeOutputSurface::CreateSoftware(
            make_scoped_ptr(new SoftwareOutputDevice));
        break;
      case ResourceProvider::InvalidType:
        NOTREACHED();
        break;
    }
    resource_provider_ = ResourceProvider::Create(output_surface_.get(), 0);
void CheckCreateResource(ResourceProvider::ResourceType expected_default_type,
                         ResourceProvider* resource_provider,
                         ResourceProviderContext* context) {
  DCHECK_EQ(expected_default_type, resource_provider->default_resource_type());

  ResourceProvider::ResourceId id = resource_provider->CreateResource(
  EXPECT_EQ(1, static_cast<int>(resource_provider->num_resources()));
  if (expected_default_type == ResourceProvider::GLTexture)
    EXPECT_EQ(0, context->texture_count());
  resource_provider->SetPixels(id, data, rect, rect, gfx::Vector2d());
  if (expected_default_type == ResourceProvider::GLTexture)
    EXPECT_EQ(1, context->texture_count());
  GetResourcePixels(resource_provider, context, id, size, format, result);
  resource_provider->DeleteResource(id);
  EXPECT_EQ(0, static_cast<int>(resource_provider->num_resources()));
  if (expected_default_type == ResourceProvider::GLTexture)
    EXPECT_EQ(0, context->texture_count());
}

TEST_P(ResourceProviderTest, Basic) {
  CheckCreateResource(GetParam(), resource_provider_.get(), context());
    GetResourcePixels(
        resource_provider_.get(), context(), id, size, format, result);
    GetResourcePixels(
        resource_provider_.get(), context(), id, size, format, result);
    GetResourcePixels(
        resource_provider_.get(), context(), id, size, format, result);
    GetResourcePixels(
        resource_provider_.get(), context(), id, size, format, result);
  GetResourcePixels(
      resource_provider_.get(), context(), mapped_id1, size, format, result);
  GetResourcePixels(
      resource_provider_.get(), context(), mapped_id2, size, format, result);
void InitializeGLAndCheck(ResourceProvider* resource_provider,
                          FakeOutputSurface* output_surface) {
  scoped_ptr<ContextSharedData> shared_data = ContextSharedData::Create();
  scoped_ptr<ResourceProviderContext> context =
      ResourceProviderContext::Create(shared_data.release());
  output_surface->SetAndInitializeContext3D(
      context.PassAs<WebKit::WebGraphicsContext3D>());
  EXPECT_TRUE(resource_provider->InitializeGL());
  CheckCreateResource(
      ResourceProvider::GLTexture,
      resource_provider,
      static_cast<ResourceProviderContext*>(output_surface->context3d()));
}

TEST(ResourceProviderTest, BasicInitializeGLSoftware) {
  FakeOutputSurfaceClient client;
  scoped_ptr<FakeOutputSurface> output_surface(
      FakeOutputSurface::CreateDeferredGL(
          scoped_ptr<SoftwareOutputDevice>(new SoftwareOutputDevice)));
  EXPECT_TRUE(output_surface->BindToClient(&client));
  scoped_ptr<ResourceProvider> resource_provider(
      ResourceProvider::Create(output_surface.get(), 0));

  CheckCreateResource(ResourceProvider::Bitmap, resource_provider.get(), NULL);

  InitializeGLAndCheck(resource_provider.get(), output_surface.get());

  resource_provider->InitializeSoftware();
  CheckCreateResource(ResourceProvider::Bitmap, resource_provider.get(), NULL);

  InitializeGLAndCheck(resource_provider.get(), output_surface.get());
}

  context3d_.reset();
  using OutputSurface::ReleaseGL;

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "cc/test/fake_output_surface_client.h"

namespace cc {

bool FakeOutputSurfaceClient::DeferredInitialize(
    scoped_refptr<ContextProvider> offscreen_context_provider) {
  deferred_initialize_called_ = true;
  return deferred_initialize_result_;
}

void FakeOutputSurfaceClient::BeginFrame(const BeginFrameArgs& args) {
  begin_frame_count_++;
}

void FakeOutputSurfaceClient::DidLoseOutputSurface() {
  did_lose_output_surface_called_ = true;
}

void FakeOutputSurfaceClient::SetMemoryPolicy(
    const ManagedMemoryPolicy& policy,
    bool discard_backbuffer_when_not_visible) {
  memory_policy_ = policy;
  discard_backbuffer_when_not_visible_ = discard_backbuffer_when_not_visible;
}

}  // namespace cc
// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CC_TEST_FAKE_OUTPUT_SURFACE_CLIENT_H_
#define CC_TEST_FAKE_OUTPUT_SURFACE_CLIENT_H_

#include "cc/output/managed_memory_policy.h"
#include "cc/output/output_surface_client.h"

namespace cc {

class FakeOutputSurfaceClient : public OutputSurfaceClient {
 public:
  FakeOutputSurfaceClient()
      : begin_frame_count_(0),
        deferred_initialize_result_(true),
        deferred_initialize_called_(false),
        did_lose_output_surface_called_(false),
        memory_policy_(0),
        discard_backbuffer_when_not_visible_(false) {}

  virtual bool DeferredInitialize(
      scoped_refptr<ContextProvider> offscreen_context_provider) OVERRIDE;
  virtual void ReleaseGL() OVERRIDE {}
  virtual void SetNeedsRedrawRect(gfx::Rect damage_rect) OVERRIDE {}
  virtual void BeginFrame(const BeginFrameArgs& args) OVERRIDE;
  virtual void OnSwapBuffersComplete(const CompositorFrameAck* ack) OVERRIDE {}
  virtual void DidLoseOutputSurface() OVERRIDE;
  virtual void SetExternalDrawConstraints(const gfx::Transform& transform,
                                          gfx::Rect viewport) OVERRIDE {}
  virtual void SetMemoryPolicy(
      const ManagedMemoryPolicy& policy,
      bool discard_backbuffer_when_not_visible) OVERRIDE;

  int begin_frame_count() {
    return begin_frame_count_;
  }

  void set_deferred_initialize_result(bool result) {
    deferred_initialize_result_ = result;
  }

  bool deferred_initialize_called() {
    return deferred_initialize_called_;
  }

  bool did_lose_output_surface_called() {
    return did_lose_output_surface_called_;
  }

  const ManagedMemoryPolicy& memory_policy() const { return memory_policy_; }

  bool discard_backbuffer_when_not_visible() const {
    return discard_backbuffer_when_not_visible_;
  }

 private:
  int begin_frame_count_;
  bool deferred_initialize_result_;
  bool deferred_initialize_called_;
  bool did_lose_output_surface_called_;
  ManagedMemoryPolicy memory_policy_;
  bool discard_backbuffer_when_not_visible_;
};

}  // namespace cc

#endif  // CC_TEST_FAKE_OUTPUT_SURFACE_CLIENT_H_
  virtual void ReleaseGL() OVERRIDE {}
    ResourceProvider* resource_provider,
    bool skip_gl_renderer) {
  } else if (output_surface->context3d() && !skip_gl_renderer) {
void LayerTreeHostImpl::CreateAndSetTileManager(
    ResourceProvider* resource_provider,
    bool using_map_image) {
  DCHECK(settings_.impl_side_painting);
  DCHECK(resource_provider);
  tile_manager_ = TileManager::Create(this,
                                      resource_provider,
                                      settings_.num_raster_threads,
                                      rendering_stats_instrumentation_,
                                      using_map_image);
  UpdateTileManagerMemoryPolicy(ActualManagedMemoryPolicy());
  need_check_for_completed_tile_uploads_before_draw_ = false;
}

  bool skip_gl_renderer = false;
  CreateAndSetRenderer(
      output_surface.get(), resource_provider.get(), skip_gl_renderer);
    CreateAndSetTileManager(resource_provider.get(),
                            GetRendererCapabilities().using_map_image);
  resource_provider_->InitializeGL();
  bool skip_gl_renderer = false;
  CreateAndSetRenderer(
      output_surface_.get(), resource_provider_.get(), skip_gl_renderer);
void LayerTreeHostImpl::ReleaseGL() {
  DCHECK(output_surface_->capabilities().deferred_gl_initialization);
  DCHECK(settings_.impl_side_painting);
  DCHECK(settings_.solid_color_scrollbars);
  DCHECK(output_surface_->context3d());

  ReleaseTreeResources();
  renderer_.reset();
  tile_manager_.reset();
  resource_provider_->InitializeSoftware();

  bool skip_gl_renderer = true;
  CreateAndSetRenderer(
      output_surface_.get(), resource_provider_.get(), skip_gl_renderer);
  DCHECK(renderer_);

  EnforceZeroBudget(true);
  CreateAndSetTileManager(resource_provider_.get(),
                          GetRendererCapabilities().using_map_image);
  DCHECK(tile_manager_);

  bool success = true;
  client_->DidTryInitializeRendererOnImplThread(
      success, scoped_refptr<ContextProvider>());
  client_->SetNeedsCommitOnImplThread();
}

  virtual void ReleaseGL() OVERRIDE;
                            ResourceProvider* resource_provider,
                            bool skip_gl_renderer);
  void CreateAndSetTileManager(ResourceProvider* resource_provider,
                               bool using_map_image);

  // Revert back to software.
  did_try_initialize_renderer_ = false;
  output_surface_ptr->ReleaseGL();
  EXPECT_TRUE(did_try_initialize_renderer_);
  DrawFrame();
    did_initialize_gl_ = false;
    did_release_gl_ = false;
    if (!did_initialize_gl_) {
      ImplThreadTaskRunner()->PostTask(
          FROM_HERE,
          base::Bind(
              &LayerTreeHostTestDeferredInitialize::DeferredInitializeAndRedraw,
              base::Unretained(this),
              base::Unretained(host_impl)));
    } else if (did_initialize_gl_ && !did_release_gl_) {
      EXPECT_EQ(2u, layer_impl->append_quads_count());
      ImplThreadTaskRunner()->PostTask(
          FROM_HERE,
          base::Bind(
              &LayerTreeHostTestDeferredInitialize::ReleaseGLAndRedraw,
              base::Unretained(this),
              base::Unretained(host_impl)));
    } else if (did_initialize_gl_ && did_release_gl_) {
      EXPECT_EQ(3u, layer_impl->append_quads_count());
      EndTest();
    EXPECT_FALSE(did_initialize_gl_);
    // SetAndInitializeContext3D calls SetNeedsCommit.
    did_initialize_gl_ = true;
  }
  void ReleaseGLAndRedraw(LayerTreeHostImpl* host_impl) {
    EXPECT_TRUE(did_initialize_gl_);
    EXPECT_FALSE(did_release_gl_);
    // ReleaseGL calls SetNeedsCommit.
    static_cast<FakeOutputSurface*>(host_impl->output_surface())->ReleaseGL();
    did_release_gl_ = true;
    EXPECT_TRUE(did_initialize_gl_);
    EXPECT_TRUE(did_release_gl_);
  bool did_initialize_gl_;
  bool did_release_gl_;
void SynchronousCompositorImpl::ReleaseHwDraw() {
  DCHECK(CalledOnValidThread());
  DCHECK(output_surface_);
  return output_surface_->ReleaseHwDraw();
}

  virtual void ReleaseHwDraw() OVERRIDE;
void SynchronousCompositorOutputSurface::ReleaseHwDraw() {
  cc::OutputSurface::ReleaseGL();
}

  void ReleaseHwDraw();
  // Synchronously initialize compositor for hardware draw. Can only be called
  // while compositor is in software only mode, either after compositor is
  // first created or after ReleaseHwDraw is called. It is invalid to
  // DemandDrawHw before this returns true.
  // Reverse of InitializeHwDraw above. Can only be called while hardware draw
  // is already initialized. Brings compositor back to software only mode and
  // releases all hardware resources.
  virtual void ReleaseHwDraw() = 0;

SpeechSynthesisUtterance* SpeechSynthesis::currentSpeechUtterance() const
{
    if (!m_utteranceQueue.isEmpty())
        return m_utteranceQueue.first().get();
    return 0;
}

  // NaCl's memory allocator requires 0mod64K alignment and size for
  // shared memory objects.  To allow passing shared memory to NaCl,
  // therefore we round the size actually created to the nearest 64K unit.
  // To avoid client impact, we continue to retain the size as the
  // actual requested size.
  uint32 rounded_size = (size + 0xffff) & ~0xffff;
      read_only_ ? PAGE_READONLY : PAGE_READWRITE, 0,
      static_cast<DWORD>(rounded_size),
    RuntimeEnabledFeatures::setStableFeaturesEnabled(enable);
    // FIXME: enableMediaPlayer does not use RuntimeEnabledFeatures
    // and does not belong as part of WebRuntimeFeatures.
    RuntimeEnabledFeatures::setExperimentalFeaturesEnabled(enable);
    RuntimeEnabledFeatures::setTestFeaturesEnabled(enable);
#include "grit/renderer_resources.h"
#include "grit/renderer_resources.h"
#include "grit/renderer_resources.h"
#include "grit/renderer_resources.h"

#include "grit/renderer_resources.h"
#include "grit/renderer_resources.h"
      IPC_MESSAGE_HANDLER(ViewHostMsg_CreateWorker, OnCreateWorker)
void ResourceMessageFilter::OnCreateWorker(const GURL& url,
                                           bool is_shared,
                                           const string16& name,
                                           int render_view_route_id,
                                           int* route_id) {
  WorkerService::GetInstance()->CreateWorker(
      url, is_shared, name, id(), render_view_route_id, this, id(), *route_id);
  void OnCreateWorker(const GURL& url,
                      bool is_shared,
                      const string16& name,
                      int render_view_route_id,
                      int* route_id);
  Send(new WorkerProcessMsg_CreateWorker(instance.url,
                                         instance.is_shared,
                                         instance.name,
                                         instance.worker_route_id));
      IPC_MESSAGE_HANDLER(ViewHostMsg_CreateWorker, OnCreateWorker)
void WorkerProcessHost::OnCreateWorker(const GURL& url,
                                       bool is_shared,
                                       const string16& name,
                                       int render_view_route_id,
                                       int* route_id) {
  WorkerService::GetInstance()->CreateWorker(
      url, is_shared, name, instances_.front().renderer_id,
    bool is_shared;
    string16 name;
  void OnCreateWorker(const GURL& url,
                      bool is_shared,
                      const string16& name,
                      int render_view_route_id,
                      int* route_id);
bool WorkerService::CreateWorker(const GURL &url,
                                 bool is_shared,
                                 const string16& name,
                                 int renderer_id,
                                 int render_view_route_id,
                                 IPC::Message::Sender* sender,
                                 int sender_id,
                                 int sender_route_id) {
  instance.name = name;
  instance.is_shared = is_shared;
  bool CreateWorker(const GURL &url,
                    bool is_shared,
                    const string16& name,
                    int renderer_pid,
                    int render_view_route_id,
                    IPC::Message::Sender* sender,
                    int sender_id,
                    int sender_route_id);
  IPC_SYNC_MESSAGE_CONTROL4_1(ViewHostMsg_CreateWorker,
                              bool /* is_shared */,
  IPC_MESSAGE_CONTROL4(WorkerProcessMsg_CreateWorker,
                       bool /* is_shared */,
                       string16 /* name */,
#include "chrome/renderer/websharedworker_proxy.h"
WebSharedWorkerProxy::WebSharedWorkerProxy(ChildThread* child_thread,
    : WebWorkerBase(child_thread, route_id, render_view_route_id) {
bool WebSharedWorkerProxy::isStarted() {
void WebSharedWorkerProxy::startWorkerContext(
    const WebKit::WebString& name,
  CreateWorkerContext(script_url, true, name, user_agent, source_code);
void WebSharedWorkerProxy::connect(WebKit::WebMessagePortChannel* channel) {
void WebSharedWorkerProxy::OnMessageReceived(const IPC::Message& message) {
  IPC_BEGIN_MESSAGE_MAP(WebSharedWorkerProxy, message)
void WebSharedWorkerProxy::OnWorkerCreated() {
#ifndef CHROME_RENDERER_WEBSHAREDWORKER_PROXY_H_
#define CHROME_RENDERER_WEBSHAREDWORKER_PROXY_H_
class WebSharedWorkerProxy : public WebKit::WebSharedWorker,
                             private WebWorkerBase {
  WebSharedWorkerProxy(ChildThread* child_thread,
                                  const WebKit::WebString& name,
  // IPC::Channel::Listener proxyementation.
  DISALLOW_COPY_AND_ASSIGN(WebSharedWorkerProxy);
#endif  // CHROME_RENDERER_WEBSHAREDWORKER_PROXY_H_
void WebWorkerBase::CreateWorkerContext(const GURL& script_url,
                                        bool is_shared,
                                        const string16& name,
  IPC::Message* create_message = new ViewHostMsg_CreateWorker(
      script_url, is_shared, name, render_view_route_id_, &route_id_);
  void CreateWorkerContext(const GURL& script_url,
                           bool is_shared,
                           const string16& name,
using WebKit::WebCommonWorkerClient;
  CreateWorkerContext(script_url, false, string16(), user_agent, source_code);
                        static_cast<WebCommonWorkerClient*>(client_),
                        WebCommonWorkerClient::workerContextDestroyed)
  void OnWorkerContextDestroyed();
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/worker/websharedworker_stub.h"

#include "chrome/common/webmessageportchannel_impl.h"
#include "chrome/common/worker_messages.h"
#include "webkit/api/public/WebSharedWorker.h"
#include "webkit/api/public/WebString.h"
#include "webkit/api/public/WebURL.h"

WebSharedWorkerStub::WebSharedWorkerStub(
    const string16& name, int route_id)
    : WebWorkerStubBase(route_id),
      name_(name) {

  // TODO(atwilson): Add support for NaCl when they support MessagePorts.
  impl_ = WebKit::WebSharedWorker::create(client());

}

WebSharedWorkerStub::~WebSharedWorkerStub() {
  impl_->clientDestroyed();
}

void WebSharedWorkerStub::OnMessageReceived(const IPC::Message& message) {
  IPC_BEGIN_MESSAGE_MAP(WebSharedWorkerStub, message)
    IPC_MESSAGE_HANDLER(WorkerMsg_StartWorkerContext, OnStartWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_TerminateWorkerContext,
                        OnTerminateWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_Connect, OnConnect)
  IPC_END_MESSAGE_MAP()
}

void WebSharedWorkerStub::OnStartWorkerContext(
    const GURL& url, const string16& user_agent, const string16& source_code) {
  impl_->startWorkerContext(url, name_, user_agent, source_code);
}

void WebSharedWorkerStub::OnConnect(int sent_message_port_id, int routing_id) {
  WebKit::WebMessagePortChannel* channel =
      new WebMessagePortChannelImpl(routing_id, sent_message_port_id);
  impl_->connect(channel);
}

void WebSharedWorkerStub::OnTerminateWorkerContext() {
  impl_->terminateWorkerContext();

  // Call the client to make sure context exits.
  EnsureWorkerContextTerminates();
}
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_WORKER_WEB_SHARED_WORKER_STUB_H_
#define CHROME_WORKER_WEB_SHARED_WORKER_STUB_H_

#include "chrome/worker/webworker_stub_base.h"
#include "chrome/worker/webworkerclient_proxy.h"
#include "googleurl/src/gurl.h"

namespace WebKit {
class WebSharedWorker;
}

// This class creates a WebSharedWorker, and translates incoming IPCs to the
// appropriate WebSharedWorker APIs.
class WebSharedWorkerStub : public WebWorkerStubBase {
 public:
  WebSharedWorkerStub(const string16& name, int route_id);

  // IPC::Channel::Listener implementation.
  virtual void OnMessageReceived(const IPC::Message& message);

 private:
  virtual ~WebSharedWorkerStub();

  // Invoked when the WebWorkerClientProxy is shutting down.
  void OnConnect(int sent_message_port_id, int routing_id);
  void OnStartWorkerContext(
      const GURL& url, const string16& user_agent, const string16& source_code);
  void OnTerminateWorkerContext();

  WebKit::WebSharedWorker* impl_;
  string16 name_;

  DISALLOW_COPY_AND_ASSIGN(WebSharedWorkerStub);
};

#endif  // CHROME_WORKER_WEB_SHARED_WORKER_STUB_H_
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/worker/webworker_stub.h"

#include "base/command_line.h"
#include "chrome/common/chrome_switches.h"
#include "chrome/common/webmessageportchannel_impl.h"
#include "chrome/common/worker_messages.h"
#include "chrome/worker/nativewebworker_impl.h"
#include "webkit/api/public/WebString.h"
#include "webkit/api/public/WebURL.h"
#include "webkit/api/public/WebWorker.h"

using WebKit::WebWorker;

static bool UrlIsNativeWorker(const GURL& url) {
  // If the renderer was not passed the switch to enable native workers,
  // then the URL should be treated as a JavaScript worker.
  if (!CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableNativeWebWorkers)) {
    return false;
  }
  // Based on the suffix, decide whether the url should be considered
  // a NativeWebWorker (for .nexe) or a WebWorker (for anything else).
  const std::string kNativeSuffix(".nexe");
  std::string worker_url = url.path();
  // Compute the start index of the suffix.
  std::string::size_type suffix_index =
      worker_url.length() - kNativeSuffix.length();
  std::string::size_type pos = worker_url.find(kNativeSuffix, suffix_index);
  return (suffix_index == pos);
}

WebWorkerStub::WebWorkerStub(const GURL& url, int route_id)
    : WebWorkerStubBase(route_id) {
  if (UrlIsNativeWorker(url)) {
    // Launch a native worker.
    impl_ = NativeWebWorkerImpl::create(client());
  } else {
    // Launch a JavaScript worker.
    impl_ = WebKit::WebWorker::create(client());
  }
}

WebWorkerStub::~WebWorkerStub() {
  impl_->clientDestroyed();
}

void WebWorkerStub::OnMessageReceived(const IPC::Message& message) {
  if (!impl_)
    return;

  IPC_BEGIN_MESSAGE_MAP(WebWorkerStub, message)
    IPC_MESSAGE_FORWARD(WorkerMsg_StartWorkerContext, impl_,
                        WebWorker::startWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_TerminateWorkerContext,
                        OnTerminateWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_PostMessage, OnPostMessage)
    IPC_MESSAGE_FORWARD(WorkerMsg_WorkerObjectDestroyed, impl_,
                        WebWorker::workerObjectDestroyed)
  IPC_END_MESSAGE_MAP()
}

void WebWorkerStub::OnTerminateWorkerContext() {
  impl_->terminateWorkerContext();

  // Call the client to make sure context exits.
  EnsureWorkerContextTerminates();
}

void WebWorkerStub::OnPostMessage(
    const string16& message,
    const std::vector<int>& sent_message_port_ids,
    const std::vector<int>& new_routing_ids) {
  WebKit::WebMessagePortChannelArray channels(sent_message_port_ids.size());
  for (size_t i = 0; i < sent_message_port_ids.size(); i++) {
    channels[i] = new WebMessagePortChannelImpl(
        new_routing_ids[i], sent_message_port_ids[i]);
  }

  impl_->postMessageToWorkerContext(message, channels);
}
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_WORKER_WEB_WORKER_STUB_H_
#define CHROME_WORKER_WEB_WORKER_STUB_H_

#include "chrome/worker/webworker_stub_base.h"
#include "chrome/worker/webworkerclient_proxy.h"
#include "googleurl/src/gurl.h"

namespace WebKit {
class WebWorker;
}

// This class creates a WebWorker, and translates incoming IPCs to the
// appropriate WebWorker APIs.
class WebWorkerStub : public WebWorkerStubBase {
 public:
  WebWorkerStub(const GURL& url, int route_id);

  // IPC::Channel::Listener implementation.
  virtual void OnMessageReceived(const IPC::Message& message);

 private:
  virtual ~WebWorkerStub();

  void OnTerminateWorkerContext();
  void OnPostMessage(const string16& message,
                     const std::vector<int>& sent_message_port_ids,
                     const std::vector<int>& new_routing_ids);

  WebKit::WebWorker* impl_;

  DISALLOW_COPY_AND_ASSIGN(WebWorkerStub);
};

#endif  // CHROME_WORKER_WEB_WORKER_STUB_H_
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/worker/webworker_stub_base.h"

#include "base/compiler_specific.h"
#include "chrome/common/child_process.h"
#include "chrome/worker/worker_thread.h"

WebWorkerStubBase::WebWorkerStubBase(int route_id)
    : route_id_(route_id),
      ALLOW_THIS_IN_INITIALIZER_LIST(client_(route_id, this)) {

  // Start processing incoming IPCs for this worker.
  WorkerThread::current()->AddRoute(route_id_, this);
  ChildProcess::current()->AddRefProcess();
}

WebWorkerStubBase::~WebWorkerStubBase() {
  WorkerThread::current()->RemoveRoute(route_id_);
  ChildProcess::current()->ReleaseProcess();
}

void WebWorkerStubBase::Shutdown() {
  // The worker has exited - free ourselves and the client.
  delete this;
}

void WebWorkerStubBase::EnsureWorkerContextTerminates() {
  client_.EnsureWorkerContextTerminates();
}
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_WORKER_WEB_WORKER_STUB_BASE_H_
#define CHROME_WORKER_WEB_WORKER_STUB_BASE_H_

#include "chrome/worker/webworkerclient_proxy.h"
#include "ipc/ipc_channel.h"

// This class is the common base class for both WebWorkerStub and
// WebSharedWorkerStub and contains common setup/teardown functionality.
class WebWorkerStubBase : public IPC::Channel::Listener {
 public:
  WebWorkerStubBase(int route_id);
  virtual ~WebWorkerStubBase();

  // Invoked when the WebWorkerClientProxy is shutting down.
  void Shutdown();

  // Called after terminating the worker context to make sure that the worker
  // actually terminates (is not stuck in an infinite loop).
  void EnsureWorkerContextTerminates();

  WebWorkerClientProxy* client() { return &client_; }

 private:
  int route_id_;

  // WebWorkerClient that responds to outgoing API calls from the worker object.
  WebWorkerClientProxy client_;

  DISALLOW_COPY_AND_ASSIGN(WebWorkerStubBase);
};

#endif  // CHROME_WORKER_WEB_WORKER_STUB_BASE_H_
#include "chrome/worker/webworker_stub_base.h"
WebWorkerClientProxy::WebWorkerClientProxy(int route_id,
                                           WebWorkerStubBase* stub)
    : route_id_(route_id),
      stub_(stub),
  // Tell the stub that the worker has shutdown - frees this object.
  if (stub_)
    stub_->Shutdown();
void WebWorkerClientProxy::EnsureWorkerContextTerminates() {
class WebWorkerStubBase;

class WebWorkerClientProxy : public WebKit::WebWorkerClient {
  WebWorkerClientProxy(int route_id, WebWorkerStubBase* stub);
  ~WebWorkerClientProxy();
  void EnsureWorkerContextTerminates();
  WebWorkerStubBase* stub_;
#include "chrome/worker/webworker_stub.h"
#include "chrome/worker/websharedworker_stub.h"
void WorkerThread::OnCreateWorker(const GURL& url,
                                  bool is_shared,
                                  const string16& name,
                                  int route_id) {
  // WebWorkerStub and WebSharedWorkerStub own themselves.
  if (is_shared)
    new WebSharedWorkerStub(name, route_id);
  else
    new WebWorkerStub(url, route_id);
  void OnCreateWorker(
      const GURL& url, bool is_shared, const string16& name, int route_id);
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef WebCommonWorkerClient_h
#define WebCommonWorkerClient_h

namespace WebKit {
    class WebNotificationPresenter;
    class WebString;
    class WebWorker;
    class WebWorkerClient;

    // Provides an interface back to the in-page script object for a worker.
    // This interface contains common APIs used by both shared and dedicated
    // workers.
    // All functions are expected to be called back on the thread that created
    // the Worker object, unless noted.
    class WebCommonWorkerClient {
    public:
        virtual void postExceptionToWorkerObject(
            const WebString& errorString, int lineNumber,
            const WebString& sourceURL) = 0;

        virtual void postConsoleMessageToWorkerObject(
            int destinationIdentifier,
            int sourceIdentifier,
            int messageType,
            int messageLevel,
            const WebString& message,
            int lineNumber,
            const WebString& sourceURL) = 0;

        virtual void workerContextDestroyed() = 0;

        // Returns the notification presenter for this worker context.  Pointer
        // is owned by the object implementing WebCommonWorkerClient.
        virtual WebNotificationPresenter* notificationPresenter() = 0;

        // This can be called on any thread to create a nested WebWorker.
        // WebSharedWorkers are not instantiated via this API - instead
        // they are created via the WebSharedWorkerRepository.
        virtual WebWorker* createWorker(WebWorkerClient* client) = 0;

    protected:
        ~WebCommonWorkerClient() { }
    };

} // namespace WebKit

#endif
    class WebCommonWorkerClient;
        // Invoked from the worker thread to instantiate a WebSharedWorker that interacts with the WebKit worker components.
        WEBKIT_API static WebSharedWorker* create(WebCommonWorkerClient*);

        virtual ~WebSharedWorker() {};
                                        const WebString& name,
        // Sends a connect event to the SharedWorker context.

        // Invoked to shutdown the worker when there are no more associated documents.
        virtual void terminateWorkerContext() = 0;

        // Notification when the WebCommonWorkerClient is destroyed.
        virtual void clientDestroyed() = 0;
#include "WebCommonWorkerClient.h"
    class WebWorkerClient : public WebCommonWorkerClient {
  SharedWorkerScriptLoader(PassRefPtr<SharedWorker> worker, const KURL& url, const String& name, PassOwnPtr<MessagePortChannel> port, PassOwnPtr<WebSharedWorker> webWorker)
      : m_worker(worker),
        m_url(url),
        m_name(name),
        m_webWorker(webWorker),
        m_port(port)
    void load();
    KURL m_url;
    String m_name;
void SharedWorkerScriptLoader::load()
    m_scriptLoader.loadAsynchronously(m_worker->scriptExecutionContext(), m_url, DenyCrossOriginRequests, this);
        m_webWorker->startWorkerContext(m_url, m_name, m_worker->scriptExecutionContext()->userAgent(m_url), m_scriptLoader.script());
        SharedWorkerScriptLoader* loader = new SharedWorkerScriptLoader(worker, url, name, port.release(), webWorker.release());
        loader->load();
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "WebSharedWorkerImpl.h"

using namespace WebCore;

namespace WebKit {

#if ENABLE(SHARED_WORKERS)

WebSharedWorker* WebSharedWorker::create(WebCommonWorkerClient* client)
{
    // FIXME: Return an instance of WebSharedWorkerImpl once the implementation is complete.
    ASSERT_NOT_REACHED();
    return NULL;
}

#endif // ENABLE(SHARED_WORKERS)

} // namespace WebKit
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef WebSharedWorkerImpl_h
#define WebSharedWorkerImpl_h

#include "WebSharedWorker.h"

#if ENABLE(SHARED_WORKERS)

#include "ScriptExecutionContext.h"
#include "WorkerLoaderProxy.h"
#include "WorkerObjectProxy.h"
#include <wtf/PassOwnPtr.h>
#include <wtf/RefPtr.h>

namespace WebCore {
class SharedWorkerThread;
}

namespace WebKit {
class WebView;

// This class is used by the worker process code to talk to the WebCore::SharedWorker implementation.
// It can't use it directly since it uses WebKit types, so this class converts the data types.
// When the WebCore::SharedWorker object wants to call WebCore::WorkerReportingProxy, this class will
// convert to Chrome data types first and then call the supplied WebCommonWorkerClient.
class WebSharedWorkerImpl : public WebCore::WorkerLoaderProxy {
public:
    explicit WebSharedWorkerImpl(WebCommonWorkerClient* client);

    // WebSharedWorker methods:
    virtual bool isStarted();
    virtual void startWorkerContext(const WebURL&, const WebString& name, const WebString& userAgent, const WebString& sourceCode);
    virtual void connect(WebMessagePortChannel*);

    WebCommonWorkerClient* client() { return m_client; }

private:
    virtual ~WebSharedWorkerImpl();

    WebCommonWorkerClient* m_client;

    RefPtr<WebCore::SharedWorkerThread> m_workerThread;
};

} // namespace WebKit

#endif // ENABLE(SHARED_WORKERS)

#endif
using blink::WebFrame;
  WebFrame* frame = context()->web_frame();
    WebFrame* frame,
#include "third_party/WebKit/public/web/WebFrame.h"
      blink::WebFrame* frame,
#include "extensions/common/extension.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "extensions/renderer/extension_groups.h"
const Extension* Dispatcher::GetExtensionFromFrameAndWorld(
    const blink::WebFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.

    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_.GetExtensionOrAppIDByURL(frame_url);
  }

  const Extension* extension = extensions_.GetByID(extension_id);
  if (!extension && !extension_id.empty()) {
    // There are conditions where despite a context being associated with an
    // extension, no extension actually gets found.  Ignore "invalid" because
    // CSP blocks extension page loading by switching the extension ID to
    // "invalid". This isn't interesting.
    if (extension_id != "invalid") {
      LOG(ERROR) << "Extension \"" << extension_id << "\" not found";
      RenderThread::Get()->RecordAction(
          UserMetricsAction("ExtensionNotFound_ED"));
    }
  }
  return extension;
}

  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());

  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  script_context_set_.Add(context);
  if (context_type == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(extension);
  switch (context_type) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  ScriptContext* context = script_context_set_.GetByV8Context(v8_context);
  script_context_set_.Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  if (IsSandboxedPage(ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_.ForEach(
  script_context_set_.ForEach(
  MessagingBindings::DeliverMessage(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(script_context_set_, port_id,
  ScriptContextSet::ContextSet removed_contexts =
      script_context_set_.OnExtensionUnloaded(id);
  for (ScriptContextSet::ContextSet::iterator it = removed_contexts.begin();
       it != removed_contexts.end(); ++it) {
    request_sender_->InvalidateSource(*it);
// TODO(kalman): This is checking for the wrong thing, it should be checking if
// the frame's security origin is unique. The extension sandbox directive is
// checked for in extensions/common/manifest_handlers/csp_info.cc.
bool Dispatcher::IsSandboxedPage(const GURL& url) const {
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions_.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

Feature::Context Dispatcher::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (IsSandboxedPage(url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && IsExtensionActive(extension->id())) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of IsSandboxedPage().
  if (!origin.isUnique() && extensions_.ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

class Extension;
    return script_context_set_;
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(const blink::WebFrame* frame,
                                                 int world_id,
                                                 bool use_effective_url);

  bool IsSandboxedPage(const GURL& url) const;

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  ScriptContextSet script_context_set_;
  std::set<std::string> active_extension_ids_;
#include "third_party/WebKit/public/web/WebFrame.h"
    bool* port_created,
    *port_created |= retval->BooleanValue();
  // TODO(robwu): ScriptContextSet.ForEach should accept RenderFrame*.
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  bool port_created = false;
  context_set.ForEach(
      info.target_id, restrict_to_render_view,
                 channel_name, &source, info, tls_channel_id, &port_created));

  // If we didn't create a port, notify the other end of the channel (treat it
  // as a disconnect).
  if (!port_created) {
    content::RenderThread::Get()->Send(new ExtensionHostMsg_CloseChannel(
        target_port_id, kReceivingEndDoesntExistError));
  }
  scoped_ptr<blink::WebScopedUserGesture> web_user_gesture;
  scoped_ptr<blink::WebScopedWindowFocusAllowedIndicator> allow_window_focus;
  if (message.user_gesture) {
    web_user_gesture.reset(new blink::WebScopedUserGesture);
    allow_window_focus.reset(new blink::WebScopedWindowFocusAllowedIndicator);
  }

  // TODO(robwu): ScriptContextSet.ForEach should accept RenderFrame*.
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  context_set.ForEach(
      restrict_to_render_view,
      base::Bind(&DeliverMessageToScriptContext, message.data, target_port_id));
  // TODO(robwu): ScriptContextSet.ForEach should accept RenderFrame*.
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  context_set.ForEach(
      restrict_to_render_view,
#include "third_party/WebKit/public/web/WebFrame.h"
  if (blink::WebFrame* webframe = context->web_frame())
                             blink::WebFrame* web_frame,
  gin::PerContextData::From(v8_context)->set_runner(runner_.get());
                blink::WebFrame* frame,
  blink::WebFrame* web_frame() const { return web_frame_; }
  // The WebFrame associated with this context. This can be NULL because this
  // object can outlive is destroyed asynchronously.
  blink::WebFrame* web_frame_;
ScriptContextSet::ScriptContextSet() {
int ScriptContextSet::size() const {
  return static_cast<int>(contexts_.size());
}
void ScriptContextSet::Add(ScriptContext* context) {
#if DCHECK_IS_ON()
  // It's OK to insert the same context twice, but we should only ever have
  // one ScriptContext per v8::Context.
  for (ContextSet::iterator iter = contexts_.begin(); iter != contexts_.end();
       ++iter) {
    ScriptContext* candidate = *iter;
    if (candidate != context)
      DCHECK(candidate->v8_context() != context->v8_context());
  }
#endif
  contexts_.insert(context);
    base::MessageLoop::current()->DeleteSoon(FROM_HERE, context);
ScriptContextSet::ContextSet ScriptContextSet::GetAll() const {
  return contexts_;
}

                              : NULL;
  return calling.IsEmpty() ? NULL : GetByV8Context(calling);
    v8::Handle<v8::Context> v8_context) const {
  for (ContextSet::const_iterator iter = contexts_.begin();
       iter != contexts_.end(); ++iter) {
    if ((*iter)->v8_context() == v8_context)
      return *iter;
  return NULL;
void ScriptContextSet::ForEach(
    content::RenderView* render_view,
  ContextSet contexts = GetAll();

  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    ScriptContext* context = *it;

    if (render_view && render_view != context_render_view)
    callback.Run(context);
  }
}
ScriptContextSet::ContextSet ScriptContextSet::OnExtensionUnloaded(
    const std::string& extension_id) {
  ContextSet contexts = GetAll();
  ContextSet removed;

  // Clean up contexts belonging to the unloaded extension. This is done so
  // that content scripts (which remain injected into the page) don't continue
  // receiving events and sending messages.
  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    if ((*it)->extension() && (*it)->extension()->id() == extension_id) {
      (*it)->DispatchOnUnloadEvent();
      removed.insert(*it);
      Remove(*it);

  return removed;
#include "base/basictypes.h"
#include "base/bind.h"
namespace v8 {
class Context;
}

// A container of ExtensionBindingsContext. Since calling JavaScript within a
// context can cause any number of contexts to be created or destroyed, this
// has additional smarts to help with the set changing underneath callers.
  ScriptContextSet();
  int size() const;
  // Takes ownership of |context|.
  void Add(ScriptContext* context);
  // Returns a copy to protect against changes.
  typedef std::set<ScriptContext*> ContextSet;
  ContextSet GetAll() const;

  ScriptContext* GetByV8Context(v8::Handle<v8::Context> context) const;
  // |extension_id| in |render_view|.
  // An empty |extension_id| will match all extensions, and a NULL |render_view|
  // will match all render views, but try to use the inline variants of these
  // methods instead.
               content::RenderView* render_view,
  void ForEach(content::RenderView* render_view,
    ForEach("", render_view, callback);
  ContextSet OnExtensionUnloaded(const std::string& extension_id);
  ContextSet contexts_;
#include "third_party/WebKit/public/web/WebFrame.h"
TEST(ScriptContextSet, Lifecycle) {
  ScriptContextSet context_set;
  context_holder.SetContext(v8::Context::New(isolate));

  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  const Extension* extension = NULL;
  ScriptContext* context =
      new ScriptContext(context_holder.context(), frame, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT);
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  EXPECT_EQ(context, context_set.GetByV8Context(context->v8_context()));
  // Adding the same item multiple times should be OK and deduped.
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  // GetAll() returns a copy so removing from one should not remove from others.
  ScriptContextSet::ContextSet set_copy = context_set.GetAll();
  EXPECT_EQ(1u, set_copy.count(context));
  EXPECT_EQ(0, context_set.size());
  EXPECT_FALSE(context_set.GetByV8Context(context->v8_context()));
  EXPECT_EQ(1u, set_copy.size());
  // After removal, the context should be marked for destruction.
  EXPECT_FALSE(context->web_frame());
#include "third_party/WebKit/public/web/WebLocalFrame.h"
  blink::WebLocalFrame* frame = context()->web_frame();
    blink::WebLocalFrame* frame,

namespace blink {
class WebLocalFrame;
}
      blink::WebLocalFrame* frame,
  script_context_set_.reset(
      new ScriptContextSet(&extensions_, &active_extension_ids_));
  ScriptContext* context = script_context_set_->Register(
      frame, v8_context, extension_group, world_id);
  if (context->context_type() == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(context->extension());
  switch (context->context_type()) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  ScriptContext* context = script_context_set_->GetByV8Context(v8_context);
  script_context_set_->Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  if (ScriptContext::IsSandboxedPage(
          extensions_, ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_->ForEach(
  script_context_set_->ForEach(
  MessagingBindings::DeliverMessage(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(*script_context_set_, port_id,
  std::set<ScriptContext*> removed_contexts =
      script_context_set_->OnExtensionUnloaded(id);
  for (ScriptContext* context : removed_contexts) {
    request_sender_->InvalidateSource(context);
#include "base/memory/scoped_ptr.h"
#include "extensions/common/extension.h"
    return *script_context_set_;

  scoped_ptr<ScriptContextSet> script_context_set_;
  ExtensionIdSet active_extension_ids_;
#include "third_party/WebKit/public/web/WebLocalFrame.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
  if (blink::WebLocalFrame* webframe = context->web_frame())
#include "extensions/common/constants.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
                             blink::WebLocalFrame* web_frame,
  gin::PerContextData* gin_data = gin::PerContextData::From(v8_context);
  CHECK(gin_data);  // may fail if the v8::Context hasn't been registered yet
  gin_data->set_runner(runner_.get());
// static
bool ScriptContext::IsSandboxedPage(const ExtensionSet& extensions,
                                    const GURL& url) {
  // TODO(kalman): This is checking for the wrong thing, it should be checking
  // if the frame's security origin is unique. The extension sandbox directive
  // is checked for in extensions/common/manifest_handlers/csp_info.cc.
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

class WebLocalFrame;
class ExtensionSet;
                blink::WebLocalFrame* frame,
  // Returns whether |url| is sandboxed (as declared in any Extension in
  // |extension_set| as sandboxed).
  //
  // Declared in ScriptContext for lack of a better place, but this should
  // become unnecessary at some point as crbug.com/466373 is worked on.
  static bool IsSandboxedPage(const ExtensionSet& extension_set,
                              const GURL& url);

  blink::WebLocalFrame* web_frame() const { return web_frame_; }
  //
  // TODO(kalman): Remove this and replace with a GetOrigin() call which reads
  // of WebDocument::securityOrigin():
  //  - The URL can change (e.g. pushState) but the origin cannot. Luckily it
  //    appears as though callers don't make security decisions based on the
  //    result of GetURL() so it's not a problem... yet.
  //  - Origin is the correct check to be making.
  //  - It might let us remove the about:blank resolving?
  // The WebLocalFrame associated with this context. This can be NULL because
  // this object can outlive is destroyed asynchronously.
  blink::WebLocalFrame* web_frame_;
#include "content/public/common/url_constants.h"
#include "extensions/renderer/extension_groups.h"
#include "extensions/renderer/script_injection.h"
#include "third_party/WebKit/public/web/WebDocument.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
ScriptContextSet::ScriptContextSet(ExtensionSet* extensions,
                                   ExtensionIdSet* active_extension_ids)
    : extensions_(extensions), active_extension_ids_(active_extension_ids) {
ScriptContextSet::~ScriptContextSet() {
ScriptContext* ScriptContextSet::Register(
    blink::WebLocalFrame* frame,
    const v8::Handle<v8::Context>& v8_context,
    int extension_group,
    int world_id) {
  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());

  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  contexts_.insert(context);  // takes ownership
  return context;
                              : nullptr;
  return calling.IsEmpty() ? nullptr : GetByV8Context(calling);
    const v8::Handle<v8::Context>& v8_context) const {
  for (ScriptContext* script_context : contexts_) {
    if (script_context->v8_context() == v8_context)
      return script_context;
  return nullptr;
  std::set<ScriptContext*> contexts_copy = contexts_;
  for (ScriptContext* context : contexts_copy) {
std::set<ScriptContext*> ScriptContextSet::OnExtensionUnloaded(
  std::set<ScriptContext*> removed;
  ForEach(extension_id,
          base::Bind(&ScriptContextSet::DispatchOnUnloadEventAndRemove,
                     base::Unretained(this), &removed));
  return removed;
}

const Extension* ScriptContextSet::GetExtensionFromFrameAndWorld(
    const blink::WebLocalFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.
    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_->GetExtensionOrAppIDByURL(frame_url);
  // There are conditions where despite a context being associated with an
  // extension, no extension actually gets found. Ignore "invalid" because CSP
  // blocks extension page loading by switching the extension ID to "invalid".
  const Extension* extension = extensions_->GetByID(extension_id);
  if (!extension && !extension_id.empty() && extension_id != "invalid") {
    // TODO(kalman): Do something here?
  }
  return extension;
}

Feature::Context ScriptContextSet::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (ScriptContext::IsSandboxedPage(*extensions_, url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && active_extension_ids_->count(extension->id()) > 0) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of ScriptContext::IsSandboxedPage().
  if (!origin.isUnique() && extensions_->ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

void ScriptContextSet::DispatchOnUnloadEventAndRemove(
    std::set<ScriptContext*>* out,
    ScriptContext* context) {
  context->DispatchOnUnloadEvent();
  Remove(context);  // deleted asynchronously
  out->insert(context);
#include "base/macros.h"
#include "base/memory/weak_ptr.h"
#include "extensions/common/extension.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/features/feature.h"
#include "url/gurl.h"
namespace blink {
class WebLocalFrame;
class WebSecurityOrigin;
namespace content {
class RenderView;
// A container of ScriptContexts, responsible for both creating and managing
// them.
//
// Since calling JavaScript within a context can cause any number of contexts
// to be created or destroyed, this has additional smarts to help with the set
// changing underneath callers.
  ScriptContextSet(
      ExtensionSet* extensions,
      // Set of the IDs of extensions that are active in this process.
      // Must outlive this. TODO(kalman): Combine this and |extensions|.
      ExtensionIdSet* active_extension_ids);

  // Returns the number of contexts being tracked by this set.
  // This may also include invalid contexts. TODO(kalman): Useful?
  size_t size() const { return contexts_.size(); }
  // Creates and starts managing a new ScriptContext. Ownership is held.
  // Returns a weak reference to the new ScriptContext.
  ScriptContext* Register(blink::WebLocalFrame* frame,
                          const v8::Handle<v8::Context>& v8_context,
                          int extension_group,
                          int world_id);
  ScriptContext* GetByV8Context(const v8::Handle<v8::Context>& context) const;
  std::set<ScriptContext*> OnExtensionUnloaded(const std::string& extension_id);
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(
      const blink::WebLocalFrame* frame,
      int world_id,
      bool use_effective_url);

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  // Calls Remove on |context| then appends |context| to |out|.
  // This is a helper designed to be used by OnExtensionUnloaded with ForEach.
  void DispatchOnUnloadEventAndRemove(std::set<ScriptContext*>* out,
                                      ScriptContext* context);

  // Weak reference to all installed Extensions.
  ExtensionSet* extensions_;

  // Weak reference to all installed Extensions that are also active in this
  // process.
  ExtensionIdSet* active_extension_ids_;

  // The set of all ScriptContexts we own.
  std::set<ScriptContext*> contexts_;
#include <vector>

#include "extensions/common/extension_set.h"
TEST(ScriptContextSetTest, Lifecycle) {
  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebLocalFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  // Do this after construction of the webview, since it may construct the
  // Isolate.

  v8::Local<v8::Context> v8_context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(v8_context);
  // ScriptContext relies on gin, it just doesn't look like it from here.
  context_holder.SetContext(v8_context);
  ExtensionSet extensions;
  ExtensionIdSet active_extensions;
  ScriptContextSet context_set(&extensions, &active_extensions);
  ScriptContext* context = context_set.Register(
      frame, v8_context, 0, 0);  // no extension group or world ID
  // Context is valid and resembles correctness.
  EXPECT_TRUE(context->is_valid());
  EXPECT_EQ(frame, context->web_frame());
  EXPECT_EQ(v8_context, context->v8_context());
  // Context has been correctly added.
  EXPECT_EQ(1u, context_set.size());
  EXPECT_EQ(context, context_set.GetByV8Context(v8_context));
  // Test context is correctly removed.
  EXPECT_EQ(0u, context_set.size());
  EXPECT_EQ(nullptr, context_set.GetByV8Context(v8_context));
  int flags = base::PLATFORM_FILE_OPEN | base::PLATFORM_FILE_WRITE_ATTRIBUTES;

#if defined(OS_WIN)
  // On Windows, FILE_FLAG_BACKUP_SEMANTICS is needed to open a directory.
  if (DirectoryExists(path))
    flags |= base::PLATFORM_FILE_BACKUP_SEMANTICS;
#endif  // OS_WIN

  const base::PlatformFile file =
      base::CreatePlatformFile(path, flags, NULL, NULL);
  PLATFORM_FILE_BACKUP_SEMANTICS = 1 << 17,  // Used on Windows only
  if (flags & PLATFORM_FILE_BACKUP_SEMANTICS)
    create_flags |= FILE_FLAG_BACKUP_SEMANTICS;
TEST_F(LocalFileUtilTest, TouchFile) {
  const char *file_name = "test_file";
  base::PlatformFile file_handle;
  bool created;
  ASSERT_EQ(base::PLATFORM_FILE_OK,
            CreateFile(file_name, &file_handle, &created));
  ASSERT_TRUE(created);

  scoped_ptr<FileSystemOperationContext> context(NewContext());

  base::PlatformFileInfo info;
  ASSERT_TRUE(file_util::GetFileInfo(LocalPath(file_name), &info));
  const base::Time new_accessed =
      info.last_accessed + base::TimeDelta::FromHours(10);
  const base::Time new_modified =
      info.last_modified + base::TimeDelta::FromHours(5);

  EXPECT_EQ(base::PLATFORM_FILE_OK,
            FileUtil()->Touch(context.get(), Path(file_name),
                              new_accessed, new_modified));

  ASSERT_TRUE(file_util::GetFileInfo(LocalPath(file_name), &info));
  EXPECT_EQ(new_accessed, info.last_accessed);
  EXPECT_EQ(new_modified, info.last_modified);

  EXPECT_EQ(base::PLATFORM_FILE_OK,
            FileUtil()->Close(context.get(), file_handle));
}

TEST_F(LocalFileUtilTest, TouchDirectory) {
  const char *dir_name = "test_dir";
  scoped_ptr<FileSystemOperationContext> context(NewContext());
  ASSERT_EQ(base::PLATFORM_FILE_OK,
            FileUtil()->CreateDirectory(context.get(),
                                        Path(dir_name),
                                        false /* exclusive */,
                                        false /* recursive */));

  base::PlatformFileInfo info;
  ASSERT_TRUE(file_util::GetFileInfo(LocalPath(dir_name), &info));
  const base::Time new_accessed =
      info.last_accessed + base::TimeDelta::FromHours(10);
  const base::Time new_modified =
      info.last_modified + base::TimeDelta::FromHours(5);

  EXPECT_EQ(base::PLATFORM_FILE_OK,
            FileUtil()->Touch(context.get(), Path(dir_name),
                              new_accessed, new_modified));

  ASSERT_TRUE(file_util::GetFileInfo(LocalPath(dir_name), &info));
  EXPECT_EQ(new_accessed, info.last_accessed);
  EXPECT_EQ(new_modified, info.last_modified);
}

static bool schemeRequiresAuthority(const KURL& url)
    // We expect URLs with these schemes to have authority components. If the
    // URL lacks an authority component, we get concerned and mark the origin
    // as unique.
    return url.protocolIsInHTTPFamily() || url.protocolIs("ftp");
}

// Some URL schemes use nested URLs for their security context. For example,
// filesystem URLs look like the following:
//
//   filesystem:http://example.com/temporary/path/to/file.png
//
// We're supposed to use "http://example.com" as the origin.
//
// Generally, we add URL schemes to this list when WebKit support them. For
// example, we don't include the "jar" scheme, even though Firefox understands
// that jar uses an inner URL for it's security origin.
//
static bool shouldUseInnerURL(const KURL& url)
{
#if ENABLE(BLOB)
    if (url.protocolIs("blob"))
        return true;
#endif
#if ENABLE(FILE_SYSTEM)
    if (url.protocolIs("filesystem"))
        return true;
#endif
    return false;
}

// In general, extracting the inner URL varies by scheme. It just so happens
// that all the URL schemes we currently support that use inner URLs for their
// security origin can be parsed using this algorithm.
static KURL extractInnerURL(const KURL& url)
{
    // FIXME: Update this callsite to use the innerURL member function when
    // we finish implementing it.
    return KURL(ParsedURLString, decodeURLEscapeSequences(url.path()));
}

static bool isDirectory(const String& path)
{
    return path.endsWith("/");
}

static bool shouldTreatAsUniqueOrigin(const KURL& url)
{
    if (!url.isValid())
        return true;

    // FIXME: Do we need to unwrap the URL further?
    KURL innerURL = shouldUseInnerURL(url) ? extractInnerURL(url) : url;

    // FIXME: Check whether innerURL is valid.
    // For edge case URLs that were probably misparsed, make sure that the origin is unique.
    // FIXME: Do we really need to do this? This looks to be a hack around a
    // security bug in CFNetwork that might have been fixed.
    if (schemeRequiresAuthority(innerURL) && innerURL.host().isEmpty())
        return true;

    // SchemeRegistry needs a lower case protocol because it uses HashMaps
    // that assume the scheme has already been canonicalized.
    String protocol = innerURL.protocol().lower();

    if (SchemeRegistry::shouldTreatURLSchemeAsNoAccess(protocol))
        return true;

    // We use unique origins for directory listings to make it harder to crawl
    // a local filesystem. Notice that we apply this protection only when we
    // use the outer URL for the security context because schemes that wrap
    // other URLs don't have directory listings.
    if (SchemeRegistry::shouldTreatURLSchemeAsLocal(protocol) && !shouldUseInnerURL(url)) {
        if (!innerURL.hasPath() || isDirectory(innerURL.path()))
            return true;
    // This is the common case.
    return false;
SecurityOrigin::SecurityOrigin(const KURL& url)
    , m_isUnique(false)
    , m_needsDatabaseIdentifierQuirkForFiles(false)
    ASSERT(url.isValid());
    // By default, only local SecurityOrigins can load local resources.
    m_canLoadLocalResources = isLocal();

    if (m_canLoadLocalResources)
        m_filePath = url.path(); // In case enforceFilePathSeparation() is called.
}
SecurityOrigin::SecurityOrigin()
    : m_protocol("")
    , m_host("")
    , m_domain("")
    , m_port(InvalidPort)
    , m_isUnique(true)
    , m_universalAccess(false)
    , m_domainWasSetInDOM(false)
    , m_canLoadLocalResources(false)
    , m_enforceFilePathSeparation(false)
    , m_needsDatabaseIdentifierQuirkForFiles(false)
{
    , m_needsDatabaseIdentifierQuirkForFiles(other->m_needsDatabaseIdentifierQuirkForFiles)
    if (forceUnique || shouldTreatAsUniqueOrigin(url)) {
        RefPtr<SecurityOrigin> origin = adoptRef(new SecurityOrigin());

        if (url.protocolIs("file")) {
            // Unfortunately, we can't represent all unique origins exactly
            // the same way because we need to produce a quirky database
            // identifier for file URLs due to persistent storage in some
            // embedders of WebKit.
            origin->m_needsDatabaseIdentifierQuirkForFiles = true;
        }

        return origin.release();
    }

    if (shouldUseInnerURL(url))
        return adoptRef(new SecurityOrigin(extractInnerURL(url)));

    return adoptRef(new SecurityOrigin(url));
    RefPtr<SecurityOrigin> origin = adoptRef(new SecurityOrigin());
    if (m_needsDatabaseIdentifierQuirkForFiles)
    SecurityOrigin();
    explicit SecurityOrigin(const KURL&);
    bool m_needsDatabaseIdentifierQuirkForFiles;
    if (m_documentLoader) {
        FrameNavigationDisabler navigationDisabler(m_frame);
    }
FrameNavigationDisabler::FrameNavigationDisabler(LocalFrame* frame)
    : m_navigationScheduler(frame->navigationScheduler())
{
    m_navigationScheduler.disableFrameNavigation();
}

FrameNavigationDisabler::~FrameNavigationDisabler()
{
    m_navigationScheduler.enableFrameNavigation();
}

    , m_navigationDisableCount(0)
    return m_frame->page() && isFrameNavigationAllowed() && NavigationDisablerForBeforeUnload::isNavigationAllowed();
    return m_frame->page() && isFrameNavigationAllowed() && (protocolIsJavaScript(url) || NavigationDisablerForBeforeUnload::isNavigationAllowed());
class NavigationScheduler;
    STACK_ALLOCATED();
class FrameNavigationDisabler {
    WTF_MAKE_NONCOPYABLE(FrameNavigationDisabler);
    STACK_ALLOCATED();
public:
    explicit FrameNavigationDisabler(LocalFrame*);
    ~FrameNavigationDisabler();

private:
    FrameNavigationDisabler() = delete;

    NavigationScheduler& m_navigationScheduler;
};

    friend class FrameNavigationDisabler;

    void disableFrameNavigation() { ++m_navigationDisableCount; }
    void enableFrameNavigation() { --m_navigationDisableCount; }
    bool isFrameNavigationAllowed() const { return !m_navigationDisableCount; }

    int m_navigationDisableCount;
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Software adjust volume of samples, allows each audio stream its own
// volume without impacting master volume for chrome and other applications.

#include "base/basictypes.h"
#include "base/logging.h"
#include "media/audio/audio_util.h"

namespace media {

// Done as C for future assembly optimization and/or to move to different class.
// TODO(fbarchard): add channels_in to allow number of channels to be reduced.

template<class Format>
void AdjustVolumeInternal(Format* buf_out,
                          int sample_count,
                          float volume) {
  for (int i = 0; i < sample_count; ++i) {
    buf_out[i] = static_cast<Format>(buf_out[i] * volume);
  }
}

// AdjustVolume() does an in place audio sample change.
bool AdjustVolume(void* buf,
                  size_t buflen,
                  int channels,
                  int bytes_per_sample,
                  float volume) {
  DCHECK(buf);
  DCHECK(volume >= 0.0f && volume <= 1.0f);
  if (volume == 1.0f) {
    return true;
  } else if (volume == 0.0f) {
    memset(buf, 0, buflen);
    return true;
  }
  if (channels > 0 && channels <= 6 && bytes_per_sample > 0) {
    int sample_count = buflen / bytes_per_sample;
    if (bytes_per_sample == 1) {
      AdjustVolumeInternal(reinterpret_cast<uint8*>(buf),
                           sample_count,
                           volume);
      return true;
    } else if (bytes_per_sample == 2) {
      AdjustVolumeInternal(reinterpret_cast<int16*>(buf),
                           sample_count,
                           volume);
      return true;
    } else if (bytes_per_sample == 4) {
      AdjustVolumeInternal(reinterpret_cast<int32*>(buf),
                           sample_count,
                           volume);
      return true;
    }
  }
  return false;
}

}  // namespace media
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_AUDIO_AUDIO_UTIL_H_
#define MEDIA_AUDIO_AUDIO_UTIL_H_

#include "base/basictypes.h"

namespace media {

// AdjustVolume() does a software volume adjustment of a sample buffer.
// The samples are multiplied by the volume, which should range from
// 0.0 (mute) to 1.0 (full volume).
// Using software allows each audio and video to have its own volume without
// affecting the master volume.
// In the future the function may be used to adjust the sample format to
// simplify hardware requirements and to support a wider variety of input
// formats.
// The buffer is modified in-place to avoid memory management, as this
// function may be called in performance critical code.
bool AdjustVolume(void* buf,
                  size_t buflen,
                  int channels,
                  int bytes_per_sample,
                  float volume);

}  // namespace media

#endif  // MEDIA_AUDIO_AUDIO_UTIL_H_
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "base/basictypes.h"
#include "media/audio/audio_util.h"
#include "testing/gtest/include/gtest/gtest.h"

// Number of samples in each audio array.
static const size_t kNumberOfSamples = 4;

namespace media {

TEST(AudioUtilTest, AdjustVolume_u8) {
  // Test AdjustVolume() on 8 bit samples.
  uint8 samples_u8[kNumberOfSamples] = { 4, 0x40, 0x80, 0xff };
  uint8 expected_u8[kNumberOfSamples] = { 2, 0x20, 0x40, 0x7f };
  bool result_u8 = media::AdjustVolume(samples_u8, sizeof(samples_u8),
                                       1,  // channels.
                                       sizeof(samples_u8[0]),
                                       0.5f);
  EXPECT_EQ(true, result_u8);
  int expected_test = memcmp(samples_u8, expected_u8, sizeof(expected_u8));
  EXPECT_EQ(0, expected_test);
}

TEST(AudioUtilTest, AdjustVolume_s16) {
  // Test AdjustVolume() on 16 bit samples.
  int16 samples_s16[kNumberOfSamples] = { -4, 0x40, -32768, 123 };
  int16 expected_s16[kNumberOfSamples] = { -1, 0x10, -8192, 30 };
  bool result_s16 = media::AdjustVolume(samples_s16, sizeof(samples_s16),
                                        2,  // channels.
                                        sizeof(samples_s16[0]),
                                        0.25f);
  EXPECT_EQ(true, result_s16);
  int expected_test = memcmp(samples_s16, expected_s16, sizeof(expected_s16));
  EXPECT_EQ(0, expected_test);
}

TEST(AudioUtilTest, AdjustVolume_s16_zero) {
  // Test AdjustVolume() on 16 bit samples.
  int16 samples_s16[kNumberOfSamples] = { -4, 0x40, -32768, 123 };
  int16 expected_s16[kNumberOfSamples] = { 0, 0, 0, 0 };
  bool result_s16 = media::AdjustVolume(samples_s16, sizeof(samples_s16),
                                        2,  // channels.
                                        sizeof(samples_s16[0]),
                                        0.0f);
  EXPECT_EQ(true, result_s16);
  int expected_test = memcmp(samples_s16, expected_s16, sizeof(expected_s16));
  EXPECT_EQ(0, expected_test);
}

TEST(AudioUtilTest, AdjustVolume_s32) {
  // Test AdjustVolume() on 32 bit samples.
  int32 samples_s32[kNumberOfSamples] = { -4, 0x40, -32768, 123 };
  int32 expected_s32[kNumberOfSamples] = { -1, 0x10, -8192, 30 };
  bool result_s32 = media::AdjustVolume(samples_s32, sizeof(samples_s32),
                                        4,  // channels.
                                        sizeof(samples_s32[0]),
                                        0.25f);
  EXPECT_EQ(true, result_s32);
  int expected_test = memcmp(samples_s32, expected_s32, sizeof(expected_s32));
  EXPECT_EQ(0, expected_test);
}

}  // namespace media
#include "media/audio/audio_util.h"
      buffer_size_(0),
      volume_(1) {
    QueueNextPacket(buffer);  // Read more data.

                                            double ) {
  volume_ = static_cast<float>(left_level);
  *left_level = volume_;
  *right_level = volume_;
    media::AdjustVolume(buffer->lpData, buffer->dwBufferLength,
                        format_.nChannels, format_.wBitsPerSample >> 3,
                        volume_);

#ifndef MEDIA_AUDIO_WIN_WAVEOUT_OUTPUT_WIN_H_
#define MEDIA_AUDIO_WIN_WAVEOUT_OUTPUT_WIN_H_
  // Volume level from 0 to 1.
  float volume_;

#endif  // MEDIA_AUDIO_WIN_WAVEOUT_OUTPUT_WIN_H_

#include <errno.h>
#include <string.h>
  if (base::strlcpy(top_dir, utf8_path,
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }
bool CopyDirectory(const std::wstring& from_path_wide,
                   const std::wstring& to_path_wide,
                   bool recursive) {
  const std::string to_path = WideToUTF8(to_path_wide);
  const std::string from_path = WideToUTF8(from_path_wide);

  // Some old callers of CopyDirectory want it to support wildcards.
  // After some discussion, we decided to fix those callers.
  // Break loudly here if anyone tries to do this.
  // TODO(evanm): remove this once we're sure it's ok.
  DCHECK(to_path.find('*') == std::string::npos);
  DCHECK(from_path.find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  char* dir_list[] = { top_dir, NULL };
  FTS* fts = fts_open(dir_list, FTS_PHYSICAL | FTS_NOSTAT, NULL);
  if (!fts) {
    LOG(ERROR) << "fts_open failed: " << strerror(errno);
    return false;
  }

  int error = 0;
  FTSENT* ent;
  while (!error && (ent = fts_read(fts)) != NULL) {
    // ent->fts_path is the source path, including from_path, so paste
    // the suffix after from_path onto to_path to create the target_path.
    const std::string target_path = to_path + &ent->fts_path[from_path.size()];
    switch (ent->fts_info) {
      case FTS_D:  // Preorder directory.
        // If we encounter a subdirectory in a non-recursive copy, prune it
        // from the traversal.
        if (!recursive && ent->fts_level > 0) {
          if (fts_set(fts, ent, FTS_SKIP) != 0)
            error = errno;
          continue;
        }

        // Try creating the target dir, continuing on it if it exists already.
        if (mkdir(target_path.c_str(), 0777) != 0) {
          if (errno != EEXIST)
            error = errno;
        }
        break;
      case FTS_F:     // Regular file.
      case FTS_NSOK:  // File, no stat info requested.
        // TODO(port): use a native file path rather than all these
        // conversions.
        errno = 0;
        if (!CopyFile(UTF8ToWide(ent->fts_path), UTF8ToWide(target_path)))
          error = errno ? errno : EINVAL;
        break;
      case FTS_DP:   // Postorder directory.
      case FTS_DOT:  // "." or ".."
        // Skip it.
        continue;
      case FTS_DC:   // Directory causing a cycle.
        // Skip this branch.
        if (fts_set(fts, ent, FTS_SKIP) != 0)
          error = errno;
        break;
      case FTS_DNR:  // Directory cannot be read.
      case FTS_ERR:  // Error.
      case FTS_NS:   // Stat failed.
        // Abort with the error.
        error = ent->fts_errno;
        break;
      case FTS_SL:      // Symlink.
      case FTS_SLNONE:  // Symlink with broken target.
        LOG(WARNING) << "CopyDirectory() skipping symbolic link.";
        continue;
      case FTS_DEFAULT:  // Some other sort of file.
        LOG(WARNING) << "CopyDirectory() skipping weird file.";
        continue;
      default:
        NOTREACHED();
        continue;  // Hope for the best!
    }
  }
  // fts_read may have returned NULL and set errno to indicate an error.
  if (!error && errno != 0)
    error = errno;

  if (!fts_close(fts)) {
    // If we already have an error, let's use that error instead of the error
    // fts_close set.
    if (!error)
      error = errno;
  }

  if (error) {
    LOG(ERROR) << "CopyDirectory(): " << strerror(error);
    return false;
  }
  return true;
bool GetFileUrl(IDataObject* data_object, std::wstring* url,
                std::wstring* title) {
  STGMEDIUM store;
  if (SUCCEEDED(data_object->GetData(ClipboardUtil::GetFilenameWFormat(),
                                     &store))) {
    bool success = false;
    {
      // filename using unicode
      ScopedHGlobal<wchar_t> data(store.hGlobal);
      if (data.get() && data.get()[0] &&
          (PathFileExists(data.get()) || PathIsUNC(data.get()))) {
        wchar_t file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathW(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(file_url);
          title->assign(file_url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }

  if (SUCCEEDED(data_object->GetData(ClipboardUtil::GetFilenameFormat(),
                                     &store))) {
    bool success = false;
    {
      // filename using ascii
      ScopedHGlobal<char> data(store.hGlobal);
      if (data.get() && data.get()[0] && (PathFileExistsA(data.get()) ||
                                          PathIsUNCA(data.get()))) {
        char file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathA(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(UTF8ToWide(file_url));
          title->assign(*url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }
  return false;
}

    std::wstring* url, std::wstring* title, bool convert_filenames) {
  if (convert_filenames) {
    return GetFileUrl(data_object, url, title);
  } else {
    return false;
  return GetUrl(data_object, plain_text, &title, false);
      std::wstring* url, std::wstring* title, bool convert_filenames);
  bool success = ClipboardUtil::GetUrl(source_object_, &url_str, title, true);
      ClipboardUtil::GetUrl(data_object, &url, &title, true);
  if (ClipboardUtil::GetUrl(data_object, &url_str, &drop_data->url_title,
                            false)) {
bool GetFileUrl(IDataObject* data_object, std::wstring* url,
                std::wstring* title) {
  STGMEDIUM store;
  if (SUCCEEDED(data_object->GetData(ClipboardUtil::GetFilenameWFormat(),
                                     &store))) {
    bool success = false;
    {
      // filename using unicode
      ScopedHGlobal<wchar_t> data(store.hGlobal);
      if (data.get() && data.get()[0] &&
          (PathFileExists(data.get()) || PathIsUNC(data.get()))) {
        wchar_t file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathW(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(file_url);
          title->assign(file_url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }

  if (SUCCEEDED(data_object->GetData(ClipboardUtil::GetFilenameFormat(),
                                     &store))) {
    bool success = false;
    {
      // filename using ascii
      ScopedHGlobal<char> data(store.hGlobal);
      if (data.get() && data.get()[0] && (PathFileExistsA(data.get()) ||
                                          PathIsUNCA(data.get()))) {
        char file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathA(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(UTF8ToWide(file_url));
          title->assign(*url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }
  return false;
}

    std::wstring* url, std::wstring* title, bool convert_filenames) {
  if (convert_filenames) {
    return GetFileUrl(data_object, url, title);
  } else {
    return false;
  return GetUrl(data_object, plain_text, &title, false);
      std::wstring* url, std::wstring* title, bool convert_filenames);
  bool success = ClipboardUtil::GetUrl(source_object_, &url_str, title, true);
      ClipboardUtil::GetUrl(data_object, &url, &title, true);
  if (ClipboardUtil::GetUrl(data_object, &url_str, &drop_data->url_title,
                            false)) {
#include "chrome/browser/ui/webui/options/options_managed_banner_handler.h"
#include "chrome/browser/ui/webui/options/core_options_handler.h"
#include "chrome/browser/ui/webui/options/language_options_handler.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/content_settings_handler.h"
#include "chrome/browser/ui/webui/options/about_page_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#include "chrome/browser/ui/webui/options/add_startup_page_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#include "chrome/browser/ui/webui/options/advanced_options_handler.h"
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#include "chrome/browser/ui/webui/options/options_managed_banner_handler.h"
#include "chrome/browser/ui/webui/options/advanced_options_utils.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#include "chrome/browser/ui/webui/options/advanced_options_utils.h"
#include "chrome/browser/ui/webui/options/advanced_options_utils.h"
#include "chrome/browser/ui/webui/options/autofill_options_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/browser_options_handler.h"
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#include "chrome/browser/ui/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/certificate_manager_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/clear_browser_data_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#include "chrome/browser/ui/webui/options/content_settings_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#include "chrome/browser/ui/webui/options/cookies_view_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#include "chrome/browser/ui/webui/options/core_options_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#include "chrome/browser/ui/webui/options/font_settings_handler.h"
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#include "chrome/browser/ui/webui/options/font_settings_utils.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#include "chrome/browser/ui/webui/options/font_settings_utils.h"
#include "chrome/browser/ui/webui/options/font_settings_utils.h"
#include "chrome/browser/ui/webui/options/import_data_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#include "chrome/browser/ui/webui/options/language_options_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/language_options_handler_common.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/language_options_handler_common.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#include "chrome/browser/ui/webui/options/language_options_handler.h"
#include "chrome/browser/ui/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#include "chrome/browser/ui/webui/options/about_page_handler.h"
#include "chrome/browser/ui/webui/options/add_startup_page_handler.h"
#include "chrome/browser/ui/webui/options/advanced_options_handler.h"
#include "chrome/browser/ui/webui/options/autofill_options_handler.h"
#include "chrome/browser/ui/webui/options/browser_options_handler.h"
#include "chrome/browser/ui/webui/options/clear_browser_data_handler.h"
#include "chrome/browser/ui/webui/options/content_settings_handler.h"
#include "chrome/browser/ui/webui/options/cookies_view_handler.h"
#include "chrome/browser/ui/webui/options/core_options_handler.h"
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#include "chrome/browser/ui/webui/options/font_settings_handler.h"
#include "chrome/browser/ui/webui/options/import_data_handler.h"
#include "chrome/browser/ui/webui/options/language_options_handler.h"
#include "chrome/browser/ui/webui/options/password_manager_handler.h"
#include "chrome/browser/ui/webui/options/personal_options_handler.h"
#include "chrome/browser/ui/webui/options/search_engine_manager_handler.h"
#include "chrome/browser/ui/webui/options/stop_syncing_handler.h"
#include "chrome/browser/ui/webui/options/certificate_manager_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_UI_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_UI_H_
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_OPTIONS_UI_H_
#include "chrome/browser/ui/webui/options/password_manager_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/personal_options_handler.h"
#include "chrome/browser/ui/webui/options/dom_options_util.h"
#include "chrome/browser/ui/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#include "chrome/browser/ui/webui/options/search_engine_manager_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#include "chrome/browser/ui/webui/options/stop_syncing_handler.h"
#ifndef CHROME_BROWSER_UI_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#define CHROME_BROWSER_UI_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#include "chrome/browser/ui/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_UI_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#include "chrome/browser/ui/webui/options/core_options_handler.h"
#include "chrome/browser/ui/webui/options/options_ui.h"
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/spdy/spdy_frame_producer.h"

#include "base/logging.h"
#include "net/spdy/spdy_protocol.h"

namespace net {

SpdyFrameProducer::SpdyFrameProducer() {}

SpdyFrameProducer::~SpdyFrameProducer() {}

SimpleFrameProducer::SimpleFrameProducer(scoped_ptr<SpdyFrame> frame)
    : frame_(frame.Pass()) {}

SimpleFrameProducer::~SimpleFrameProducer() {}

scoped_ptr<SpdyFrame> SimpleFrameProducer::ProduceFrame() {
  DCHECK(frame_);
  return frame_.Pass();
}

}  // namespace net
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef NET_SPDY_SPDY_FRAME_PRODUCER_H_
#define NET_SPDY_SPDY_FRAME_PRODUCER_H_

#include "base/basictypes.h"
#include "base/compiler_specific.h"
#include "base/memory/scoped_ptr.h"
#include "net/base/net_export.h"

namespace net {

class SpdyFrame;

// An object which provides a SpdyFrame for writing. We pass these
// around instead of SpdyFrames since some frames have to be generated
// "just in time".
class NET_EXPORT_PRIVATE SpdyFrameProducer {
 public:
  SpdyFrameProducer();

  // Produces the frame to be written. Will be called at most once.
  virtual scoped_ptr<SpdyFrame> ProduceFrame() = 0;

  virtual ~SpdyFrameProducer();

 private:
  DISALLOW_COPY_AND_ASSIGN(SpdyFrameProducer);
};

// A simple wrapper around a single SpdyFrame.
class NET_EXPORT_PRIVATE SimpleFrameProducer : public SpdyFrameProducer {
 public:
  explicit SimpleFrameProducer(scoped_ptr<SpdyFrame> frame);

  virtual ~SimpleFrameProducer();

  virtual scoped_ptr<SpdyFrame> ProduceFrame() OVERRIDE;

 private:
  scoped_ptr<SpdyFrame> frame_;

  DISALLOW_COPY_AND_ASSIGN(SimpleFrameProducer);
};

}  // namespace net

#endif  // NET_SPDY_SPDY_FRAME_PRODUCER_H_
SpdyIOBuffer::SpdyIOBuffer() {}
SpdyIOBuffer::SpdyIOBuffer(IOBuffer* buffer, int size, SpdyStream* stream)
  : buffer_(new DrainableIOBuffer(buffer, size)), stream_(stream) {}
void SpdyIOBuffer::Swap(SpdyIOBuffer* other) {
  buffer_.swap(other->buffer_);
  stream_.swap(other->stream_);
}

void SpdyIOBuffer::Release() {
// A class for managing SPDY write buffers.  These write buffers need
// to track the SpdyStream which they are associated with so that the
// session can activate the stream lazily and also notify the stream
// on completion of the write.
  SpdyIOBuffer();

  // |stream| is a pointer to the stream which is managing this buffer
  // (can be NULL if the write is for the session itself).
  SpdyIOBuffer(IOBuffer* buffer, int size, SpdyStream* stream);



  void Swap(SpdyIOBuffer* other);

  void Release();

#include "net/spdy/spdy_frame_producer.h"
  for (int i = 0; i < NUM_PRIORITIES; ++i) {
void SpdySession::EnqueueStreamWrite(
    SpdyStream* stream,
    scoped_ptr<SpdyFrameProducer> producer) {
  EnqueueWrite(stream->priority(), producer.Pass(), stream);
}

scoped_ptr<SpdyFrame> SpdySession::CreateSynStream(
  return syn_frame.Pass();
int SpdySession::CreateCredentialFrame(
    RequestPriority priority,
    scoped_ptr<SpdyFrame>* credential_frame) {
  DCHECK_NE(rv, ERR_IO_PENDING);
    return rv;
  credential_frame->reset(
  return OK;
scoped_ptr<SpdyFrame> SpdySession::CreateHeadersFrame(
  return frame.Pass();
scoped_ptr<SpdyFrame> SpdySession::CreateDataFrame(SpdyStreamId stream_id,
                                                   net::IOBuffer* data,
                                                   int len,
                                                   SpdyDataFlags flags) {
    return scoped_ptr<SpdyFrame>();
      return scoped_ptr<SpdyFrame>();
        return scoped_ptr<SpdyFrame>();
  return frame.Pass();
  EnqueueSessionWrite(priority, rst_frame.Pass());
  DCHECK_GT(in_flight_write_.buffer()->BytesRemaining(), 0);
  if (result < 0) {
    in_flight_write_.Release();
    CloseSessionOnError(static_cast<net::Error>(result), true, "Write error");
    return;
  }
  // It should not be possible to have written more bytes than our
  // in_flight_write_.
  DCHECK_LE(result, in_flight_write_.buffer()->BytesRemaining());
  in_flight_write_.buffer()->DidConsume(result);
  // We only notify the stream when we've fully written the pending frame.
  if (in_flight_write_.buffer()->BytesRemaining() == 0) {
    DCHECK_GT(result, 0);

    scoped_refptr<SpdyStream> stream = in_flight_write_.stream();

    // It is possible that the stream was cancelled while we were writing
    // to the socket.
    if (stream && !stream->cancelled()) {
      // Report the number of bytes written to the caller, but exclude the
      // frame size overhead.  NOTE: if this frame was compressed the
      // reported bytes written is the compressed size, not the original
      // size.
      result = in_flight_write_.buffer()->size();
      DCHECK_GE(result,
                static_cast<int>(
                    buffered_spdy_framer_->GetControlFrameHeaderSize()));
      result -= buffered_spdy_framer_->GetControlFrameHeaderSize();

      stream->OnWriteComplete(result);
    }

    // Cleanup the write which just completed.
    in_flight_write_.Release();

  // Write more data.  We're already in a continuation, so we can go
  // ahead and write it immediately (without going back to the message
  // loop).
  WriteSocketLater();
  while (true) {
    if (in_flight_write_.buffer()) {
      DCHECK_GT(in_flight_write_.buffer()->BytesRemaining(), 0);
    } else {
      // Grab the next frame to send.
      scoped_ptr<SpdyFrameProducer> producer;
      scoped_refptr<SpdyStream> stream;
      if (!write_queue_.Dequeue(&producer, &stream))
        break;

      if (stream.get() && stream->cancelled())
      if (stream.get() && stream->stream_id() == 0)
        ActivateStream(stream);

      scoped_ptr<SpdyFrame> frame = producer->ProduceFrame();
      if (!frame) {
        NOTREACHED();
        continue;
      }
      DCHECK_GT(frame->size(), 0u);

      // TODO(mbelshe): We have too much copying of data here.
      scoped_refptr<IOBufferWithSize> buffer =
          new IOBufferWithSize(frame->size());
      memcpy(buffer->data(), frame->data(), frame->size());
      in_flight_write_ = SpdyIOBuffer(buffer, frame->size(), stream);
  write_queue_.Clear();
void SpdySession::EnqueueSessionWrite(RequestPriority priority,
                                      scoped_ptr<SpdyFrame> frame) {
  EnqueueWrite(
      priority,
      scoped_ptr<SpdyFrameProducer>(new SimpleFrameProducer(frame.Pass())),
      NULL);
}
void SpdySession::EnqueueWrite(RequestPriority priority,
                               scoped_ptr<SpdyFrameProducer> producer,
                               const scoped_refptr<SpdyStream>& stream) {
  write_queue_.Enqueue(priority, producer.Pass(), stream);
    for (PushedStreamMap::iterator it = unclaimed_pushed_streams_.begin();
  ActiveStreamMap::iterator it = active_streams_.find(id);
  if (it == active_streams_.end())
  const scoped_refptr<SpdyStream> stream(it->second);
  active_streams_.erase(it);
  DCHECK(stream);

  write_queue_.RemovePendingWritesForStream(stream);
  EnqueueSessionWrite(HIGHEST, settings_frame.Pass());
  EnqueueSessionWrite(priority, window_update_frame.Pass());
  EnqueueSessionWrite(HIGHEST, ping_frame.Pass());
#include "base/memory/scoped_ptr.h"
#include "net/base/net_export.h"
#include "net/spdy/spdy_write_queue.h"
  // Pushes the given producer into the write queue for
  // |stream|. |stream| is guaranteed to be activated before the
  // producer is used to produce its frame.
  void EnqueueStreamWrite(SpdyStream* stream,
                          scoped_ptr<SpdyFrameProducer> producer);
  // Creates and returns a SYN frame for |stream_id|.
  scoped_ptr<SpdyFrame> CreateSynStream(
  // Tries to create a CREDENTIAL frame. If successful, fills in
  // |credential_frame| and returns OK. Returns the error (guaranteed
  // to not be ERR_IO_PENDING) otherwise.
  int CreateCredentialFrame(const std::string& origin,
                            SSLClientCertType type,
                            const std::string& key,
                            const std::string& cert,
                            RequestPriority priority,
                            scoped_ptr<SpdyFrame>* credential_frame);

  // Creates and returns a HEADERS frame.
  scoped_ptr<SpdyFrame> CreateHeadersFrame(SpdyStreamId stream_id,
                                           const SpdyHeaderBlock& headers,
                                           SpdyControlFlags flags);

  // Creates and returns a data frame. May return NULL if stalled by
  // flow control.
  scoped_ptr<SpdyFrame> CreateDataFrame(SpdyStreamId stream_id,
                                        net::IOBuffer* data,
                                        int len,
                                        SpdyDataFlags flags);
  // Pushes the given frame with the given priority into the write
  // queue for the session.
  void EnqueueSessionWrite(RequestPriority priority,
                           scoped_ptr<SpdyFrame> frame);

  // Puts |producer| associated with |stream| onto the write queue
  // with the given priority.
  void EnqueueWrite(RequestPriority priority,
                    scoped_ptr<SpdyFrameProducer> producer,
                    const scoped_refptr<SpdyStream>& stream);
  // The write queue.
  SpdyWriteQueue write_queue_;
#include "net/spdy/spdy_frame_producer.h"
// A wrapper around a stream that calls into ProduceSynStreamFrame().
class SpdyStream::SynStreamFrameProducer : public SpdyFrameProducer {
 public:
  SynStreamFrameProducer(const base::WeakPtr<SpdyStream>& stream)
      : stream_(stream) {
    DCHECK(stream_);
  }

  virtual ~SynStreamFrameProducer() {}

  virtual scoped_ptr<SpdyFrame> ProduceFrame() OVERRIDE {
    if (!stream_) {
      NOTREACHED();
      return scoped_ptr<SpdyFrame>();
    }
    DCHECK_GT(stream_->stream_id(), 0u);
    return stream_->ProduceSynStreamFrame();
  }

 private:
  const base::WeakPtr<SpdyStream> stream_;
};

// A wrapper around a stream that calls into ProduceHeaderFrame() with
// a given header block.
class SpdyStream::HeaderFrameProducer : public SpdyFrameProducer {
 public:
  HeaderFrameProducer(const base::WeakPtr<SpdyStream>& stream,
                      scoped_ptr<SpdyHeaderBlock> headers)
      : stream_(stream),
        headers_(headers.Pass()) {
    DCHECK(stream_);
    DCHECK(headers_);
  }

  virtual ~HeaderFrameProducer() {}

  virtual scoped_ptr<SpdyFrame> ProduceFrame() OVERRIDE {
    if (!stream_) {
      NOTREACHED();
      return scoped_ptr<SpdyFrame>();
    }
    DCHECK_GT(stream_->stream_id(), 0u);
    return stream_->ProduceHeaderFrame(headers_.Pass());
  }

 private:
  const base::WeakPtr<SpdyStream> stream_;
  scoped_ptr<SpdyHeaderBlock> headers_;
};

scoped_ptr<SpdyFrame> SpdyStream::ProduceSynStreamFrame() {
  CHECK_EQ(io_state_, STATE_SEND_HEADERS_COMPLETE);
  CHECK(request_.get());
  CHECK_GT(stream_id_, 0u);

  SpdyControlFlags flags =
      has_upload_data_ ? CONTROL_FLAG_NONE : CONTROL_FLAG_FIN;
  scoped_ptr<SpdyFrame> frame(session_->CreateSynStream(
      stream_id_, priority_, slot_, flags, *request_));
  send_time_ = base::TimeTicks::Now();
  return frame.Pass();
}

scoped_ptr<SpdyFrame> SpdyStream::ProduceHeaderFrame(
    scoped_ptr<SpdyHeaderBlock> header_block) {
  CHECK(!cancelled());
  // We must need to write stream data.
  // Until the headers have been completely sent, we can not be sure
  // that our stream_id is correct.
  DCHECK_GT(io_state_, STATE_SEND_HEADERS_COMPLETE);
  DCHECK_GT(stream_id_, 0u);

  // Create actual HEADERS frame just in time because it depends on
  // compression context and should not be reordered after the creation.
  scoped_ptr<SpdyFrame> header_frame(session_->CreateHeadersFrame(
      stream_id_, *header_block, SpdyControlFlags()));
  return header_frame.Pass();
}

  waiting_completions_.push_back(TYPE_HEADERS);
  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(
          new HeaderFrameProducer(
              weak_ptr_factory_.GetWeakPtr(), headers.Pass())));
  CHECK(!cancelled());
  waiting_completions_.push_back(TYPE_DATA);
  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(
          new SimpleFrameProducer(data_frame.Pass())));
      // OnDataReceived, OnClose and OnWriteComplete can be called.

  std::string origin = GetUrl().GetOrigin().spec();
  DCHECK(origin[origin.length() - 1] == '/');
  origin.erase(origin.length() - 1);  // Trim trailing slash.
  scoped_ptr<SpdyFrame> frame;
  int rv = session_->CreateCredentialFrame(
      origin, domain_bound_cert_type_, domain_bound_private_key_,
      domain_bound_cert_, priority_, &frame);
  if (rv != OK) {
    DCHECK_NE(rv, ERR_IO_PENDING);
    return rv;
  }

  DCHECK(frame);
  // TODO(akalin): Fix a couple of race conditions:
  //
  // 1) Since this counts as a write for this stream, the stream will
  // be activated (and hence allocated a stream ID) before this frame
  // is sent, even though the ID should only be activated for the
  // SYN_STREAM frame. This can be solved by signalling to the session
  // when we're sending a SYN_STREAM frame, and have it only activate
  // the stream then.
  //
  // 2) Since this is decoupled from sending the SYN_STREAM frame, it
  // is possible that other domain-bound cert frames will clobber ours
  // before our SYN_STREAM frame gets sent. This can be solved by
  // immediately enqueueing the SYN_STREAM frame here and adjusting
  // the state machine appropriately.
  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(new SimpleFrameProducer(frame.Pass())));

  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(
          new SynStreamFrameProducer(weak_ptr_factory_.GetWeakPtr())));
#include <deque>
  class SynStreamFrameProducer;
  class HeaderFrameProducer;
  // Produces the SYN_STREAM frame for the stream. The stream must
  // already be activated.
  scoped_ptr<SpdyFrame> ProduceSynStreamFrame();
  // Produce the initial HEADER frame for the stream with the given
  // block. The stream must already be activated.
  scoped_ptr<SpdyFrame> ProduceHeaderFrame(
      scoped_ptr<SpdyHeaderBlock> header_block);
  // An in order list of sending frame types. Used communicate to the
  // delegate which type of frame was sent in DoOpen().
  //
  // TODO(akalin): We can remove the need for this queue if we add an
  // OnFrameSent() callback to SpdyFrameProducer and have the session
  // call that instead of SpdyStream::OnWriteComplete().
  std::deque<FrameType> waiting_completions_;
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/spdy/spdy_write_queue.h"

#include <cstddef>

#include "base/logging.h"
#include "net/spdy/spdy_frame_producer.h"
#include "net/spdy/spdy_stream.h"

namespace net {

SpdyWriteQueue::PendingWrite::PendingWrite() : frame_producer(NULL) {}

SpdyWriteQueue::PendingWrite::PendingWrite(
    SpdyFrameProducer* frame_producer,
    const scoped_refptr<SpdyStream>& stream)
    : frame_producer(frame_producer),
      stream(stream) {}

SpdyWriteQueue::PendingWrite::~PendingWrite() {}

SpdyWriteQueue::SpdyWriteQueue() {}

SpdyWriteQueue::~SpdyWriteQueue() {
  Clear();
}

void SpdyWriteQueue::Enqueue(RequestPriority priority,
                             scoped_ptr<SpdyFrameProducer> frame_producer,
                             const scoped_refptr<SpdyStream>& stream) {
  if (stream.get()) {
    DCHECK_EQ(stream->priority(), priority);
  }
  queue_[priority].push_back(PendingWrite(frame_producer.release(), stream));
}

bool SpdyWriteQueue::Dequeue(scoped_ptr<SpdyFrameProducer>* frame_producer,
                             scoped_refptr<SpdyStream>* stream) {
  for (int i = NUM_PRIORITIES - 1; i >= 0; --i) {
    if (!queue_[i].empty()) {
      PendingWrite pending_write = queue_[i].front();
      queue_[i].pop_front();
      frame_producer->reset(pending_write.frame_producer);
      *stream = pending_write.stream;
      return true;
    }
  }
  return false;
}

void SpdyWriteQueue::RemovePendingWritesForStream(
    const scoped_refptr<SpdyStream>& stream) {
  DCHECK(stream.get());
  if (DCHECK_IS_ON()) {
    // |stream| should not have pending writes in a queue not matching
    // its priority.
    for (int i = 0; i < NUM_PRIORITIES; ++i) {
      if (stream->priority() == i)
        continue;
      for (std::deque<PendingWrite>::const_iterator it = queue_[i].begin();
           it != queue_[i].end(); ++it) {
        DCHECK_NE(it->stream, stream);
      }
    }
  }

  // Do the actual deletion and removal, preserving FIFO-ness.
  std::deque<PendingWrite>* queue = &queue_[stream->priority()];
  std::deque<PendingWrite>::iterator out_it = queue->begin();
  for (std::deque<PendingWrite>::const_iterator it = queue->begin();
       it != queue->end(); ++it) {
    if (it->stream == stream) {
      delete it->frame_producer;
    } else {
      *out_it = *it;
      ++out_it;
    }
  }
  queue->erase(out_it, queue->end());
}

void SpdyWriteQueue::Clear() {
  for (int i = 0; i < NUM_PRIORITIES; ++i) {
    for (std::deque<PendingWrite>::iterator it = queue_[i].begin();
         it != queue_[i].end(); ++it) {
      delete it->frame_producer;
    }
    queue_[i].clear();
  }
}

}  // namespace net
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef NET_SPDY_SPDY_WRITE_QUEUE_H_
#define NET_SPDY_SPDY_WRITE_QUEUE_H_

#include <deque>

#include "base/basictypes.h"
#include "base/memory/ref_counted.h"
#include "base/memory/scoped_ptr.h"
#include "net/base/net_export.h"
#include "net/base/request_priority.h"

namespace net {

class SpdyFrameProducer;
class SpdyStream;

// A queue of SpdyFrameProducers to produce frames to write. Ordered
// by priority, and then FIFO.
class NET_EXPORT_PRIVATE SpdyWriteQueue {
 public:
  SpdyWriteQueue();
  ~SpdyWriteQueue();

  // Enqueues the given frame producer at the given priority
  // associated with the given stream, which may be NULL if the frame
  // producer is not associated with a stream. If |stream| is
  // non-NULL, its priority must be equal to |priority|.
  void Enqueue(RequestPriority priority,
               scoped_ptr<SpdyFrameProducer> frame_producer,
               const scoped_refptr<SpdyStream>& stream);

  // Dequeues the frame producer with the highest priority that was
  // enqueued the earliest and its associated stream. Returns true and
  // fills in |frame_producer| and |stream| if successful --
  // otherwise, just returns false.
  bool Dequeue(scoped_ptr<SpdyFrameProducer>* frame_producer,
               scoped_refptr<SpdyStream>* stream);

  // Removes all pending writes for the given stream, which must be
  // non-NULL.
  void RemovePendingWritesForStream(const scoped_refptr<SpdyStream>& stream);

  // Removes all pending writes.
  void Clear();

 private:
  // A struct holding a frame producer and its associated stream.
  struct PendingWrite {
    // This has to be a raw pointer since we store this in an STL
    // container.
    SpdyFrameProducer* frame_producer;
    scoped_refptr<SpdyStream> stream;

    PendingWrite();
    PendingWrite(SpdyFrameProducer* frame_producer,
                 const scoped_refptr<SpdyStream>& stream);
    ~PendingWrite();
  };

  // The actual write queue, binned by priority.
  std::deque<PendingWrite> queue_[NUM_PRIORITIES];

  DISALLOW_COPY_AND_ASSIGN(SpdyWriteQueue);
};

}  // namespace net

#endif  // NET_SPDY_SPDY_WRITE_QUEUE_H_
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/spdy/spdy_write_queue.h"

#include <cstddef>
#include <cstring>
#include <string>

#include "base/basictypes.h"
#include "base/memory/ref_counted.h"
#include "base/memory/scoped_ptr.h"
#include "base/strings/string_number_conversions.h"
#include "net/base/net_log.h"
#include "net/base/request_priority.h"
#include "net/spdy/spdy_frame_producer.h"
#include "net/spdy/spdy_stream.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace net {

namespace {

class SpdyWriteQueueTest : public ::testing::Test {};

// Makes a SpdyFrameProducer producing a frame with the data in the
// given string.
scoped_ptr<SpdyFrameProducer> StringToProducer(const std::string& s) {
  scoped_ptr<char[]> data(new char[s.size()]);
  std::memcpy(data.get(), s.data(), s.size());
  return scoped_ptr<SpdyFrameProducer>(
      new SimpleFrameProducer(
          scoped_ptr<SpdyFrame>(
              new SpdyFrame(data.release(), s.size(), true))));
}

// Makes a SpdyFrameProducer producing a frame with the data in the
// given int (converted to a string).
scoped_ptr<SpdyFrameProducer> IntToProducer(int i) {
  return StringToProducer(base::IntToString(i));
}

// Produces a frame with the given producer and returns a copy of its
// data as a string.
std::string ProducerToString(scoped_ptr<SpdyFrameProducer> producer) {
  scoped_ptr<SpdyFrame> frame = producer->ProduceFrame();
  return std::string(frame->data(), frame->size());
}

// Produces a frame with the given producer and returns a copy of its
// data as an int (converted from a string).
int ProducerToInt(scoped_ptr<SpdyFrameProducer> producer) {
  int i = 0;
  EXPECT_TRUE(base::StringToInt(ProducerToString(producer.Pass()), &i));
  return i;
}

// Makes a SpdyStream with the given priority and a NULL SpdySession
// -- be careful to not call any functions that expect the session to
// be there.
SpdyStream* MakeTestStream(RequestPriority priority) {
  return new SpdyStream(NULL, "", priority, 0, 0, false, BoundNetLog());
}

// Add some frame producers of different priority. The producers
// should be dequeued in priority order with their associated stream.
TEST_F(SpdyWriteQueueTest, DequeuesByPriority) {
  SpdyWriteQueue write_queue;

  scoped_ptr<SpdyFrameProducer> producer_low = StringToProducer("LOW");
  scoped_ptr<SpdyFrameProducer> producer_medium = StringToProducer("MEDIUM");
  scoped_ptr<SpdyFrameProducer> producer_highest = StringToProducer("HIGHEST");

  // A NULL stream should still work.
  scoped_refptr<SpdyStream> stream_low(NULL);
  scoped_refptr<SpdyStream> stream_medium(MakeTestStream(MEDIUM));
  scoped_refptr<SpdyStream> stream_highest(MakeTestStream(HIGHEST));

  write_queue.Enqueue(LOW, producer_low.Pass(), stream_low);
  write_queue.Enqueue(MEDIUM, producer_medium.Pass(), stream_medium);
  write_queue.Enqueue(HIGHEST, producer_highest.Pass(), stream_highest);

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ("HIGHEST", ProducerToString(frame_producer.Pass()));
  EXPECT_EQ(stream_highest, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ("MEDIUM", ProducerToString(frame_producer.Pass()));
  EXPECT_EQ(stream_medium, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ("LOW", ProducerToString(frame_producer.Pass()));
  EXPECT_EQ(stream_low, stream);

  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

// Add some frame producers with the same priority. The producers
// should be dequeued in FIFO order with their associated stream.
TEST_F(SpdyWriteQueueTest, DequeuesFIFO) {
  SpdyWriteQueue write_queue;

  scoped_ptr<SpdyFrameProducer> producer1 = IntToProducer(1);
  scoped_ptr<SpdyFrameProducer> producer2 = IntToProducer(2);
  scoped_ptr<SpdyFrameProducer> producer3 = IntToProducer(3);

  scoped_refptr<SpdyStream> stream1(MakeTestStream(DEFAULT_PRIORITY));
  scoped_refptr<SpdyStream> stream2(MakeTestStream(DEFAULT_PRIORITY));
  scoped_refptr<SpdyStream> stream3(MakeTestStream(DEFAULT_PRIORITY));

  write_queue.Enqueue(DEFAULT_PRIORITY, producer1.Pass(), stream1);
  write_queue.Enqueue(DEFAULT_PRIORITY, producer2.Pass(), stream2);
  write_queue.Enqueue(DEFAULT_PRIORITY, producer3.Pass(), stream3);

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ(1, ProducerToInt(frame_producer.Pass()));
  EXPECT_EQ(stream1, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ(2, ProducerToInt(frame_producer.Pass()));
  EXPECT_EQ(stream2, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ(3, ProducerToInt(frame_producer.Pass()));
  EXPECT_EQ(stream3, stream);

  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

// Enqueue a bunch of writes and then call
// RemovePendingWritesForStream() on one of the streams. No dequeued
// write should be for that stream.
TEST_F(SpdyWriteQueueTest, RemovePendingWritesForStream) {
  SpdyWriteQueue write_queue;

  scoped_refptr<SpdyStream> stream1(MakeTestStream(DEFAULT_PRIORITY));
  scoped_refptr<SpdyStream> stream2(MakeTestStream(DEFAULT_PRIORITY));

  for (int i = 0; i < 100; ++i) {
    scoped_refptr<SpdyStream> stream = ((i % 3) == 0) ? stream1 : stream2;
    write_queue.Enqueue(DEFAULT_PRIORITY, IntToProducer(i), stream);
  }

  write_queue.RemovePendingWritesForStream(stream2);

  for (int i = 0; i < 100; i += 3) {
    scoped_ptr<SpdyFrameProducer> frame_producer;
    scoped_refptr<SpdyStream> stream;
    ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
    EXPECT_EQ(i, ProducerToInt(frame_producer.Pass()));
    EXPECT_EQ(stream1, stream);
  }

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

// Enqueue a bunch of writes and then call Clear(). The write queue
// should clean up the memory properly, and Dequeue() should return
// false.
TEST_F(SpdyWriteQueueTest, Clear) {
  SpdyWriteQueue write_queue;

  for (int i = 0; i < 100; ++i) {
    write_queue.Enqueue(DEFAULT_PRIORITY, IntToProducer(i), NULL);
  }

  write_queue.Clear();

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

}

}  // namespace net
template<class Collection> static void nodeCollectionIndexedPropertyEnumerator(const v8::PropertyCallbackInfo<v8::Array>& info)
    v8SetReturnValue(info, properties);
void npObjectNamedPropertyGetter(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>& info)
    v8SetReturnValue(info, npObjectGetProperty(info.Holder(), identifier, name, info.GetIsolate()));
void npObjectIndexedPropertyGetter(uint32_t index, const v8::PropertyCallbackInfo<v8::Value>& info)
    v8SetReturnValue(info, npObjectGetProperty(info.Holder(), identifier, v8::Number::New(index), info.GetIsolate()));
void npObjectGetNamedProperty(v8::Local<v8::Object> self, v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>& info)
    v8SetReturnValue(info, npObjectGetProperty(self, identifier, name, info.GetIsolate()));
void npObjectGetIndexedProperty(v8::Local<v8::Object> self, uint32_t index, const v8::PropertyCallbackInfo<v8::Value>& info)
    v8SetReturnValue(info, npObjectGetProperty(self, identifier, v8::Number::New(index), info.GetIsolate()));
void npObjectQueryProperty(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Integer>& info)
    if (npObjectGetProperty(info.Holder(), identifier, name, info.GetIsolate()).IsEmpty())
        return;
    v8SetReturnValueInt(info, 0);
void npObjectNamedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
    v8SetReturnValue(info, npObjectSetProperty(info.Holder(), identifier, value, info.GetIsolate()));
void npObjectIndexedPropertySetter(uint32_t index, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
    v8SetReturnValue(info, npObjectSetProperty(info.Holder(), identifier, value, info.GetIsolate()));
void npObjectSetNamedProperty(v8::Local<v8::Object> self, v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
    v8SetReturnValue(info, npObjectSetProperty(self, identifier, value, info.GetIsolate()));
void npObjectSetIndexedProperty(v8::Local<v8::Object> self, uint32_t index, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
    v8SetReturnValue(info, npObjectSetProperty(self, identifier, value, info.GetIsolate()));
void npObjectPropertyEnumerator(const v8::PropertyCallbackInfo<v8::Array>& info, bool namedProperty)
            v8SetReturnValue(info, properties);
            return;
void npObjectNamedPropertyEnumerator(const v8::PropertyCallbackInfo<v8::Array>& info)
    npObjectPropertyEnumerator(info, true);
void npObjectIndexedPropertyEnumerator(const v8::PropertyCallbackInfo<v8::Array>& info)
    npObjectPropertyEnumerator(info, false);
void npObjectNamedPropertyGetter(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>&);
void npObjectIndexedPropertyGetter(uint32_t index, const v8::PropertyCallbackInfo<v8::Value>&);
void npObjectGetNamedProperty(v8::Local<v8::Object> self, v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>&);
void npObjectGetIndexedProperty(v8::Local<v8::Object> self, uint32_t index, const v8::PropertyCallbackInfo<v8::Value>&);
void npObjectNamedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value>, const v8::PropertyCallbackInfo<v8::Value>&);
void npObjectIndexedPropertySetter(uint32_t index, const v8::PropertyCallbackInfo<v8::Value>&);
void npObjectSetNamedProperty(v8::Local<v8::Object> self, v8::Local<v8::String> name, v8::Local<v8::Value>, const v8::PropertyCallbackInfo<v8::Value>&);
void npObjectSetIndexedProperty(v8::Local<v8::Object> self, uint32_t index, v8::Local<v8::Value>, const v8::PropertyCallbackInfo<v8::Value>&);
void V8CSSStyleDeclaration::namedPropertyEnumerator(const v8::PropertyCallbackInfo<v8::Array>& info)
    v8SetReturnValue(info, properties);
void V8CSSStyleDeclaration::namedPropertyQuery(v8::Local<v8::String> v8Name, const v8::PropertyCallbackInfo<v8::Integer>& info)
    if (cssPropertyInfo(v8Name)) {
        v8SetReturnValueInt(info, 0);
        return;
    }
void V8CSSStyleDeclaration::namedPropertyGetter(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>& info)
        return;
        return;
        return;
        return;
            v8SetReturnValue(info, static_cast<CSSPrimitiveValue*>(
            return;
        v8SetReturnValue(info, v8StringOrNull(cssValue->cssText(), info.GetIsolate()));
        return;
    v8SetReturnValue(info, v8String(result, info.GetIsolate()));
void V8CSSStyleDeclaration::namedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
        return;
        return;
        return;
        return;
    if (ec) {
        return;
    }
    v8SetReturnValue(info, value);
void V8DOMStringMap::namedPropertyQuery(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Integer>& info)
        v8SetReturnValueInt(info, 0);
void V8DOMWindow::namedPropertyGetter(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>& info)
        return;
        return;
    if (child) {
        v8SetReturnValue(info, toV8Fast(child->document()->domWindow(), info, window));
        return;
    }
        return;
                if (items->hasExactlyOneItem()) {
                    v8SetReturnValue(info, toV8Fast(items->item(0), info, window));
                    return;
                }
                v8SetReturnValue(info, toV8Fast(items.release(), info, window));
                return;
static void npObjectNamedGetter(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>& info)
        return;
        return;
    npObjectGetNamedProperty(instance, name, info);
static void npObjectNamedSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
        return;
        return;
    npObjectSetNamedProperty(instance, name, value, info);
void V8HTMLAppletElement::namedPropertyGetter(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>& info)
    npObjectNamedGetter<V8HTMLAppletElement>(name, info);
void V8HTMLEmbedElement::namedPropertyGetter(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>& info)
    npObjectNamedGetter<V8HTMLEmbedElement>(name, info);
void V8HTMLObjectElement::namedPropertyGetter(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>& info)
    npObjectNamedGetter<V8HTMLObjectElement>(name, info);
void V8HTMLAppletElement::namedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
    npObjectNamedSetter<V8HTMLAppletElement>(name, value, info);
void V8HTMLEmbedElement::namedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
    npObjectNamedSetter<V8HTMLEmbedElement>(name, value, info);
void V8HTMLObjectElement::namedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
void npObjectIndexedGetter(uint32_t index, const v8::PropertyCallbackInfo<v8::Value>& info)
        return;
        return;
    npObjectGetIndexedProperty(instance, index, info);
void npObjectIndexedSetter(uint32_t index, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
        return;
        return;
    npObjectSetIndexedProperty(instance, index, value, info);
void V8HTMLAppletElement::indexedPropertyGetter(uint32_t index, const v8::PropertyCallbackInfo<v8::Value>& info)
    npObjectIndexedGetter<V8HTMLAppletElement>(index, info);
void V8HTMLEmbedElement::indexedPropertyGetter(uint32_t index, const v8::PropertyCallbackInfo<v8::Value>& info)
    npObjectIndexedGetter<V8HTMLEmbedElement>(index, info);
void V8HTMLObjectElement::indexedPropertyGetter(uint32_t index, const v8::PropertyCallbackInfo<v8::Value>& info)
    npObjectIndexedGetter<V8HTMLObjectElement>(index, info);
void V8HTMLAppletElement::indexedPropertySetter(uint32_t index, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
    npObjectIndexedSetter<V8HTMLAppletElement>(index, value, info);
void V8HTMLEmbedElement::indexedPropertySetter(uint32_t index, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
    npObjectIndexedSetter<V8HTMLEmbedElement>(index, value, info);
void V8HTMLObjectElement::indexedPropertySetter(uint32_t index, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)
    npObjectIndexedSetter<V8HTMLObjectElement>(index, value, info);
void V8Storage::namedPropertyQuery(v8::Local<v8::String> v8Name, const v8::PropertyCallbackInfo<v8::Integer>& info)
        return;
    if (ec) {
        setDOMException(ec, info.GetIsolate());
        return;
    }
        return;
    v8SetReturnValueInt(info, 0);
  SharedMemoryCreateOptions() : name_deprecated(NULL), size(0),
                                open_existing_deprecated(false),
  // DEPRECATED (crbug.com/345734):
  const std::string* name_deprecated;
  // DEPRECATED (crbug.com/345734):
  // shared memory must not exist.  This flag is meaningless unless
  // name_deprecated is non-NULL.
  bool open_existing_deprecated;
  // DEPRECATED (crbug.com/345734):
  bool CreateNamedDeprecated(
      const std::string& name, bool open_existing, size_t size) {
    options.name_deprecated = &name;
    options.open_existing_deprecated = open_existing;
      options.name_deprecated == NULL ? "" : options.name_deprecated->c_str(),
  if (options.name_deprecated == NULL || options.name_deprecated->empty()) {
    DCHECK(!options.open_existing_deprecated);
    if (!FilePathForMemoryName(*options.name_deprecated, &path))
    if (fd == -1 && options.open_existing_deprecated) {
    bool rv = memory.CreateNamedDeprecated(s_test_name_, true, kDataSize);
      EXPECT_TRUE(memory1.CreateNamedDeprecated(
          "SharedMemoryMultipleLockThreadTest", true, kDataSize));
// CreateNamedDeprecated(openExisting=true)
  rv = memory1.CreateNamedDeprecated(test_name, false, kDataSize);
  // Open two handles to a memory segment and check that
  // open_existing_deprecated works as expected.
  bool rv = memory1.CreateNamedDeprecated(test_name, false, kDataSize);
  rv = memory2.CreateNamedDeprecated(test_name, false, kDataSize2);
  rv = memory2.CreateNamedDeprecated(test_name, true, kDataSize2);
  options.name_deprecated = &shared_mem_name;
    bool rv = memory.CreateNamedDeprecated(s_test_name_, true, kDataSize);
  name_ = ASCIIToWide(options.name_deprecated == NULL ? "" :
                          *options.name_deprecated);
    if (!options.open_existing_deprecated) {
  if (!shared_memory->CreateNamedDeprecated(name, true, size))
  // TODO(viettrungluu): Named shared memory is deprecated (crbug.com/345734).
  if (!shared_mem_service_data->CreateNamedDeprecated
          (GetServiceProcessSharedMemName(), true, alloc_size))
    // TODO(viettrungluu): Named shared memory is deprecated (crbug.com/345734).
    // (I don't think we even need it here.)
    EXPECT_TRUE(shared_handle_.CreateNamedDeprecated(kShmemSegmentName, false,
                                                     100));
    if (m_isExternalScript) {
        ScriptResource* resource = m_resource ? m_resource.get() : sourceCode.resource();
        if (resource && !resource->mimeTypeAllowedByNosniff()) {
            contextDocument->addConsoleMessage(SecurityMessageSource, ErrorMessageLevel, "Refused to execute script from '" + resource->url().elidedString() + "' because its MIME type ('" + resource->mimeType() + "') is not executable, and strict MIME type checking is enabled.");
            return;
        }
                ownerNode->notifyLoadedSheetAndAllCriticalSubresources(m_didLoadErrorOccur ? Node::ErrorOccurredLoadingSubresource : Node::NoErrorLoadingSubresource);
    enum LoadedSheetErrorStatus {
        NoErrorLoadingSubresource,
        ErrorOccurredLoadingSubresource
    };
    virtual void notifyLoadedSheetAndAllCriticalSubresources(LoadedSheetErrorStatus) { }
        if (!executeScript(ScriptSourceCode(scriptContent(), scriptURL, position))) {
            dispatchErrorEvent();
        }
    if (!m_isExternalScript && (!shouldBypassMainWorldCSP && !csp->allowInlineScript(elementDocument->url(), m_startLineNumber, sourceCode.source()))) {
        return false;
    }
            return false;
            return false;
StyleElement::ProcessingResult StyleElement::processStyleSheet(Document& document, Element* element)
        return ProcessingSuccessful;
    return process(element);
StyleElement::ProcessingResult StyleElement::childrenChanged(Element* element)
        return ProcessingSuccessful;
    return process(element);
StyleElement::ProcessingResult StyleElement::finishParsingChildren(Element* element)
    ProcessingResult result = process(element);
    return result;
StyleElement::ProcessingResult StyleElement::process(Element* element)
        return ProcessingSuccessful;
    return createSheet(element, element->textFromChildren());
StyleElement::ProcessingResult StyleElement::createSheet(Element* e, const String& text)

    return passesContentSecurityPolicyChecks ? ProcessingSuccessful : ProcessingFatalError;
    enum ProcessingResult {
        ProcessingSuccessful,
        ProcessingFatalError
    };

    ProcessingResult processStyleSheet(Document&, Element*);
    ProcessingResult childrenChanged(Element*);
    ProcessingResult finishParsingChildren(Element*);
    ProcessingResult createSheet(Element*, const String& text = String());
    ProcessingResult process(Element*);
void HTMLLinkElement::notifyLoadedSheetAndAllCriticalSubresources(LoadedSheetErrorStatus errorStatus)
    linkStyle()->notifyLoadedSheetAndAllCriticalSubresources(errorStatus);
        notifyLoadedSheetAndAllCriticalSubresources(Node::ErrorOccurredLoadingSubresource);
void LinkStyle::notifyLoadedSheetAndAllCriticalSubresources(Node::LoadedSheetErrorStatus errorStatus)
    m_loadedSheet = (errorStatus == Node::NoErrorLoadingSubresource);
            // The request may have been denied if (for example) the stylesheet is local and the document is remote, or if there was a Content Security Policy Failure.
            notifyLoadedSheetAndAllCriticalSubresources(Node::ErrorOccurredLoadingSubresource);
    void notifyLoadedSheetAndAllCriticalSubresources(Node::LoadedSheetErrorStatus);
    virtual void notifyLoadedSheetAndAllCriticalSubresources(LoadedSheetErrorStatus) override;
    StyleElement::ProcessingResult result = StyleElement::finishParsingChildren(this);
    if (result == StyleElement::ProcessingFatalError)
        notifyLoadedSheetAndAllCriticalSubresources(ErrorOccurredLoadingSubresource);
    if (StyleElement::processStyleSheet(document(), this) == StyleElement::ProcessingFatalError)
        notifyLoadedSheetAndAllCriticalSubresources(ErrorOccurredLoadingSubresource);
    if (StyleElement::childrenChanged(this) == StyleElement::ProcessingFatalError)
        notifyLoadedSheetAndAllCriticalSubresources(ErrorOccurredLoadingSubresource);
void HTMLStyleElement::notifyLoadedSheetAndAllCriticalSubresources(LoadedSheetErrorStatus errorStatus)
    m_loadedSheet = (errorStatus == NoErrorLoadingSubresource);
    virtual void notifyLoadedSheetAndAllCriticalSubresources(LoadedSheetErrorStatus) override;
  // calling LockDeprecated() to acquire the named mutex before either Create or
  // Open are called on Windows.
  // DEPRECATED (crbug.com/345734):
  // processes, not across threads.  The LockDeprecated method is not currently
  void LockDeprecated();
  // DEPRECATED (crbug.com/345734):
  void UnlockDeprecated();
  HANDLE             lock_;
// DEPRECATED (crbug.com/345734):
// the SharedMemoryAutoLockDeprecated is in scope.
class SharedMemoryAutoLockDeprecated {
  explicit SharedMemoryAutoLockDeprecated(SharedMemory* shared_memory)
    shared_memory_->LockDeprecated();
  ~SharedMemoryAutoLockDeprecated() {
    shared_memory_->UnlockDeprecated();
  DISALLOW_COPY_AND_ASSIGN(SharedMemoryAutoLockDeprecated);
void SharedMemory::LockDeprecated() {
void SharedMemory::UnlockDeprecated() {
void SharedMemory::LockDeprecated() {
void SharedMemory::UnlockDeprecated() {
      memory2.LockDeprecated();
      memory2.UnlockDeprecated();
      memory.LockDeprecated();
      memory.UnlockDeprecated();
void SharedMemory::LockDeprecated() {
    lock_ = CreateMutex(NULL, FALSE, name.c_str());
      NOTREACHED();
      return;  // There is nothing good we can do here.
  DWORD result = WaitForSingleObject(lock_, INFINITE);
  DCHECK_EQ(result, WAIT_OBJECT_0);
void SharedMemory::UnlockDeprecated() {
  // TODO(viettrungluu): crbug.com/345734: Use a different locking mechanism.
    SharedMemoryAutoLockDeprecated lock(internal_->shared_memory());
    SharedMemoryAutoLockDeprecated lock(internal_->shared_memory());
static bool schemeRequiresAuthority(const KURL& url)
    // We expect URLs with these schemes to have authority components. If the
    // URL lacks an authority component, we get concerned and mark the origin
    // as unique.
    return url.protocolIsInHTTPFamily() || url.protocolIs("ftp");
}

// Some URL schemes use nested URLs for their security context. For example,
// filesystem URLs look like the following:
//
//   filesystem:http://example.com/temporary/path/to/file.png
//
// We're supposed to use "http://example.com" as the origin.
//
// Generally, we add URL schemes to this list when WebKit support them. For
// example, we don't include the "jar" scheme, even though Firefox understands
// that jar uses an inner URL for it's security origin.
//
static bool shouldUseInnerURL(const KURL& url)
{
#if ENABLE(BLOB)
    if (url.protocolIs("blob"))
        return true;
#endif
#if ENABLE(FILE_SYSTEM)
    if (url.protocolIs("filesystem"))
        return true;
#endif
    return false;
}

// In general, extracting the inner URL varies by scheme. It just so happens
// that all the URL schemes we currently support that use inner URLs for their
// security origin can be parsed using this algorithm.
static KURL extractInnerURL(const KURL& url)
{
    // FIXME: Update this callsite to use the innerURL member function when
    // we finish implementing it.
    return KURL(ParsedURLString, decodeURLEscapeSequences(url.path()));
}

static bool isDirectory(const String& path)
{
    return path.endsWith("/");
}

static bool shouldTreatAsUniqueOrigin(const KURL& url)
{
    if (!url.isValid())
        return true;

    // FIXME: Do we need to unwrap the URL further?
    KURL innerURL = shouldUseInnerURL(url) ? extractInnerURL(url) : url;

    // FIXME: Check whether innerURL is valid.
    // For edge case URLs that were probably misparsed, make sure that the origin is unique.
    // FIXME: Do we really need to do this? This looks to be a hack around a
    // security bug in CFNetwork that might have been fixed.
    if (schemeRequiresAuthority(innerURL) && innerURL.host().isEmpty())
        return true;

    // SchemeRegistry needs a lower case protocol because it uses HashMaps
    // that assume the scheme has already been canonicalized.
    String protocol = innerURL.protocol().lower();

    if (SchemeRegistry::shouldTreatURLSchemeAsNoAccess(protocol))
        return true;

    // We use unique origins for directory listings to make it harder to crawl
    // a local filesystem. Notice that we apply this protection only when we
    // use the outer URL for the security context because schemes that wrap
    // other URLs don't have directory listings.
    if (SchemeRegistry::shouldTreatURLSchemeAsLocal(protocol) && !shouldUseInnerURL(url)) {
        if (!innerURL.hasPath() || isDirectory(innerURL.path()))
            return true;
    // This is the common case.
    return false;
SecurityOrigin::SecurityOrigin(const KURL& url)
    , m_isUnique(false)
    , m_needsDatabaseIdentifierQuirkForFiles(false)
    ASSERT(url.isValid());
    // By default, only local SecurityOrigins can load local resources.
    m_canLoadLocalResources = isLocal();

    if (m_canLoadLocalResources)
        m_filePath = url.path(); // In case enforceFilePathSeparation() is called.
}
SecurityOrigin::SecurityOrigin()
    : m_protocol("")
    , m_host("")
    , m_domain("")
    , m_port(InvalidPort)
    , m_isUnique(true)
    , m_universalAccess(false)
    , m_domainWasSetInDOM(false)
    , m_canLoadLocalResources(false)
    , m_enforceFilePathSeparation(false)
    , m_needsDatabaseIdentifierQuirkForFiles(false)
{
    , m_needsDatabaseIdentifierQuirkForFiles(other->m_needsDatabaseIdentifierQuirkForFiles)
    if (forceUnique || shouldTreatAsUniqueOrigin(url)) {
        RefPtr<SecurityOrigin> origin = adoptRef(new SecurityOrigin());

        if (url.protocolIs("file")) {
            // Unfortunately, we can't represent all unique origins exactly
            // the same way because we need to produce a quirky database
            // identifier for file URLs due to persistent storage in some
            // embedders of WebKit.
            origin->m_needsDatabaseIdentifierQuirkForFiles = true;
        }

        return origin.release();
    }

    if (shouldUseInnerURL(url))
        return adoptRef(new SecurityOrigin(extractInnerURL(url)));

    return adoptRef(new SecurityOrigin(url));
    RefPtr<SecurityOrigin> origin = adoptRef(new SecurityOrigin());
    if (m_needsDatabaseIdentifierQuirkForFiles)
    SecurityOrigin();
    explicit SecurityOrigin(const KURL&);
    bool m_needsDatabaseIdentifierQuirkForFiles;
    wstring explanation = auth_info_->realm.empty() ?
        l10n_util::GetStringF(IDS_LOGIN_DIALOG_DESCRIPTION_NO_REALM,
                              auth_info_->host) :
        l10n_util::GetStringF(IDS_LOGIN_DIALOG_DESCRIPTION,
                              auth_info_->host,
                              auth_info_->realm);
  // Release a pointer.
  // The return value is the current pointer held by this object.
  // If this object holds a NULL pointer, the return value is NULL.
  // After this operation, this object will hold a NULL pointer,
  // and will not own the object any more.
  T* release() {
    T* retVal = ptr_;
    ptr_ = NULL;
    return retVal;
  }

WebKit::WebMessagePortChannel*
BrowserWebKitClientImpl::createMessagePortChannel() {
  NOTREACHED();
  return NULL;
}

  virtual WebKit::WebMessagePortChannel* createMessagePortChannel();
  virtual WebKit::WebMessagePortChannel* createMessagePortChannel() {
    return NULL;
  }

#include "chrome/browser/worker_host/message_port_dispatcher.h"
#include "chrome/common/worker_messages.h"
      off_the_record_(profile->IsOffTheRecord()),
      next_route_id_(NewCallbackWithReturnValue(
          render_widget_helper, &RenderWidgetHelper::GetNextRoutingID)) {
bool ResourceMessageFilter::OnMessageReceived(const IPC::Message& msg) {
  MessagePortDispatcher* mp_dispatcher = MessagePortDispatcher::GetInstance();
  bool handled =
      resource_dispatcher_host_->OnMessageReceived(msg, this, &msg_is_ok) ||
      app_cache_dispatcher_host_->OnMessageReceived(msg, &msg_is_ok) ||
      dom_storage_dispatcher_host_->OnMessageReceived(msg, &msg_is_ok) ||
      audio_renderer_host_->OnMessageReceived(msg, &msg_is_ok) ||
      db_dispatcher_host_->OnMessageReceived(msg, &msg_is_ok) ||
      mp_dispatcher->OnMessageReceived(msg, this, next_route_id_, &msg_is_ok);
    IPC_BEGIN_MESSAGE_MAP_EX(ResourceMessageFilter, msg, msg_is_ok)
                                  OnReceiveContextMenuMsg(msg))
          render_widget_helper_->DidReceivePaintMsg(msg))
      IPC_MESSAGE_HANDLER(ViewHostMsg_OpenChannelToTab, OnOpenChannelToTab)
      IPC_MESSAGE_HANDLER(ViewHostMsg_SetCacheMode, OnSetCacheMode)
      IPC_MESSAGE_HANDLER_DELAY_REPLY(ViewHostMsg_GetFileSize, OnGetFileSize)
    BrowserRenderProcessHost::BadMessageTerminateProcess(msg.type(), handle());
#include "base/task.h"
  // A callback to create a routing id for the associated renderer process.
  CallbackWithReturnValue<int>::Type* next_route_id_;

// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/worker_host/message_port_dispatcher.h"

#include "base/singleton.h"
#include "chrome/browser/renderer_host/resource_message_filter.h"
#include "chrome/browser/worker_host/worker_process_host.h"
#include "chrome/common/notification_service.h"
#include "chrome/common/worker_messages.h"


MessagePortDispatcher* MessagePortDispatcher::GetInstance() {
  return Singleton<MessagePortDispatcher>::get();
}

MessagePortDispatcher::MessagePortDispatcher()
    : next_message_port_id_(0),
      sender_(NULL),
      next_routing_id_(NULL) {
  // Receive a notification if a message filter or WorkerProcessHost is deleted.
  registrar_.Add(this, NotificationType::RESOURCE_MESSAGE_FILTER_SHUTDOWN,
                 NotificationService::AllSources());

  registrar_.Add(this, NotificationType::WORKER_PROCESS_HOST_SHUTDOWN,
                 NotificationService::AllSources());
}

MessagePortDispatcher::~MessagePortDispatcher() {
}

bool MessagePortDispatcher::OnMessageReceived(
    const IPC::Message& message,
    IPC::Message::Sender* sender,
    CallbackWithReturnValue<int>::Type* next_routing_id,
    bool* message_was_ok) {
  sender_ = sender;
  next_routing_id_ = next_routing_id;

  bool handled = true;
  *message_was_ok = true;

  IPC_BEGIN_MESSAGE_MAP_EX(MessagePortDispatcher, message, *message_was_ok)
    IPC_MESSAGE_HANDLER(WorkerProcessHostMsg_CreateMessagePort, OnCreate)
    IPC_MESSAGE_HANDLER(WorkerProcessHostMsg_DestroyMessagePort, OnDestroy)
    IPC_MESSAGE_HANDLER(WorkerProcessHostMsg_Entangle, OnEntangle)
    IPC_MESSAGE_HANDLER(WorkerProcessHostMsg_PostMessage, OnPostMessage)
    IPC_MESSAGE_HANDLER(WorkerProcessHostMsg_QueueMessages, OnQueueMessages)
    IPC_MESSAGE_HANDLER(WorkerProcessHostMsg_SendQueuedMessages,
                        OnSendQueuedMessages)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP_EX()

  sender_ = NULL;
  next_routing_id_ = NULL;

  return handled;
}

bool MessagePortDispatcher::Send(IPC::Message* message) {
  return sender_->Send(message);
}

void MessagePortDispatcher::OnCreate(int *route_id,
                                     int* message_port_id) {
  *message_port_id = ++next_message_port_id_;
  *route_id = next_routing_id_->Run();

  MessagePort port;
  port.sender = sender_;
  port.route_id = *route_id;
  port.next_routing_id = next_routing_id_;
  port.message_port_id = *message_port_id;
  port.entangled_message_port_id = MSG_ROUTING_NONE;
  port.queue_messages = false;
  message_ports_[*message_port_id] = port;
}

void MessagePortDispatcher::OnDestroy(int message_port_id) {
  if (!message_ports_.count(message_port_id)) {
    NOTREACHED();
    return;
  }

  DCHECK(message_ports_[message_port_id].queued_messages.empty());
  delete message_ports_[message_port_id].next_routing_id;
  message_ports_.erase(message_port_id);
}

void MessagePortDispatcher::OnEntangle(int local_message_port_id,
                                       int remote_message_port_id) {
  if (!message_ports_.count(local_message_port_id) ||
      !message_ports_.count(remote_message_port_id)) {
    NOTREACHED();
    return;
  }

  DCHECK(message_ports_[remote_message_port_id].entangled_message_port_id ==
      MSG_ROUTING_NONE);
  message_ports_[remote_message_port_id].entangled_message_port_id =
      local_message_port_id;
}

void MessagePortDispatcher::OnPostMessage(int sender_message_port_id,
                                          const string16& message,
                                          int sent_message_port_id) {
  if (!message_ports_.count(sender_message_port_id)) {
    NOTREACHED();
    return;
  }

  int entangled_message_port_id =
      message_ports_[sender_message_port_id].entangled_message_port_id;
  if (entangled_message_port_id == MSG_ROUTING_NONE)
    return;  // Process could have crashed.

  if (!message_ports_.count(entangled_message_port_id)) {
    NOTREACHED();
    return;
  }

  PostMessageTo(entangled_message_port_id, message, sent_message_port_id);
}

void MessagePortDispatcher::PostMessageTo(int message_port_id,
                                          const string16& message,
                                          int sent_message_port_id) {
  if (!message_ports_.count(message_port_id) ||
      (sent_message_port_id != MSG_ROUTING_NONE &&
       !message_ports_.count(sent_message_port_id))) {
    NOTREACHED();
    return;
  }

  MessagePort& entangled_port = message_ports_[message_port_id];

  MessagePort* sent_port = NULL;
  if (sent_message_port_id != MSG_ROUTING_NONE) {
    sent_port = &message_ports_[sent_message_port_id];
    sent_port->queue_messages = true;
  }

  if (entangled_port.queue_messages) {
    entangled_port.queued_messages.push_back(
        std::make_pair(message, sent_message_port_id));
  } else {
    // If a message port was sent around, the new location will need a routing
    // id.  Instead of having the created port send us a sync message to get it,
    // send along with the message.
    int new_routing_id = MSG_ROUTING_NONE;
    if (sent_message_port_id != MSG_ROUTING_NONE) {
      new_routing_id = entangled_port.next_routing_id->Run();
      sent_port->sender = entangled_port.sender;

      // Update the entry for the sent port as it can be in a different process.
      sent_port->route_id = new_routing_id;
    }

    // Now send the message to the entangled port.
    IPC::Message* ipc_msg = new WorkerProcessMsg_Message(
        entangled_port.route_id, message, sent_message_port_id,
        new_routing_id);
    entangled_port.sender->Send(ipc_msg);
  }
}

void MessagePortDispatcher::OnQueueMessages(int message_port_id) {
  if (!message_ports_.count(message_port_id)) {
    NOTREACHED();
    return;
  }

  MessagePort& port = message_ports_[message_port_id];
  port.queue_messages = true;
  port.sender->Send(new WorkerProcessMsg_MessagesQueued(port.route_id));
}

void MessagePortDispatcher::OnSendQueuedMessages(
    int message_port_id,
    const QueuedMessages& queued_messages) {
  if (!message_ports_.count(message_port_id)) {
    NOTREACHED();
    return;
  }

  // Send the queued messages to the port again.  This time they'll reach the
  // new location.
  MessagePort& port = message_ports_[message_port_id];
  port.queue_messages = false;
  port.queued_messages.insert(port.queued_messages.begin(),
                              queued_messages.begin(),
                              queued_messages.end());
  for (QueuedMessages::iterator iter = port.queued_messages.begin();
       iter != port.queued_messages.end(); ++iter) {
    PostMessageTo(message_port_id, iter->first, iter->second);
  }
  port.queued_messages.clear();
}

void MessagePortDispatcher::Observe(NotificationType type,
                                    const NotificationSource& source,
                                    const NotificationDetails& details) {
  IPC::Message::Sender* sender = NULL;
  if (type.value == NotificationType::RESOURCE_MESSAGE_FILTER_SHUTDOWN) {
    sender = Source<ResourceMessageFilter>(source).ptr();
  } else if (type.value == NotificationType::WORKER_PROCESS_HOST_SHUTDOWN) {
    sender = Source<WorkerProcessHost>(source).ptr();
  } else {
    NOTREACHED();
  }

  // Check if the (possibly) crashed process had any message ports.
  for (MessagePorts::iterator iter = message_ports_.begin();
       iter != message_ports_.end();) {
    MessagePorts::iterator cur_item = iter++;
    if (cur_item->second.sender == sender) {
      if (cur_item->second.entangled_message_port_id != MSG_ROUTING_NONE) {
        message_ports_[cur_item->second.entangled_message_port_id].
            entangled_message_port_id = MSG_ROUTING_NONE;
      }
      message_ports_.erase(cur_item);
    }
  }
}
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_WORKER_HOST_MESSAGE_PORT_DISPATCHER_H_
#define CHROME_BROWSER_WORKER_HOST_MESSAGE_PORT_DISPATCHER_H_

#include <map>
#include <utility>
#include <vector>

#include "base/basictypes.h"
#include "base/singleton.h"
#include "base/string16.h"
#include "base/task.h"
#include "chrome/common/notification_registrar.h"
#include "ipc/ipc_message.h"

class MessagePortDispatcher : public NotificationObserver {
 public:
  typedef std::vector<std::pair<string16, int> > QueuedMessages;

  // Returns the MessagePortDispatcher singleton.
  static MessagePortDispatcher* GetInstance();

  bool OnMessageReceived(const IPC::Message& message,
                         IPC::Message::Sender* sender,
                         CallbackWithReturnValue<int>::Type* next_routing_id,
                         bool* message_was_ok);

  bool Send(IPC::Message* message);

 private:
  friend struct DefaultSingletonTraits<MessagePortDispatcher>;

  MessagePortDispatcher();
  ~MessagePortDispatcher();

  // Message handlers.
  void OnCreate(int* route_id, int* message_port_id);
  void OnDestroy(int message_port_id);
  void OnEntangle(int local_message_port_id, int remote_message_port_id);
  void OnPostMessage(int sender_message_port_id,
                     const string16& message,
                     int sent_message_port_id);
  void OnQueueMessages(int message_port_id);
  void OnSendQueuedMessages(int message_port_id,
                            const QueuedMessages& queued_messages);

  void PostMessageTo(int message_port_id,
                     const string16& message,
                     int sent_message_port_id);

  // NotificationObserver interface.
  void Observe(NotificationType type,
               const NotificationSource& source,
               const NotificationDetails& details);

  struct MessagePort {
    // sender and route_id are what we need to send messages to the port.
    IPC::Message::Sender* sender;
    int route_id;
    // A function pointer to generate a new route id for the sender above.
    // Owned by "sender" above, so don't delete.
    CallbackWithReturnValue<int>::Type* next_routing_id;
    // A globally unique id for this message port.
    int message_port_id;
    // The globally unique id of the entangled message port.
    int entangled_message_port_id;
    // If true, all messages to this message port are queued and not delivered.
    bool queue_messages;
    QueuedMessages queued_messages;
  };

  typedef std::map<int, MessagePort> MessagePorts;
  MessagePorts message_ports_;

  // We need globally unique identifiers for each message port.
  int next_message_port_id_;

  // Valid only during IPC message dispatching.
  IPC::Message::Sender* sender_;
  CallbackWithReturnValue<int>::Type* next_routing_id_;

  NotificationRegistrar registrar_;

  DISALLOW_COPY_AND_ASSIGN(MessagePortDispatcher);
};

#endif  // CHROME_BROWSER_WORKER_HOST_MESSAGE_PORT_DISPATCHER_H_
#include "chrome/browser/worker_host/message_port_dispatcher.h"
#include "chrome/common/notification_service.h"
#include "chrome/common/result_codes.h"
  next_route_id_ = NewCallbackWithReturnValue(
      WorkerService::GetInstance(), &WorkerService::next_worker_route_id);
  // Let interested observers know we are being deleted.
  NotificationService::current()->Notify(
      NotificationType::WORKER_PROCESS_HOST_SHUTDOWN,
      Source<WorkerProcessHost>(this),
      NotificationService::NoDetails());
  bool msg_is_ok = true;
  bool handled = MessagePortDispatcher::GetInstance()->OnMessageReceived(
      message, this, next_route_id_, &msg_is_ok);

  if (!handled) {
    handled = true;
    IPC_BEGIN_MESSAGE_MAP_EX(WorkerProcessHost, message, msg_is_ok)
      IPC_MESSAGE_HANDLER(ViewHostMsg_CreateDedicatedWorker,
                          OnCreateDedicatedWorker)
      IPC_MESSAGE_HANDLER(ViewHostMsg_CancelCreateDedicatedWorker,
                          OnCancelCreateDedicatedWorker)
      IPC_MESSAGE_HANDLER(ViewHostMsg_ForwardToWorker,
                          OnForwardToWorker)
      IPC_MESSAGE_UNHANDLED(handled = false)
    IPC_END_MESSAGE_MAP_EX()
  }

  if (!msg_is_ok) {
    NOTREACHED();
    base::KillProcess(handle(), ResultCodes::KILLED_BAD_MESSAGE, false);
  }

#include "base/task.h"
  // A callback to create a routing id for the associated worker process.
  CallbackWithReturnValue<int>::Type* next_route_id_;

#include "chrome/browser/worker_host/worker_process_host.h"
  // Receive a notification if a message filter or WorkerProcessHost is deleted.

  registrar_.Add(this, NotificationType::WORKER_PROCESS_HOST_SHUTDOWN,
                 NotificationService::AllSources());
  if (type.value == NotificationType::RESOURCE_MESSAGE_FILTER_SHUTDOWN) {
    ResourceMessageFilter* sender = Source<ResourceMessageFilter>(source).ptr();
    SenderShutdown(sender);
  } else if (type.value == NotificationType::WORKER_PROCESS_HOST_SHUTDOWN) {
    WorkerProcessHost* sender = Source<WorkerProcessHost>(source).ptr();
    SenderShutdown(sender);
    WorkerProcessDestroyed(sender);
  } else {
    NOTREACHED();
  }
void WorkerService::SenderShutdown(IPC::Message::Sender* sender) {
void WorkerService::WorkerProcessDestroyed(WorkerProcessHost* process) {
#ifndef CHROME_BROWSER_WORKER_HOST_WORKER_SERVICE_H_
#define CHROME_BROWSER_WORKER_HOST_WORKER_SERVICE_H_
  // NotificationObserver interface.
  void Observe(NotificationType type,
               const NotificationSource& source,
               const NotificationDetails& details);

  // Notifies us that a process that's talking to a worker has shut down.
  void SenderShutdown(IPC::Message::Sender* sender);

  // Notifies us that a worker process has closed.
  void WorkerProcessDestroyed(WorkerProcessHost* process);

#endif  // CHROME_BROWSER_WORKER_HOST_WORKER_SERVICE_H_
    // Lets interested observers know when a WorkerProcessHost is being deleted
    // and can no longer be used.
    WORKER_PROCESS_HOST_SHUTDOWN,

// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/common/webmessageportchannel_impl.h"

#include "chrome/common/child_process.h"
#include "chrome/common/child_thread.h"
#include "chrome/common/worker_messages.h"
#include "webkit/api/public/WebString.h"
#include "webkit/api/public/WebMessagePortChannelClient.h"

using WebKit::WebMessagePortChannel;
using WebKit::WebMessagePortChannelClient;
using WebKit::WebString;

WebMessagePortChannelImpl::WebMessagePortChannelImpl()
    : client_(NULL),
      route_id_(MSG_ROUTING_NONE),
      message_port_id_(MSG_ROUTING_NONE) {
  AddRef();
  Init();
}

WebMessagePortChannelImpl::WebMessagePortChannelImpl(
    int route_id,
    int message_port_id)
    : client_(NULL),
      route_id_(route_id),
      message_port_id_(message_port_id) {
  AddRef();
  Init();
}

WebMessagePortChannelImpl::~WebMessagePortChannelImpl() {
  if (message_port_id_ != MSG_ROUTING_NONE)
    Send(new WorkerProcessHostMsg_DestroyMessagePort(message_port_id_));

  if (route_id_ != MSG_ROUTING_NONE)
    ChildThread::current()->RemoveRoute(route_id_);
}

void WebMessagePortChannelImpl::setClient(WebMessagePortChannelClient* client) {
  // Must lock here since client_ is called on the main thread.
  AutoLock auto_lock(lock_);
  client_ = client;
}

void WebMessagePortChannelImpl::destroy() {
  setClient(NULL);
  Release();
}

void WebMessagePortChannelImpl::entangle(WebMessagePortChannel* channel) {
  // The message port ids might not be set up yet, if this channel wasn't
  // created on the main thread.  So need to wait until we're on the main thread
  // before getting the other message port id.
  scoped_refptr<WebMessagePortChannelImpl> webchannel =
      static_cast<WebMessagePortChannelImpl*>(channel);
  Entangle(webchannel);
}

void WebMessagePortChannelImpl::postMessage(
    const WebString& message,
    WebMessagePortChannel* channel) {
  if (MessageLoop::current() != ChildThread::current()->message_loop()) {
    ChildThread::current()->message_loop()->PostTask(FROM_HERE,
        NewRunnableMethod(this, &WebMessagePortChannelImpl::postMessage,
            message, channel));
    return;
  }

  WebMessagePortChannelImpl* webchannel =
      static_cast<WebMessagePortChannelImpl*>(channel);

  int message_port_id = MSG_ROUTING_NONE;
  if (webchannel) {
    message_port_id = webchannel->message_port_id();
    webchannel->QueueMessages();
    DCHECK(message_port_id != MSG_ROUTING_NONE);
  }

  IPC::Message* msg = new WorkerProcessHostMsg_PostMessage(
      message_port_id_, message, message_port_id);

  Send(msg);
}

bool WebMessagePortChannelImpl::tryGetMessage(
    WebString* message,
    WebMessagePortChannel** channel) {
  AutoLock auto_lock(lock_);
  if (message_queue_.empty())
    return false;

  *message = message_queue_.front().message;
  *channel = message_queue_.front().port.release();
  message_queue_.pop();
  return true;
}

void WebMessagePortChannelImpl::Init() {
  if (MessageLoop::current() != ChildThread::current()->message_loop()) {
    ChildThread::current()->message_loop()->PostTask(FROM_HERE,
        NewRunnableMethod(this, &WebMessagePortChannelImpl::Init));
    return;
  }

  if (route_id_ == MSG_ROUTING_NONE) {
    DCHECK(message_port_id_ == MSG_ROUTING_NONE);
    Send(new WorkerProcessHostMsg_CreateMessagePort(
        &route_id_, &message_port_id_));
  }

  ChildThread::current()->AddRoute(route_id_, this);
}

void WebMessagePortChannelImpl::Entangle(
    scoped_refptr<WebMessagePortChannelImpl> channel) {
  if (MessageLoop::current() != ChildThread::current()->message_loop()) {
    ChildThread::current()->message_loop()->PostTask(FROM_HERE,
        NewRunnableMethod(this, &WebMessagePortChannelImpl::Entangle, channel));
    return;
  }

  Send(new WorkerProcessHostMsg_Entangle(
      message_port_id_, channel->message_port_id()));
}

void WebMessagePortChannelImpl::QueueMessages() {
  // This message port is being sent elsewhere (perhaps to another process).
  // The new endpoint needs to recieve the queued messages, including ones that
  // could still be in-flight.  So we tell the browser to queue messages, and it
  // sends us an ack, whose receipt we know means that no more messages are
  // in-flight.  We then send the queued messages to the browser, which prepends
  // them to the ones it queued and it sends them to the new endpoint.
  Send(new WorkerProcessHostMsg_QueueMessages(message_port_id_));

  // The process could potentially go away while we're still waiting for
  // in-flight messages.  Ensure it stays alive.
  ChildProcess::current()->AddRefProcess();
}

void WebMessagePortChannelImpl::Send(IPC::Message* message) {
  if (MessageLoop::current() != ChildThread::current()->message_loop()) {
    DCHECK(!message->is_sync());
    ChildThread::current()->message_loop()->PostTask(FROM_HERE,
        NewRunnableMethod(this, &WebMessagePortChannelImpl::Send, message));
    return;
  }

  ChildThread::current()->Send(message);
}

void WebMessagePortChannelImpl::OnMessageReceived(const IPC::Message& message) {
  IPC_BEGIN_MESSAGE_MAP(WebMessagePortChannelImpl, message)
    IPC_MESSAGE_HANDLER(WorkerProcessMsg_Message, OnMessage)
    IPC_MESSAGE_HANDLER(WorkerProcessMsg_MessagesQueued, OnMessagedQueued)
  IPC_END_MESSAGE_MAP()
}

void WebMessagePortChannelImpl::OnMessage(const string16& message,
                                          int sent_message_port_id,
                                          int new_routing_id) {
  AutoLock auto_lock(lock_);
  Message msg;
  msg.message = message;
  msg.port = NULL;
  if (sent_message_port_id != MSG_ROUTING_NONE) {
    msg.port = new WebMessagePortChannelImpl(
        new_routing_id, sent_message_port_id);
  }

  bool was_empty = message_queue_.empty();
  message_queue_.push(msg);
  if (client_ && was_empty)
    client_->messageAvailable();
}

void WebMessagePortChannelImpl::OnMessagedQueued() {
  std::vector<std::pair<string16, int> > queued_messages;

  {
    AutoLock auto_lock(lock_);
    queued_messages.reserve(message_queue_.size());
    while (!message_queue_.empty()) {
      string16 message = message_queue_.front().message;
      int port = MSG_ROUTING_NONE;
      if (message_queue_.front().port)
        port = message_queue_.front().port->message_port_id();

      queued_messages.push_back(std::make_pair(message, port));
      message_queue_.pop();
    }
  }

  Send(new WorkerProcessHostMsg_SendQueuedMessages(
      message_port_id_, queued_messages));

  message_port_id_ = MSG_ROUTING_NONE;

  Release();
  ChildProcess::current()->ReleaseProcess();
}
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_COMMON_WEBMESSAGEPORTCHANNEL_IMPL_H_
#define CHROME_COMMON_WEBMESSAGEPORTCHANNEL_IMPL_H_

#include <queue>

#include "base/basictypes.h"
#include "base/lock.h"
#include "base/string16.h"
#include "base/ref_counted.h"
#include "ipc/ipc_channel.h"
#include "webkit/api/public/WebMessagePortChannel.h"

// This is thread safe.
class WebMessagePortChannelImpl
    : public WebKit::WebMessagePortChannel,
      public IPC::Channel::Listener,
      public base::RefCountedThreadSafe<WebMessagePortChannelImpl> {
 public:
  WebMessagePortChannelImpl();
  WebMessagePortChannelImpl(int route_id, int message_port_id);

  // Queues received and incoming messages until there are no more in-flight
  // messages, then sends all of them to the browser process.
  void QueueMessages();
  int message_port_id() const { return message_port_id_; }

 private:
  friend class base::RefCountedThreadSafe<WebMessagePortChannelImpl>;
  ~WebMessagePortChannelImpl();

  // WebMessagePortChannel implementation.
  virtual void setClient(WebKit::WebMessagePortChannelClient* client);
  virtual void destroy();
  virtual void entangle(WebKit::WebMessagePortChannel* channel);
  virtual void postMessage(const WebKit::WebString& message,
                           WebKit::WebMessagePortChannel* channel);
  virtual bool tryGetMessage(WebKit::WebString* message,
                             WebKit::WebMessagePortChannel** channel);

  void Init();
  void Entangle(scoped_refptr<WebMessagePortChannelImpl> channel);
  void Send(IPC::Message* message);

  // IPC::Channel::Listener implementation.
  virtual void OnMessageReceived(const IPC::Message& message);

  void OnMessage(const string16& message,
                 int sent_message_port_id,
                 int new_routing_id);
  void OnMessagedQueued();

  struct Message {
    string16 message;
    scoped_refptr<WebMessagePortChannelImpl> port;
  };

  typedef std::queue<Message> MessageQueue;
  MessageQueue message_queue_;

  WebKit::WebMessagePortChannelClient* client_;
  Lock lock_;  // Locks access to above.

  int route_id_;  // The routing id for this object.
  int message_port_id_;  // A globally unique identifier for this message port.

  DISALLOW_COPY_AND_ASSIGN(WebMessagePortChannelImpl);
};

#endif  // CHROME_COMMON_WEBMESSAGEPORTCHANNEL_IMPL_H_
typedef std::pair<string16, int> QueuedMessage;

#include <utility>

  // Note: these Message Port related messages can also be sent to the
  // renderer process.  Putting them here since we don't have a shared place
  // like common_messages_internal.h
  IPC_MESSAGE_ROUTED3(WorkerProcessMsg_Message,
                      string16 /* message */,
                      int /* sent_message_port_id */,
                      int /* new_routing_id */)

  // Tells the Message Port Channel object that there are no more in-flight
  // messages arriving.
  IPC_MESSAGE_ROUTED0(WorkerProcessMsg_MessagesQueued)
IPC_BEGIN_MESSAGES(WorkerProcessHost)
  // Note: these Message Port related messages can also be sent out from the
  // renderer process.  Putting them here since we don't have a shared place
  // like common_messages_internal.h

  // Creates a new Message Port Channel object.  The first paramaeter is the
  // message port channel's routing id in this process.  The second parameter
  // is the process-wide-unique identifier for that port.
  IPC_SYNC_MESSAGE_CONTROL0_2(WorkerProcessHostMsg_CreateMessagePort,
                              int /* route_id */,
                              int /* message_port_id */)

  // Sent when a Message Port Channel object is destroyed.
  IPC_MESSAGE_CONTROL1(WorkerProcessHostMsg_DestroyMessagePort,
                       int /* message_port_id */)

  // Sends a message to a message port.  Optionally sends a message port as
  // as well if sent_message_port_id != MSG_ROUTING_NONE.
  IPC_MESSAGE_CONTROL3(WorkerProcessHostMsg_PostMessage,
                       int /* sender_message_port_id */,
                       string16 /* message */,
                       int /* sent_message_port_id */)

  // Causes messages sent to the remote port to be delivered to this local port.
  IPC_MESSAGE_CONTROL2(WorkerProcessHostMsg_Entangle,
                       int /* local_message_port_id */,
                       int /* remote_message_port_id */)

  // Causes the browser to queue messages sent to this port until the the port
  // has made sure that all in-flight messages were routed to the new
  // destination.
  IPC_MESSAGE_CONTROL1(WorkerProcessHostMsg_QueueMessages,
                       int /* message_port_id */)

  // Sends the browser all the queued messages that arrived at this message port
  // after it was sent in a postMessage call.
  // NOTE: MSVS can't compile the macro if std::vector<std::pair<string16, int> >
  // is used, so we typedef it in worker_messages.h.
  IPC_MESSAGE_CONTROL2(WorkerProcessHostMsg_SendQueuedMessages,
                       int /* message_port_id */,
                       std::vector<QueuedMessage> /* queued_messages */)
IPC_END_MESSAGES(WorkerProcessHost)
#include "chrome/common/webmessageportchannel_impl.h"
WebKit::WebMessagePortChannel*
RendererWebKitClientImpl::createMessagePortChannel() {
  return new WebMessagePortChannelImpl();
}

  virtual WebKit::WebMessagePortChannel* createMessagePortChannel();
TEST_F(WorkerTest, MessagePorts) {
  static const char* kLayoutTestFiles[] = {
    "message-channel-gc.html",
    "message-channel-gc-2.html",
    "message-channel-gc-3.html",
    "message-channel-gc-4.html",
    "message-port.html",
    "message-port-clone.html",
    "message-port-constructor-for-deleted-document.html",
    "message-port-deleted-document.html",
    "message-port-deleted-frame.html",
    "message-port-inactive-document.html",
    "message-port-no-wrapper.html",
    // Only works with run-webkit-tests --leaks.
    //"message-channel-listener-circular-ownership.html",
  };

  FilePath fast_test_dir;
  fast_test_dir = fast_test_dir.AppendASCII("LayoutTests");
  fast_test_dir = fast_test_dir.AppendASCII("fast");

  FilePath worker_test_dir;
  worker_test_dir = worker_test_dir.AppendASCII("events");
  InitializeForLayoutTest(fast_test_dir, worker_test_dir, false);

  for (size_t i = 0; i < arraysize(kLayoutTestFiles); ++i)
    RunLayoutTest(kLayoutTestFiles[i], false);
}

#include "chrome/common/webmessageportchannel_impl.h"
WebKit::WebMessagePortChannel*
WorkerWebKitClientImpl::createMessagePortChannel() {
  return new WebMessagePortChannelImpl();
}

  virtual WebKit::WebMessagePortChannel* createMessagePortChannel();
template <class A, class B>
struct ParamTraits<std::pair<A, B> > {
  typedef std::pair<A, B> param_type;
  static void Write(Message* m, const param_type& p) {
    WriteParam(m, p.first);
    WriteParam(m, p.second);
  }
  static bool Read(const Message* m, void** iter, param_type* r) {
    return ReadParam(m, iter, &r->first) && ReadParam(m, iter, &r->second);
  }
  static void Log(const param_type& p, std::wstring* l) {
    l->append(L"(");
    LogParam(p.first, l);
    l->append(L", ");
    LogParam(p.second, l);
    l->append(L")");
  }
};

    class WebMessagePortChannel;
        // Message Ports -------------------------------------------------------

        // Creates a Message Port Channel.  This can be called on any thread.
        // The returned object should only be used on the thread it was created on.
        virtual WebMessagePortChannel* createMessagePortChannel() = 0;


/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef WebMessagePortChannel_h
#define WebMessagePortChannel_h

#include "WebCommon.h"

namespace WebKit {
    class WebMessagePortChannelClient;
    class WebString;

    // Provides an interface to a Message Port Channel implementation.  The object owns itself and
    // is signalled that its not needed anymore with the destroy() call.
    class WebMessagePortChannel {
    public:
        virtual void setClient(WebMessagePortChannelClient*) = 0;
        virtual void destroy() = 0;
        // WebKit versions of WebCore::MessagePortChannel.
        virtual void entangle(WebMessagePortChannel*) = 0;
        // If sending a message port, callee receives ownership of the object.
        virtual void postMessage(const WebString&, WebMessagePortChannel*) = 0;
        virtual bool tryGetMessage(WebString*, WebMessagePortChannel**) = 0;

    protected:
        virtual ~WebMessagePortChannel() { }
    };

} // namespace WebKit

#endif
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef WebMessagePortChannelClient_h
#define WebMessagePortChannelClient_h

namespace WebKit {

    // Provides an interface for users of WebMessagePortChannel to be notified
    // when messages are available.
    class WebMessagePortChannelClient {
    public:
        // Alerts that new messages have arrived, which are retrieved by calling
        // WebMessagePortChannel::tryGetMessage.  Note that this may be called
        // on any thread.
        virtual void messageAvailable() = 0;
    protected:
        virtual ~WebMessagePortChannelClient() { }
    };

} // namespace WebKit

#endif
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "PlatformMessagePortChannel.h"

#include "WebKit.h"
#include "WebKitClient.h"
#include "WebMessagePortChannel.h"
#include "WebString.h"

#include "MessagePort.h"
#include "ScriptExecutionContext.h"

using namespace WebKit;

namespace WebCore {

PassOwnPtr<MessagePortChannel> MessagePortChannel::create(PassRefPtr<PlatformMessagePortChannel> channel)
{
    return new MessagePortChannel(channel);
}

void MessagePortChannel::createChannel(PassRefPtr<MessagePort> port1, PassRefPtr<MessagePort> port2)
{
    PlatformMessagePortChannel::createChannel(port1, port2);
}

MessagePortChannel::MessagePortChannel(PassRefPtr<PlatformMessagePortChannel> channel)
    : m_channel(channel)
{
}

MessagePortChannel::~MessagePortChannel()
{
    // Make sure we close our platform channel when the base is freed, to keep the channel objects from leaking.
    m_channel->close();
}

bool MessagePortChannel::entangleIfOpen(MessagePort* port)
{
    return m_channel->entangleIfOpen(port);
}

void MessagePortChannel::disentangle()
{
    m_channel->disentangle();
}

void MessagePortChannel::postMessageToRemote(PassOwnPtr<MessagePortChannel::EventData> message)
{
    m_channel->postMessageToRemote(message);
}

bool MessagePortChannel::tryGetMessageFromRemote(OwnPtr<MessagePortChannel::EventData>& result)
{
    return m_channel->tryGetMessageFromRemote(result);
}

void MessagePortChannel::close()
{
    m_channel->close();
}

bool MessagePortChannel::isConnectedTo(MessagePort* port)
{
    return m_channel->isConnectedTo(port);
}

bool MessagePortChannel::hasPendingActivity()
{
    return m_channel->hasPendingActivity();
}

MessagePort* MessagePortChannel::locallyEntangledPort(const ScriptExecutionContext* context)
{
    // This is just an optimization, so return NULL always.
    return NULL;
}


PassRefPtr<PlatformMessagePortChannel> PlatformMessagePortChannel::create()
{
    return adoptRef(new PlatformMessagePortChannel());
}

PassRefPtr<PlatformMessagePortChannel> PlatformMessagePortChannel::create(
    WebMessagePortChannel* channel)
{
    return adoptRef(new PlatformMessagePortChannel(channel));
}


PlatformMessagePortChannel::PlatformMessagePortChannel()
    : m_localPort(0)
{
    m_webChannel = webKitClient()->createMessagePortChannel();
    m_webChannel->setClient(this);
}

PlatformMessagePortChannel::PlatformMessagePortChannel(WebMessagePortChannel* channel)
    : m_localPort(0)
    , m_webChannel(channel)
{
}

PlatformMessagePortChannel::~PlatformMessagePortChannel()
{
    if (m_webChannel)
        m_webChannel->destroy();
}

void PlatformMessagePortChannel::createChannel(PassRefPtr<MessagePort> port1, PassRefPtr<MessagePort> port2)
{
    // Create proxies for each endpoint.
    RefPtr<PlatformMessagePortChannel> channel1 = PlatformMessagePortChannel::create();
    RefPtr<PlatformMessagePortChannel> channel2 = PlatformMessagePortChannel::create();

    // Entangle the two endpoints.
    channel1->setEntangledChannel(channel2);
    channel2->setEntangledChannel(channel1);

    // Now entangle the proxies with the appropriate local ports.
    port1->entangle(MessagePortChannel::create(channel2));
    port2->entangle(MessagePortChannel::create(channel1));
}

void PlatformMessagePortChannel::messageAvailable()
{
    MutexLocker lock(m_mutex);
    if (m_localPort)
        m_localPort->messageAvailable();
}

bool PlatformMessagePortChannel::entangleIfOpen(MessagePort* port)
{
    MutexLocker lock(m_mutex);
    m_localPort = port;
    return true;
}

void PlatformMessagePortChannel::disentangle()
{
    MutexLocker lock(m_mutex);
    m_localPort = 0;
}

void PlatformMessagePortChannel::postMessageToRemote(PassOwnPtr<MessagePortChannel::EventData> message)
{
    if (!m_localPort)
        return;

    WebString messageString = message->message();
    OwnPtr<WebCore::MessagePortChannel> channel = message->channel();
    WebMessagePortChannel* webChannel = NULL;
    if (channel.get()) {
        WebCore::PlatformMessagePortChannel* platformChannel = channel->channel();
        webChannel = platformChannel->webChannelRelease();
        webChannel->setClient(0);
    }
    m_webChannel->postMessage(messageString, webChannel);
}

bool PlatformMessagePortChannel::tryGetMessageFromRemote(OwnPtr<MessagePortChannel::EventData>& result)
{
    if (!m_webChannel)
        return false;

    WebString message;
    WebMessagePortChannel* webChannel = NULL;
    bool rv = m_webChannel->tryGetMessage(&message, &webChannel);
    if (rv) {
        OwnPtr<MessagePortChannel> channel;
        if (webChannel) {
            RefPtr<PlatformMessagePortChannel> platformChannel = create(webChannel);
            webChannel->setClient(platformChannel.get());
            channel = MessagePortChannel::create(platformChannel);
        }
        result = MessagePortChannel::EventData::create(message, channel.release());
    }

    return rv;
}

void PlatformMessagePortChannel::close()
{
    MutexLocker lock(m_mutex);
    // Disentangle ourselves from the other end.  We still maintain a reference to m_webChannel,
    // since previously-existing messages should still be delivered.
    m_localPort = 0;
    m_entangledChannel = 0;
}

bool PlatformMessagePortChannel::isConnectedTo(MessagePort* port)
{
    MutexLocker lock(m_mutex);
    return m_entangledChannel && m_entangledChannel->m_localPort == port;
}

bool PlatformMessagePortChannel::hasPendingActivity()
{
    MutexLocker lock(m_mutex);
    return m_localPort;
}

void PlatformMessagePortChannel::setEntangledChannel(PassRefPtr<PlatformMessagePortChannel> remote)
{
    m_webChannel->entangle(remote->m_webChannel);

    MutexLocker lock(m_mutex);
    m_entangledChannel = remote;
}

WebMessagePortChannel* PlatformMessagePortChannel::webChannelRelease()
{
    WebMessagePortChannel* rv = m_webChannel;
    m_webChannel = 0;
    return rv;
}

} // namespace WebCore
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef PlatformMessagePortChannel_h
#define PlatformMessagePortChannel_h

#include "WebMessagePortChannelClient.h"

#include "MessagePortChannel.h"

#include <wtf/PassRefPtr.h>
#include <wtf/Threading.h>

namespace WebKit {
class WebMessagePortChannel;
}

namespace WebCore {
    class MessagePort;

    // PlatformMessagePortChannel is a platform-dependent interface to the remote side of a message channel.
    class PlatformMessagePortChannel : public ThreadSafeShared<PlatformMessagePortChannel>,
                                       public WebKit::WebMessagePortChannelClient {
    public:
        static void createChannel(PassRefPtr<MessagePort>, PassRefPtr<MessagePort>);
        static PassRefPtr<PlatformMessagePortChannel> create();
        static PassRefPtr<PlatformMessagePortChannel> create(WebKit::WebMessagePortChannel*);

        // APIs delegated from MessagePortChannel.h
        bool entangleIfOpen(MessagePort*);
        void disentangle();
        void postMessageToRemote(PassOwnPtr<MessagePortChannel::EventData>);
        bool tryGetMessageFromRemote(OwnPtr<MessagePortChannel::EventData>&);
        void close();
        bool isConnectedTo(MessagePort* port);
        bool hasPendingActivity();

        // Releases ownership of the contained web channel.
        WebKit::WebMessagePortChannel* webChannelRelease();

        ~PlatformMessagePortChannel();

    private:
        PlatformMessagePortChannel();
        PlatformMessagePortChannel(WebKit::WebMessagePortChannel*);

        void setEntangledChannel(PassRefPtr<PlatformMessagePortChannel>);

        // WebKit::WebMessagePortChannelClient implementation
        virtual void messageAvailable();

        // Mutex used to ensure exclusive access to the object internals.
        Mutex m_mutex;

        // Pointer to our entangled pair - cleared when close() is called.
        RefPtr<PlatformMessagePortChannel> m_entangledChannel;

        // The port we are connected to - this is the port that is notified when new messages arrive.
        MessagePort* m_localPort;

        WebKit::WebMessagePortChannel* m_webChannel;
    };

} // namespace WebCore

#endif // PlatformMessagePortChannel_h
  virtual WebKit::WebMessagePortChannel* createMessagePortChannel() {
    return NULL;
  }

  virtual WebKit::WebMessagePortChannel* createMessagePortChannel() {
    return NULL;
  }

// Channel order for AAC
// From http://www.hydrogenaudio.org/forums/lofiversion/index.php/t40046.html
// And Quicktime Pro, Movie Inspector
const int kChannel_C = 0;
const int kChannel_L = 1;
const int kChannel_R = 2;
const int kChannel_SL = 3;
const int kChannel_SR = 4;
const int kChannel_LFE = 5;

template<class Format>
Format ChannelsClampInternal(float val,
                             const Format min_value,
                             const Format max_value) {
  if (val > static_cast<float>(max_value)) {
    return max_value;
  }
  if (val < static_cast<float>(min_value)) {
    return min_value;
  }
  return static_cast<Format>(val);
}

template<class Format>
void FoldChannelsInternal(Format* buf_out,
                          int sample_count,
                          float volume,
                          int channels,
                          const int min_value,
                          const int max_value) {
  Format* buf_in = buf_out;
  // mid_value is to adjust excess 128 notation in unsigned 8 bit samples
  // to signed before adding channels.
  const int mid_value = (max_value + min_value + 1) / 2;
  const float kHalfPerceived = 0.707f; // 1/sqrt(2)
  for (int i = 0; i < sample_count; ++i) {
    float center_half = static_cast<float>(buf_in[kChannel_C] - mid_value) * kHalfPerceived;
    float left = static_cast<float>(buf_in[kChannel_L] - mid_value);
    float right = static_cast<float>(buf_in[kChannel_R] - mid_value);
    float surround_left = static_cast<float>(buf_in[kChannel_SL] - mid_value);
    float surround_right = static_cast<float>(buf_in[kChannel_SR] - mid_value);
    buf_out[0] = ChannelsClampInternal(
      (left + surround_left + center_half) * volume + mid_value,
      static_cast<Format>(min_value), static_cast<Format>(max_value));
    buf_out[1] = ChannelsClampInternal(
      (right + surround_right + center_half) * volume + mid_value,
      static_cast<Format>(min_value), static_cast<Format>(max_value));
    buf_out += 2;
    buf_in += channels;
  }
}

bool FoldChannels(void* buf,
                  size_t buflen,
                  int channels,
                  int bytes_per_sample,
                  float volume) {
  DCHECK(buf);
  DCHECK(volume >= 0.0f && volume <= 1.0f);
  if (channels >= 5 && channels <= 6 && bytes_per_sample > 0) {
    int sample_count = buflen / (channels * bytes_per_sample);
    if (bytes_per_sample == 1) {
      FoldChannelsInternal(reinterpret_cast<uint8*>(buf),
                           sample_count,
                           volume,
                           channels,
                           0, 255);
      return true;
    } else if (bytes_per_sample == 2) {
      FoldChannelsInternal(reinterpret_cast<int16*>(buf),
                           sample_count,
                           volume,
                           channels,
                           -32768,
                           32767);
      return true;
    } else if (bytes_per_sample == 4) {
      FoldChannelsInternal(reinterpret_cast<int32*>(buf),
                           sample_count,
                           volume,
                           channels,
                           0x80000000,
                           0x7fffffff);
      return true;
    }
  }
  return false;
}

// For all audio functions 3 audio formats are supported:
// 8 bits unsigned 0 to 255.
// 16 bit signed (little endian).
// 32 bit signed (little endian)

// FoldChannels() does a software multichannel folding down to stereo.
// Channel order is assumed to be 5.1 Dolby standard which is
// front left, front right, center, surround left, surround right.
// The subwoofer is ignored.
// 6.1 adds a rear center speaker, and 7.1 has 2 rear speakers.  These
// channels are rare and ignored.
// After summing the channels, volume is adjusted and the samples are
// clipped to the maximum value.
// Volume should normally range from 0.0 (mute) to 1.0 (full volume), but
// since clamping is performed a value of more than 1 is allowed to increase
// volume.
// The buffer is modified in-place to avoid memory management, as this
// function may be called in performance critical code.
bool FoldChannels(void* buf,
                  size_t buflen,
                  int channels,
                  int bytes_per_sample,
                  float volume);

TEST(AudioUtilTest, AdjustVolume_s16_one) {
  // Test AdjustVolume() on 16 bit samples.
  int16 samples_s16[kNumberOfSamples] = { -4, 0x40, -32768, 123 };
  int16 expected_s16[kNumberOfSamples] = { -4, 0x40, -32768, 123 };
  bool result_s16 = media::AdjustVolume(samples_s16, sizeof(samples_s16),
                                        2,  // channels.
                                        sizeof(samples_s16[0]),
                                        1.0f);
  EXPECT_EQ(true, result_s16);
  int expected_test = memcmp(samples_s16, expected_s16, sizeof(expected_s16));
  EXPECT_EQ(0, expected_test);
}

TEST(AudioUtilTest, FoldChannels_u8) {
  // Test AdjustVolume() on 16 bit samples.
  uint8 samples_u8[6] = { 130, 100, 150, 70, 130, 170 };
  uint8 expected_u8[2] = { 43, 153 };
  bool result_u8 = media::FoldChannels(samples_u8, sizeof(samples_u8),
                                        6,  // channels.
                                        sizeof(samples_u8[0]),
                                        1.0f);
  EXPECT_EQ(true, result_u8);
  int expected_test = memcmp(samples_u8, expected_u8, sizeof(expected_u8));
  EXPECT_EQ(0, expected_test);
}

TEST(AudioUtilTest, FoldChannels_s16) {
  // Test AdjustVolume() on 16 bit samples.
  int16 samples_s16[6] = { 12, 1, 3, 7, 13, 17 };
  int16 expected_s16[2] = { static_cast<int16>(12 * .707 + 1 + 7),
                            static_cast<int16>(12 * .707 + 3 + 13) };
  bool result_s16 = media::FoldChannels(samples_s16, sizeof(samples_s16),
                                        6,  // channels.
                                        sizeof(samples_s16[0]),
                                        1.00f);
  EXPECT_EQ(true, result_s16);
  int expected_test = memcmp(samples_s16, expected_s16, sizeof(expected_s16));
  EXPECT_EQ(0, expected_test);
}

TEST(AudioUtilTest, FoldChannels_s32) {
  // Test AdjustVolume() on 16 bit samples.
  int32 samples_s32[6] = { 12, 1, 3, 7, 13, 17 };
  int32 expected_s32[2] = { static_cast<int16>(12 * .707 + 1 + 7),
                            static_cast<int16>(12 * .707 + 3 + 13) };
  bool result_s32 = media::FoldChannels(samples_s32, sizeof(samples_s32),
                                        6,  // channels.
                                        sizeof(samples_s32[0]),
                                        1.00f);
  EXPECT_EQ(true, result_s32);
  int expected_test = memcmp(samples_s32, expected_s32, sizeof(expected_s32));
  EXPECT_EQ(0, expected_test);
}

// This mimics 1 second of audio at 48000 samples per second.
// Running the unittest will produce timing.
TEST(AudioUtilTest, FoldChannels_s16_benchmark) {
  const int kBufferSize = 1024 * 6;
  // Test AdjustVolume() on 16 bit samples.
  for (int i = 0; i < 48000; ++i) {
    int16 samples_s16[kBufferSize];
    for (int j = 0; j < kBufferSize; ++j)
      samples_s16[j] = j;

    bool result_s16 = media::FoldChannels(samples_s16, sizeof(samples_s16),
                                          6,  // channels.
                                          sizeof(samples_s16[0]),
                                          0.5f);
    EXPECT_EQ(true, result_s16);
  }
}
// Enable or disable software folding
#define FOLDING 1

      volume_(1),
      channels_(channels) {
#ifdef FOLDING
  format_.nChannels = channels > 2 ? 2 : channels;
#else
#endif
    buffer->dwBufferLength = used * format_.nChannels / channels_;
    if (channels_ > 2 && format_.nChannels == 2) {
      media::FoldChannels(buffer->lpData, used,
                          channels_, format_.wBitsPerSample >> 3,
                          volume_);
    } else {
      media::AdjustVolume(buffer->lpData, used,
                          format_.nChannels, format_.wBitsPerSample >> 3,
                          volume_);
    }

  // Channels from 0 to 6.
  int channels_;

using WebKit::WebFindOptions;
bool RenderView::canHandleRequest(
    WebFrame* frame, const WebURLRequest& request) {
  // We allow WebKit to think that everything can be handled even though
  // browser-side we limit what we load.
WebURLError RenderView::cannotHandleRequestError(
    WebFrame* frame, const WebURLRequest& request) {
  NOTREACHED();  // Since we said we can handle all requests.
  return WebURLError();
}

WebURLError RenderView::cancelledError(
    WebFrame* frame, const WebURLRequest& request) {
  WebURLError error;
  error.domain = WebString::fromUTF8(net::kErrorDomain);
  error.reason = net::ERR_ABORTED;
  error.unreachableURL = request.url();
  return error;
    WebFrame*, const WebURLError&) {
  NOTREACHED();  // Since we said we can handle all requests.
void RenderView::didDisplayInsecureContent(WebFrame* frame) {
void RenderView::OnFind(int request_id, const string16& search_text,
                        const WebFindOptions& options) {
  WebVector<WebString> ws_file_names(file_names.size());
  virtual bool canHandleRequest(
      WebKit::WebFrame* frame, const WebKit::WebURLRequest& request);
  virtual WebKit::WebURLError cannotHandleRequestError(
      WebKit::WebFrame* frame, const WebKit::WebURLRequest& request);
  virtual WebKit::WebURLError cancelledError(
      WebKit::WebFrame* frame, const WebKit::WebURLRequest& request);
        virtual bool canHandleRequest(
            WebFrame*, const WebURLRequest& request) = 0;
        // Returns an error corresponding to canHandledRequest() returning false.
        virtual WebURLError cannotHandleRequestError(
            WebFrame*, const WebURLRequest& request) = 0;

        // Returns an error corresponding to a user cancellation event.
        virtual WebURLError cancelledError(
            WebFrame*, const WebURLRequest& request) = 0;

} // WebKit
  virtual bool canHandleRequest(
      WebKit::WebFrame*, const WebKit::WebURLRequest&) { return true; }
  virtual WebKit::WebURLError cannotHandleRequestError(
      WebKit::WebFrame*, const WebKit::WebURLRequest& request) {
    return WebKit::WebURLError();
  }
  virtual WebKit::WebURLError cancelledError(
      WebKit::WebFrame*, const WebKit::WebURLRequest& request) {
    return WebKit::WebURLError();
  }
  if (!webframe_->client())
    return ResourceError();

  return webkit_glue::WebURLErrorToResourceError(
      webframe_->client()->cancelledError(
          webframe_, WrappedResourceRequest(request)));
  if (!webframe_->client())
    return ResourceError();

      webframe_->client()->cannotHandleRequestError(
          webframe_, WrappedResourceRequest(request)));
  ResourceError cancelled_error = cancelledError(ResourceRequest());
  return error.errorCode() != cancelled_error.errorCode() ||
         error.domain() != cancelled_error.domain();
  return webframe_->client()->canHandleRequest(
      webframe_, WrappedResourceRequest(request));
bool TestWebViewDelegate::canHandleRequest(
    WebFrame* frame, const WebURLRequest& request) {
WebURLError TestWebViewDelegate::cannotHandleRequestError(
    WebFrame* frame, const WebURLRequest& request) {
WebURLError TestWebViewDelegate::cancelledError(
    WebFrame* frame, const WebURLRequest& request) {
  WebURLError error;
  error.domain = WebString::fromUTF8(net::kErrorDomain);
  error.reason = net::ERR_ABORTED;
  error.unreachableURL = request.url();
  return error;
}

  virtual bool canHandleRequest(
      WebKit::WebFrame*, const WebKit::WebURLRequest&);
  virtual WebKit::WebURLError cannotHandleRequestError(
      WebKit::WebFrame*, const WebKit::WebURLRequest& request);
  virtual WebKit::WebURLError cancelledError(
      WebKit::WebFrame*, const WebKit::WebURLRequest& request);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, url1);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, url2);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, url1);
      main_test_rfh(), -1, GURL(kUnreachableWebDataURL));
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, url1);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, url2);
  bool is_main_frame = render_frame_host->frame_tree_node()->IsMainFrame();
        render_frame_host, parent_routing_id,
        render_frame_host, url, error_code,
    // TODO(creis): Until we mirror the frame tree in the subframe's process,
    // cross-process subframe navigations happen in a renderer's main frame.
    // Correct the transition type here if we know it is for a subframe.
    if (!render_frame_host->frame_tree_node()->IsMainFrame() &&
        pending_entry &&
        pending_entry->frame_tree_node_id() ==
            render_frame_host->frame_tree_node()->frame_tree_node_id()) {
    FrameTreeNode* frame = render_frame_host->frame_tree_node();
      this, parent_routing_id, url);
      this, validated_url, error_code, error_description);
  FrameTreeNode* node = frame_tree_.root();

  // If we are using --site-per-process, we should navigate in the FrameTreeNode
  // specified in the pending entry.
  NavigationEntryImpl* pending_entry =
      NavigationEntryImpl::FromNavigationEntry(controller_.GetPendingEntry());
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSitePerProcess) &&
      pending_entry->frame_tree_node_id() != -1) {
    node = frame_tree_.FindByID(pending_entry->frame_tree_node_id());
  }

  return node->navigator()->NavigateToPendingEntry(
      node->current_frame_host(), reload_type);
  bool is_main_frame = render_frame_host->frame_tree_node()->IsMainFrame();
  bool is_main_frame = render_frame_host->frame_tree_node()->IsMainFrame();
                             is_main_frame,
  bool is_main_frame = render_frame_host->frame_tree_node()->IsMainFrame();
                                error_description, render_view_host));
    const GURL& url) {
  RenderFrameHostImpl* rfh =
      static_cast<RenderFrameHostImpl*>(render_frame_message_source_);
  bool is_main_frame = rfh->frame_tree_node()->IsMainFrame();
  void OnDidFinishLoad(const GURL& url);
  contents()->TestDidFinishLoad(url_from_ipc);
      url_from_ipc, 1, base::string16());
IPC_MESSAGE_ROUTED2(FrameHostMsg_DidStartProvisionalLoadForFrame,
IPC_MESSAGE_ROUTED3(FrameHostMsg_DidFailLoadWithError,
IPC_MESSAGE_ROUTED1(FrameHostMsg_DidFinishLoad,
                    GURL /* validated_url */)
       routing_id_, parent_routing_id, ds->request().url()));
                                      ds->request().url()));
  OnDidStartProvisionalLoadForFrame(-1, url_copy);
  OnDidStartProvisionalLoadForFrame(-1, url);
void TestWebContents::TestDidFinishLoad(const GURL& url) {
  FrameHostMsg_DidFinishLoad msg(0, url);
      0, url, error_code, error_description);
  void TestDidFinishLoad(const GURL& url);
#include "cc/trees/blocking_task_runner.h"
      needs_filter_context_(false),
      main_thread_runner_(BlockingTaskRunner::current()),
      weak_ptrs_(this) {}
  delegated_impl->CreateChildIdIfNeeded(
      base::Bind(&DelegatedRendererLayer::ReceiveUnusedResourcesOnImplThread,
                 main_thread_runner_,
                 weak_ptrs_.GetWeakPtr()));

  // The ResourceProvider will have the new frame as soon as we push it to the
  // pending tree. So unused resources will be returned as well.
  // TODO(danakj): The DidCommitFrameData() notification requires a push
  // properties to happen in order to notify about unused resources returned
  DCHECK(new_frame_data);

void DelegatedRendererLayer::ReceiveUnusedResources(
    const ReturnedResourceArray& unused) {
  unused_resources_for_child_compositor_.insert(
      unused_resources_for_child_compositor_.end(),
      unused.begin(),
      unused.end());
}

// static
void DelegatedRendererLayer::ReceiveUnusedResourcesOnImplThread(
    scoped_refptr<BlockingTaskRunner> task_runner,
    base::WeakPtr<DelegatedRendererLayer> self,
    const ReturnedResourceArray& unused) {
  task_runner->PostTask(
      FROM_HERE,
      base::Bind(
          &DelegatedRendererLayer::ReceiveUnusedResources, self, unused));
}

#include "base/memory/ref_counted.h"
#include "base/memory/weak_ptr.h"
#include "base/synchronization/lock.h"
class BlockingTaskRunner;
  void ReceiveUnusedResources(const ReturnedResourceArray& unused);
  static void ReceiveUnusedResourcesOnImplThread(
      scoped_refptr<BlockingTaskRunner> task_runner,
      base::WeakPtr<DelegatedRendererLayer> self,
      const ReturnedResourceArray& unused);

  ReturnedResourceArray unused_resources_for_child_compositor_;
  scoped_refptr<BlockingTaskRunner> main_thread_runner_;
  base::WeakPtrFactory<DelegatedRendererLayer> weak_ptrs_;


    ResourceProvider::ResourceIdArray* resources_in_frame,
  resources_in_frame->push_back(id);
  // This is just a copy for testing, since resources are added to the
  // ResourceProvider in the pending tree.
void DelegatedRendererLayerImpl::CreateChildIdIfNeeded(
    const ReturnCallback& return_callback) {
  if (child_id_)
    return;

  ResourceProvider* resource_provider = layer_tree_impl()->resource_provider();
  child_id_ = resource_provider->CreateChild(return_callback);
  own_child_id_ = true;
}

  DCHECK(child_id_) << "CreateChildIdIfNeeded must be called first.";
  ResourceProvider::ResourceIdArray resources_in_frame;
                 &resources_in_frame);
  if (invalid_frame) {
    // Declare we are still using the last frame's resources.
    resource_provider->DeclareUsedResourcesFromChild(child_id_, resources_);
  }

  // Declare we are using the new frame's resources.
  resources_.swap(resources_in_frame);
  resource_provider->DeclareUsedResourcesFromChild(child_id_, resources_);
  // Creates an ID with the resource provider for the child renderer
  // that will be sending quads to the layer. Registers the callback to
  // inform when resources are no longer in use.
  void CreateChildIdIfNeeded(const ReturnCallback& return_callback);

  const ResourceProvider::ResourceIdArray& ResourcesForTesting() const {
  ResourceProvider::ResourceIdArray resources_;
    : child_id(0),
      gl_id(0),
ResourceProvider::Resource::Resource(unsigned texture_id,
                                     gfx::Size size,
                                     GLenum filter,
                                     GLenum texture_pool,
                                     GLint wrap_mode,
                                     TextureUsageHint hint,
                                     ResourceFormat format)
    : child_id(0),
      gl_id(texture_id),
ResourceProvider::Resource::Resource(uint8_t* pixels,
                                     gfx::Size size,
                                     GLenum filter,
                                     GLint wrap_mode)
    : child_id(0),
      gl_id(0),
  while (!children_.empty())
    DestroyChild(children_.begin()->first);
int ResourceProvider::CreateChild(const ReturnCallback& return_callback) {

  child_info.return_callback = return_callback;



  ResourceIdArray resources_for_child;

    resources_for_child.push_back(id);

  // If the child is going away, don't consider any resources in use.
  child.in_use_resources.clear();

  DeleteAndReturnUnusedResourcesToChild(
      &child, ForShutdown, resources_for_child);

    ResourceId local_id = next_id_++;
    Resource resource(texture_id,
                      it->size,
                      it->filter,
                      0,
                      GL_CLAMP_TO_EDGE,
                      TextureUsageAny,
                      it->format);
    resource.child_id = child;
    resources_[local_id] = resource;
    child_info.parent_to_child_map[local_id] = it->id;
    child_info.child_to_parent_map[it->id] = local_id;
  }
}

void ResourceProvider::DeclareUsedResourcesFromChild(
    int child,
    const ResourceIdArray& resources_from_child) {
  DCHECK(thread_checker_.CalledOnValidThread());

  Child& child_info = children_.find(child)->second;
  child_info.in_use_resources.clear();

  for (size_t i = 0; i < resources_from_child.size(); ++i) {
    ResourceIdMap::iterator it =
        child_info.child_to_parent_map.find(resources_from_child[i]);
    DCHECK(it != child_info.child_to_parent_map.end());

    ResourceId local_id = it->second;
    child_info.in_use_resources.insert(local_id);
  }

  ResourceIdArray unused;
  for (ResourceIdMap::iterator it = child_info.child_to_parent_map.begin();
       it != child_info.child_to_parent_map.end();
       ++it) {
    ResourceId local_id = it->second;
    bool resource_is_in_use = child_info.in_use_resources.count(local_id) > 0;
    if (!resource_is_in_use)
      unused.push_back(local_id);
  DeleteAndReturnUnusedResourcesToChild(&child_info, Normal, unused);
}

// static
bool ResourceProvider::CompareResourceMapIteratorsByChildId(
    const std::pair<ReturnedResource, ResourceMap::iterator>& a,
    const std::pair<ReturnedResource, ResourceMap::iterator>& b) {
  const ResourceMap::iterator& a_it = a.second;
  const ResourceMap::iterator& b_it = b.second;
  const Resource& a_resource = a_it->second;
  const Resource& b_resource = b_it->second;
  return a_resource.child_id < b_resource.child_id;

  int child_id = 0;
  Child* child_info = NULL;
  ResourceIdArray resources_for_child;

  std::vector<std::pair<ReturnedResource, ResourceMap::iterator> >
      sorted_resources;

    ResourceId local_id = it->id;
    ResourceMap::iterator map_iterator = resources_.find(local_id);

    // Resource was already lost (e.g. it belonged to a child that was
    // destroyed).
    if (map_iterator == resources_.end())
      continue;

    sorted_resources.push_back(
        std::pair<ReturnedResource, ResourceMap::iterator>(*it, map_iterator));
  }

  std::sort(sorted_resources.begin(),
            sorted_resources.end(),
            CompareResourceMapIteratorsByChildId);

  for (size_t i = 0; i < sorted_resources.size(); ++i) {
    ReturnedResource& returned = sorted_resources[i].first;
    ResourceMap::iterator& map_iterator = sorted_resources[i].second;
    ResourceId local_id = map_iterator->first;

    CHECK_GE(resource->exported_count, returned.count);
    resource->exported_count -= returned.count;

      if (returned.sync_point)
        GLC(context3d, context3d->waitSyncPoint(returned.sync_point));
          TextureMailbox(resource->mailbox.name(), returned.sync_point);

    if (!resource->marked_for_deletion)
      continue;

    if (!resource->child_id) {
      // The resource belongs to this ResourceProvider, so it can be destroyed.
      continue;
    }

    // Delete the resource and return it to the child it came from one.
    if (resource->child_id != child_id) {
      ChildMap::iterator child_it = children_.find(resource->child_id);
      DCHECK(child_it != children_.end());

      if (child_id) {
        DCHECK_NE(resources_for_child.size(), 0u);
        DeleteAndReturnUnusedResourcesToChild(
            child_info, Normal, resources_for_child);
        resources_for_child.clear();
      }

      child_info = &child_it->second;
      child_id = resource->child_id;
    }
    resources_for_child.push_back(local_id);
  }

  if (child_id) {
    DCHECK_NE(resources_for_child.size(), 0u);
    DeleteAndReturnUnusedResourcesToChild(
        child_info, Normal, resources_for_child);
void ResourceProvider::DeleteAndReturnUnusedResourcesToChild(
    Child* child_info,
    DeleteStyle style,
    const ResourceIdArray& unused) {
  DCHECK(thread_checker_.CalledOnValidThread());
  DCHECK(child_info);

  if (unused.empty())
    return;

  WebGraphicsContext3D* context3d = Context3d();
  if (!context3d || !context3d->makeContextCurrent()) {
    // TODO(skaslev): Implement this path for software compositing.
    return;
  }

  ReturnedResourceArray to_return;

  bool need_sync_point = false;
  for (size_t i = 0; i < unused.size(); ++i) {
    ResourceId local_id = unused[i];

    ResourceMap::iterator it = resources_.find(local_id);
    CHECK(it != resources_.end());
    Resource& resource = it->second;

    DCHECK(!resource.locked_for_write);
    DCHECK(!resource.lock_for_read_count);
    DCHECK_EQ(0u, child_info->in_use_resources.count(local_id));
    DCHECK(child_info->parent_to_child_map.count(local_id));

    ResourceId child_id = child_info->parent_to_child_map[local_id];
    DCHECK(child_info->child_to_parent_map.count(child_id));

    // TODO(danakj): bool is_lost = false;
    if (resource.exported_count > 0) {
      if (style != ForShutdown) {
        // Defer this until we receive the resource back from the parent.
        resource.marked_for_deletion = true;
        continue;
      }

      // We still have an exported_count, so we'll have to lose it.
      // TODO(danakj): is_lost = true;
    }

    if (resource.filter != resource.original_filter) {
      DCHECK(resource.target);
      DCHECK(resource.gl_id);

      GLC(context3d, context3d->bindTexture(resource.target, resource.gl_id));
      GLC(context3d,
          context3d->texParameteri(resource.target,
                                   GL_TEXTURE_MIN_FILTER,
                                   resource.original_filter));
      GLC(context3d,
          context3d->texParameteri(resource.target,
                                   GL_TEXTURE_MAG_FILTER,
                                   resource.original_filter));
    }

    ReturnedResource returned;
    returned.id = child_id;
    returned.sync_point = resource.mailbox.sync_point();
    if (!returned.sync_point)
      need_sync_point = true;
    returned.count = resource.imported_count;
    // TODO(danakj): Save the |is_lost| bit.
    to_return.push_back(returned);

    child_info->parent_to_child_map.erase(local_id);
    child_info->child_to_parent_map.erase(child_id);
    resource.imported_count = 0;
    DeleteResourceInternal(it, style);
  }
  if (need_sync_point) {
    unsigned int sync_point = context3d->insertSyncPoint();
    for (size_t i = 0; i < to_return.size(); ++i) {
      if (!to_return[i].sync_point)
        to_return[i].sync_point = sync_point;
    }
  }

  if (!to_return.empty())
    child_info->return_callback.Run(to_return);
}

#include <utility>
#include "cc/resources/return_callback.h"
  int CreateChild(const ReturnCallback& return_callback);
  // This adds the resources to the working set in the ResourceProvider without
  // declaring which resources are in use. Use DeclareUsedResourcesFromChild
  // after calling this method to do that. All calls to ReceiveFromChild should
  // be followed by a DeclareUsedResourcesFromChild.
  // Once a set of resources have been received, they may or may not be used.
  // This declares what set of resources are currently in use from the child,
  // releasing any other resources back to the child.
  void DeclareUsedResourcesFromChild(
      int child,
      const ResourceIdArray& resources_from_child);

    int child_id;

  static bool CompareResourceMapIteratorsByChildId(
      const std::pair<ReturnedResource, ResourceMap::iterator>& a,
      const std::pair<ReturnedResource, ResourceMap::iterator>& b);

    ReturnCallback return_callback;
    ResourceIdSet in_use_resources;
  void DeleteAndReturnUnusedResourcesToChild(Child* child_info,
                                             DeleteStyle style,
                                             const ResourceIdArray& unused);
  static void CollectResources(ReturnedResourceArray* array,
                               const ReturnedResourceArray& returned) {
    array->insert(array->end(), returned.begin(), returned.end());
  }

  static ReturnCallback GetReturnCallback(ReturnedResourceArray* array) {
    return base::Bind(&ResourceProviderTest::CollectResources, array);
  }

                                ResourceProvider::ResourceId id,
                                WGC3Denum filter) {
  ReturnedResourceArray returned_to_child;
  int child_id =
      resource_provider_->CreateChild(GetReturnCallback(&returned_to_child));
    resource_provider_->DeclareUsedResourcesFromChild(child_id,
                                                      resource_ids_to_transfer);
    EXPECT_EQ(0u, returned_to_child.size());

    // Transfer resources back from the parent to the child. Set no resources as
    // being in use.
    ResourceProvider::ResourceIdArray no_resources;
    resource_provider_->DeclareUsedResourcesFromChild(child_id, no_resources);

    ASSERT_EQ(2u, returned_to_child.size());
    EXPECT_NE(0u, returned_to_child[0].sync_point);
    EXPECT_NE(0u, returned_to_child[1].sync_point);
    child_resource_provider->ReceiveReturnsFromParent(returned_to_child);
    returned_to_child.clear();
    resource_provider_->DeclareUsedResourcesFromChild(child_id,
                                                      resource_ids_to_transfer);
  EXPECT_EQ(0u, returned_to_child.size());


  ASSERT_EQ(2u, returned_to_child.size());
  // TODO(danakj): Verify the resources are not marked as lost.
  EXPECT_NE(0u, returned_to_child[0].sync_point);
  EXPECT_NE(0u, returned_to_child[1].sync_point);
}

TEST_P(ResourceProviderTest, DeleteExportedResources) {
  // Resource transfer is only supported with GL textures for now.
  if (GetParam() != ResourceProvider::GLTexture)
    return;

  scoped_ptr<ResourceProviderContext> child_context_owned(
      ResourceProviderContext::Create(shared_data_.get()));

  FakeOutputSurfaceClient child_output_surface_client;
  scoped_ptr<OutputSurface> child_output_surface(FakeOutputSurface::Create3d(
      child_context_owned.PassAs<TestWebGraphicsContext3D>()));
  CHECK(child_output_surface->BindToClient(&child_output_surface_client));

  scoped_ptr<ResourceProvider> child_resource_provider(
      ResourceProvider::Create(child_output_surface.get(), 0, false));

  gfx::Size size(1, 1);
  ResourceFormat format = RGBA_8888;
  size_t pixel_size = TextureSize(size, format);
  ASSERT_EQ(4U, pixel_size);

  ResourceProvider::ResourceId id1 = child_resource_provider->CreateResource(
      size, GL_CLAMP_TO_EDGE, ResourceProvider::TextureUsageAny, format);
  uint8_t data1[4] = {1, 2, 3, 4};
  gfx::Rect rect(size);
  child_resource_provider->SetPixels(id1, data1, rect, rect, gfx::Vector2d());

  ResourceProvider::ResourceId id2 = child_resource_provider->CreateResource(
      size, GL_CLAMP_TO_EDGE, ResourceProvider::TextureUsageAny, format);
  uint8_t data2[4] = {5, 5, 5, 5};
  child_resource_provider->SetPixels(id2, data2, rect, rect, gfx::Vector2d());

  ReturnedResourceArray returned_to_child;
  int child_id =
      resource_provider_->CreateChild(GetReturnCallback(&returned_to_child));
  {
    // Transfer some resources to the parent.
    ResourceProvider::ResourceIdArray resource_ids_to_transfer;
    resource_ids_to_transfer.push_back(id1);
    resource_ids_to_transfer.push_back(id2);
    TransferableResourceArray list;
    child_resource_provider->PrepareSendToParent(resource_ids_to_transfer,
                                                 &list);
    ASSERT_EQ(2u, list.size());
    EXPECT_NE(0u, list[0].sync_point);
    EXPECT_NE(0u, list[1].sync_point);
    EXPECT_TRUE(child_resource_provider->InUseByConsumer(id1));
    EXPECT_TRUE(child_resource_provider->InUseByConsumer(id2));
    resource_provider_->ReceiveFromChild(child_id, list);
    resource_provider_->DeclareUsedResourcesFromChild(child_id,
                                                      resource_ids_to_transfer);
  }

  EXPECT_EQ(2u, resource_provider_->num_resources());
  ResourceProvider::ResourceIdMap resource_map =
      resource_provider_->GetChildToParentMap(child_id);
  ResourceProvider::ResourceId mapped_id1 = resource_map[id1];
  ResourceProvider::ResourceId mapped_id2 = resource_map[id2];
  EXPECT_NE(0u, mapped_id1);
  EXPECT_NE(0u, mapped_id2);
  EXPECT_FALSE(resource_provider_->InUseByConsumer(id1));
  EXPECT_FALSE(resource_provider_->InUseByConsumer(id2));

  {
    // The parent transfers the resources to the grandparent.
    ResourceProvider::ResourceIdArray resource_ids_to_transfer;
    resource_ids_to_transfer.push_back(mapped_id1);
    resource_ids_to_transfer.push_back(mapped_id2);
    TransferableResourceArray list;
    resource_provider_->PrepareSendToParent(resource_ids_to_transfer, &list);

    ASSERT_EQ(2u, list.size());
    EXPECT_NE(0u, list[0].sync_point);
    EXPECT_NE(0u, list[1].sync_point);
    EXPECT_TRUE(resource_provider_->InUseByConsumer(id1));
    EXPECT_TRUE(resource_provider_->InUseByConsumer(id2));

    // Release the resource in the parent. Set no resources as being in use. The
    // resources are exported so that can't be transferred back yet.
    ResourceProvider::ResourceIdArray no_resources;
    resource_provider_->DeclareUsedResourcesFromChild(child_id, no_resources);

    EXPECT_EQ(0u, returned_to_child.size());
    EXPECT_EQ(2u, resource_provider_->num_resources());

    // Return the resources from the grandparent to the parent. They should be
    // returned to the child then.
    EXPECT_EQ(2u, list.size());
    EXPECT_EQ(mapped_id1, list[0].id);
    EXPECT_EQ(mapped_id2, list[1].id);
    ReturnedResourceArray returned;
    TransferableResource::ReturnResources(list, &returned);
    resource_provider_->ReceiveReturnsFromParent(returned);

    EXPECT_EQ(0u, resource_provider_->num_resources());
    ASSERT_EQ(2u, returned_to_child.size());
    // TODO(danakj): Verify the resources are not marked as lost.
    EXPECT_NE(0u, returned_to_child[0].sync_point);
    EXPECT_NE(0u, returned_to_child[1].sync_point);
  }
}

TEST_P(ResourceProviderTest, DestroyChildWithExportedResources) {
  // Resource transfer is only supported with GL textures for now.
  if (GetParam() != ResourceProvider::GLTexture)
    return;

  scoped_ptr<ResourceProviderContext> child_context_owned(
      ResourceProviderContext::Create(shared_data_.get()));

  FakeOutputSurfaceClient child_output_surface_client;
  scoped_ptr<OutputSurface> child_output_surface(FakeOutputSurface::Create3d(
      child_context_owned.PassAs<TestWebGraphicsContext3D>()));
  CHECK(child_output_surface->BindToClient(&child_output_surface_client));

  scoped_ptr<ResourceProvider> child_resource_provider(
      ResourceProvider::Create(child_output_surface.get(), 0, false));

  gfx::Size size(1, 1);
  ResourceFormat format = RGBA_8888;
  size_t pixel_size = TextureSize(size, format);
  ASSERT_EQ(4U, pixel_size);

  ResourceProvider::ResourceId id1 = child_resource_provider->CreateResource(
      size, GL_CLAMP_TO_EDGE, ResourceProvider::TextureUsageAny, format);
  uint8_t data1[4] = {1, 2, 3, 4};
  gfx::Rect rect(size);
  child_resource_provider->SetPixels(id1, data1, rect, rect, gfx::Vector2d());

  ResourceProvider::ResourceId id2 = child_resource_provider->CreateResource(
      size, GL_CLAMP_TO_EDGE, ResourceProvider::TextureUsageAny, format);
  uint8_t data2[4] = {5, 5, 5, 5};
  child_resource_provider->SetPixels(id2, data2, rect, rect, gfx::Vector2d());

  ReturnedResourceArray returned_to_child;
  int child_id =
      resource_provider_->CreateChild(GetReturnCallback(&returned_to_child));
  {
    // Transfer some resources to the parent.
    ResourceProvider::ResourceIdArray resource_ids_to_transfer;
    resource_ids_to_transfer.push_back(id1);
    resource_ids_to_transfer.push_back(id2);
    TransferableResourceArray list;
    child_resource_provider->PrepareSendToParent(resource_ids_to_transfer,
                                                 &list);
    ASSERT_EQ(2u, list.size());
    EXPECT_NE(0u, list[0].sync_point);
    EXPECT_NE(0u, list[1].sync_point);
    EXPECT_TRUE(child_resource_provider->InUseByConsumer(id1));
    EXPECT_TRUE(child_resource_provider->InUseByConsumer(id2));
    resource_provider_->ReceiveFromChild(child_id, list);
    resource_provider_->DeclareUsedResourcesFromChild(child_id,
                                                      resource_ids_to_transfer);
  }

  EXPECT_EQ(2u, resource_provider_->num_resources());
  ResourceProvider::ResourceIdMap resource_map =
      resource_provider_->GetChildToParentMap(child_id);
  ResourceProvider::ResourceId mapped_id1 = resource_map[id1];
  ResourceProvider::ResourceId mapped_id2 = resource_map[id2];
  EXPECT_NE(0u, mapped_id1);
  EXPECT_NE(0u, mapped_id2);
  EXPECT_FALSE(resource_provider_->InUseByConsumer(id1));
  EXPECT_FALSE(resource_provider_->InUseByConsumer(id2));

  {
    // The parent transfers the resources to the grandparent.
    ResourceProvider::ResourceIdArray resource_ids_to_transfer;
    resource_ids_to_transfer.push_back(mapped_id1);
    resource_ids_to_transfer.push_back(mapped_id2);
    TransferableResourceArray list;
    resource_provider_->PrepareSendToParent(resource_ids_to_transfer, &list);

    ASSERT_EQ(2u, list.size());
    EXPECT_NE(0u, list[0].sync_point);
    EXPECT_NE(0u, list[1].sync_point);
    EXPECT_TRUE(resource_provider_->InUseByConsumer(id1));
    EXPECT_TRUE(resource_provider_->InUseByConsumer(id2));

    // Release the resource in the parent. Set no resources as being in use. The
    // resources are exported so that can't be transferred back yet.
    ResourceProvider::ResourceIdArray no_resources;
    resource_provider_->DeclareUsedResourcesFromChild(child_id, no_resources);

    // Destroy the child, the resources should be returned immediately from the
    // parent and marked as lost.
    EXPECT_EQ(0u, returned_to_child.size());
    EXPECT_EQ(2u, resource_provider_->num_resources());

    resource_provider_->DestroyChild(child_id);

    EXPECT_EQ(0u, resource_provider_->num_resources());
    ASSERT_EQ(2u, returned_to_child.size());
    // TODO(danakj): Verify the resources are marked as lost.
    EXPECT_NE(0u, returned_to_child[0].sync_point);
    EXPECT_NE(0u, returned_to_child[1].sync_point);
    returned_to_child.clear();

    // Return the resources from the grandparent to the parent. They should be
    // dropped on the floor since they were already returned to the child.
    EXPECT_EQ(2u, list.size());
    EXPECT_EQ(mapped_id1, list[0].id);
    EXPECT_EQ(mapped_id2, list[1].id);
    ReturnedResourceArray returned;
    TransferableResource::ReturnResources(list, &returned);
    resource_provider_->ReceiveReturnsFromParent(returned);

    EXPECT_EQ(0u, returned_to_child.size());
  }
  ReturnedResourceArray returned_to_child;
  int child_id =
      resource_provider_->CreateChild(GetReturnCallback(&returned_to_child));
    resource_provider_->DeclareUsedResourcesFromChild(child_id,
                                                      resource_ids_to_transfer);
    EXPECT_EQ(0u, returned_to_child.size());

    // Transfer resources back from the parent to the child. Set no resources as
    // being in use.
    ResourceProvider::ResourceIdArray no_resources;
    resource_provider_->DeclareUsedResourcesFromChild(child_id, no_resources);

    ASSERT_EQ(1u, returned_to_child.size());
    EXPECT_NE(0u, returned_to_child[0].sync_point);
    child_resource_provider->ReceiveReturnsFromParent(returned_to_child);
    ReturnedResourceArray returned_to_child;
    int child_id = parent_resource_provider->CreateChild(
        GetReturnCallback(&returned_to_child));

      parent_resource_provider->DeclareUsedResourcesFromChild(
          child_id, resource_ids_to_transfer);
      Mock::VerifyAndClearExpectations(parent_context);
      EXPECT_EQ(0u, returned_to_child.size());
      // Transfer resources back from the parent to the child. Set no resources
      // as being in use.
      ResourceProvider::ResourceIdArray no_resources;
      parent_resource_provider->DeclareUsedResourcesFromChild(child_id,
                                                              no_resources);
      Mock::VerifyAndClearExpectations(parent_context);
      ASSERT_EQ(1u, returned_to_child.size());
      child_resource_provider->ReceiveReturnsFromParent(returned_to_child);
// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CC_RESOURCES_RETURN_CALLBACK_H_
#define CC_RESOURCES_RETURN_CALLBACK_H_

#include "base/callback.h"
#include "cc/resources/returned_resource.h"

namespace cc {

typedef base::Callback<void(const ReturnedResourceArray&)> ReturnCallback;

}  // namespace cc

#endif  // CC_RESOURCES_RETURN_CALLBACK_H_
ResourceProvider::ResourceIdSet FakeDelegatedRendererLayerImpl::Resources()
    const {
  ResourceProvider::ResourceIdSet set;
  ResourceProvider::ResourceIdArray array;
  array = ResourcesForTesting();
  for (size_t i = 0; i < array.size(); ++i)
    set.insert(array[i]);
  return set;
}

void NoopReturnCallback(const ReturnedResourceArray& returned) {}

  CreateChildIdIfNeeded(base::Bind(&NoopReturnCallback));
  ResourceProvider::ResourceIdSet Resources() const;
  base::SingleThreadTaskRunner* MainThreadTaskRunner() {
    return main_task_runner_.get();
  }
#include "base/location.h"
    EXPECT_EQ(1u, delegated_impl->Resources().count(999));
    EXPECT_EQ(1u, delegated_impl->Resources().count(555));
        AddTransferableResource(frame.get(), 999);
      case 3:
      case 4:
      case 5:
        // 444 and 999 are no longer in use. We sent two refs to 999, so we
        // should get two back.
          unsigned expected[] = {444, 999, 999};
        AddTransferableResource(frame.get(), 999);
        AddTransferableResource(frame.get(), 555);
        AddTransferableResource(frame.get(), 444);
      case 3:
        // The 999 resource is the only unused one. Two references were sent, so
        // two should be returned.
          unsigned expected[] = {999, 999};
        AddTransferableResource(frame.get(), 999);
      case 3:
        // The child compositor sends a frame referring to resources not in the
        // frame.
    if (host_impl->active_tree()->source_frame_number() != 3)
    EXPECT_EQ(1u, delegated_impl->Resources().count(999));
      case 3:
      case 4:
    if (host_impl->active_tree()->source_frame_number() != 3)
    EXPECT_EQ(1u, delegated_impl->Resources().count(999));
    EXPECT_EQ(1u, delegated_impl->Resources().count(555));
    EXPECT_EQ(1u, delegated_impl->Resources().count(444));
      case 3:
      case 4:
        EXPECT_EQ(1u, delegated_impl->Resources().count(999));
        EXPECT_EQ(1u, delegated_impl->Resources().count(555));
      case 2: {
        EXPECT_EQ(1u, delegated_impl->Resources().count(999));
        EXPECT_EQ(1u, delegated_impl->Resources().count(555));
      case 3: {
        EXPECT_EQ(1u, delegated_impl->Resources().count(999));
    EXPECT_EQ(1u, delegated_impl->Resources().count(555));
  virtual void DidCommitAndDrawFrame() OVERRIDE {
    EXPECT_EQ(1u, delegated_impl->Resources().count(555));
        AddTransferableResource(frame.get(), 555);
        ImplThreadTaskRunner()->PostTask(FROM_HERE,
                                         receive_resource_on_thread_);
    }
  }
  void ReceiveResourceOnThread(LayerTreeHostImpl* host_impl) {
    LayerImpl* root_impl = host_impl->active_tree()->root_layer();
    FakeDelegatedRendererLayerImpl* delegated_impl =
        static_cast<FakeDelegatedRendererLayerImpl*>(root_impl->children()[0]);

    const ResourceProvider::ResourceIdMap& map =
        host_impl->resource_provider()->GetChildToParentMap(
            delegated_impl->ChildId());

    // Receive 999 back from the grandparent.
    CompositorFrameAck ack;
    output_surface()->ReturnResource(map.find(999)->second, &ack);
    host_impl->ReclaimResources(&ack);
    host_impl->OnSwapBuffersComplete();

    // And then it should be released by the DelegatedRendererLayer.
    MainThreadTaskRunner()->PostTask(
        FROM_HERE,
        base::Bind(&LayerTreeHostDelegatedTestResourceSentToParent::
                        DidReceiveResourceOnMainThread,
                   base::Unretained(this)));
  }

  void DidReceiveResourceOnMainThread() {
    ReturnedResourceArray resources;

    // 999 was returned from the grandparent and could be released.
    delegated_->TakeUnusedResourcesForChildCompositor(&resources);
    {
      unsigned expected[] = {999};
      EXPECT_RESOURCES(expected, resources);

    EndTest();
        EXPECT_EQ(1u, delegated_impl->Resources().count(999));
        EXPECT_EQ(1u, delegated_impl->Resources().count(555));
        EXPECT_EQ(1u, delegated_impl->Resources().count(555));
        receive_resource_on_thread_ =
            base::Bind(&LayerTreeHostDelegatedTestResourceSentToParent::
                            ReceiveResourceOnThread,
                       base::Unretained(this),
                       host_impl);
  base::Closure receive_resource_on_thread_;
        EXPECT_EQ(1u, delegated_impl->Resources().count(999));
        EXPECT_EQ(1u, delegated_impl->Resources().count(555));
        EXPECT_EQ(1u, delegated_impl->Resources().count(444));
        EXPECT_EQ(1u, delegated_impl->Resources().count(555));
        EXPECT_EQ(1u, delegated_impl->Resources().count(999));
        EXPECT_EQ(1u, delegated_impl->Resources().count(555));
    DebugScopedSetMainThreadBlocked main_thread_blocked(this);
    DebugScopedSetMainThreadBlocked main_thread_blocked(this);
    DebugScopedSetMainThreadBlocked main_thread_blocked(this);
    {
      DebugScopedSetMainThreadBlocked main_thread_blocked(this);
      DebugScopedSetImplThread impl(this);

      // This CapturePostTasks should be destroyed before
      // DidCommitAndDrawFrame() is called since that goes out to the embedder,
      // and we want the embedder to receive its callbacks before that.
      // NOTE: This maintains consistent ordering with the ThreadProxy since
      // the DidCommitAndDrawFrame() must be post-tasked from the impl thread
      // there as the main thread is not blocked, so any posted tasks inside
      // the swap buffers will execute first.
      BlockingTaskRunner::CapturePostTasks blocked;

      layer_tree_host_impl_->SwapBuffers(frame);
    }
#include "net/base/net_util.h"
  // Grant navigation to a file but not the file:// scheme in general.
  void GrantRequestOfSpecificFile(const FilePath &file) {
    request_file_set_.insert(file.StripTrailingSeparators());
  }

    FilePath stripped = file.StripTrailingSeparators();
    file_permissions_.erase(stripped);
    request_file_set_.erase(stripped);
  // Determine whether permission has been granted to request |url|.
    // Having permission to a scheme implies permssion to all of its URLs.
    if (judgment != scheme_policy_.end())
      return judgment->second;

    // file:// URLs are more granular.  The child may have been given
    // permission to a specific file but not the file:// scheme in general.
    if (url.SchemeIs(chrome::kFileScheme)) {
      FilePath path;
      if (net::FileURLToFilePath(url, &path))
        return request_file_set_.find(path) != request_file_set_.end();
    }
    return false;  // Unmentioned schemes are disallowed.
  typedef std::set<FilePath> FileSet;
  // The set of files the child process is permitted to load.
  FileSet request_file_set_;

    // When the child process has been commanded to request this scheme,
    // we grant it the capability to request all URLs of that scheme.
void ChildProcessSecurityPolicyImpl::GrantRequestSpecificFileURL(
    int child_id,
    const GURL& url) {
  if (!url.SchemeIs(chrome::kFileScheme))
    return;

  {
    base::AutoLock lock(lock_);
    SecurityStateMap::iterator state = security_state_.find(child_id);
    if (state == security_state_.end())
      return;

    // When the child process has been commanded to request a file:// URL,
    // then we grant it the capability for that URL only.
    FilePath path;
    if (net::FileURLToFilePath(url, &path))
        state->second->GrantRequestOfSpecificFile(path);
  }
}

  // request the URL, along with permission to request all URLs of the same
  // scheme.
  // Whenever the browser process drops a file icon on a tab, it should call
  // this method to grant the child process the capability to request this one
  // file:// URL, but not all urls of the file:// scheme.
  void GrantRequestSpecificFileURL(int child_id, const GURL& url);

TEST_F(ChildProcessSecurityPolicyTest, SpecificFile) {
  ChildProcessSecurityPolicyImpl* p =
      ChildProcessSecurityPolicyImpl::GetInstance();

  p->Add(kRendererID);

  GURL icon_url("file:///tmp/foo.png");
  GURL sensitive_url("file:///etc/passwd");
  EXPECT_FALSE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_FALSE(p->CanRequestURL(kRendererID, sensitive_url));

  p->GrantRequestSpecificFileURL(kRendererID, icon_url);
  EXPECT_TRUE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_FALSE(p->CanRequestURL(kRendererID, sensitive_url));

  p->GrantRequestURL(kRendererID, icon_url);
  EXPECT_TRUE(p->CanRequestURL(kRendererID, icon_url));
  EXPECT_TRUE(p->CanRequestURL(kRendererID, sensitive_url));

  p->Remove(kRendererID);
}

    // A dragged file may wind up as the value of an input element, or it
    // may be used as the target of a navigation instead.  We don't know
    // which will happen at this point, so generously grant both access
    // and request permissions to the specific file to cover both cases.
    // We do not give it the permission to request all file:// URLs.
    policy->GrantRequestSpecificFileURL(renderer_id,
                                        net::FilePathToFileURL(path));
#include "base/utf_string_conversions.h"
  FilePath highlighted_file_path(FILE_PATH_LITERAL("/tmp/foo.html"));
  FilePath dragged_file_path(FILE_PATH_LITERAL("/tmp/image.jpg"));
  FilePath sensitive_file_path(FILE_PATH_LITERAL("/etc/passwd"));
  GURL highlighted_file_url = net::FilePathToFileURL(highlighted_file_path);
  GURL dragged_file_url = net::FilePathToFileURL(dragged_file_path);
  GURL sensitive_file_url = net::FilePathToFileURL(sensitive_file_path);
  dropped_data.url = highlighted_file_url;
  dropped_data.filenames.push_back(WebDropData::FileInfo(
      UTF8ToUTF16(dragged_file_path.AsUTF8Unsafe()), string16()));

                              WebKit::WebDragOperationNone, 0);

  int id = process()->GetID();
  ChildProcessSecurityPolicyImpl* policy =
      ChildProcessSecurityPolicyImpl::GetInstance();

  EXPECT_FALSE(policy->CanRequestURL(id, highlighted_file_url));
  EXPECT_FALSE(policy->CanReadFile(id, highlighted_file_path));
  EXPECT_TRUE(policy->CanRequestURL(id, dragged_file_url));
  EXPECT_TRUE(policy->CanReadFile(id, dragged_file_path));
  EXPECT_FALSE(policy->CanRequestURL(id, sensitive_file_url));
  EXPECT_FALSE(policy->CanReadFile(id, sensitive_file_path));
  // Use the frame's original request's URL rather than the document's URL for
  // subsequent checks.  For a popup, the document's URL may become the opener
  // window's URL if the opener has called document.write().
  // See http://crbug.com/93517.
  GURL old_url(frame->dataSource()->request().url());

    // Lastly, access to file:// URLs from non-file:// URL pages must be
    // handled by the browser so that ordinary renderer processes don't get
    // blessed with file permissions.
    int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
    bool is_initial_navigation = page_id_ == -1;
    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      // Fork non-file to file opens.  Check the opener URL if this is the
      // initial navigation in a newly opened window.
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "DOMWindow.h"

#include "V8Binding.h"
#include "V8CustomBinding.h"
#include "V8CustomEventListener.h"
#include "V8Proxy.h"

#include "DOMTimer.h"
#include "Frame.h"
#include "FrameLoadRequest.h"
#include "FrameView.h"
#include "Page.h"
#include "PlatformScreen.h"
#include "ScriptSourceCode.h"
#include "Settings.h"
#include "WindowFeatures.h"


// Horizontal and vertical offset, from the parent content area, around newly
// opened popups that don't specify a location.
static const int popupTilePixels = 10;

namespace WebCore {

ACCESSOR_SETTER(DOMWindowLocation)
{
    v8::Handle<v8::Object> holder = V8Proxy::LookupDOMWrapper(V8ClassIndex::DOMWINDOW, info.This());
    if (holder.IsEmpty())
        return;

    DOMWindow* imp = V8Proxy::ToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, holder);
    WindowSetLocation(imp, toWebCoreString(value));
}


ACCESSOR_SETTER(DOMWindowOpener)
{
    DOMWindow* imp = V8Proxy::ToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, info.Holder());

    if (!V8Proxy::CanAccessFrame(imp->frame(), true))
        return;
  
    // Opener can be shadowed if it is in the same domain.
    // Have a special handling of null value to behave
    // like Firefox. See bug http://b/1224887 & http://b/791706.
    if (value->IsNull()) {
        // imp->frame() cannot be null,
        // otherwise, SameOrigin check would have failed.
        ASSERT(imp->frame());
        imp->frame()->loader()->setOpener(0);
    }

    // Delete the accessor from this object.
    info.Holder()->Delete(name);

    // Put property on the front (this) object.
    info.This()->Set(name, value);
}

CALLBACK_FUNC_DECL(DOMWindowAddEventListener)
{
    INC_STATS("DOM.DOMWindow.addEventListener()");
    DOMWindow* imp = V8Proxy::ToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, args.Holder());

    if (!V8Proxy::CanAccessFrame(imp->frame(), true))
        return v8::Undefined();

    if (!imp->frame())
        return v8::Undefined();  // DOMWindow could be disconnected from the frame
  
    Document* doc = imp->frame()->document();
    if (!doc)
        return v8::Undefined();

    // TODO: Check if there is not enough arguments
    V8Proxy* proxy = V8Proxy::retrieve(imp->frame());
    if (!proxy)
        return v8::Undefined();

    RefPtr<EventListener> listener = proxy->FindOrCreateV8EventListener(args[1], false);

    if (listener) {
        String eventType = toWebCoreString(args[0]);
        bool useCapture = args[2]->BooleanValue();
        doc->addWindowEventListener(eventType, listener, useCapture);
    }

    return v8::Undefined();
}


CALLBACK_FUNC_DECL(DOMWindowRemoveEventListener)
{
    INC_STATS("DOM.DOMWindow.removeEventListener()");
    DOMWindow* imp = V8Proxy::ToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, args.Holder());

    if (!V8Proxy::CanAccessFrame(imp->frame(), true))
        return v8::Undefined();

    if (!imp->frame())
        return v8::Undefined();

    Document* doc = imp->frame()->document();
    if (!doc)
        return v8::Undefined();

    V8Proxy* proxy = V8Proxy::retrieve(imp->frame());
    if (!proxy)
        return v8::Undefined();

    RefPtr<EventListener> listener = proxy->FindV8EventListener(args[1], false);

    if (listener) {
        String eventType = toWebCoreString(args[0]);
        bool useCapture = args[2]->BooleanValue();
        doc->removeWindowEventListener(eventType, listener.get(), useCapture);
    }

    return v8::Undefined();
}

CALLBACK_FUNC_DECL(DOMWindowPostMessage)
{
    INC_STATS("DOM.DOMWindow.postMessage()");
    DOMWindow* window = V8Proxy::ToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, args.Holder());

    DOMWindow* source = V8Proxy::retrieveActiveFrame()->domWindow();
    ASSERT(source->frame());

    String uri = source->frame()->loader()->url().string();

    v8::TryCatch tryCatch;

    String message = toWebCoreString(args[0]);
    MessagePort* port = 0;
    String domain;

    // This function has variable arguments and can either be:
    //   postMessage(message, port, domain);
    // or
    //   postMessage(message, domain);
    if (args.Length() > 2) {
        if (V8Proxy::IsWrapperOfType(args[1], V8ClassIndex::MESSAGEPORT))
            port = V8Proxy::ToNativeObject<MessagePort>(V8ClassIndex::MESSAGEPORT, args[1]);
        domain = valueToStringWithNullOrUndefinedCheck(args[2]);
    } else
        domain = valueToStringWithNullOrUndefinedCheck(args[1]);

    if (tryCatch.HasCaught())
        return v8::Undefined();

    ExceptionCode ec = 0;
    window->postMessage(message, port, domain, source, ec);
    if (ec)
        V8Proxy::SetDOMException(ec);

    return v8::Undefined();
}


static bool canShowModalDialogNow(const Frame* frame)
{
    // A frame can out live its page. See bug 1219613.
    if (!frame || !frame->page())
        return false;
    return frame->page()->chrome()->canRunModalNow();
}

static bool allowPopUp()
{
    Frame* frame = V8Proxy::retrieveActiveFrame();

    ASSERT(frame);
    if (frame->script()->processingUserGesture())
        return true;
    Settings* settings = frame->settings();
    return settings && settings->JavaScriptCanOpenWindowsAutomatically();
}

static HashMap<String, String> parseModalDialogFeatures(const String& featuresArg)
{
    HashMap<String, String> map;

    Vector<String> features;
    featuresArg.split(';', features);
    Vector<String>::const_iterator end = features.end();
    for (Vector<String>::const_iterator it = features.begin(); it != end; ++it) {
        String featureString = *it;
        int pos = featureString.find('=');
        int colonPos = featureString.find(':');
        if (pos >= 0 && colonPos >= 0)
            continue;  // ignore any strings that have both = and :
        if (pos < 0)
            pos = colonPos;
        if (pos < 0) {
            // null string for value means key without value
            map.set(featureString.stripWhiteSpace().lower(), String());
        } else {
            String key = featureString.left(pos).stripWhiteSpace().lower();
            String val = featureString.substring(pos + 1).stripWhiteSpace().lower();
            int spacePos = val.find(' ');
            if (spacePos != -1)
                val = val.left(spacePos);
            map.set(key, val);
        }
    }

    return map;
}


static Frame* createWindow(Frame* openerFrame,
                           const String& url,
                           const String& frameName,
                           const WindowFeatures& windowFeatures,
                           v8::Local<v8::Value> dialogArgs)
{
    Frame* activeFrame = V8Proxy::retrieveActiveFrame();

    ResourceRequest request;
    if (activeFrame)
        request.setHTTPReferrer(activeFrame->loader()->outgoingReferrer());
    FrameLoadRequest frameRequest(request, frameName);

    // FIXME: It's much better for client API if a new window starts with a URL,
    // here where we know what URL we are going to open. Unfortunately, this
    // code passes the empty string for the URL, but there's a reason for that.
    // Before loading we have to set up the opener, openedByDOM,
    // and dialogArguments values. Also, to decide whether to use the URL
    // we currently do an allowsAccessFrom call using the window we create,
    // which can't be done before creating it. We'd have to resolve all those
    // issues to pass the URL instead of "".

    bool created;
    // We pass in the opener frame here so it can be used for looking up the
    // frame name, in case the active frame is different from the opener frame,
    // and the name references a frame relative to the opener frame, for example
    // "_self" or "_parent".
    Frame* newFrame = activeFrame->loader()->createWindow(openerFrame->loader(), frameRequest, windowFeatures, created);
    if (!newFrame)
        return 0;

    newFrame->loader()->setOpener(openerFrame);
    newFrame->loader()->setOpenedByDOM();

    // Set dialog arguments on the global object of the new frame.
    if (!dialogArgs.IsEmpty()) {
        v8::Local<v8::Context> context = V8Proxy::GetContext(newFrame);
        if (!context.IsEmpty()) {
            v8::Context::Scope scope(context);
            context->Global()->Set(v8::String::New("dialogArguments"), dialogArgs);
        }
    }

    if (!parseURL(url).startsWith("javascript:", false)
        || ScriptController::isSafeScript(newFrame)) {
        KURL completedUrl =
            url.isEmpty() ? KURL("") : activeFrame->document()->completeURL(url);
        bool userGesture = activeFrame->script()->processingUserGesture();

        if (created)
            newFrame->loader()->changeLocation(completedUrl, activeFrame->loader()->outgoingReferrer(), false, false, userGesture);
        else if (!url.isEmpty())
            newFrame->loader()->scheduleLocationChange(completedUrl.string(), activeFrame->loader()->outgoingReferrer(), false, userGesture);
    }

    return newFrame;
}



CALLBACK_FUNC_DECL(DOMWindowShowModalDialog)
{
    INC_STATS("DOM.DOMWindow.showModalDialog()");
    DOMWindow* window = V8Proxy::ToNativeObject<DOMWindow>(
        V8ClassIndex::DOMWINDOW, args.Holder());
    Frame* frame = window->frame();

    if (!frame || !V8Proxy::CanAccessFrame(frame, true)) 
        return v8::Undefined();

    if (!canShowModalDialogNow(frame) || !allowPopUp())
        return v8::Undefined();

    String url = valueToStringWithNullOrUndefinedCheck(args[0]);
    v8::Local<v8::Value> dialogArgs = args[1];
    String featureArgs = valueToStringWithNullOrUndefinedCheck(args[2]);

    const HashMap<String, String> features = parseModalDialogFeatures(featureArgs);

    const bool trusted = false;

    FloatRect screenRect = screenAvailableRect(frame->view());

    WindowFeatures features;
    // default here came from frame size of dialog in MacIE.
    features.width = WindowFeatures::floatFeature(features, "dialogwidth", 100, screenRect.width(), 620);
    features.widthSet = true;
    // default here came from frame size of dialog in MacIE.
    features.height = WindowFeatures::floatFeature(features, "dialogheight", 100, screenRect.height(), 450);
    features.heightSet = true;
  
    features.x = WindowFeatures::floatFeature(features, "dialogleft", screenRect.x(), screenRect.right() - features.width, -1);
    features.xSet = features.x > 0;
    features.y = WindowFeatures::floatFeature(features, "dialogtop", screenRect.y(), screenRect.bottom() - features.height, -1);
    features.ySet = features.y > 0;

    if (WindowFeatures::boolFeature(features, "center", true)) {
        if (!features.xSet) {
            features.x = screenRect.x() + (screenRect.width() - features.width) / 2;
            features.xSet = true;
        }
        if (!features.ySet) {
            features.y = screenRect.y() + (screenRect.height() - features.height) / 2;
            features.ySet = true;
        }
    }

    features.dialog = true;
    features.resizable = WindowFeatures::boolFeature(features, "resizable");
    features.scrollbarsVisible = WindowFeatures::boolFeature(features, "scroll", true);
    features.statusBarVisible = WindowFeatures::boolFeature(features, "status", !trusted);
    features.menuBarVisible = false;
    features.toolBarVisible = false;
    features.locationBarVisible = false;
    features.fullscreen = false;

    Frame* dialogFrame = createWindow(frame, url, "", features, dialogArgs);
    if (!dialogFrame)
        return v8::Undefined();

    // Hold on to the context of the dialog window long enough to retrieve the
    // value of the return value property.
    v8::Local<v8::Context> context = V8Proxy::GetContext(dialogFrame);

    // Run the dialog.
    dialogFrame->page()->chrome()->runModal();

    // Extract the return value property from the dialog window.
    v8::Local<v8::Value> returnValue;
    if (!context.IsEmpty()) {
        v8::Context::Scope scope(context);
        returnValue = context->Global()->Get(v8::String::New("returnValue"));
    }

    if (!returnValue.IsEmpty())
        return returnValue;

    return v8::Undefined();
}


CALLBACK_FUNC_DECL(DOMWindowOpen)
{
    INC_STATS("DOM.DOMWindow.open()");
    DOMWindow* parent = V8Proxy::ToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, args.Holder());
    Frame* frame = parent->frame();

    if (!V8Proxy::CanAccessFrame(frame, true))
      return v8::Undefined();

    Frame* activeFrame = V8Proxy::retrieveActiveFrame();
    if (!activeFrame)
      return v8::Undefined();

    Page* page = frame->page();
    if (!page)
      return v8::Undefined();

    String urlString = valueToStringWithNullOrUndefinedCheck(args[0]);
    AtomicString frameName = (args[1]->IsUndefined() || args[1]->IsNull()) ? "_blank" : AtomicString(toWebCoreString(args[1]));

    // Because FrameTree::find() returns true for empty strings, we must check
    // for empty framenames. Otherwise, illegitimate window.open() calls with
    // no name will pass right through the popup blocker.
    if (!allowPopUp() &&
        (frameName.isEmpty() || !frame->tree()->find(frameName))) {
        return v8::Undefined();
    }

    // Get the target frame for the special cases of _top and _parent.  In those
    // cases, we can schedule a location change right now and return early.
    bool topOrParent = false;
    if (frameName == "_top") {
        frame = frame->tree()->top();
        topOrParent = true;
    } else if (frameName == "_parent") {
        if (Frame* parent = frame->tree()->parent())
            frame = parent;
        topOrParent = true;
    }
    if (topOrParent) {
        if (!activeFrame->loader()->shouldAllowNavigation(frame))
            return v8::Undefined();
    
        String completedUrl;
        if (!urlString.isEmpty())
            completedUrl = activeFrame->document()->completeURL(urlString);
    
        if (!completedUrl.isEmpty() &&
            (!parseURL(urlString).startsWith("javascript:", false)
             || ScriptController::isSafeScript(frame))) {
            bool userGesture = activeFrame->script()->processingUserGesture();
            frame->loader()->scheduleLocationChange(completedUrl, activeFrame->loader()->outgoingReferrer(), false, userGesture);
        }
        return V8Proxy::ToV8Object(V8ClassIndex::DOMWINDOW, frame->domWindow());
    }

    // In the case of a named frame or a new window, we'll use the
    // createWindow() helper.

    // Parse the values, and then work with a copy of the parsed values
    // so we can restore the values we may not want to overwrite after
    // we do the multiple monitor fixes.
    WindowFeatures rawFeatures(valueToStringWithNullOrUndefinedCheck(args[2]));
    WindowFeatures windowFeatures(rawFeatures);
    FloatRect screenRect = screenAvailableRect(page->mainFrame()->view());

    // Set default size and location near parent window if none were specified.
    // These may be further modified by adjustWindowRect, below.
    if (!windowFeatures.xSet) {
        windowFeatures.x = parent->screenX() - screenRect.x() + popupTilePixels;
        windowFeatures.xSet = true;
    }
    if (!windowFeatures.ySet) {
        windowFeatures.y = parent->screenY() - screenRect.y() + popupTilePixels;
        windowFeatures.ySet = true;
    }
    if (!windowFeatures.widthSet) {
        windowFeatures.width = parent->innerWidth();
        windowFeatures.widthSet = true;
    }
    if (!windowFeatures.heightSet) {
        windowFeatures.height = parent->innerHeight();
        windowFeatures.heightSet = true;
    }

    FloatRect windowRect(windowFeatures.x, windowFeatures.y, windowFeatures.width, windowFeatures.height);

    // The new window's location is relative to its current screen, so shift
    // it in case it's on a secondary monitor. See http://b/viewIssue?id=967905.
    windowRect.move(screenRect.x(), screenRect.y());
    WebCore::DOMWindow::adjustWindowRect(screenRect, windowRect, windowRect);

    windowFeatures.x = windowRect.x();
    windowFeatures.y = windowRect.y();
    windowFeatures.height = windowRect.height();
    windowFeatures.width = windowRect.width();

    // If either of the origin coordinates weren't set in the original
    // string, make sure they aren't set now.
    if (!rawFeatures.xSet) {
        windowFeatures.x = 0;
        windowFeatures.xSet = false;
    }
    if (!rawFeatures.ySet) {
        windowFeatures.y = 0;
        windowFeatures.ySet = false;
    }

    frame = createWindow(frame, urlString, frameName, windowFeatures, v8::Local<v8::Value>());

    if (!frame)
        return v8::Undefined();

    return V8Proxy::ToV8Object(V8ClassIndex::DOMWINDOW, frame->domWindow());
}


INDEXED_PROPERTY_GETTER(DOMWindow)
{
    INC_STATS("DOM.DOMWindow.IndexedPropertyGetter");
    v8::Handle<v8::Object> holder = V8Proxy::LookupDOMWrapper(V8ClassIndex::DOMWINDOW, info.This());
    if (holder.IsEmpty())
        return notHandledByInterceptor();

    DOMWindow* window = V8Proxy::ToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, holder);
    if (!window)
        return notHandledByInterceptor();

    Frame* frame = window->frame();
    if (!frame)
        return notHandledByInterceptor();

    Frame* child = frame->tree()->child(index);
    if (child)
        return V8Proxy::ToV8Object(V8ClassIndex::DOMWINDOW, child->domWindow());

    return notHandledByInterceptor();
}


NAMED_PROPERTY_GETTER(DOMWindow)
{
    INC_STATS("DOM.DOMWindow.NamedPropertyGetter");
    // The key must be a string.
    if (!name->IsString())
        return notHandledByInterceptor();

    v8::Handle<v8::Object> holder = V8Proxy::LookupDOMWrapper(V8ClassIndex::DOMWINDOW, info.This());
    if (holder.IsEmpty())
        return notHandledByInterceptor();

    DOMWindow* window = V8Proxy::ToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, holder);
    if (!window)
        return notHandledByInterceptor();

    String propName = toWebCoreString(name);

    Frame* frame = window->frame();
    // window is detached from a frame.
    if (!frame)
        return notHandledByInterceptor();

    // Search sub-frames.
    Frame* child = frame->tree()->child(propName);
    if (child)
        return V8Proxy::ToV8Object(V8ClassIndex::DOMWINDOW, child->domWindow());

    // Search IDL functions defined in the prototype
    v8::Handle<v8::Value> result = holder->GetRealNamedPropertyInPrototypeChain(name);
    if (!result.IsEmpty())
        return result;

    // Lazy initialization map keeps global properties that can be lazily
    // initialized. The value is the code to instantiate the property.
    // It must return the value of property after initialization.
    static HashMap<String, String> lazyInitMap;
    if (lazyInitMap.isEmpty()) {
      // "new Image()" does not appear to be well-defined in a spec, but Safari,
      // Opera, and Firefox all consider it to always create an HTML image
      // element, regardless of the current doctype.
      lazyInitMap.set("Image",
                       "function Image() { \
                          return document.createElementNS( \
                            'http://www.w3.org/1999/xhtml', 'img'); \
                        }; \
                        Image");
      lazyInitMap.set("Option",
        "function Option(text, value, defaultSelected, selected) { \
           var option = document.createElement('option'); \
           if (text == null) return option; \
           option.text = text; \
           if (value == null) return option; \
           option.value = value; \
           if (defaultSelected == null) return option; \
           option.defaultSelected = defaultSelected; \
           if (selected == null) return option; \
           option.selected = selected; \
           return option; \
         }; \
         Option");
    }

    String code = lazyInitMap.get(propName);
    if (!code.isEmpty()) {
        v8::Local<v8::Context> context = V8Proxy::GetContext(window->frame());
        // Bail out if we cannot get the context for the frame.
        if (context.IsEmpty())
            return notHandledByInterceptor();
  
        // switch to the target object's environment.
        v8::Context::Scope scope(context);

        // Set the property name to undefined to make sure that the
        // property exists.  This is necessary because this getter
        // might be called when evaluating 'var RangeException = value'
        // to figure out if we have a property named 'RangeException' before
        // we set RangeException to the new value.  In that case, we will
        // evaluate 'var RangeException = {}' and enter an infinite loop.
        // Setting the property name to undefined on the global object
        // ensures that we do not have to ask this getter to figure out
        // that we have the property.
        //
        // TODO(ager): We probably should implement the Has method
        // for the interceptor instead of using the default Has method
        // that calls Get.
        context->Global()->Set(v8String(propName), v8::Undefined());
        V8Proxy* proxy = V8Proxy::retrieve(window->frame());
        ASSERT(proxy);

        return proxy->evaluate(WebCore::ScriptSourceCode(code), 0);
    }

    // Search named items in the document.
    Document* doc = frame->document();
    if (doc) {
        RefPtr<HTMLCollection> items = doc->windowNamedItems(propName);
        if (items->length() >= 1) {
            if (items->length() == 1)
                return V8Proxy::NodeToV8Object(items->firstItem());
            else
                return V8Proxy::ToV8Object(V8ClassIndex::HTMLCOLLECTION, items.get());
        }
    }

    return notHandledByInterceptor();
}


void V8Custom::WindowSetLocation(DOMWindow* window, const String& v)
{
    if (!window->frame())
        return;

    Frame* activeFrame = ScriptController::retrieveActiveFrame();
    if (!activeFrame)
        return;

    if (!activeFrame->loader()->shouldAllowNavigation(window->frame()))
        return;

    if (!parseURL(v).startsWith("javascript:", false)
        || ScriptController::isSafeScript(window->frame())) {
        String completedUrl = activeFrame->loader()->completeURL(v).string();
  
        // FIXME: The JSC bindings pass !anyPageIsProcessingUserGesture() for
        // the lockHistory parameter.  We should probably do something similar.
  
        window->frame()->loader()->scheduleLocationChange(completedUrl,
            activeFrame->loader()->outgoingReferrer(), false, false,
            activeFrame->script()->processingUserGesture());
    }
}


CALLBACK_FUNC_DECL(DOMWindowSetTimeout)
{
    INC_STATS("DOM.DOMWindow.setTimeout()");
    return WindowSetTimeoutImpl(args, true);
}


CALLBACK_FUNC_DECL(DOMWindowSetInterval)
{
    INC_STATS("DOM.DOMWindow.setInterval()");
    return WindowSetTimeoutImpl(args, false);
}


void V8Custom::ClearTimeoutImpl(const v8::Arguments& args)
{
    v8::Handle<v8::Value> holder = args.Holder();
    DOMWindow* imp = V8Proxy::ToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, holder);
    if (!V8Proxy::CanAccessFrame(imp->frame(), true))
        return;
    ScriptExecutionContext* context = static_cast<ScriptExecutionContext*>(imp->frame()->document());
    int handle = toInt32(args[0]);
    DOMTimer::removeById(context, handle);
}


CALLBACK_FUNC_DECL(DOMWindowClearTimeout)
{
    INC_STATS("DOM.DOMWindow.clearTimeout");
    ClearTimeoutImpl(args);
    return v8::Undefined();
}

CALLBACK_FUNC_DECL(DOMWindowClearInterval)
{
    INC_STATS("DOM.DOMWindow.clearInterval");
    ClearTimeoutImpl(args);
    return v8::Undefined();
}

} // namespace WebCore
#include "extensions/browser/extension_service_worker_message_filter.h"
#include "extensions/common/extensions_client.h"
  if (extensions::ExtensionsClient::Get()
          ->ExtensionAPIEnabledInExtensionServiceWorkers()) {
    host->AddFilter(new ExtensionServiceWorkerMessageFilter(id, profile));
  }
  Profile* profile = Profile::FromBrowserContext(
      web_contents ? web_contents->GetBrowserContext() : browser_context());
  Browser* browser = chrome::FindAnyBrowser(profile, include_incognito_);
  if (browser)
    return browser;
IN_PROC_BROWSER_TEST_F(ServiceWorkerTest, TabsCreate) {
  // Extensions APIs from SW are only enabled on trunk.
  ScopedCurrentChannel current_channel_override(version_info::Channel::UNKNOWN);
  const Extension* extension = LoadExtensionWithFlags(
      test_data_dir_.AppendASCII("service_worker/tabs_create"), kFlagNone);
  ASSERT_TRUE(extension);
  ui_test_utils::NavigateToURL(browser(),
                               extension->GetResourceURL("page.html"));
  content::WebContents* web_contents =
      browser()->tab_strip_model()->GetActiveWebContents();

  int starting_tab_count = browser()->tab_strip_model()->count();
  std::string result;
  ASSERT_TRUE(content::ExecuteScriptAndExtractString(
      web_contents, "window.runServiceWorker()", &result));
  ASSERT_EQ("chrome.tabs.create callback", result);
  EXPECT_EQ(starting_tab_count + 1, browser()->tab_strip_model()->count());

  // Check extension shutdown path.
  UnloadExtension(extension->id());
  EXPECT_EQ(starting_tab_count, browser()->tab_strip_model()->count());
}

bool ChromeContentClient::AllowScriptExtensionForServiceWorker(
    const GURL& script_url) {
#if defined(ENABLE_EXTENSIONS)
  return script_url.SchemeIs(extensions::kExtensionScheme) ||
         script_url.SchemeIs(extensions::kExtensionResourceScheme);
#else
  return false;
#endif
}

  bool AllowScriptExtensionForServiceWorker(const GURL& script_url) override;
bool ChromeExtensionsClient::ExtensionAPIEnabledInExtensionServiceWorkers()
    const {
  return GetCurrentChannel() == version_info::Channel::UNKNOWN;
}

  bool ExtensionAPIEnabledInExtensionServiceWorkers() const override;
void ChromeContentRendererClient::
    DidInitializeServiceWorkerContextOnWorkerThread(
        v8::Local<v8::Context> context,
        int embedded_worker_id,
        const GURL& url) {
  ChromeExtensionsRendererClient::GetInstance()
      ->extension_dispatcher()
      ->DidInitializeServiceWorkerContextOnWorkerThread(
          context, embedded_worker_id, url);
    int embedded_worker_id,
  extensions::Dispatcher::WillDestroyServiceWorkerContextOnWorkerThread(
      context, embedded_worker_id, url);
      int embedded_worker_id,
      int embedded_worker_id,
bool BlinkPlatformImpl::allowScriptExtensionForServiceWorker(
    const blink::WebURL& scriptUrl) {
  return GetContentClient()->AllowScriptExtensionForServiceWorker(scriptUrl);
}

  bool allowScriptExtensionForServiceWorker(
      const blink::WebURL& script_url) override;
bool ContentClient::AllowScriptExtensionForServiceWorker(
    const GURL& script_url) {
  return false;
}

  // Returns whether or not V8 script extensions should be allowed for a
  // service worker.
  virtual bool AllowScriptExtensionForServiceWorker(const GURL& script_url);

      int embedded_worker_id,
      int embedded_worker_id,
      ->DidInitializeServiceWorkerContextOnWorkerThread(
          context, embedded_worker_id_, script_url_);
      context, embedded_worker_id_, script_url_);
  // An extension function from Service Worker does not have a RenderFrameHost.
  if (!render_frame_host)
    return;
#include "base/scoped_observer.h"
#include "content/public/browser/render_process_host_observer.h"
#include "extensions/common/extensions_client.h"
  // The renderer has done validation before sending extension api requests.
  // Therefore, we should never receive a request that is invalid in a way
  // that JSON validation in the renderer should have caught. It could be an
  // attacker trying to exploit the browser, so we crash the renderer instead.
  LOG(ERROR) << "Terminating renderer because of malformed extension message.";
  if (content::RenderProcessHost::run_renderer_in_process()) {
    // In single process mode it is better if we don't suicide but just crash.
    CHECK(false);
    return;
  }

void KillBadMessageSenderRPH(content::RenderProcessHost* sender_process_host,
                             functions::HistogramValue histogram_value) {
  base::Process peer_process =
      content::RenderProcessHost::run_renderer_in_process()
          ? base::Process::Current()
          : base::Process::DeprecatedGetProcessFromHandle(
                sender_process_host->GetHandle());
  KillBadMessageSender(peer_process, histogram_value);
}

    KillBadMessageSender(peer_process, histogram_value);
class ExtensionFunctionDispatcher::UIThreadWorkerResponseCallbackWrapper
    : public content::RenderProcessHostObserver {
 public:
  UIThreadWorkerResponseCallbackWrapper(
      const base::WeakPtr<ExtensionFunctionDispatcher>& dispatcher,
      int render_process_id,
      int worker_thread_id)
      : dispatcher_(dispatcher),
        observer_(this),
        render_process_id_(render_process_id),
        worker_thread_id_(worker_thread_id),
        weak_ptr_factory_(this) {
    observer_.Add(content::RenderProcessHost::FromID(render_process_id_));
    DCHECK(ExtensionsClient::Get()
               ->ExtensionAPIEnabledInExtensionServiceWorkers());
  }

  ~UIThreadWorkerResponseCallbackWrapper() override {}

  // content::RenderProcessHostObserver override.
  void RenderProcessExited(content::RenderProcessHost* rph,
                           base::TerminationStatus status,
                           int exit_code) override {
    CleanUp();
  }

  // content::RenderProcessHostObserver override.
  void RenderProcessHostDestroyed(content::RenderProcessHost* rph) override {
    CleanUp();
  }

  ExtensionFunction::ResponseCallback CreateCallback(int request_id) {
    return base::Bind(
        &UIThreadWorkerResponseCallbackWrapper::OnExtensionFunctionCompleted,
        weak_ptr_factory_.GetWeakPtr(), request_id);
  }

 private:
  void CleanUp() {
    DCHECK_CURRENTLY_ON(BrowserThread::UI);
    if (dispatcher_)
      dispatcher_->RemoveWorkerCallbacksForProcess(render_process_id_);
    // Note: we are deleted here!
  }

  void OnExtensionFunctionCompleted(int request_id,
                                    ExtensionFunction::ResponseType type,
                                    const base::ListValue& results,
                                    const std::string& error,
                                    functions::HistogramValue histogram_value) {
    content::RenderProcessHost* sender =
        content::RenderProcessHost::FromID(render_process_id_);
    if (type == ExtensionFunction::BAD_MESSAGE) {
      KillBadMessageSenderRPH(sender, histogram_value);
      return;
    }
    DCHECK(sender);
    sender->Send(new ExtensionMsg_ResponseWorker(
        worker_thread_id_, request_id, type == ExtensionFunction::SUCCEEDED,
        results, error));
  }

  base::WeakPtr<ExtensionFunctionDispatcher> dispatcher_;
  ScopedObserver<content::RenderProcessHost,
                 UIThreadWorkerResponseCallbackWrapper>
      observer_;
  const int render_process_id_;
  const int worker_thread_id_;
  base::WeakPtrFactory<UIThreadWorkerResponseCallbackWrapper> weak_ptr_factory_;

  DISALLOW_COPY_AND_ASSIGN(UIThreadWorkerResponseCallbackWrapper);
};

struct ExtensionFunctionDispatcher::WorkerResponseCallbackMapKey {
  WorkerResponseCallbackMapKey(int render_process_id, int embedded_worker_id)
      : render_process_id(render_process_id),
        embedded_worker_id(embedded_worker_id) {}

  bool operator<(const WorkerResponseCallbackMapKey& other) const {
    return std::tie(render_process_id, embedded_worker_id) <
           std::tie(other.render_process_id, other.embedded_worker_id);
  }

  int render_process_id;
  int embedded_worker_id;
};

    content::RenderFrameHost* render_frame_host,
    int render_process_id) {
  if (render_frame_host) {
    // Extension API from a non Service Worker context, e.g. extension page,
    // background page, content script.
    UIThreadResponseCallbackWrapperMap::const_iterator iter =
        ui_thread_response_callback_wrappers_.find(render_frame_host);
    UIThreadResponseCallbackWrapper* callback_wrapper = nullptr;
    if (iter == ui_thread_response_callback_wrappers_.end()) {
      callback_wrapper =
          new UIThreadResponseCallbackWrapper(AsWeakPtr(), render_frame_host);
      ui_thread_response_callback_wrappers_[render_frame_host] =
          callback_wrapper;
    } else {
      callback_wrapper = iter->second;
    }
    DispatchWithCallbackInternal(
        params, render_frame_host, render_process_id,
        callback_wrapper->CreateCallback(params.request_id));
    // Extension API from Service Worker.
    DCHECK_GE(params.embedded_worker_id, 0);
    WorkerResponseCallbackMapKey key(render_process_id,
                                     params.embedded_worker_id);
    UIThreadWorkerResponseCallbackWrapperMap::const_iterator iter =
        ui_thread_response_callback_wrappers_for_worker_.find(key);
    UIThreadWorkerResponseCallbackWrapper* callback_wrapper = nullptr;
    if (iter == ui_thread_response_callback_wrappers_for_worker_.end()) {
      callback_wrapper = new UIThreadWorkerResponseCallbackWrapper(
          AsWeakPtr(), render_process_id, params.worker_thread_id);
      ui_thread_response_callback_wrappers_for_worker_[key] =
          base::WrapUnique(callback_wrapper);
    } else {
      callback_wrapper = iter->second.get();
    }
    DispatchWithCallbackInternal(
        params, nullptr, render_process_id,
        callback_wrapper->CreateCallback(params.request_id));
    int render_process_id,
  if (render_frame_host)
    DCHECK_EQ(render_process_id, render_frame_host->GetProcess()->GetID());

  scoped_refptr<ExtensionFunction> function(CreateExtensionFunction(
      params, extension, render_process_id, *process_map,
      ExtensionAPI::GetSharedInstance(), browser_context_, callback));
  // TODO(lazyboy): API functions from extension Service Worker will incorrectly
  // change keepalive count below.
void ExtensionFunctionDispatcher::RemoveWorkerCallbacksForProcess(
    int render_process_id) {
  UIThreadWorkerResponseCallbackWrapperMap& map =
      ui_thread_response_callback_wrappers_for_worker_;
  for (UIThreadWorkerResponseCallbackWrapperMap::iterator it = map.begin();
       it != map.end();) {
    if (it->first.render_process_id == render_process_id) {
      it = map.erase(it);
      continue;
    }
    ++it;
  }
}

  // TODO(lazyboy): API functions from extension Service Worker will incorrectly
  // change keepalive count below.
                content::RenderFrameHost* render_frame_host,
                int render_process_id);
  // Same as UIThreadResponseCallbackWrapper above, but applies to an extension
  // function from an extension Service Worker.
  class UIThreadWorkerResponseCallbackWrapper;

  // Key used to store UIThreadWorkerResponseCallbackWrapper in the map
  // |ui_thread_response_callback_wrappers_for_worker_|.
  struct WorkerResponseCallbackMapKey;

      int render_process_id,
  void RemoveWorkerCallbacksForProcess(int render_process_id);


  using UIThreadWorkerResponseCallbackWrapperMap =
      std::map<WorkerResponseCallbackMapKey,
               std::unique_ptr<UIThreadWorkerResponseCallbackWrapper>>;
  // TODO(lazyboy): The map entries are cleared upon RenderProcessHost shutown,
  // we should really be clearing it on service worker shutdown.
  UIThreadWorkerResponseCallbackWrapperMap
      ui_thread_response_callback_wrappers_for_worker_;
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/browser/extension_service_worker_message_filter.h"

#include "extensions/browser/extension_function_dispatcher.h"
#include "extensions/common/extension_messages.h"

namespace extensions {

ExtensionServiceWorkerMessageFilter::ExtensionServiceWorkerMessageFilter(
    int render_process_id,
    content::BrowserContext* context)
    : content::BrowserMessageFilter(ExtensionWorkerMsgStart),
      render_process_id_(render_process_id),
      browser_context_(context),
      dispatcher_(new ExtensionFunctionDispatcher(context)) {}

ExtensionServiceWorkerMessageFilter::~ExtensionServiceWorkerMessageFilter() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
}

void ExtensionServiceWorkerMessageFilter::OverrideThreadForMessage(
    const IPC::Message& message,
    content::BrowserThread::ID* thread) {
  if (message.type() == ExtensionHostMsg_RequestWorker::ID) {
    *thread = content::BrowserThread::UI;
  }
}

bool ExtensionServiceWorkerMessageFilter::OnMessageReceived(
    const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(ExtensionServiceWorkerMessageFilter, message)
    IPC_MESSAGE_HANDLER(ExtensionHostMsg_RequestWorker, OnRequestWorker)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}

void ExtensionServiceWorkerMessageFilter::OnRequestWorker(
    const ExtensionHostMsg_Request_Params& params) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  dispatcher_->Dispatch(params, nullptr, render_process_id_);
}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_BROWSER_EXTENSION_SERVICE_WORKER_MESSAGE_FILTER_H_
#define EXTENSIONS_BROWSER_EXTENSION_SERVICE_WORKER_MESSAGE_FILTER_H_

#include "base/macros.h"
#include "content/public/browser/browser_message_filter.h"

struct ExtensionHostMsg_Request_Params;

namespace content {
class BrowserContext;
}

namespace extensions {

class ExtensionFunctionDispatcher;

// IPC handler class for extension service worker.
class ExtensionServiceWorkerMessageFilter
    : public content::BrowserMessageFilter {
 public:
  ExtensionServiceWorkerMessageFilter(int render_process_id,
                                      content::BrowserContext* context);

  // content::BrowserMessageFilter:
  bool OnMessageReceived(const IPC::Message& message) override;
  void OverrideThreadForMessage(const IPC::Message& message,
                                content::BrowserThread::ID* thread) override;

 private:
  ~ExtensionServiceWorkerMessageFilter() override;

  void OnRequestWorker(const ExtensionHostMsg_Request_Params& params);

  const int render_process_id_;
  content::BrowserContext* browser_context_;

  std::unique_ptr<ExtensionFunctionDispatcher,
                  content::BrowserThread::DeleteOnUIThread>
      dispatcher_;

  DISALLOW_COPY_AND_ASSIGN(ExtensionServiceWorkerMessageFilter);
};

}  // namespace extensions

#endif  // EXTENSIONS_BROWSER_EXTENSION_SERVICE_WORKER_MESSAGE_FILTER_H_
  dispatcher_.Dispatch(params, render_frame_host,
                       render_frame_host->GetProcess()->GetID());

  // If this API call is for a service worker, then this is the worker thread
  // id. Otherwise, this is -1.
  IPC_STRUCT_MEMBER(int, worker_thread_id)

  // If this API call is for a service worker, then this is the embedded
  // worker id. Otherwise, this is -1.
  IPC_STRUCT_MEMBER(int, embedded_worker_id)

// Messages related to Extension Service Worker.
#undef IPC_MESSAGE_START
#define IPC_MESSAGE_START ExtensionWorkerMsgStart
// A service worker thread sends this message when an extension service worker
// starts an API request. The browser will always respond with a
// ExtensionMsg_ResponseWorker.
IPC_MESSAGE_CONTROL1(ExtensionHostMsg_RequestWorker,
                     ExtensionHostMsg_Request_Params)

// The browser sends this message in response to all service worker extension
// api calls. The response data (if any) is one of the base::Value subclasses,
// wrapped as the first element in a ListValue.
IPC_MESSAGE_CONTROL5(ExtensionMsg_ResponseWorker,
                     int /* thread_id */,
                     int /* request_id */,
                     bool /* success */,
                     base::ListValue /* response wrapper (see comment above) */,
                     std::string /* error */)
bool ExtensionsClient::ExtensionAPIEnabledInExtensionServiceWorkers() const {
  return false;
}

  // Returns whether or not extension APIs are allowed in extension service
  // workers.
  // This is currently disallowed as the code to support this is work in
  // progress.
  // Can be overridden in tests.
  virtual bool ExtensionAPIEnabledInExtensionServiceWorkers() const;

    contexts["extension_service_worker"] = Feature::SERVICE_WORKER_CONTEXT;
  // TODO(lazyboy): This isn't quite right for Extension Service Worker
  // extension API calls, since there's no guarantee that the extension is
  // "active" in current renderer process when the API permission check is
  // done.
  contexts->Append(new base::StringValue("extension_service_worker"));
  EXPECT_EQ(7u, feature->contexts()->size());
#include "content/public/child/worker_thread.h"
  // A worker's ScriptContext neither lives in ScriptContextSet nor it has a
  // RenderFrame associated with it, so early exit in this case.
  // TODO(lazyboy): Fix.
  if (content::WorkerThread::GetCurrentId() > 0)
    return;

#include "extensions/common/features/feature_util.h"
#include "extensions/renderer/worker_thread_dispatcher.h"
#include "third_party/WebKit/public/web/WebScriptController.h"
  // Ideally this should be done after checking
  // ExtensionAPIEnabledInExtensionServiceWorkers(), but the Dispatcher is
  // created so early that sending an IPC from browser/ process to synchronize
  // this enabled-ness is too late.
  WorkerThreadDispatcher::Get()->Init(RenderThread::Get());
  RegisterNativeHandlers(module_system, context, request_sender_.get(),
                         v8_schema_registry_.get());
    int embedded_worker_id,
  if (ExtensionsClient::Get()->ExtensionAPIEnabledInExtensionServiceWorkers()) {
    WorkerThreadDispatcher::Get()->AddWorkerData(embedded_worker_id);
    {
      // TODO(lazyboy): Make sure accessing |source_map_| in worker thread is
      // safe.
      std::unique_ptr<ModuleSystem> module_system(
          new ModuleSystem(context, &source_map_));
      context->set_module_system(std::move(module_system));
    }

    ModuleSystem* module_system = context->module_system();
    // Enable natives in startup.
    ModuleSystem::NativesEnabledScope natives_enabled_scope(module_system);
    RegisterNativeHandlers(
        module_system, context,
        WorkerThreadDispatcher::Get()->GetRequestSender(),
        WorkerThreadDispatcher::Get()->GetV8SchemaRegistry());
    // chrome.Event is part of the public API (although undocumented). Make it
    // lazily evalulate to Event from event_bindings.js.
    v8::Local<v8::Object> chrome = AsObjectOrEmpty(GetOrCreateChrome(context));
    if (!chrome.IsEmpty())
      module_system->SetLazyField(chrome, "Event", kEventBindings, "Event");

    UpdateBindingsForContext(context);
    // TODO(lazyboy): Get rid of RequireGuestViewModules() as this doesn't seem
    // necessary for Extension SW.
    RequireGuestViewModules(context);
    delegate_->RequireAdditionalModules(context,
                                        false /* is_within_platform_app */);
  }

    int embedded_worker_id,
  if (ExtensionsClient::Get()->ExtensionAPIEnabledInExtensionServiceWorkers())
    WorkerThreadDispatcher::Get()->RemoveWorkerData(embedded_worker_id);
// Note: this function runs on multiple threads: main renderer thread and
// service worker threads.
    case Feature::SERVICE_WORKER_CONTEXT:
      DCHECK(ExtensionsClient::Get()
                 ->ExtensionAPIEnabledInExtensionServiceWorkers());
    // Intentional fallthrough.
        if (context->IsAnyFeatureAvailableToContext(*map_entry.second.get())) {
          // TODO(lazyboy): RegisterBinding() uses |source_map_|, any thread
          // safety issue?
        }
                                        ScriptContext* context,
                                        RequestSender* request_sender,
                                        V8SchemaRegistry* v8_schema_registry) {
  RegisterNativeHandlers(module_system, context, this, request_sender,
                         v8_schema_registry);
// static.
// static.
  // Runs on a different thread and should only use thread safe member
  // variables.
  void DidInitializeServiceWorkerContextOnWorkerThread(
      int embedded_worker_id,
      int embedded_worker_id,
                              ScriptContext* context,
                              RequestSender* request_sender,
                              V8SchemaRegistry* v8_schema_registry);
  static v8::Local<v8::Object> GetOrCreateObject(
      const v8::Local<v8::Object>& object,
      const std::string& field,
      v8::Isolate* isolate);
  static v8::Local<v8::Object> GetOrCreateBindObjectIfAvailable(
  // TODO(lazyboy): ScriptContextSet isn't available on worker threads. We
  // should probably use WorkerScriptContextSet somehow.
      content::WorkerThread::GetCurrentId() == 0
          ? ScriptContextSet::GetContextByObject(object)
          : nullptr;
  bool for_service_worker =
      context->context_type() == Feature::SERVICE_WORKER_CONTEXT;
  // Note that |render_frame| would be nullptr for Service Workers. Service
  // Workers use control IPC instead.
  if (!for_service_worker && !render_frame) {
    // It is important to early exit here for non Service Worker contexts so
    // that we do not create orphaned PendingRequests below.
  }

  // Set Service Worker specific params to default values.
  params.worker_thread_id = -1;
  params.embedded_worker_id = -1;

  SendRequest(render_frame, for_io_thread, params);
}

void RequestSender::SendRequest(content::RenderFrame* render_frame,
                                bool for_io_thread,
                                ExtensionHostMsg_Request_Params& params) {
struct ExtensionHostMsg_Request_Params;

namespace content {
class RenderFrame;
}

  virtual ~RequestSender();
  // Sends the IPC to extension host for the API function that is described
  // in |params|.
  virtual void SendRequest(content::RenderFrame* render_frame,
                           bool for_io_thread,
                           ExtensionHostMsg_Request_Params& params);

  // TODO(lazyboy): Decide what we should do for SERVICE_WORKER_CONTEXT.
  GURL url = context_type() == Feature::SERVICE_WORKER_CONTEXT
                 ? url_
                 : GetDataSourceURLForFrame(web_frame());
      api, extension(), context_type(), url);
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/service_worker_data.h"

#include "extensions/renderer/service_worker_request_sender.h"
#include "extensions/renderer/worker_thread_dispatcher.h"

namespace extensions {

ServiceWorkerData::ServiceWorkerData(WorkerThreadDispatcher* dispatcher,
                                     int embedded_worker_id)
    : embedded_worker_id_(embedded_worker_id),
      v8_schema_registry_(new V8SchemaRegistry),
      request_sender_(
          new ServiceWorkerRequestSender(dispatcher, embedded_worker_id)) {}

ServiceWorkerData::~ServiceWorkerData() {}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_BROWSER_SERVICE_WORKER_DATA_H_
#define EXTENSIONS_BROWSER_SERVICE_WORKER_DATA_H_

#include <memory>

#include "base/macros.h"
#include "extensions/renderer/service_worker_request_sender.h"
#include "extensions/renderer/v8_schema_registry.h"

namespace extensions {
class WorkerThreadDispatcher;

// Per ServiceWorker data in worker thread.
// Contains: RequestSender, V8SchemaRegistry.
// TODO(lazyboy): Also put worker ScriptContexts in this.
class ServiceWorkerData {
 public:
  ServiceWorkerData(WorkerThreadDispatcher* dispatcher, int embedded_worker_id);
  ~ServiceWorkerData();

  V8SchemaRegistry* v8_schema_registry() { return v8_schema_registry_.get(); }
  RequestSender* request_sender() { return request_sender_.get(); }
  int embedded_worker_id() const { return embedded_worker_id_; }

 private:
  const int embedded_worker_id_;

  std::unique_ptr<V8SchemaRegistry> v8_schema_registry_;
  std::unique_ptr<ServiceWorkerRequestSender> request_sender_;

  DISALLOW_COPY_AND_ASSIGN(ServiceWorkerData);
};

}  // namespace extensions

#endif  // EXTENSIONS_BROWSER_SERVICE_WORKER_DATA_H_
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/service_worker_request_sender.h"

#include "content/public/child/worker_thread.h"
#include "extensions/common/extension_messages.h"
#include "extensions/renderer/worker_thread_dispatcher.h"

namespace extensions {

ServiceWorkerRequestSender::ServiceWorkerRequestSender(
    WorkerThreadDispatcher* dispatcher,
    int embedded_worker_id)
    : dispatcher_(dispatcher), embedded_worker_id_(embedded_worker_id) {}

ServiceWorkerRequestSender::~ServiceWorkerRequestSender() {}

void ServiceWorkerRequestSender::SendRequest(
    content::RenderFrame* render_frame,
    bool for_io_thread,
    ExtensionHostMsg_Request_Params& params) {
  DCHECK(!render_frame && !for_io_thread);
  int worker_thread_id = content::WorkerThread::GetCurrentId();
  DCHECK_GT(worker_thread_id, 0);
  params.worker_thread_id = worker_thread_id;
  params.embedded_worker_id = embedded_worker_id_;

  dispatcher_->Send(new ExtensionHostMsg_RequestWorker(params));
}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_RENDERER_SERVICE_WORKER_REQUEST_SENDER_H_
#define EXTENSIONS_RENDERER_SERVICE_WORKER_REQUEST_SENDER_H_

#include "extensions/renderer/request_sender.h"

namespace extensions {
class WorkerThreadDispatcher;

// A RequestSender variant for Extension Service Worker.
class ServiceWorkerRequestSender : public RequestSender {
 public:
  ServiceWorkerRequestSender(WorkerThreadDispatcher* dispatcher,
                             int embedded_worker_id);
  ~ServiceWorkerRequestSender() override;

  void SendRequest(content::RenderFrame* render_frame,
                   bool for_io_thread,
                   ExtensionHostMsg_Request_Params& params) override;

 private:
  WorkerThreadDispatcher* const dispatcher_;
  const int embedded_worker_id_;

  DISALLOW_COPY_AND_ASSIGN(ServiceWorkerRequestSender);
};

}  // namespace extensions

#endif  // EXTENSIONS_RENDERER_SERVICE_WORKER_REQUEST_SENDER_H_
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/worker_thread_dispatcher.h"

#include "base/threading/thread_local.h"
#include "base/values.h"
#include "content/public/child/worker_thread.h"
#include "content/public/renderer/render_thread.h"
#include "extensions/common/extension_messages.h"
#include "extensions/renderer/service_worker_data.h"

namespace extensions {

namespace {

base::LazyInstance<WorkerThreadDispatcher> g_instance =
    LAZY_INSTANCE_INITIALIZER;
base::LazyInstance<base::ThreadLocalPointer<extensions::ServiceWorkerData>>
    g_data_tls = LAZY_INSTANCE_INITIALIZER;

void OnResponseOnWorkerThread(int request_id,
                              bool succeeded,
                              const std::unique_ptr<base::ListValue>& response,
                              const std::string& error) {
  WorkerThreadDispatcher::GetRequestSender()->HandleResponse(
      request_id, succeeded, *response, error);
}

}  // namespace

WorkerThreadDispatcher::WorkerThreadDispatcher() {}
WorkerThreadDispatcher::~WorkerThreadDispatcher() {}

WorkerThreadDispatcher* WorkerThreadDispatcher::Get() {
  return g_instance.Pointer();
}

void WorkerThreadDispatcher::Init(content::RenderThread* render_thread) {
  DCHECK(render_thread);
  DCHECK_EQ(content::RenderThread::Get(), render_thread);
  DCHECK(!message_filter_);
  message_filter_ = render_thread->GetSyncMessageFilter();
  render_thread->AddObserver(this);
}

V8SchemaRegistry* WorkerThreadDispatcher::GetV8SchemaRegistry() {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  DCHECK(data);
  return data->v8_schema_registry();
}

// static
RequestSender* WorkerThreadDispatcher::GetRequestSender() {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  DCHECK(data);
  return data->request_sender();
}

bool WorkerThreadDispatcher::OnControlMessageReceived(
    const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(WorkerThreadDispatcher, message)
    IPC_MESSAGE_HANDLER(ExtensionMsg_ResponseWorker, OnResponseWorker)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}

bool WorkerThreadDispatcher::Send(IPC::Message* message) {
  return message_filter_->Send(message);
}

void WorkerThreadDispatcher::OnResponseWorker(int worker_thread_id,
                                              int request_id,
                                              bool succeeded,
                                              const base::ListValue& response,
                                              const std::string& error) {
  content::WorkerThread::PostTask(
      worker_thread_id,
      base::Bind(&OnResponseOnWorkerThread, request_id, succeeded,
                 // TODO(lazyboy): Can we avoid CreateDeepCopy()?
                 base::Passed(response.CreateDeepCopy()), error));
}

void WorkerThreadDispatcher::AddWorkerData(int embedded_worker_id) {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  if (!data) {
    ServiceWorkerData* new_data =
        new ServiceWorkerData(this, embedded_worker_id);
    g_data_tls.Pointer()->Set(new_data);
  }
}

void WorkerThreadDispatcher::RemoveWorkerData(int embedded_worker_id) {
  ServiceWorkerData* data = g_data_tls.Pointer()->Get();
  if (data) {
    DCHECK_EQ(embedded_worker_id, data->embedded_worker_id());
    delete data;
    g_data_tls.Pointer()->Set(nullptr);
  }
}

}  // namespace extensions
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef EXTENSIONS_RENDERER_WORKER_THREAD_DISPATCHER_H_
#define EXTENSIONS_RENDERER_WORKER_THREAD_DISPATCHER_H_

#include "base/synchronization/lock.h"
#include "content/public/renderer/render_thread_observer.h"
#include "ipc/ipc_sync_message_filter.h"

namespace base {
class ListValue;
}

namespace content {
class RenderThread;
}

namespace extensions {
class RequestSender;
class V8SchemaRegistry;

// Sends and receives IPC in an extension Service Worker.
// TODO(lazyboy): This class should really be a combination of the following
// two:
// 1) A content::WorkerThreadMessageFilter, so that we can receive IPC directly
// on worker thread.
// 2) A content::ThreadSafeSender, so we can safely send IPC from worker thread.
class WorkerThreadDispatcher : public content::RenderThreadObserver {
 public:
  WorkerThreadDispatcher();
  ~WorkerThreadDispatcher() override;

  // Thread safe.
  static WorkerThreadDispatcher* Get();
  static RequestSender* GetRequestSender();

  void Init(content::RenderThread* render_thread);
  bool Send(IPC::Message* message);
  void AddWorkerData(int embedded_worker_id);
  void RemoveWorkerData(int embedded_worker_id);
  V8SchemaRegistry* GetV8SchemaRegistry();

 private:
  // content::RenderThreadObserver:
  bool OnControlMessageReceived(const IPC::Message& message) override;

  // IPC handlers.
  void OnResponseWorker(int worker_thread_id,
                        int request_id,
                        bool succeeded,
                        const base::ListValue& response,
                        const std::string& error);

  // IPC sender. Belongs to the render thread, but thread safe.
  scoped_refptr<IPC::SyncMessageFilter> message_filter_;

  DISALLOW_COPY_AND_ASSIGN(WorkerThreadDispatcher);
};

}  // namespace extensions

#endif  // EXTENSIONS_RENDERER_WORKER_THREAD_DISPATCHER_H_
  ExtensionWorkerMsgStart,
#include "bindings/core/v8/ScriptController.h"
        // Initialize V8 extensions before creating the context.
        Vector<const char*> extensionNames;
        if (m_globalScope->isServiceWorkerGlobalScope() && Platform::current()->allowScriptExtensionForServiceWorker(toWorkerGlobalScope(m_globalScope.get())->url())) {
            const V8Extensions& extensions = ScriptController::registeredExtensions();
            extensionNames.reserveInitialCapacity(extensions.size());
            for (const auto* extension : extensions)
                extensionNames.append(extension->name());
        }
        v8::ExtensionConfiguration extensionConfiguration(extensionNames.size(), extensionNames.data());

        context = v8::Context::New(m_isolate, &extensionConfiguration, globalTemplate);
    virtual bool allowScriptExtensionForServiceWorker(const WebURL& scriptUrl) { return false; }
                ownerNode->notifyLoadedSheetAndAllCriticalSubresources(m_didLoadErrorOccur ? Node::ErrorOccurredLoadingSubresource : Node::NoErrorLoadingSubresource);
    enum LoadedSheetErrorStatus {
        NoErrorLoadingSubresource,
        ErrorOccurredLoadingSubresource
    };
    virtual void notifyLoadedSheetAndAllCriticalSubresources(LoadedSheetErrorStatus) { }
        if (!executeScript(ScriptSourceCode(scriptContent(), scriptURL, position))) {
            dispatchErrorEvent();
        }
    if (!m_isExternalScript && (!shouldBypassMainWorldCSP && !csp->allowInlineScript(elementDocument->url(), m_startLineNumber, sourceCode.source()))) {
        return false;
    }
            return false;
            return false;
StyleElement::ProcessingResult StyleElement::processStyleSheet(Document& document, Element* element)
        return ProcessingSuccessful;
    return process(element);
StyleElement::ProcessingResult StyleElement::childrenChanged(Element* element)
        return ProcessingSuccessful;
    return process(element);
StyleElement::ProcessingResult StyleElement::finishParsingChildren(Element* element)
    ProcessingResult result = process(element);
    return result;
StyleElement::ProcessingResult StyleElement::process(Element* element)
        return ProcessingSuccessful;
    return createSheet(element, element->textFromChildren());
StyleElement::ProcessingResult StyleElement::createSheet(Element* e, const String& text)

    return passesContentSecurityPolicyChecks ? ProcessingSuccessful : ProcessingFatalError;
    enum ProcessingResult {
        ProcessingSuccessful,
        ProcessingFatalError
    };

    ProcessingResult processStyleSheet(Document&, Element*);
    ProcessingResult childrenChanged(Element*);
    ProcessingResult finishParsingChildren(Element*);
    ProcessingResult createSheet(Element*, const String& text = String());
    ProcessingResult process(Element*);
void HTMLLinkElement::notifyLoadedSheetAndAllCriticalSubresources(LoadedSheetErrorStatus errorStatus)
    linkStyle()->notifyLoadedSheetAndAllCriticalSubresources(errorStatus);
        notifyLoadedSheetAndAllCriticalSubresources(Node::ErrorOccurredLoadingSubresource);
void LinkStyle::notifyLoadedSheetAndAllCriticalSubresources(Node::LoadedSheetErrorStatus errorStatus)
    m_loadedSheet = (errorStatus == Node::NoErrorLoadingSubresource);
            // The request may have been denied if (for example) the stylesheet is local and the document is remote, or if there was a Content Security Policy Failure.
            notifyLoadedSheetAndAllCriticalSubresources(Node::ErrorOccurredLoadingSubresource);
    void notifyLoadedSheetAndAllCriticalSubresources(Node::LoadedSheetErrorStatus);
    virtual void notifyLoadedSheetAndAllCriticalSubresources(LoadedSheetErrorStatus) override;
    StyleElement::ProcessingResult result = StyleElement::finishParsingChildren(this);
    if (result == StyleElement::ProcessingFatalError)
        notifyLoadedSheetAndAllCriticalSubresources(ErrorOccurredLoadingSubresource);
    if (StyleElement::processStyleSheet(document(), this) == StyleElement::ProcessingFatalError)
        notifyLoadedSheetAndAllCriticalSubresources(ErrorOccurredLoadingSubresource);
    if (StyleElement::childrenChanged(this) == StyleElement::ProcessingFatalError)
        notifyLoadedSheetAndAllCriticalSubresources(ErrorOccurredLoadingSubresource);
void HTMLStyleElement::notifyLoadedSheetAndAllCriticalSubresources(LoadedSheetErrorStatus errorStatus)
    m_loadedSheet = (errorStatus == NoErrorLoadingSubresource);
    virtual void notifyLoadedSheetAndAllCriticalSubresources(LoadedSheetErrorStatus) override;
            RefPtrWillBeRawPtr<DocumentLoader> documentLoader = m_frame->loader().provisionalDocumentLoader();
        node = pluginDocument->pluginNode();
        RefPtrWillBeRawPtr<DocumentLoader> documentLoader = frame()->loader().documentLoader();
    mutable PersistentWillBeMember<ApplicationCache> m_applicationCache;
        return nullptr;
    return m_mainResource ? m_mainResource->loader() : nullptr;
    ASSERT(!m_mainResource);
    ASSERT(!m_applicationCacheHost);
}

DEFINE_TRACE(DocumentLoader)
{
    visitor->trace(m_frame);
    visitor->trace(m_fetcher);
    // TODO(sof): start tracing ResourcePtr<>s (and m_mainResource.)
    visitor->trace(m_writer);
    visitor->trace(m_archive);
    visitor->trace(m_applicationCacheHost);
    return nullptr;
    if (m_applicationCacheHost)
        m_applicationCacheHost->failedLoadingMainResource();
    RefPtrWillBeRawPtr<LocalFrame> protectFrame(m_frame.get());
    RefPtrWillBeRawPtr<DocumentLoader> protectLoader(this);
    RefPtrWillBeRawPtr<DocumentLoader> protect(this);
    RefPtrWillBeRawPtr<DocumentLoader> protect(this);
    RefPtrWillBeRawPtr<DocumentLoader> protect(this);
    RefPtrWillBeRawPtr<LocalFrame> protectFrame(m_frame.get());
    RefPtrWillBeRawPtr<DocumentLoader> protectLoader(this);
    RefPtrWillBeRawPtr<LocalFrame> protectFrame(m_frame.get());
    RefPtrWillBeRawPtr<DocumentLoader> protectLoader(this);
    // If that load cancellation triggered another detach, leave.
    // (fast/frames/detach-frame-nested-no-crash.html is an example of this.)
    if (!m_frame)
        return;

    m_applicationCacheHost->detachFromDocumentLoader();
    m_applicationCacheHost.clear();
    clearMainResourceHandle();
    m_frame = nullptr;
    m_mainResource = nullptr;
    RefPtrWillBeRawPtr<DocumentLoader> protect(this);
        if (m_applicationCacheHost)
            m_applicationCacheHost->detachFromDocumentLoader();
    RefPtrWillBeRawPtr<DocumentLoader> protect(this);

    class CORE_EXPORT DocumentLoader : public RefCountedWillBeGarbageCollectedFinalized<DocumentLoader>, private RawResourceClient {
        WTF_MAKE_FAST_ALLOCATED_WILL_BE_REMOVED(DocumentLoader);
        static PassRefPtrWillBeRawPtr<DocumentLoader> create(LocalFrame* frame, const ResourceRequest& request, const SubstituteData& data)
            return adoptRefWillBeNoop(new DocumentLoader(frame, request, data));
        virtual void detachFromFrame();
        DECLARE_VIRTUAL_TRACE();

        RawPtrWillBeMember<LocalFrame> m_frame;
        RefPtrWillBeMember<ResourceFetcher> m_fetcher;
        RefPtrWillBeMember<DocumentWriter> m_writer;
        RefPtrWillBeMember<MHTMLArchive> m_archive;
        PersistentWillBeMember<ApplicationCacheHost> m_applicationCacheHost;

} // namespace blink
PassRefPtrWillBeRawPtr<DocumentLoader> EmptyFrameLoaderClient::createDocumentLoader(LocalFrame* frame, const ResourceRequest& request, const SubstituteData& substituteData)
    virtual PassRefPtrWillBeRawPtr<DocumentLoader> createDocumentLoader(LocalFrame*, const ResourceRequest&, const SubstituteData&) override;
    virtual void TearDown()
    {
        documentLoader->detachFromFrame();
        documentLoader.clear();
    }

    RefPtrWillBePersistent<DocumentLoader> documentLoader;
    virtual void TearDown()
    {
        documentLoader->detachFromFrame();
        documentLoader.clear();
    }

    RefPtrWillBePersistent<DocumentLoader> documentLoader;
    visitor->trace(m_documentLoader);
    visitor->trace(m_provisionalDocumentLoader);
    visitor->trace(m_policyDocumentLoader);
    RefPtrWillBeRawPtr<DocumentLoader> documentLoader(m_frame->document()->loader());
void FrameLoader::detachDocumentLoader(RefPtrWillBeMember<DocumentLoader>& loader)
{
    if (!loader)
        return;

    loader->detachFromFrame();
    loader = nullptr;
}

        detachDocumentLoader(m_provisionalDocumentLoader);
    detachDocumentLoader(m_provisionalDocumentLoader);
    detachDocumentLoader(m_policyDocumentLoader);
    RefPtrWillBeRawPtr<DocumentLoader> pdl = m_provisionalDocumentLoader;
        detachDocumentLoader(m_documentLoader);
    detachDocumentLoader(m_documentLoader);
    detachDocumentLoader(m_provisionalDocumentLoader);
    detachDocumentLoader(m_policyDocumentLoader);
        detachDocumentLoader(m_provisionalDocumentLoader);
        detachDocumentLoader(m_policyDocumentLoader);
        detachDocumentLoader(m_provisionalDocumentLoader);
    void detachDocumentLoader(RefPtrWillBeMember<DocumentLoader>&);

    RefPtrWillBeMember<DocumentLoader> m_documentLoader;
    RefPtrWillBeMember<DocumentLoader> m_provisionalDocumentLoader;
    RefPtrWillBeMember<DocumentLoader> m_policyDocumentLoader;
        virtual PassRefPtrWillBeRawPtr<DocumentLoader> createDocumentLoader(LocalFrame*, const ResourceRequest&, const SubstituteData&) = 0;
class ApplicationCache final : public RefCountedGarbageCollectedEventTargetWithInlineData<ApplicationCache>, public DOMWindowProperty {
    REFCOUNTED_GARBAGE_COLLECTED_EVENT_TARGET(ApplicationCache);
    static ApplicationCache* create(LocalFrame* frame)
        return new ApplicationCache(frame);
    // Verify that detachFromDocumentLoader() has been performed already.
    ASSERT(!m_host);
    if (!m_host)
        return;
    WrappedResourceRequest wrapped(request);
    const WebApplicationCacheHost* spawningHost = nullptr;
    Frame* spawningFrame = frame.tree().parent();
    if (!spawningFrame || !spawningFrame->isLocalFrame())
        spawningFrame = frame.loader().opener();
    if (!spawningFrame || !spawningFrame->isLocalFrame())
        spawningFrame = &frame;
    if (DocumentLoader* spawningDocLoader = toLocalFrame(spawningFrame)->loader().documentLoader())
        spawningHost = spawningDocLoader->applicationCacheHost() ? spawningDocLoader->applicationCacheHost()->m_host.get() : nullptr;

    m_host->willStartMainResourceRequest(wrapped, spawningHost);
void ApplicationCacheHost::detachFromDocumentLoader()
    // Detach from the owning DocumentLoader and let go of WebApplicationCacheHost.
    setApplicationCache(nullptr);
    RefPtrWillBeRawPtr<DocumentLoader> protect(documentLoader());
    if (!m_domApplicationCache)
        return;

    const AtomicString& eventType = ApplicationCache::toEventType(id);
    RefPtrWillBeRawPtr<Event> event = nullptr;
    if (id == PROGRESS_EVENT)
        event = ProgressEvent::create(eventType, true, progressDone, progressTotal);
    else if (id == ERROR_EVENT)
        event = ApplicationCacheErrorEvent::create(errorReason, errorURL, errorStatus, errorMessage);
    else
        event = Event::create(eventType);
    m_domApplicationCache->dispatchEvent(event, ASSERT_NO_EXCEPTION);
    visitor->trace(m_documentLoader);
    class ApplicationCacheHost final : public GarbageCollectedFinalized<ApplicationCacheHost>, public WebApplicationCacheHostClient {
        static ApplicationCacheHost* create(DocumentLoader* loader)
            return new ApplicationCacheHost(loader);
        virtual ~ApplicationCacheHost();
        void detachFromDocumentLoader();
        WeakMember<ApplicationCache> m_domApplicationCache;
        RawPtrWillBeMember<DocumentLoader> m_documentLoader;
PassRefPtrWillBeRawPtr<DocumentLoader> FrameLoaderClientImpl::createDocumentLoader(LocalFrame* frame, const ResourceRequest& request, const SubstituteData& data)
    RefPtrWillBeRawPtr<WebDataSourceImpl> ds = WebDataSourceImpl::create(frame, request, data);
    virtual PassRefPtrWillBeRawPtr<DocumentLoader> createDocumentLoader(LocalFrame*, const ResourceRequest&, const SubstituteData&) override;
PassRefPtrWillBeRawPtr<WebDataSourceImpl> WebDataSourceImpl::create(LocalFrame* frame, const ResourceRequest& request, const SubstituteData& data)
    return adoptRefWillBeNoop(new WebDataSourceImpl(frame, request, data));
    // Verify that detachFromFrame() has been called.
    ASSERT(!m_extraData);
}

void WebDataSourceImpl::detachFromFrame()
{
    RefPtrWillBeRawPtr<DocumentLoader> protect(this);

    DocumentLoader::detachFromFrame();
    m_extraData.clear();
    m_pluginLoadObserver.clear();
}

DEFINE_TRACE(WebDataSourceImpl)
{
    DocumentLoader::trace(visitor);
#include "platform/heap/Handle.h"
    static PassRefPtrWillBeRawPtr<WebDataSourceImpl> create(LocalFrame*, const ResourceRequest&, const SubstituteData&);
    DECLARE_VIRTUAL_TRACE();

    virtual void detachFromFrame() override;
#include "chrome/browser/ui/views/color_chooser_aura.h"

#if !defined(OS_WIN)
#endif  // OS_WIN
// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_UI_VIEWS_COLOR_CHOOSER_AURA_H_
#define CHROME_BROWSER_UI_VIEWS_COLOR_CHOOSER_AURA_H_

#include "base/basictypes.h"
#include "base/compiler_specific.h"
#include "content/public/browser/color_chooser.h"
#include "ui/views/color_chooser/color_chooser_listener.h"

namespace content {
class WebContents;
}

namespace views {
class ColorChooserView;
class Widget;
}

// TODO(mukai): rename this as -Ash and move to c/b/ui/ash after Linux-aura
// switches to its native color chooser.
class ColorChooserAura : public content::ColorChooser,
                         public views::ColorChooserListener {
 public:
  static ColorChooserAura* Open(content::WebContents* web_contents,
                                SkColor initial_color);

 private:
  static ColorChooserAura* current_color_chooser_;

  ColorChooserAura(content::WebContents* web_contents, SkColor initial_color);

  // content::ColorChooser overrides:
  virtual void End() OVERRIDE;
  virtual void SetSelectedColor(SkColor color) OVERRIDE;

  // views::ColorChooserListener overrides:
  virtual void OnColorChosen(SkColor color) OVERRIDE;
  virtual void OnColorChooserDialogClosed() OVERRIDE;

  void DidEndColorChooser();

  // The actual view of the color chooser.  No ownership because its parent
  // view will take care of its lifetime.
  views::ColorChooserView* view_;

  // The widget for the color chooser.  No ownership because it's released
  // automatically when closed.
  views::Widget* widget_;

  // The web contents invoking the color chooser.  No ownership because it will
  // outlive this class.
  content::WebContents* web_contents_;

  DISALLOW_COPY_AND_ASSIGN(ColorChooserAura);
};

#endif  // CHROME_BROWSER_UI_VIEWS_COLOR_CHOOSER_AURA_H_
#include "ui/views/win/hwnd_util.h"
  HWND owning_hwnd = views::HWNDForNativeWindow(owning_window);
  ExecuteOpenParams execute_params(initial_color, BeginRun(owning_hwnd),
                                   owning_hwnd);
bool ColorChooserDialog::IsRunning(gfx::NativeWindow owning_window) const {
  return listener_ && IsRunningDialogForOwner(
      views::HWNDForNativeWindow(owning_window));
  virtual bool IsRunning(gfx::NativeWindow owning_window) const OVERRIDE;
#include "chrome/browser/ui/host_desktop.h"
#include "content/public/browser/web_contents_view.h"
#if defined(USE_ASH)
#include "chrome/browser/ui/views/color_chooser_aura.h"
#endif

#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();
  if (GetHostDesktopTypeForNativeView(native_view) == HOST_DESKTOP_TYPE_ASH)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  if (!lock.valid())
    return;
  if (!lock.valid())
    return;
  if (!lock.valid())
    return;
    if (!lock.valid())
      return;
      has_shared_bitmap_id(false),
      has_shared_bitmap_id(false),
      has_shared_bitmap_id(!!bitmap),
  if (bitmap)
    shared_bitmap_id = bitmap->id();
}

ResourceProvider::Resource::Resource(const SharedBitmapId& bitmap_id,
                                     const gfx::Size& size,
                                     Origin origin,
                                     GLenum filter,
                                     GLint wrap_mode)
    : child_id(0),
      gl_id(0),
      gl_pixel_buffer_id(0),
      gl_upload_query_id(0),
      pixels(NULL),
      pixel_buffer(NULL),
      lock_for_read_count(0),
      imported_count(0),
      exported_count(0),
      locked_for_write(false),
      origin(origin),
      marked_for_deletion(false),
      pending_set_pixels(false),
      set_pixels_completion_forced(false),
      allocated(false),
      enable_read_lock_fences(false),
      read_lock_fence(NULL),
      size(size),
      target(0),
      original_filter(filter),
      filter(filter),
      image_id(0),
      bound_image_id(0),
      dirty_image(false),
      texture_pool(0),
      wrap_mode(wrap_mode),
      lost(false),
      hint(TextureUsageAny),
      type(Bitmap),
      format(RGBA_8888),
      has_shared_bitmap_id(true),
      shared_bitmap_id(bitmap_id),
      shared_bitmap(NULL) {
  DCHECK(wrap_mode == GL_CLAMP_TO_EDGE || wrap_mode == GL_REPEAT);
  if (!resource->pixels && resource->has_shared_bitmap_id &&
      shared_bitmap_manager_) {
    scoped_ptr<SharedBitmap> bitmap =
        shared_bitmap_manager_->GetSharedBitmapFromId(
            resource->size, resource->shared_bitmap_id);
    if (bitmap) {
      resource->shared_bitmap = bitmap.release();
      resource->pixels = resource->shared_bitmap->pixels();
    }
  }

  DCHECK(valid());
    if ((!it->is_software && !gl) ||
        (it->is_software && !shared_bitmap_manager_)) {
      resource = Resource(it->mailbox_holder.mailbox,
      DCHECK(!resource->has_shared_bitmap_id);
    resource->mailbox_holder.mailbox = source->shared_bitmap_id;
#include "cc/resources/shared_bitmap.h"
    const SkBitmap* sk_bitmap() const {
      DCHECK(valid());
      return &sk_bitmap_;
    }
    bool valid() const { return !!sk_bitmap_.getPixels(); }

    bool valid() const { return !!sk_bitmap_.getPixels(); }
    Resource(const SharedBitmapId& bitmap_id,
             const gfx::Size& size,
             Origin origin,
             GLenum filter,
             GLint wrap_mode);
    bool has_shared_bitmap_id;
    SharedBitmapId shared_bitmap_id;
  EXPECT_EQ(1u, resource_provider_->num_resources());
  EXPECT_EQ(0u, returned_to_child.size());

  EXPECT_NE(0u, mapped_id1);
  {
    ResourceProvider::ScopedReadLockSoftware lock(resource_provider_.get(),
                                                  mapped_id1);
    EXPECT_FALSE(lock.valid());
  }
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/spdy/spdy_frame_producer.h"

#include "base/logging.h"
#include "net/spdy/spdy_protocol.h"

namespace net {

SpdyFrameProducer::SpdyFrameProducer() {}

SpdyFrameProducer::~SpdyFrameProducer() {}

SimpleFrameProducer::SimpleFrameProducer(scoped_ptr<SpdyFrame> frame)
    : frame_(frame.Pass()) {}

SimpleFrameProducer::~SimpleFrameProducer() {}

scoped_ptr<SpdyFrame> SimpleFrameProducer::ProduceFrame() {
  DCHECK(frame_);
  return frame_.Pass();
}

}  // namespace net
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef NET_SPDY_SPDY_FRAME_PRODUCER_H_
#define NET_SPDY_SPDY_FRAME_PRODUCER_H_

#include "base/basictypes.h"
#include "base/compiler_specific.h"
#include "base/memory/scoped_ptr.h"
#include "net/base/net_export.h"

namespace net {

class SpdyFrame;

// An object which provides a SpdyFrame for writing. We pass these
// around instead of SpdyFrames since some frames have to be generated
// "just in time".
class NET_EXPORT_PRIVATE SpdyFrameProducer {
 public:
  SpdyFrameProducer();

  // Produces the frame to be written. Will be called at most once.
  virtual scoped_ptr<SpdyFrame> ProduceFrame() = 0;

  virtual ~SpdyFrameProducer();

 private:
  DISALLOW_COPY_AND_ASSIGN(SpdyFrameProducer);
};

// A simple wrapper around a single SpdyFrame.
class NET_EXPORT_PRIVATE SimpleFrameProducer : public SpdyFrameProducer {
 public:
  explicit SimpleFrameProducer(scoped_ptr<SpdyFrame> frame);

  virtual ~SimpleFrameProducer();

  virtual scoped_ptr<SpdyFrame> ProduceFrame() OVERRIDE;

 private:
  scoped_ptr<SpdyFrame> frame_;

  DISALLOW_COPY_AND_ASSIGN(SimpleFrameProducer);
};

}  // namespace net

#endif  // NET_SPDY_SPDY_FRAME_PRODUCER_H_
SpdyIOBuffer::SpdyIOBuffer() {}
SpdyIOBuffer::SpdyIOBuffer(IOBuffer* buffer, int size, SpdyStream* stream)
  : buffer_(new DrainableIOBuffer(buffer, size)), stream_(stream) {}
void SpdyIOBuffer::Swap(SpdyIOBuffer* other) {
  buffer_.swap(other->buffer_);
  stream_.swap(other->stream_);
}

void SpdyIOBuffer::Release() {
// A class for managing SPDY write buffers.  These write buffers need
// to track the SpdyStream which they are associated with so that the
// session can activate the stream lazily and also notify the stream
// on completion of the write.
  SpdyIOBuffer();

  // |stream| is a pointer to the stream which is managing this buffer
  // (can be NULL if the write is for the session itself).
  SpdyIOBuffer(IOBuffer* buffer, int size, SpdyStream* stream);



  void Swap(SpdyIOBuffer* other);

  void Release();

#include "net/spdy/spdy_frame_producer.h"
  for (int i = 0; i < NUM_PRIORITIES; ++i) {
void SpdySession::EnqueueStreamWrite(
    SpdyStream* stream,
    scoped_ptr<SpdyFrameProducer> producer) {
  EnqueueWrite(stream->priority(), producer.Pass(), stream);
}

scoped_ptr<SpdyFrame> SpdySession::CreateSynStream(
  return syn_frame.Pass();
int SpdySession::CreateCredentialFrame(
    RequestPriority priority,
    scoped_ptr<SpdyFrame>* credential_frame) {
  DCHECK_NE(rv, ERR_IO_PENDING);
    return rv;
  credential_frame->reset(
  return OK;
scoped_ptr<SpdyFrame> SpdySession::CreateHeadersFrame(
  return frame.Pass();
scoped_ptr<SpdyFrame> SpdySession::CreateDataFrame(SpdyStreamId stream_id,
                                                   net::IOBuffer* data,
                                                   int len,
                                                   SpdyDataFlags flags) {
    return scoped_ptr<SpdyFrame>();
      return scoped_ptr<SpdyFrame>();
        return scoped_ptr<SpdyFrame>();
  return frame.Pass();
  EnqueueSessionWrite(priority, rst_frame.Pass());
  DCHECK_GT(in_flight_write_.buffer()->BytesRemaining(), 0);
  if (result < 0) {
    in_flight_write_.Release();
    CloseSessionOnError(static_cast<net::Error>(result), true, "Write error");
    return;
  }
  // It should not be possible to have written more bytes than our
  // in_flight_write_.
  DCHECK_LE(result, in_flight_write_.buffer()->BytesRemaining());
  in_flight_write_.buffer()->DidConsume(result);
  // We only notify the stream when we've fully written the pending frame.
  if (in_flight_write_.buffer()->BytesRemaining() == 0) {
    DCHECK_GT(result, 0);

    scoped_refptr<SpdyStream> stream = in_flight_write_.stream();

    // It is possible that the stream was cancelled while we were writing
    // to the socket.
    if (stream && !stream->cancelled()) {
      // Report the number of bytes written to the caller, but exclude the
      // frame size overhead.  NOTE: if this frame was compressed the
      // reported bytes written is the compressed size, not the original
      // size.
      result = in_flight_write_.buffer()->size();
      DCHECK_GE(result,
                static_cast<int>(
                    buffered_spdy_framer_->GetControlFrameHeaderSize()));
      result -= buffered_spdy_framer_->GetControlFrameHeaderSize();

      stream->OnWriteComplete(result);
    }

    // Cleanup the write which just completed.
    in_flight_write_.Release();

  // Write more data.  We're already in a continuation, so we can go
  // ahead and write it immediately (without going back to the message
  // loop).
  WriteSocketLater();
  while (true) {
    if (in_flight_write_.buffer()) {
      DCHECK_GT(in_flight_write_.buffer()->BytesRemaining(), 0);
    } else {
      // Grab the next frame to send.
      scoped_ptr<SpdyFrameProducer> producer;
      scoped_refptr<SpdyStream> stream;
      if (!write_queue_.Dequeue(&producer, &stream))
        break;

      if (stream.get() && stream->cancelled())
      if (stream.get() && stream->stream_id() == 0)
        ActivateStream(stream);

      scoped_ptr<SpdyFrame> frame = producer->ProduceFrame();
      if (!frame) {
        NOTREACHED();
        continue;
      }
      DCHECK_GT(frame->size(), 0u);

      // TODO(mbelshe): We have too much copying of data here.
      scoped_refptr<IOBufferWithSize> buffer =
          new IOBufferWithSize(frame->size());
      memcpy(buffer->data(), frame->data(), frame->size());
      in_flight_write_ = SpdyIOBuffer(buffer, frame->size(), stream);
  write_queue_.Clear();
void SpdySession::EnqueueSessionWrite(RequestPriority priority,
                                      scoped_ptr<SpdyFrame> frame) {
  EnqueueWrite(
      priority,
      scoped_ptr<SpdyFrameProducer>(new SimpleFrameProducer(frame.Pass())),
      NULL);
}
void SpdySession::EnqueueWrite(RequestPriority priority,
                               scoped_ptr<SpdyFrameProducer> producer,
                               const scoped_refptr<SpdyStream>& stream) {
  write_queue_.Enqueue(priority, producer.Pass(), stream);
    for (PushedStreamMap::iterator it = unclaimed_pushed_streams_.begin();
  ActiveStreamMap::iterator it = active_streams_.find(id);
  if (it == active_streams_.end())
  const scoped_refptr<SpdyStream> stream(it->second);
  active_streams_.erase(it);
  DCHECK(stream);

  write_queue_.RemovePendingWritesForStream(stream);
  EnqueueSessionWrite(HIGHEST, settings_frame.Pass());
  EnqueueSessionWrite(priority, window_update_frame.Pass());
  EnqueueSessionWrite(HIGHEST, ping_frame.Pass());
#include "base/memory/scoped_ptr.h"
#include "net/base/net_export.h"
#include "net/spdy/spdy_write_queue.h"
  // Pushes the given producer into the write queue for
  // |stream|. |stream| is guaranteed to be activated before the
  // producer is used to produce its frame.
  void EnqueueStreamWrite(SpdyStream* stream,
                          scoped_ptr<SpdyFrameProducer> producer);
  // Creates and returns a SYN frame for |stream_id|.
  scoped_ptr<SpdyFrame> CreateSynStream(
  // Tries to create a CREDENTIAL frame. If successful, fills in
  // |credential_frame| and returns OK. Returns the error (guaranteed
  // to not be ERR_IO_PENDING) otherwise.
  int CreateCredentialFrame(const std::string& origin,
                            SSLClientCertType type,
                            const std::string& key,
                            const std::string& cert,
                            RequestPriority priority,
                            scoped_ptr<SpdyFrame>* credential_frame);

  // Creates and returns a HEADERS frame.
  scoped_ptr<SpdyFrame> CreateHeadersFrame(SpdyStreamId stream_id,
                                           const SpdyHeaderBlock& headers,
                                           SpdyControlFlags flags);

  // Creates and returns a data frame. May return NULL if stalled by
  // flow control.
  scoped_ptr<SpdyFrame> CreateDataFrame(SpdyStreamId stream_id,
                                        net::IOBuffer* data,
                                        int len,
                                        SpdyDataFlags flags);
  // Pushes the given frame with the given priority into the write
  // queue for the session.
  void EnqueueSessionWrite(RequestPriority priority,
                           scoped_ptr<SpdyFrame> frame);

  // Puts |producer| associated with |stream| onto the write queue
  // with the given priority.
  void EnqueueWrite(RequestPriority priority,
                    scoped_ptr<SpdyFrameProducer> producer,
                    const scoped_refptr<SpdyStream>& stream);
  // The write queue.
  SpdyWriteQueue write_queue_;
#include "net/spdy/spdy_frame_producer.h"
// A wrapper around a stream that calls into ProduceSynStreamFrame().
class SpdyStream::SynStreamFrameProducer : public SpdyFrameProducer {
 public:
  SynStreamFrameProducer(const base::WeakPtr<SpdyStream>& stream)
      : stream_(stream) {
    DCHECK(stream_);
  }

  virtual ~SynStreamFrameProducer() {}

  virtual scoped_ptr<SpdyFrame> ProduceFrame() OVERRIDE {
    if (!stream_) {
      NOTREACHED();
      return scoped_ptr<SpdyFrame>();
    }
    DCHECK_GT(stream_->stream_id(), 0u);
    return stream_->ProduceSynStreamFrame();
  }

 private:
  const base::WeakPtr<SpdyStream> stream_;
};

// A wrapper around a stream that calls into ProduceHeaderFrame() with
// a given header block.
class SpdyStream::HeaderFrameProducer : public SpdyFrameProducer {
 public:
  HeaderFrameProducer(const base::WeakPtr<SpdyStream>& stream,
                      scoped_ptr<SpdyHeaderBlock> headers)
      : stream_(stream),
        headers_(headers.Pass()) {
    DCHECK(stream_);
    DCHECK(headers_);
  }

  virtual ~HeaderFrameProducer() {}

  virtual scoped_ptr<SpdyFrame> ProduceFrame() OVERRIDE {
    if (!stream_) {
      NOTREACHED();
      return scoped_ptr<SpdyFrame>();
    }
    DCHECK_GT(stream_->stream_id(), 0u);
    return stream_->ProduceHeaderFrame(headers_.Pass());
  }

 private:
  const base::WeakPtr<SpdyStream> stream_;
  scoped_ptr<SpdyHeaderBlock> headers_;
};

scoped_ptr<SpdyFrame> SpdyStream::ProduceSynStreamFrame() {
  CHECK_EQ(io_state_, STATE_SEND_HEADERS_COMPLETE);
  CHECK(request_.get());
  CHECK_GT(stream_id_, 0u);

  SpdyControlFlags flags =
      has_upload_data_ ? CONTROL_FLAG_NONE : CONTROL_FLAG_FIN;
  scoped_ptr<SpdyFrame> frame(session_->CreateSynStream(
      stream_id_, priority_, slot_, flags, *request_));
  send_time_ = base::TimeTicks::Now();
  return frame.Pass();
}

scoped_ptr<SpdyFrame> SpdyStream::ProduceHeaderFrame(
    scoped_ptr<SpdyHeaderBlock> header_block) {
  CHECK(!cancelled());
  // We must need to write stream data.
  // Until the headers have been completely sent, we can not be sure
  // that our stream_id is correct.
  DCHECK_GT(io_state_, STATE_SEND_HEADERS_COMPLETE);
  DCHECK_GT(stream_id_, 0u);

  // Create actual HEADERS frame just in time because it depends on
  // compression context and should not be reordered after the creation.
  scoped_ptr<SpdyFrame> header_frame(session_->CreateHeadersFrame(
      stream_id_, *header_block, SpdyControlFlags()));
  return header_frame.Pass();
}

  waiting_completions_.push_back(TYPE_HEADERS);
  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(
          new HeaderFrameProducer(
              weak_ptr_factory_.GetWeakPtr(), headers.Pass())));
  CHECK(!cancelled());
  waiting_completions_.push_back(TYPE_DATA);
  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(
          new SimpleFrameProducer(data_frame.Pass())));
      // OnDataReceived, OnClose and OnWriteComplete can be called.

  std::string origin = GetUrl().GetOrigin().spec();
  DCHECK(origin[origin.length() - 1] == '/');
  origin.erase(origin.length() - 1);  // Trim trailing slash.
  scoped_ptr<SpdyFrame> frame;
  int rv = session_->CreateCredentialFrame(
      origin, domain_bound_cert_type_, domain_bound_private_key_,
      domain_bound_cert_, priority_, &frame);
  if (rv != OK) {
    DCHECK_NE(rv, ERR_IO_PENDING);
    return rv;
  }

  DCHECK(frame);
  // TODO(akalin): Fix a couple of race conditions:
  //
  // 1) Since this counts as a write for this stream, the stream will
  // be activated (and hence allocated a stream ID) before this frame
  // is sent, even though the ID should only be activated for the
  // SYN_STREAM frame. This can be solved by signalling to the session
  // when we're sending a SYN_STREAM frame, and have it only activate
  // the stream then.
  //
  // 2) Since this is decoupled from sending the SYN_STREAM frame, it
  // is possible that other domain-bound cert frames will clobber ours
  // before our SYN_STREAM frame gets sent. This can be solved by
  // immediately enqueueing the SYN_STREAM frame here and adjusting
  // the state machine appropriately.
  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(new SimpleFrameProducer(frame.Pass())));

  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(
          new SynStreamFrameProducer(weak_ptr_factory_.GetWeakPtr())));
#include <deque>
  class SynStreamFrameProducer;
  class HeaderFrameProducer;
  // Produces the SYN_STREAM frame for the stream. The stream must
  // already be activated.
  scoped_ptr<SpdyFrame> ProduceSynStreamFrame();
  // Produce the initial HEADER frame for the stream with the given
  // block. The stream must already be activated.
  scoped_ptr<SpdyFrame> ProduceHeaderFrame(
      scoped_ptr<SpdyHeaderBlock> header_block);
  // An in order list of sending frame types. Used communicate to the
  // delegate which type of frame was sent in DoOpen().
  //
  // TODO(akalin): We can remove the need for this queue if we add an
  // OnFrameSent() callback to SpdyFrameProducer and have the session
  // call that instead of SpdyStream::OnWriteComplete().
  std::deque<FrameType> waiting_completions_;
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/spdy/spdy_write_queue.h"

#include <cstddef>

#include "base/logging.h"
#include "net/spdy/spdy_frame_producer.h"
#include "net/spdy/spdy_stream.h"

namespace net {

SpdyWriteQueue::PendingWrite::PendingWrite() : frame_producer(NULL) {}

SpdyWriteQueue::PendingWrite::PendingWrite(
    SpdyFrameProducer* frame_producer,
    const scoped_refptr<SpdyStream>& stream)
    : frame_producer(frame_producer),
      stream(stream) {}

SpdyWriteQueue::PendingWrite::~PendingWrite() {}

SpdyWriteQueue::SpdyWriteQueue() {}

SpdyWriteQueue::~SpdyWriteQueue() {
  Clear();
}

void SpdyWriteQueue::Enqueue(RequestPriority priority,
                             scoped_ptr<SpdyFrameProducer> frame_producer,
                             const scoped_refptr<SpdyStream>& stream) {
  if (stream.get()) {
    DCHECK_EQ(stream->priority(), priority);
  }
  queue_[priority].push_back(PendingWrite(frame_producer.release(), stream));
}

bool SpdyWriteQueue::Dequeue(scoped_ptr<SpdyFrameProducer>* frame_producer,
                             scoped_refptr<SpdyStream>* stream) {
  for (int i = NUM_PRIORITIES - 1; i >= 0; --i) {
    if (!queue_[i].empty()) {
      PendingWrite pending_write = queue_[i].front();
      queue_[i].pop_front();
      frame_producer->reset(pending_write.frame_producer);
      *stream = pending_write.stream;
      return true;
    }
  }
  return false;
}

void SpdyWriteQueue::RemovePendingWritesForStream(
    const scoped_refptr<SpdyStream>& stream) {
  DCHECK(stream.get());
  if (DCHECK_IS_ON()) {
    // |stream| should not have pending writes in a queue not matching
    // its priority.
    for (int i = 0; i < NUM_PRIORITIES; ++i) {
      if (stream->priority() == i)
        continue;
      for (std::deque<PendingWrite>::const_iterator it = queue_[i].begin();
           it != queue_[i].end(); ++it) {
        DCHECK_NE(it->stream, stream);
      }
    }
  }

  // Do the actual deletion and removal, preserving FIFO-ness.
  std::deque<PendingWrite>* queue = &queue_[stream->priority()];
  std::deque<PendingWrite>::iterator out_it = queue->begin();
  for (std::deque<PendingWrite>::const_iterator it = queue->begin();
       it != queue->end(); ++it) {
    if (it->stream == stream) {
      delete it->frame_producer;
    } else {
      *out_it = *it;
      ++out_it;
    }
  }
  queue->erase(out_it, queue->end());
}

void SpdyWriteQueue::Clear() {
  for (int i = 0; i < NUM_PRIORITIES; ++i) {
    for (std::deque<PendingWrite>::iterator it = queue_[i].begin();
         it != queue_[i].end(); ++it) {
      delete it->frame_producer;
    }
    queue_[i].clear();
  }
}

}  // namespace net
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef NET_SPDY_SPDY_WRITE_QUEUE_H_
#define NET_SPDY_SPDY_WRITE_QUEUE_H_

#include <deque>

#include "base/basictypes.h"
#include "base/memory/ref_counted.h"
#include "base/memory/scoped_ptr.h"
#include "net/base/net_export.h"
#include "net/base/request_priority.h"

namespace net {

class SpdyFrameProducer;
class SpdyStream;

// A queue of SpdyFrameProducers to produce frames to write. Ordered
// by priority, and then FIFO.
class NET_EXPORT_PRIVATE SpdyWriteQueue {
 public:
  SpdyWriteQueue();
  ~SpdyWriteQueue();

  // Enqueues the given frame producer at the given priority
  // associated with the given stream, which may be NULL if the frame
  // producer is not associated with a stream. If |stream| is
  // non-NULL, its priority must be equal to |priority|.
  void Enqueue(RequestPriority priority,
               scoped_ptr<SpdyFrameProducer> frame_producer,
               const scoped_refptr<SpdyStream>& stream);

  // Dequeues the frame producer with the highest priority that was
  // enqueued the earliest and its associated stream. Returns true and
  // fills in |frame_producer| and |stream| if successful --
  // otherwise, just returns false.
  bool Dequeue(scoped_ptr<SpdyFrameProducer>* frame_producer,
               scoped_refptr<SpdyStream>* stream);

  // Removes all pending writes for the given stream, which must be
  // non-NULL.
  void RemovePendingWritesForStream(const scoped_refptr<SpdyStream>& stream);

  // Removes all pending writes.
  void Clear();

 private:
  // A struct holding a frame producer and its associated stream.
  struct PendingWrite {
    // This has to be a raw pointer since we store this in an STL
    // container.
    SpdyFrameProducer* frame_producer;
    scoped_refptr<SpdyStream> stream;

    PendingWrite();
    PendingWrite(SpdyFrameProducer* frame_producer,
                 const scoped_refptr<SpdyStream>& stream);
    ~PendingWrite();
  };

  // The actual write queue, binned by priority.
  std::deque<PendingWrite> queue_[NUM_PRIORITIES];

  DISALLOW_COPY_AND_ASSIGN(SpdyWriteQueue);
};

}  // namespace net

#endif  // NET_SPDY_SPDY_WRITE_QUEUE_H_
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/spdy/spdy_write_queue.h"

#include <cstddef>
#include <cstring>
#include <string>

#include "base/basictypes.h"
#include "base/memory/ref_counted.h"
#include "base/memory/scoped_ptr.h"
#include "base/strings/string_number_conversions.h"
#include "net/base/net_log.h"
#include "net/base/request_priority.h"
#include "net/spdy/spdy_frame_producer.h"
#include "net/spdy/spdy_stream.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace net {

namespace {

class SpdyWriteQueueTest : public ::testing::Test {};

// Makes a SpdyFrameProducer producing a frame with the data in the
// given string.
scoped_ptr<SpdyFrameProducer> StringToProducer(const std::string& s) {
  scoped_ptr<char[]> data(new char[s.size()]);
  std::memcpy(data.get(), s.data(), s.size());
  return scoped_ptr<SpdyFrameProducer>(
      new SimpleFrameProducer(
          scoped_ptr<SpdyFrame>(
              new SpdyFrame(data.release(), s.size(), true))));
}

// Makes a SpdyFrameProducer producing a frame with the data in the
// given int (converted to a string).
scoped_ptr<SpdyFrameProducer> IntToProducer(int i) {
  return StringToProducer(base::IntToString(i));
}

// Produces a frame with the given producer and returns a copy of its
// data as a string.
std::string ProducerToString(scoped_ptr<SpdyFrameProducer> producer) {
  scoped_ptr<SpdyFrame> frame = producer->ProduceFrame();
  return std::string(frame->data(), frame->size());
}

// Produces a frame with the given producer and returns a copy of its
// data as an int (converted from a string).
int ProducerToInt(scoped_ptr<SpdyFrameProducer> producer) {
  int i = 0;
  EXPECT_TRUE(base::StringToInt(ProducerToString(producer.Pass()), &i));
  return i;
}

// Makes a SpdyStream with the given priority and a NULL SpdySession
// -- be careful to not call any functions that expect the session to
// be there.
SpdyStream* MakeTestStream(RequestPriority priority) {
  return new SpdyStream(NULL, "", priority, 0, 0, false, BoundNetLog());
}

// Add some frame producers of different priority. The producers
// should be dequeued in priority order with their associated stream.
TEST_F(SpdyWriteQueueTest, DequeuesByPriority) {
  SpdyWriteQueue write_queue;

  scoped_ptr<SpdyFrameProducer> producer_low = StringToProducer("LOW");
  scoped_ptr<SpdyFrameProducer> producer_medium = StringToProducer("MEDIUM");
  scoped_ptr<SpdyFrameProducer> producer_highest = StringToProducer("HIGHEST");

  // A NULL stream should still work.
  scoped_refptr<SpdyStream> stream_low(NULL);
  scoped_refptr<SpdyStream> stream_medium(MakeTestStream(MEDIUM));
  scoped_refptr<SpdyStream> stream_highest(MakeTestStream(HIGHEST));

  write_queue.Enqueue(LOW, producer_low.Pass(), stream_low);
  write_queue.Enqueue(MEDIUM, producer_medium.Pass(), stream_medium);
  write_queue.Enqueue(HIGHEST, producer_highest.Pass(), stream_highest);

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ("HIGHEST", ProducerToString(frame_producer.Pass()));
  EXPECT_EQ(stream_highest, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ("MEDIUM", ProducerToString(frame_producer.Pass()));
  EXPECT_EQ(stream_medium, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ("LOW", ProducerToString(frame_producer.Pass()));
  EXPECT_EQ(stream_low, stream);

  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

// Add some frame producers with the same priority. The producers
// should be dequeued in FIFO order with their associated stream.
TEST_F(SpdyWriteQueueTest, DequeuesFIFO) {
  SpdyWriteQueue write_queue;

  scoped_ptr<SpdyFrameProducer> producer1 = IntToProducer(1);
  scoped_ptr<SpdyFrameProducer> producer2 = IntToProducer(2);
  scoped_ptr<SpdyFrameProducer> producer3 = IntToProducer(3);

  scoped_refptr<SpdyStream> stream1(MakeTestStream(DEFAULT_PRIORITY));
  scoped_refptr<SpdyStream> stream2(MakeTestStream(DEFAULT_PRIORITY));
  scoped_refptr<SpdyStream> stream3(MakeTestStream(DEFAULT_PRIORITY));

  write_queue.Enqueue(DEFAULT_PRIORITY, producer1.Pass(), stream1);
  write_queue.Enqueue(DEFAULT_PRIORITY, producer2.Pass(), stream2);
  write_queue.Enqueue(DEFAULT_PRIORITY, producer3.Pass(), stream3);

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ(1, ProducerToInt(frame_producer.Pass()));
  EXPECT_EQ(stream1, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ(2, ProducerToInt(frame_producer.Pass()));
  EXPECT_EQ(stream2, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ(3, ProducerToInt(frame_producer.Pass()));
  EXPECT_EQ(stream3, stream);

  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

// Enqueue a bunch of writes and then call
// RemovePendingWritesForStream() on one of the streams. No dequeued
// write should be for that stream.
TEST_F(SpdyWriteQueueTest, RemovePendingWritesForStream) {
  SpdyWriteQueue write_queue;

  scoped_refptr<SpdyStream> stream1(MakeTestStream(DEFAULT_PRIORITY));
  scoped_refptr<SpdyStream> stream2(MakeTestStream(DEFAULT_PRIORITY));

  for (int i = 0; i < 100; ++i) {
    scoped_refptr<SpdyStream> stream = ((i % 3) == 0) ? stream1 : stream2;
    write_queue.Enqueue(DEFAULT_PRIORITY, IntToProducer(i), stream);
  }

  write_queue.RemovePendingWritesForStream(stream2);

  for (int i = 0; i < 100; i += 3) {
    scoped_ptr<SpdyFrameProducer> frame_producer;
    scoped_refptr<SpdyStream> stream;
    ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
    EXPECT_EQ(i, ProducerToInt(frame_producer.Pass()));
    EXPECT_EQ(stream1, stream);
  }

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

// Enqueue a bunch of writes and then call Clear(). The write queue
// should clean up the memory properly, and Dequeue() should return
// false.
TEST_F(SpdyWriteQueueTest, Clear) {
  SpdyWriteQueue write_queue;

  for (int i = 0; i < 100; ++i) {
    write_queue.Enqueue(DEFAULT_PRIORITY, IntToProducer(i), NULL);
  }

  write_queue.Clear();

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

}

}  // namespace net
    if (m_isExternalScript) {
        ScriptResource* resource = m_resource ? m_resource.get() : sourceCode.resource();
        if (resource && !resource->mimeTypeAllowedByNosniff()) {
            contextDocument->addConsoleMessage(SecurityMessageSource, ErrorMessageLevel, "Refused to execute script from '" + resource->url().elidedString() + "' because its MIME type ('" + resource->mimeType() + "') is not executable, and strict MIME type checking is enabled.");
            return;
        }
#include "chrome/browser/renderer_host/audio_sync_reader.h"
///////////////////////////////////////////////////////////////////////////////
// AudioRendererHost implementations.
AudioRendererHost::AudioRendererHost()
    : process_handle_(0),
      ipc_sender_(NULL) {
  // Increase the ref count of this object so it is active until we do
  // Release().
  AddRef();
AudioRendererHost::~AudioRendererHost() {
  DCHECK(ChromeThread::CurrentlyOn(ChromeThread::IO));
  DCHECK(audio_entries_.empty());
  // Make sure we received IPCChannelClosing() signal.
  DCHECK(!ipc_sender_);
  DCHECK(!process_handle_);
void AudioRendererHost::Destroy() {
  // Post a message to the thread where this object should live and do the
  // actual operations there.
  ChromeThread::PostTask(
      ChromeThread::IO, FROM_HERE,
      NewRunnableMethod(this, &AudioRendererHost::DoDestroy));
// Event received when IPC channel is connected to the renderer process.
void AudioRendererHost::IPCChannelConnected(int process_id,
                                            base::ProcessHandle process_handle,
                                            IPC::Message::Sender* ipc_sender) {
  DCHECK(ChromeThread::CurrentlyOn(ChromeThread::IO));
  process_handle_ = process_handle;
  ipc_sender_ = ipc_sender;
// Event received when IPC channel is closing.
void AudioRendererHost::IPCChannelClosing() {
  DCHECK(ChromeThread::CurrentlyOn(ChromeThread::IO));
  // Reset IPC related member variables.
  ipc_sender_ = NULL;
  process_handle_ = 0;
  // Since the IPC channel is gone, close all requested audio streams.
  DeleteEntries();
///////////////////////////////////////////////////////////////////////////////
// media::AudioController::EventHandler implementations.
void AudioRendererHost::OnCreated(media::AudioController* controller) {
  ChromeThread::PostTask(
      ChromeThread::IO, FROM_HERE,
      NewRunnableMethod(this, &AudioRendererHost::DoCompleteCreation,
                        controller));
void AudioRendererHost::OnPlaying(media::AudioController* controller) {
  ChromeThread::PostTask(
      ChromeThread::IO, FROM_HERE,
      NewRunnableMethod(this, &AudioRendererHost::DoSendPlayingMessage,
                        controller));
void AudioRendererHost::OnPaused(media::AudioController* controller) {
  ChromeThread::PostTask(
      ChromeThread::IO, FROM_HERE,
      NewRunnableMethod(this, &AudioRendererHost::DoSendPausedMessage,
                        controller));
void AudioRendererHost::OnError(media::AudioController* controller,
                                int error_code) {
  ChromeThread::PostTask(
      ChromeThread::IO, FROM_HERE,
      NewRunnableMethod(this, &AudioRendererHost::DoHandleError,
                        controller, error_code));
void AudioRendererHost::OnMoreData(media::AudioController* controller,
                                   base::Time timestamp,
                                   uint32 pending_bytes) {
  ChromeThread::PostTask(
      ChromeThread::IO, FROM_HERE,
      NewRunnableMethod(this, &AudioRendererHost::DoRequestMoreData,
                        controller, timestamp, pending_bytes));
void AudioRendererHost::DoCompleteCreation(media::AudioController* controller) {
  DCHECK(ChromeThread::CurrentlyOn(ChromeThread::IO));
  AudioEntry* entry = LookupByController(controller);
  if (!entry)
    return;
  if (!process_handle_) {
    NOTREACHED() << "Renderer process handle is invalid.";
    DeleteEntryOnError(entry);
  // Once the audio stream is created then complete the creation process by
  // mapping shared memory and sharing with the renderer process.
  base::SharedMemoryHandle foreign_memory_handle;
  if (!entry->shared_memory.ShareToProcess(process_handle_,
                                            &foreign_memory_handle)) {
    // If we failed to map and share the shared memory then close the audio
    // stream and send an error message.
    DeleteEntryOnError(entry);
    return;
  }
  if (entry->controller->LowLatencyMode()) {
    AudioSyncReader* reader =
        static_cast<AudioSyncReader*>(entry->reader.get());
#if defined(OS_WIN)
    base::SyncSocket::Handle foreign_socket_handle;
#else
    base::FileDescriptor foreign_socket_handle;
#endif
    // If we failed to prepare the sync socket for the renderer then we fail
    // the construction of audio stream.
    if (!reader->PrepareForeignSocketHandle(process_handle_,
                                            &foreign_socket_handle)) {
      DeleteEntryOnError(entry);
      return;
    }
    SendMessage(new ViewMsg_NotifyLowLatencyAudioStreamCreated(
        entry->render_view_id, entry->stream_id, foreign_memory_handle,
        foreign_socket_handle, entry->shared_memory.max_size()));
    return;
  // The normal audio stream has created, send a message to the renderer
  // process.
  SendMessage(new ViewMsg_NotifyAudioStreamCreated(
      entry->render_view_id, entry->stream_id, foreign_memory_handle,
      entry->shared_memory.max_size()));
void AudioRendererHost::DoSendPlayingMessage(
    media::AudioController* controller) {
  DCHECK(ChromeThread::CurrentlyOn(ChromeThread::IO));
  AudioEntry* entry = LookupByController(controller);
  if (!entry)
    return;

  ViewMsg_AudioStreamState_Params params;
  params.state = ViewMsg_AudioStreamState_Params::kPlaying;
  SendMessage(new ViewMsg_NotifyAudioStreamStateChanged(
      entry->render_view_id, entry->stream_id, params));
void AudioRendererHost::DoSendPausedMessage(
    media::AudioController* controller) {
  AudioEntry* entry = LookupByController(controller);
  if (!entry)
    return;

  ViewMsg_AudioStreamState_Params params;
  params.state = ViewMsg_AudioStreamState_Params::kPaused;
  SendMessage(new ViewMsg_NotifyAudioStreamStateChanged(
      entry->render_view_id, entry->stream_id, params));
void AudioRendererHost::DoRequestMoreData(media::AudioController* controller,
                                          base::Time timestamp,
                                          uint32 pending_bytes) {

  // If we already have a pending request then return.
  AudioEntry* entry = LookupByController(controller);
  if (!entry || entry->pending_buffer_request)
    return;

  DCHECK(!entry->controller->LowLatencyMode());
  entry->pending_buffer_request = true;
  SendMessage(
      new ViewMsg_RequestAudioPacket(
          entry->render_view_id,
          entry->stream_id,
          pending_bytes,
          timestamp.ToInternalValue()));
void AudioRendererHost::DoHandleError(media::AudioController* controller,
                                      int error_code) {

  AudioEntry* entry = LookupByController(controller);
  if (!entry)
    return;

  DeleteEntryOnError(entry);
///////////////////////////////////////////////////////////////////////////////
// IPC Messages handler
  DCHECK(LookupById(msg.routing_id(), stream_id) == NULL);
  if (audio_entries_.size() >= GetMaxAudioStreamsAllowed()) {
  // Select the hardwaer packet size if not specified.
  uint32 hardware_packet_size = params.packet_size;
  if (!hardware_packet_size) {
    hardware_packet_size = SelectHardwarePacketSize(params.channels,
                                                    params.sample_rate,
                                                    params.bits_per_sample);

  scoped_ptr<AudioEntry> entry(new AudioEntry());
  scoped_refptr<media::AudioController> controller = NULL;
  if (low_latency) {
    // If this is the low latency mode, we need to construct a SyncReader first.
    scoped_ptr<AudioSyncReader> reader(
        new AudioSyncReader(&entry->shared_memory));

    // Then try to initialize the sync reader.
    if (!reader->Init()) {
      SendErrorMessage(msg.routing_id(), stream_id);
      return;
    }

    // If we have successfully created the SyncReader then assign it to the
    // entry and construct an AudioController.
    entry->reader.reset(reader.release());
    controller =
        media::AudioController::CreateLowLatency(
            this, params.format, params.channels,
            params.sample_rate,
            params.bits_per_sample,
            hardware_packet_size,
            entry->reader.get());
  } else {
    // The choice of buffer capacity is based on experiment.
    controller =
        media::AudioController::Create(this, params.format, params.channels,
                                       params.sample_rate,
                                       params.bits_per_sample,
                                       hardware_packet_size,
                                       3 * hardware_packet_size);
  }

  if (!controller) {
    SendErrorMessage(msg.routing_id(), stream_id);
    return;
  }

  // If we have created the controller successfully create a entry and add it
  // to the map.
  entry->controller = controller;
  entry->render_view_id = msg.routing_id();
  entry->stream_id = stream_id;

  // Create the shared memory and share with the renderer process.
  if (!entry->shared_memory.Create(L"", false, false, hardware_packet_size) ||
      !entry->shared_memory.Map(entry->shared_memory.max_size())) {
    // If creation of shared memory failed then close the controller and
    // sends an error message.
    controller->Close();
    SendErrorMessage(msg.routing_id(), stream_id);
    return;
  }

  // If everything is successful then add it to the map.
  audio_entries_.insert(std::make_pair(
      AudioEntryId(msg.routing_id(), stream_id),
      entry.release()));

  AudioEntry* entry = LookupById(msg.routing_id(), stream_id);
  if (!entry) {
    return;

  entry->controller->Play();

  AudioEntry* entry = LookupById(msg.routing_id(), stream_id);
  if (!entry) {
    return;

  entry->controller->Pause();

  AudioEntry* entry = LookupById(msg.routing_id(), stream_id);
  if (!entry) {
    return;

  entry->controller->Flush();

  AudioEntry* entry = LookupById(msg.routing_id(), stream_id);

  // Note that closing an audio stream is a blocking operation. This call may
  // block the IO thread for up to 100ms.
  if (entry)
    DeleteEntry(entry);

  AudioEntry* entry = LookupById(msg.routing_id(), stream_id);
  if (!entry) {
    return;

  // Make sure the volume is valid.
  CHECK(volume >= 0 && volume <= 1.0);
  entry->controller->SetVolume(volume);
  NOTREACHED() << "This message shouldn't be received";
void AudioRendererHost::OnNotifyPacketReady(
    const IPC::Message& msg, int stream_id, uint32 packet_size) {

  AudioEntry* entry = LookupById(msg.routing_id(), stream_id);
  if (!entry) {
    return;
  }

  DCHECK(!entry->controller->LowLatencyMode());
  CHECK(packet_size <= entry->shared_memory.max_size());

  if (!entry->pending_buffer_request) {
    NOTREACHED() << "Buffer received but no such pending request";
  entry->pending_buffer_request = false;

  // If the audio packet is empty then don't enqueue to controller. This will
  // avoid excessive communication between browser and renderer when audio
  // data is depleted.
  if (!packet_size)
    return;

  // Enqueue the data to media::AudioController.
  entry->controller->EnqueueData(
      reinterpret_cast<uint8*>(entry->shared_memory.memory()),
      packet_size);
void AudioRendererHost::DoDestroy() {

  // Reset IPC releated members.

  // Close all audio streams.
  DeleteEntries();

void AudioRendererHost::SendMessage(IPC::Message* message) {

  if (ipc_sender_)
void AudioRendererHost::SendErrorMessage(int32 render_view_id,
                                         int32 stream_id) {
  ViewMsg_AudioStreamState_Params state;
  state.state = ViewMsg_AudioStreamState_Params::kError;
  SendMessage(new ViewMsg_NotifyAudioStreamStateChanged(
      render_view_id, stream_id, state));
void AudioRendererHost::DeleteEntries() {

  while (!audio_entries_.empty()) {
    DeleteEntry(audio_entries_.begin()->second);
  DCHECK(audio_entries_.empty());
void AudioRendererHost::DeleteEntry(AudioEntry* entry) {

  // Delete the entry when this method goes out of scope.
  scoped_ptr<AudioEntry> entry_deleter(entry);

  // Close the audio stream then remove the entry.
  entry->controller->Close();

  // Entry the entry from the map.
  audio_entries_.erase(
      AudioEntryId(entry->render_view_id, entry->stream_id));
void AudioRendererHost::DeleteEntryOnError(AudioEntry* entry) {
  DCHECK(ChromeThread::CurrentlyOn(ChromeThread::IO));

  // Sends the error message first before we close the stream because
  // |entry| is destroyed in DeleteEntry().
  SendErrorMessage(entry->render_view_id, entry->stream_id);
  DeleteEntry(entry);
AudioRendererHost::AudioEntry* AudioRendererHost::LookupById(
    int route_id, int stream_id) {
  DCHECK(ChromeThread::CurrentlyOn(ChromeThread::IO));

  AudioEntryMap::iterator i = audio_entries_.find(
      AudioEntryId(route_id, stream_id));
  if (i != audio_entries_.end())
    return i->second;
  return NULL;
AudioRendererHost::AudioEntry* AudioRendererHost::LookupByController(
    media::AudioController* controller) {
  DCHECK(ChromeThread::CurrentlyOn(ChromeThread::IO));

  // Iterate the map of entries.
  // TODO(hclam): Implement a faster look up method.
  for (AudioEntryMap::iterator i = audio_entries_.begin();
       i != audio_entries_.end(); ++i) {
    if (controller == i->second->controller.get())
      return i->second;
  return NULL;
// lives inside the render process and provide access to audio hardware.
#include "media/audio/audio_controller.h"
class AudioRendererHost : public base::RefCountedThreadSafe<
                              AudioRendererHost,
                              ChromeThread::DeleteOnIOThread>,
                          public media::AudioController::EventHandler {
  typedef std::pair<int32, int> AudioEntryId;

  struct AudioEntry {
    AudioEntry()
        : render_view_id(0),
          stream_id(0),
          pending_buffer_request(false) {
    }

    // The AudioController that manages the audio stream.
    scoped_refptr<media::AudioController> controller;

    // Render view ID that requested the audio stream.
    int32 render_view_id;

    // The audio stream ID in the render view.
    int stream_id;

    // Shared memory for transmission of the audio data.
    base::SharedMemory shared_memory;

    // The synchronous reader to be used by the controller. We have the
    // ownership of the reader.
    scoped_ptr<media::AudioController::SyncReader> reader;

    bool pending_buffer_request;
  };

  typedef std::map<AudioEntryId, AudioEntry*> AudioEntryMap;

  /////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////
  // AudioController::EventHandler implementations.
  virtual void OnCreated(media::AudioController* controller);
  virtual void OnPlaying(media::AudioController* controller);
  virtual void OnPaused(media::AudioController* controller);
  virtual void OnError(media::AudioController* controller, int error_code);
  virtual void OnMoreData(media::AudioController* controller,
                          base::Time timestamp,
                          uint32 pending_bytes);
  friend class ChromeThread;
  friend class DeleteTask<AudioRendererHost>;
  friend class MockAudioRendererHost;
  virtual ~AudioRendererHost();
  ////////////////////////////////////////////////////////////////////////////
  // required properties.
  // Play the audio stream referenced by |stream_id|.
  // Pause the audio stream referenced by |stream_id|.
  // Discard all audio data in  stream referenced by |stream_id|.
  // Close the audio stream referenced by |stream_id|.
  // Set the volume of the audio stream referenced by |stream_id|.
  // Get the volume of the audio stream referenced by |stream_id|.
  // Notify packet has been prepared for the audio stream.
  // Release all acquired resources and decrease reference to this object.
  void DoDestroy();

  // Complete the process of creating an audio stream. This will set up the
  // shared memory or shared socket in low latency mode.
  void DoCompleteCreation(media::AudioController* controller);

  // Send a state change message to the renderer.
  void DoSendPlayingMessage(media::AudioController* controller);
  void DoSendPausedMessage(media::AudioController* controller);

  // Request more data from the renderer. This method is used only in normal
  // latency mode.
  void DoRequestMoreData(media::AudioController* controller,
                         base::Time timestamp,
                         uint32 pending_bytes);

  // Handle error coming from audio stream.
  void DoHandleError(media::AudioController* controller, int error_code);

  // A helper method to send an IPC message to renderer process on IO thread.
  // This method is virtual for testing purpose.
  virtual void SendMessage(IPC::Message* message);

  // Send an error message to the renderer.
  void SendErrorMessage(int32 render_view_id, int32 stream_id);

  // Delete all audio entry and all audio streams
  void DeleteEntries();
  // Delete an audio entry and close the related audio stream.
  void DeleteEntry(AudioEntry* entry);
  // Delete audio entry and close the related audio stream due to an error,
  // and error message is send to the renderer.
  void DeleteEntryOnError(AudioEntry* entry);
  // A helper method to look up a AudioEntry with a tuple of render view
  // id and stream id. Returns NULL if not found.
  AudioEntry* LookupById(int render_view_id, int stream_id);
  // Search for a AudioEntry having the reference to |controller|.
  // This method is used to look up an AudioEntry after a controller
  // event is received.
  AudioEntry* LookupByController(media::AudioController* controller);
  AudioEntryMap audio_entries_;
#include "base/env_var.h"
#include "base/sync_socket.h"
#include "base/waitable_event.h"
#include "ipc/ipc_message_utils.h"
#include "media/audio/fake_audio_output_stream.h"
using ::testing::InvokeWithoutArgs;
static const int kInvalidId = -1;
static const int kRouteId = 200;
static const int kStreamId = 50;
static bool IsRunningHeadless() {
  scoped_ptr<base::EnvVarGetter> env(base::EnvVarGetter::Create());
  if (env->HasEnv("CHROME_HEADLESS"))
    return true;
  return false;
}
  MockAudioRendererHost() : shared_memory_length_(0) {
  }

  virtual ~MockAudioRendererHost() {
  MOCK_METHOD3(OnLowLatencyStreamCreated,
               void(int routing_id, int stream_id, int length));
  MOCK_METHOD2(OnStreamPlaying, void(int routing_id, int stream_id));
  MOCK_METHOD2(OnStreamPaused, void(int routing_id, int stream_id));
  MOCK_METHOD2(OnStreamError, void(int routing_id, int stream_id));
  uint32 shared_memory_length() { return shared_memory_length_; }
  base::SyncSocket* sync_socket() { return sync_socket_.get(); }

 private:
  virtual void SendMessage(IPC::Message* message) {
      IPC_MESSAGE_HANDLER(ViewMsg_NotifyLowLatencyAudioStreamCreated,
                          OnLowLatencyStreamCreated)
    shared_memory_.reset(new base::SharedMemory(handle, false));
    ASSERT_TRUE(shared_memory_->Map(length));
    ASSERT_TRUE(shared_memory_->memory());
    shared_memory_length_ = length;

    // And then delegate the call to the mock method.
    OnStreamCreated(msg.routing_id(), stream_id, length);
  }

  void OnLowLatencyStreamCreated(const IPC::Message& msg, int stream_id,
                               base::SharedMemoryHandle handle,
#if defined(OS_WIN)
                               base::SyncSocket::Handle socket_handle,
#else
                               base::FileDescriptor socket_descriptor,
#endif
                               uint32 length) {
    // Maps the shared memory.
    shared_memory_.reset(new base::SharedMemory(handle, false));
    shared_memory_length_ = length;

    // Create the SyncSocket using the handle.
    base::SyncSocket::Handle sync_socket_handle;
#if defined(OS_WIN)
    sync_socket_handle = socket_handle;
#else
    sync_socket_handle = socket_descriptor.fd;
#endif
    sync_socket_.reset(new base::SyncSocket(sync_socket_handle));
    OnLowLatencyStreamCreated(msg.routing_id(), stream_id, length);
                            const ViewMsg_AudioStreamState_Params& params) {
    if (params.state == ViewMsg_AudioStreamState_Params::kPlaying) {
      OnStreamPlaying(msg.routing_id(), stream_id);
    } else if (params.state == ViewMsg_AudioStreamState_Params::kPaused) {
      OnStreamPaused(msg.routing_id(), stream_id);
    } else if (params.state == ViewMsg_AudioStreamState_Params::kError) {
      OnStreamError(msg.routing_id(), stream_id);
    } else {
      FAIL() << "Unknown stream state";
    }
  scoped_ptr<base::SyncSocket> sync_socket_;
  uint32 shared_memory_length_;
ACTION_P(QuitMessageLoop, message_loop) {
  message_loop->PostTask(FROM_HERE, new MessageLoop::QuitTask());
}

      : mock_stream_(true) {

    // Simulate IPC channel connected.
    host_->IPCChannelConnected(base::GetCurrentProcId(),
                               base::GetCurrentProcessHandle(),
                               NULL);
    // Simulate closing the IPC channel.
    host_->IPCChannelClosing();

  void Create() {
                OnStreamCreated(kRouteId, kStreamId, _));

    // 2. First packet request will arrive.
    EXPECT_CALL(*host_, OnRequestPacket(kRouteId, kStreamId, _, _))
        .WillOnce(QuitMessageLoop(message_loop_.get()));

    IPC::Message msg;
    msg.set_routing_id(kRouteId);

    ViewHostMsg_Audio_CreateStream_Params params;
    if (mock_stream_)
      params.format = AudioManager::AUDIO_MOCK;
    else
      params.format = AudioManager::AUDIO_PCM_LINEAR;
    params.channels = 2;
    params.sample_rate = AudioManager::kAudioCDSampleRate;
    params.bits_per_sample = 16;
    params.packet_size = 0;

    // Send a create stream message to the audio output stream and wait until
    // we receive the created message.
    host_->OnCreateStream(msg, kStreamId, params, false);
    message_loop_->Run();
  }

  void CreateLowLatency() {
    InSequence s;
    // We will first receive a OnLowLatencyStreamCreated() signal.
    EXPECT_CALL(*host_,
                OnLowLatencyStreamCreated(kRouteId, kStreamId, _))
        .WillOnce(QuitMessageLoop(message_loop_.get()));

    IPC::Message msg;
    msg.set_routing_id(kRouteId);

    ViewHostMsg_Audio_CreateStream_Params params;
    if (mock_stream_)
      params.format = AudioManager::AUDIO_MOCK;
    else
      params.format = AudioManager::AUDIO_PCM_LINEAR;
    params.channels = 2;
    params.sample_rate = AudioManager::kAudioCDSampleRate;
    params.bits_per_sample = 16;
    params.packet_size = 0;

    // Send a create stream message to the audio output stream and wait until
    // we receive the created message.
    host_->OnCreateStream(msg, kStreamId, params, true);
    message_loop_->Run();
  }

  void Close() {
    // Send a message to AudioRendererHost to tell it we want to close the
    // stream.
    IPC::Message msg;
    msg.set_routing_id(kRouteId);
    host_->OnCloseStream(msg, kStreamId);
    message_loop_->RunAllPending();
  }
  void Play() {
    EXPECT_CALL(*host_, OnStreamPlaying(kRouteId, kStreamId))
        .WillOnce(QuitMessageLoop(message_loop_.get()));
    IPC::Message msg;
    msg.set_routing_id(kRouteId);
    host_->OnPlayStream(msg, kStreamId);
    message_loop_->Run();
  void Pause() {
    EXPECT_CALL(*host_, OnStreamPaused(kRouteId, kStreamId))
        .WillOnce(QuitMessageLoop(message_loop_.get()));

    IPC::Message msg;
    msg.set_routing_id(kRouteId);
    host_->OnPauseStream(msg, kStreamId);
    message_loop_->Run();
  void SetVolume(double volume) {
    IPC::Message msg;
    msg.set_routing_id(kRouteId);
    host_->OnSetVolume(msg, kStreamId, volume);
    message_loop_->RunAllPending();
  void NotifyPacketReady() {
    EXPECT_CALL(*host_, OnRequestPacket(kRouteId, kStreamId, _, _))
        .WillOnce(QuitMessageLoop(message_loop_.get()));

    IPC::Message msg;
    msg.set_routing_id(kRouteId);
    memset(host_->shared_memory()->memory(), 0, host_->shared_memory_length());
    host_->OnNotifyPacketReady(msg, kStreamId,
                               host_->shared_memory_length());
    message_loop_->Run();
  }

  void SimulateError() {
    // Find the first AudioController in the AudioRendererHost.
    CHECK(host_->audio_entries_.size())
        << "Calls Create() before calling this method";
    media::AudioController* controller =
        host_->audio_entries_.begin()->second->controller;
    CHECK(controller) << "AudioController not found";

    // Expect an error signal sent through IPC.
    EXPECT_CALL(*host_, OnStreamError(kRouteId, kStreamId))
        .WillOnce(QuitMessageLoop(message_loop_.get()));

    // Simulate an error sent from the audio device.
    host_->OnError(controller, 0);
    message_loop_->Run();

    // Expect the audio stream record is removed.
    EXPECT_EQ(0u, host_->audio_entries_.size());
  }

  MessageLoop* message_loop() { return message_loop_.get(); }
  MockAudioRendererHost* host() { return host_; }
  void EnableRealDevice() { mock_stream_ = false; }
  bool mock_stream_;
  scoped_refptr<MockAudioRendererHost> host_;
  scoped_ptr<MessageLoop> message_loop_;

TEST_F(AudioRendererHostTest, CreateAndClose) {
  if (!IsRunningHeadless())
    EnableRealDevice();

  Create();
  Close();
}

TEST_F(AudioRendererHostTest, CreatePlayAndClose) {
  if (!IsRunningHeadless())
    EnableRealDevice();

  Create();
  Play();
  Close();
}

TEST_F(AudioRendererHostTest, CreatePlayPauseAndClose) {
  if (!IsRunningHeadless())
    EnableRealDevice();

  Create();
  Play();
  Pause();
  Close();
}

TEST_F(AudioRendererHostTest, SetVolume) {
  if (!IsRunningHeadless())
    EnableRealDevice();

  Create();
  SetVolume(0.5);
  Play();
  Pause();
  Close();

  // Expect the volume is set.
  if (IsRunningHeadless()) {
    EXPECT_EQ(0.5, FakeAudioOutputStream::GetLastFakeStream()->volume());
  }
}

// Simulate the case where a stream is not properly closed.
TEST_F(AudioRendererHostTest, CreateAndShutdown) {
  if (!IsRunningHeadless())
    EnableRealDevice();

  Create();
}

// Simulate the case where a stream is not properly closed.
TEST_F(AudioRendererHostTest, CreatePlayAndShutdown) {
  if (!IsRunningHeadless())
    EnableRealDevice();

  Create();
  Play();
}

// Simulate the case where a stream is not properly closed.
TEST_F(AudioRendererHostTest, CreatePlayPauseAndShutdown) {
  if (!IsRunningHeadless())
    EnableRealDevice();

  Create();
  Play();
  Pause();
}

TEST_F(AudioRendererHostTest, DataConversationMockStream) {
  Create();

  // Note that we only do notify three times because the buffer capacity is
  // triple of one packet size.
  NotifyPacketReady();
  NotifyPacketReady();
  NotifyPacketReady();
  Close();
}

TEST_F(AudioRendererHostTest, DataConversationRealStream) {
  if (IsRunningHeadless())
    return;
  EnableRealDevice();
  Create();
  Play();

  // If this is a real audio device, the data conversation is not limited
  // to the buffer capacity of AudioController. So we do 5 exchanges before
  // we close the device.
  for (int i = 0; i < 5; ++i) {
    NotifyPacketReady();
  }
  Close();
}

TEST_F(AudioRendererHostTest, SimulateError) {
  if (!IsRunningHeadless())
    EnableRealDevice();

  Create();
  Play();
  SimulateError();
}

// Simulate the case when an error is generated on the browser process,
// the audio device is closed but the render process try to close the
// audio stream again.
TEST_F(AudioRendererHostTest, SimulateErrorAndClose) {
  if (!IsRunningHeadless())
    EnableRealDevice();

  Create();
  Play();
  SimulateError();
  Close();

TEST_F(AudioRendererHostTest, CreateLowLatencyAndClose) {
  if (!IsRunningHeadless())
    EnableRealDevice();

  CreateLowLatency();
  Close();
}

// Simulate the case where a stream is not properly closed.
TEST_F(AudioRendererHostTest, CreateLowLatencyAndShutdown) {
  if (!IsRunningHeadless())
    EnableRealDevice();

  CreateLowLatency();
}

// TODO(hclam): Add tests for data conversation in low latency mode.
// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/renderer_host/audio_sync_reader.h"

#include "base/process_util.h"
#include "base/shared_memory.h"

AudioSyncReader::AudioSyncReader(base::SharedMemory* shared_memory)
      : shared_memory_(shared_memory) {
}

AudioSyncReader::~AudioSyncReader() {
}

// media::AudioController::SyncReader implementations.
void AudioSyncReader::UpdatePendingBytes(uint32 bytes) {
  socket_->Send(&bytes, sizeof(bytes));
}

uint32 AudioSyncReader::Read(void* data, uint32 size) {
  int read_size = std::min(size, shared_memory_->max_size());
  memcpy(data, shared_memory_->memory(), read_size);
  memset(shared_memory_->memory(), 0, shared_memory_->max_size());
  return read_size;
}

void AudioSyncReader::Close() {
  socket_->Close();
}

bool AudioSyncReader::Init() {
  base::SyncSocket* sockets[2] = {0};
  if (base::SyncSocket::CreatePair(sockets)) {
    socket_.reset(sockets[0]);
    foreign_socket_.reset(sockets[1]);
    return true;
  }
  return false;
}

#if defined(OS_WIN)
bool AudioSyncReader::PrepareForeignSocketHandle(
    base::ProcessHandle process_handle,
    base::SyncSocket::Handle* foreign_handle) {
  ::DuplicateHandle(GetCurrentProcess(), foreign_socket_->handle(),
                    process_handle, foreign_handle,
                    0, FALSE, DUPLICATE_SAME_ACCESS);
  if (*foreign_handle != 0) {
    // Note that this is just a way to get away with the unused variable
    // warning. We want to return true here.
    return foreign_socket_.release() != NULL;
  }
  return false;
}
#else
bool AudioSyncReader::PrepareForeignSocketHandle(
    base::ProcessHandle process_handle,
    base::FileDescriptor* foreign_handle) {
  foreign_handle->fd = foreign_socket_->handle();
  foreign_handle->auto_close = false;
  if (foreign_handle->fd != -1) {
    // Note that this is just a way to get away with the unused variable
    // warning. We want to return true here.
    return foreign_socket_.release() != NULL;
  }
  return false;
}
#endif
// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_RENDERER_HOST_AUDIO_SYNC_READER_
#define CHROME_BROWSER_RENDERER_HOST_AUDIO_SYNC_READER_

#include "base/file_descriptor_posix.h"
#include "base/process.h"
#include "base/sync_socket.h"
#include "media/audio/audio_controller.h"

namespace base {

class SharedMemory;

}

// A AudioController::SyncReader implementation using SyncSocket. This is used
// by AudioController to provide a low latency data source for transmitting
// audio packets between the browser process and the renderer process.
class AudioSyncReader : public media::AudioController::SyncReader {
 public:
  explicit AudioSyncReader(base::SharedMemory* shared_memory);

  virtual ~AudioSyncReader();

  // media::AudioController::SyncReader implementations.
  virtual void UpdatePendingBytes(uint32 bytes);
  virtual uint32 Read(void* data, uint32 size);
  virtual void Close();

  bool Init();
  bool PrepareForeignSocketHandle(base::ProcessHandle process_handle,
#if defined(OS_WIN)
                                  base::SyncSocket::Handle* foreign_handle);
#else
                                  base::FileDescriptor* foreign_handle);
#endif

 private:
  base::SharedMemory* shared_memory_;

  // A pair of SyncSocket for transmitting audio data.
  scoped_ptr<base::SyncSocket> socket_;

  // SyncSocket to be used by the renderer. The reference is released after
  // PrepareForeignSocketHandle() is called and ran successfully.
  scoped_ptr<base::SyncSocket> foreign_socket_;

  DISALLOW_COPY_AND_ASSIGN(AudioSyncReader);
};

#endif  // CHROME_BROWSER_RENDERER_HOST_AUDIO_SYNC_READER_
      volume_(0),
      state_(kEmpty),
  DCHECK(kClosed == state_);
  DCHECK_EQ(thread_.message_loop(), MessageLoop::current());
  DCHECK_EQ(kEmpty, state_);

  // We have successfully opened the stream. Set the initial volume.
  stream_->SetVolume(volume_);

  // Finally set the state to kCreated.
  state_ = kCreated;

  // And then report we have been created.
  // Saves the volume to a member first. We may not be able to set the volume
  // right away but when the stream is created we'll set the volume.
  volume_ = volume;

  if (state_ != kPlaying && state_ != kPaused && state_ != kCreated)
  stream_->SetVolume(volume_);
  if (LowLatencyMode()) {
    sync_reader_->Close();
  } else {
  // The current volume of the audio stream.
  double volume_;

  // Calls |callback_| only if it is valid. We don't have |callback_| if
  // we have not yet started.
  if (callback_) {
    callback_->OnClose(this);
    callback_ = NULL;
  }
  // HTML Encoding spec treats US-ASCII as synonymous with windows-1252
  {"foo-\xff.html", "ascii", true, "foo-\xc3\xbf.html"},
    EXPECT_TRUE(base::ContentsEqual(full_file_name, expected_file_name)) <<
        "generated_file = " << full_file_name.AsUTF8Unsafe() <<
        ", expected_file = " << expected_file_name.AsUTF8Unsafe();
      category_string_id != IDS_ENCODING_TURKISH &&
      category_string_id != IDS_ENCODING_VIETNAMESE &&
      category_string_id != IDS_ENCODING_ROMANIAN) {
  const char* standards[3] = { "HTML", "MIME", "IANA" };
  for (size_t i = 0; i < arraysize(standards); ++i) {
    UErrorCode error_code = U_ZERO_ERROR;
    const char* canonical_name = ucnv_getCanonicalName(
        alias_name.c_str(), standards[i], &error_code);
    if (U_SUCCESS(error_code) && canonical_name)
      return canonical_name;
  return std::string();
  EXPECT_FALSE(model.IsCommandIdChecked(IDC_ENCODING_WINDOWS1252));
    if (m_isExternalScript) {
        const KURL resourceUrl = sourceCode.resource()->resourceRequest().url();
        if (!SubresourceIntegrity::CheckSubresourceIntegrity(*m_element, sourceCode.source(), sourceCode.resource()->url(), sourceCode.resource()->mimeType(), *sourceCode.resource())) {
            return;
        }
    }

bool Resource::passesAccessControlCheck(ExecutionContext* context, SecurityOrigin* securityOrigin) const
bool Resource::passesAccessControlCheck(ExecutionContext* context, SecurityOrigin* securityOrigin, String& errorDescription) const
bool Resource::isEligibleForIntegrityCheck(ExecutionContext* source) const
{
    String errorDescription;
    return source->securityOrigin()->canRequest(resourceRequest().url()) || passesAccessControlCheck(source, source->securityContext().securityOrigin(), errorDescription);
}

    bool passesAccessControlCheck(ExecutionContext*, SecurityOrigin*) const;
    bool passesAccessControlCheck(ExecutionContext*, SecurityOrigin*, String& errorDescription) const;

    bool isEligibleForIntegrityCheck(ExecutionContext*) const;
bool ResourceFetcher::canAccessResource(Resource* resource, SecurityOrigin* sourceOrigin, const KURL& url, AccessControlLoggingDecision logErrorsDecision) const
        if (!forPreload && (logErrorsDecision == ShouldLogAccessControlErrors) && frame() && frame()->document()) {
    virtual bool canAccessResource(Resource*, SecurityOrigin*, const KURL&, AccessControlLoggingDecision) const override;
#include "core/fetch/CSSStyleSheetResource.h"
            if (!m_host->canAccessResource(resource, m_options.securityOrigin.get(), response.url(), ResourceLoaderHost::ShouldLogAccessControlErrors)) {
    enum AccessControlLoggingDecision {
        ShouldLogAccessControlErrors,
        ShouldNotLogAccessControlErrors
    };
    virtual bool canAccessResource(Resource*, SecurityOrigin* sourceOrigin, const KURL&, AccessControlLoggingDecision) const = 0;
#include "core/fetch/Resource.h"
bool SubresourceIntegrity::CheckSubresourceIntegrity(const Element& element, const String& source, const KURL& resourceUrl, const String& resourceType, const Resource& resource)
    if (!resource.isEligibleForIntegrityCheck(&document)) {
        logErrorToConsole("Subresource Integrity: The resource '" + resourceUrl.elidedString() + "' has an integrity attribute, but the resource requires CORS to be enabled to check the integrity, and it is not. The resource has been blocked.", document);
        return false;
    }

class Resource;
    static bool CheckSubresourceIntegrity(const Element&, const WTF::String& content, const KURL& resourceUrl, const WTF::String& mimeType, const Resource&);
#include "core/fetch/Resource.h"
#include "core/fetch/ResourcePtr.h"
    enum CorsStatus {
        WithCors,
        NoCors
    };

    void expectIntegrity(const char* integrity, const char* script, const KURL& url, const KURL& requestorUrl, const String& mimeType = String(), CorsStatus corsStatus = WithCors)
        EXPECT_TRUE(SubresourceIntegrity::CheckSubresourceIntegrity(*scriptElement, script, url, mimeType, *createTestResource(url, requestorUrl, corsStatus).get()));
    void expectIntegrityFailure(const char* integrity, const char* script, const KURL& url, const KURL& requestorUrl, const String& mimeType = String(), CorsStatus corsStatus = WithCors)
        EXPECT_FALSE(SubresourceIntegrity::CheckSubresourceIntegrity(*scriptElement, script, url, mimeType, *createTestResource(url, requestorUrl, corsStatus).get()));
    }

    ResourcePtr<Resource> createTestResource(const KURL& url, const KURL& allowOriginUrl, CorsStatus corsStatus)
    {
        OwnPtr<ResourceResponse> response = adoptPtr(new ResourceResponse);
        response->setURL(url);
        response->setHTTPStatusCode(200);
        if (corsStatus == WithCors) {
            response->setHTTPHeaderField("access-control-allow-origin", SecurityOrigin::create(allowOriginUrl)->toAtomicString());
            response->setHTTPHeaderField("access-control-allow-credentials", "true");
        }
        ResourcePtr<Resource> resource = new Resource(ResourceRequest(response->url()), Resource::Raw);
        resource->setResponse(*response);
        return resource;
    expectIntegrity(kSha256Integrity, kBasicScript, secureURL, secureURL);
    expectIntegrity(kSha384Integrity, kBasicScript, secureURL, secureURL);
    expectIntegrity(kSha512Integrity, kBasicScript, secureURL, secureURL);
    expectIntegrityFailure(kSha384IntegrityLabeledAs256, kBasicScript, secureURL, secureURL);
    expectIntegrityFailure(kUnsupportedHashFunctionIntegrity, kBasicScript, secureURL, secureURL);

    // All parameters are fine, and because this is not cross origin, CORS is
    // not needed.
    expectIntegrity(kSha256Integrity, kBasicScript, secureURL, secureURL, String(), NoCors);
    // The same checks as CheckSubresourceIntegrityInSecureOrigin should pass
    // here, with the expection of the NoCors check at the end.
    expectIntegrity(kSha256Integrity, kBasicScript, secureURL, insecureURL);
    expectIntegrity(kSha384Integrity, kBasicScript, secureURL, insecureURL);
    expectIntegrity(kSha512Integrity, kBasicScript, secureURL, insecureURL);
    expectIntegrityFailure(kSha384IntegrityLabeledAs256, kBasicScript, secureURL, insecureURL);
    expectIntegrityFailure(kUnsupportedHashFunctionIntegrity, kBasicScript, secureURL, insecureURL);

    // This check should fail because, unlike in the
    // CheckSubresourceIntegirtyInSecureOrigin case, this is cross origin
    // (secure origin requesting a resource on an insecure origin)
    expectIntegrityFailure(kSha256Integrity, kBasicScript, secureURL, insecureURL, String(), NoCors);
    if (!cachedStyleSheet->errorOccurred() && !SubresourceIntegrity::CheckSubresourceIntegrity(*m_owner, cachedStyleSheet->sheetText(), KURL(baseURL, href), cachedStyleSheet->mimeType(), *cachedStyleSheet)) {
SpeechSynthesisUtterance* SpeechSynthesis::currentSpeechUtterance() const
{
    if (!m_utteranceQueue.isEmpty())
        return m_utteranceQueue.first().get();
    return 0;
}

#include "grit/renderer_resources.h"
#include "grit/renderer_resources.h"
#include "grit/renderer_resources.h"
#include "grit/renderer_resources.h"

#include "grit/renderer_resources.h"
#include "grit/renderer_resources.h"
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/spdy/spdy_frame_producer.h"

#include "base/logging.h"
#include "net/spdy/spdy_protocol.h"

namespace net {

SpdyFrameProducer::SpdyFrameProducer() {}

SpdyFrameProducer::~SpdyFrameProducer() {}

SimpleFrameProducer::SimpleFrameProducer(scoped_ptr<SpdyFrame> frame)
    : frame_(frame.Pass()) {}

SimpleFrameProducer::~SimpleFrameProducer() {}

scoped_ptr<SpdyFrame> SimpleFrameProducer::ProduceFrame() {
  DCHECK(frame_);
  return frame_.Pass();
}

}  // namespace net
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef NET_SPDY_SPDY_FRAME_PRODUCER_H_
#define NET_SPDY_SPDY_FRAME_PRODUCER_H_

#include "base/basictypes.h"
#include "base/compiler_specific.h"
#include "base/memory/scoped_ptr.h"
#include "net/base/net_export.h"

namespace net {

class SpdyFrame;

// An object which provides a SpdyFrame for writing. We pass these
// around instead of SpdyFrames since some frames have to be generated
// "just in time".
class NET_EXPORT_PRIVATE SpdyFrameProducer {
 public:
  SpdyFrameProducer();

  // Produces the frame to be written. Will be called at most once.
  virtual scoped_ptr<SpdyFrame> ProduceFrame() = 0;

  virtual ~SpdyFrameProducer();

 private:
  DISALLOW_COPY_AND_ASSIGN(SpdyFrameProducer);
};

// A simple wrapper around a single SpdyFrame.
class NET_EXPORT_PRIVATE SimpleFrameProducer : public SpdyFrameProducer {
 public:
  explicit SimpleFrameProducer(scoped_ptr<SpdyFrame> frame);

  virtual ~SimpleFrameProducer();

  virtual scoped_ptr<SpdyFrame> ProduceFrame() OVERRIDE;

 private:
  scoped_ptr<SpdyFrame> frame_;

  DISALLOW_COPY_AND_ASSIGN(SimpleFrameProducer);
};

}  // namespace net

#endif  // NET_SPDY_SPDY_FRAME_PRODUCER_H_
SpdyIOBuffer::SpdyIOBuffer() {}
SpdyIOBuffer::SpdyIOBuffer(IOBuffer* buffer, int size, SpdyStream* stream)
  : buffer_(new DrainableIOBuffer(buffer, size)), stream_(stream) {}
void SpdyIOBuffer::Swap(SpdyIOBuffer* other) {
  buffer_.swap(other->buffer_);
  stream_.swap(other->stream_);
}

void SpdyIOBuffer::Release() {
// A class for managing SPDY write buffers.  These write buffers need
// to track the SpdyStream which they are associated with so that the
// session can activate the stream lazily and also notify the stream
// on completion of the write.
  SpdyIOBuffer();

  // |stream| is a pointer to the stream which is managing this buffer
  // (can be NULL if the write is for the session itself).
  SpdyIOBuffer(IOBuffer* buffer, int size, SpdyStream* stream);



  void Swap(SpdyIOBuffer* other);

  void Release();

#include "net/spdy/spdy_frame_producer.h"
  for (int i = 0; i < NUM_PRIORITIES; ++i) {
void SpdySession::EnqueueStreamWrite(
    SpdyStream* stream,
    scoped_ptr<SpdyFrameProducer> producer) {
  EnqueueWrite(stream->priority(), producer.Pass(), stream);
}

scoped_ptr<SpdyFrame> SpdySession::CreateSynStream(
  return syn_frame.Pass();
int SpdySession::CreateCredentialFrame(
    RequestPriority priority,
    scoped_ptr<SpdyFrame>* credential_frame) {
  DCHECK_NE(rv, ERR_IO_PENDING);
    return rv;
  credential_frame->reset(
  return OK;
scoped_ptr<SpdyFrame> SpdySession::CreateHeadersFrame(
  return frame.Pass();
scoped_ptr<SpdyFrame> SpdySession::CreateDataFrame(SpdyStreamId stream_id,
                                                   net::IOBuffer* data,
                                                   int len,
                                                   SpdyDataFlags flags) {
    return scoped_ptr<SpdyFrame>();
      return scoped_ptr<SpdyFrame>();
        return scoped_ptr<SpdyFrame>();
  return frame.Pass();
  EnqueueSessionWrite(priority, rst_frame.Pass());
  DCHECK_GT(in_flight_write_.buffer()->BytesRemaining(), 0);
  if (result < 0) {
    in_flight_write_.Release();
    CloseSessionOnError(static_cast<net::Error>(result), true, "Write error");
    return;
  }
  // It should not be possible to have written more bytes than our
  // in_flight_write_.
  DCHECK_LE(result, in_flight_write_.buffer()->BytesRemaining());
  in_flight_write_.buffer()->DidConsume(result);
  // We only notify the stream when we've fully written the pending frame.
  if (in_flight_write_.buffer()->BytesRemaining() == 0) {
    DCHECK_GT(result, 0);

    scoped_refptr<SpdyStream> stream = in_flight_write_.stream();

    // It is possible that the stream was cancelled while we were writing
    // to the socket.
    if (stream && !stream->cancelled()) {
      // Report the number of bytes written to the caller, but exclude the
      // frame size overhead.  NOTE: if this frame was compressed the
      // reported bytes written is the compressed size, not the original
      // size.
      result = in_flight_write_.buffer()->size();
      DCHECK_GE(result,
                static_cast<int>(
                    buffered_spdy_framer_->GetControlFrameHeaderSize()));
      result -= buffered_spdy_framer_->GetControlFrameHeaderSize();

      stream->OnWriteComplete(result);
    }

    // Cleanup the write which just completed.
    in_flight_write_.Release();

  // Write more data.  We're already in a continuation, so we can go
  // ahead and write it immediately (without going back to the message
  // loop).
  WriteSocketLater();
  while (true) {
    if (in_flight_write_.buffer()) {
      DCHECK_GT(in_flight_write_.buffer()->BytesRemaining(), 0);
    } else {
      // Grab the next frame to send.
      scoped_ptr<SpdyFrameProducer> producer;
      scoped_refptr<SpdyStream> stream;
      if (!write_queue_.Dequeue(&producer, &stream))
        break;

      if (stream.get() && stream->cancelled())
      if (stream.get() && stream->stream_id() == 0)
        ActivateStream(stream);

      scoped_ptr<SpdyFrame> frame = producer->ProduceFrame();
      if (!frame) {
        NOTREACHED();
        continue;
      }
      DCHECK_GT(frame->size(), 0u);

      // TODO(mbelshe): We have too much copying of data here.
      scoped_refptr<IOBufferWithSize> buffer =
          new IOBufferWithSize(frame->size());
      memcpy(buffer->data(), frame->data(), frame->size());
      in_flight_write_ = SpdyIOBuffer(buffer, frame->size(), stream);
  write_queue_.Clear();
void SpdySession::EnqueueSessionWrite(RequestPriority priority,
                                      scoped_ptr<SpdyFrame> frame) {
  EnqueueWrite(
      priority,
      scoped_ptr<SpdyFrameProducer>(new SimpleFrameProducer(frame.Pass())),
      NULL);
}
void SpdySession::EnqueueWrite(RequestPriority priority,
                               scoped_ptr<SpdyFrameProducer> producer,
                               const scoped_refptr<SpdyStream>& stream) {
  write_queue_.Enqueue(priority, producer.Pass(), stream);
    for (PushedStreamMap::iterator it = unclaimed_pushed_streams_.begin();
  ActiveStreamMap::iterator it = active_streams_.find(id);
  if (it == active_streams_.end())
  const scoped_refptr<SpdyStream> stream(it->second);
  active_streams_.erase(it);
  DCHECK(stream);

  write_queue_.RemovePendingWritesForStream(stream);
  EnqueueSessionWrite(HIGHEST, settings_frame.Pass());
  EnqueueSessionWrite(priority, window_update_frame.Pass());
  EnqueueSessionWrite(HIGHEST, ping_frame.Pass());
#include "base/memory/scoped_ptr.h"
#include "net/base/net_export.h"
#include "net/spdy/spdy_write_queue.h"
  // Pushes the given producer into the write queue for
  // |stream|. |stream| is guaranteed to be activated before the
  // producer is used to produce its frame.
  void EnqueueStreamWrite(SpdyStream* stream,
                          scoped_ptr<SpdyFrameProducer> producer);
  // Creates and returns a SYN frame for |stream_id|.
  scoped_ptr<SpdyFrame> CreateSynStream(
  // Tries to create a CREDENTIAL frame. If successful, fills in
  // |credential_frame| and returns OK. Returns the error (guaranteed
  // to not be ERR_IO_PENDING) otherwise.
  int CreateCredentialFrame(const std::string& origin,
                            SSLClientCertType type,
                            const std::string& key,
                            const std::string& cert,
                            RequestPriority priority,
                            scoped_ptr<SpdyFrame>* credential_frame);

  // Creates and returns a HEADERS frame.
  scoped_ptr<SpdyFrame> CreateHeadersFrame(SpdyStreamId stream_id,
                                           const SpdyHeaderBlock& headers,
                                           SpdyControlFlags flags);

  // Creates and returns a data frame. May return NULL if stalled by
  // flow control.
  scoped_ptr<SpdyFrame> CreateDataFrame(SpdyStreamId stream_id,
                                        net::IOBuffer* data,
                                        int len,
                                        SpdyDataFlags flags);
  // Pushes the given frame with the given priority into the write
  // queue for the session.
  void EnqueueSessionWrite(RequestPriority priority,
                           scoped_ptr<SpdyFrame> frame);

  // Puts |producer| associated with |stream| onto the write queue
  // with the given priority.
  void EnqueueWrite(RequestPriority priority,
                    scoped_ptr<SpdyFrameProducer> producer,
                    const scoped_refptr<SpdyStream>& stream);
  // The write queue.
  SpdyWriteQueue write_queue_;
#include "net/spdy/spdy_frame_producer.h"
// A wrapper around a stream that calls into ProduceSynStreamFrame().
class SpdyStream::SynStreamFrameProducer : public SpdyFrameProducer {
 public:
  SynStreamFrameProducer(const base::WeakPtr<SpdyStream>& stream)
      : stream_(stream) {
    DCHECK(stream_);
  }

  virtual ~SynStreamFrameProducer() {}

  virtual scoped_ptr<SpdyFrame> ProduceFrame() OVERRIDE {
    if (!stream_) {
      NOTREACHED();
      return scoped_ptr<SpdyFrame>();
    }
    DCHECK_GT(stream_->stream_id(), 0u);
    return stream_->ProduceSynStreamFrame();
  }

 private:
  const base::WeakPtr<SpdyStream> stream_;
};

// A wrapper around a stream that calls into ProduceHeaderFrame() with
// a given header block.
class SpdyStream::HeaderFrameProducer : public SpdyFrameProducer {
 public:
  HeaderFrameProducer(const base::WeakPtr<SpdyStream>& stream,
                      scoped_ptr<SpdyHeaderBlock> headers)
      : stream_(stream),
        headers_(headers.Pass()) {
    DCHECK(stream_);
    DCHECK(headers_);
  }

  virtual ~HeaderFrameProducer() {}

  virtual scoped_ptr<SpdyFrame> ProduceFrame() OVERRIDE {
    if (!stream_) {
      NOTREACHED();
      return scoped_ptr<SpdyFrame>();
    }
    DCHECK_GT(stream_->stream_id(), 0u);
    return stream_->ProduceHeaderFrame(headers_.Pass());
  }

 private:
  const base::WeakPtr<SpdyStream> stream_;
  scoped_ptr<SpdyHeaderBlock> headers_;
};

scoped_ptr<SpdyFrame> SpdyStream::ProduceSynStreamFrame() {
  CHECK_EQ(io_state_, STATE_SEND_HEADERS_COMPLETE);
  CHECK(request_.get());
  CHECK_GT(stream_id_, 0u);

  SpdyControlFlags flags =
      has_upload_data_ ? CONTROL_FLAG_NONE : CONTROL_FLAG_FIN;
  scoped_ptr<SpdyFrame> frame(session_->CreateSynStream(
      stream_id_, priority_, slot_, flags, *request_));
  send_time_ = base::TimeTicks::Now();
  return frame.Pass();
}

scoped_ptr<SpdyFrame> SpdyStream::ProduceHeaderFrame(
    scoped_ptr<SpdyHeaderBlock> header_block) {
  CHECK(!cancelled());
  // We must need to write stream data.
  // Until the headers have been completely sent, we can not be sure
  // that our stream_id is correct.
  DCHECK_GT(io_state_, STATE_SEND_HEADERS_COMPLETE);
  DCHECK_GT(stream_id_, 0u);

  // Create actual HEADERS frame just in time because it depends on
  // compression context and should not be reordered after the creation.
  scoped_ptr<SpdyFrame> header_frame(session_->CreateHeadersFrame(
      stream_id_, *header_block, SpdyControlFlags()));
  return header_frame.Pass();
}

  waiting_completions_.push_back(TYPE_HEADERS);
  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(
          new HeaderFrameProducer(
              weak_ptr_factory_.GetWeakPtr(), headers.Pass())));
  CHECK(!cancelled());
  waiting_completions_.push_back(TYPE_DATA);
  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(
          new SimpleFrameProducer(data_frame.Pass())));
      // OnDataReceived, OnClose and OnWriteComplete can be called.

  std::string origin = GetUrl().GetOrigin().spec();
  DCHECK(origin[origin.length() - 1] == '/');
  origin.erase(origin.length() - 1);  // Trim trailing slash.
  scoped_ptr<SpdyFrame> frame;
  int rv = session_->CreateCredentialFrame(
      origin, domain_bound_cert_type_, domain_bound_private_key_,
      domain_bound_cert_, priority_, &frame);
  if (rv != OK) {
    DCHECK_NE(rv, ERR_IO_PENDING);
    return rv;
  }

  DCHECK(frame);
  // TODO(akalin): Fix a couple of race conditions:
  //
  // 1) Since this counts as a write for this stream, the stream will
  // be activated (and hence allocated a stream ID) before this frame
  // is sent, even though the ID should only be activated for the
  // SYN_STREAM frame. This can be solved by signalling to the session
  // when we're sending a SYN_STREAM frame, and have it only activate
  // the stream then.
  //
  // 2) Since this is decoupled from sending the SYN_STREAM frame, it
  // is possible that other domain-bound cert frames will clobber ours
  // before our SYN_STREAM frame gets sent. This can be solved by
  // immediately enqueueing the SYN_STREAM frame here and adjusting
  // the state machine appropriately.
  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(new SimpleFrameProducer(frame.Pass())));

  session_->EnqueueStreamWrite(
      this,
      scoped_ptr<SpdyFrameProducer>(
          new SynStreamFrameProducer(weak_ptr_factory_.GetWeakPtr())));
#include <deque>
  class SynStreamFrameProducer;
  class HeaderFrameProducer;
  // Produces the SYN_STREAM frame for the stream. The stream must
  // already be activated.
  scoped_ptr<SpdyFrame> ProduceSynStreamFrame();
  // Produce the initial HEADER frame for the stream with the given
  // block. The stream must already be activated.
  scoped_ptr<SpdyFrame> ProduceHeaderFrame(
      scoped_ptr<SpdyHeaderBlock> header_block);
  // An in order list of sending frame types. Used communicate to the
  // delegate which type of frame was sent in DoOpen().
  //
  // TODO(akalin): We can remove the need for this queue if we add an
  // OnFrameSent() callback to SpdyFrameProducer and have the session
  // call that instead of SpdyStream::OnWriteComplete().
  std::deque<FrameType> waiting_completions_;
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/spdy/spdy_write_queue.h"

#include <cstddef>

#include "base/logging.h"
#include "net/spdy/spdy_frame_producer.h"
#include "net/spdy/spdy_stream.h"

namespace net {

SpdyWriteQueue::PendingWrite::PendingWrite() : frame_producer(NULL) {}

SpdyWriteQueue::PendingWrite::PendingWrite(
    SpdyFrameProducer* frame_producer,
    const scoped_refptr<SpdyStream>& stream)
    : frame_producer(frame_producer),
      stream(stream) {}

SpdyWriteQueue::PendingWrite::~PendingWrite() {}

SpdyWriteQueue::SpdyWriteQueue() {}

SpdyWriteQueue::~SpdyWriteQueue() {
  Clear();
}

void SpdyWriteQueue::Enqueue(RequestPriority priority,
                             scoped_ptr<SpdyFrameProducer> frame_producer,
                             const scoped_refptr<SpdyStream>& stream) {
  if (stream.get()) {
    DCHECK_EQ(stream->priority(), priority);
  }
  queue_[priority].push_back(PendingWrite(frame_producer.release(), stream));
}

bool SpdyWriteQueue::Dequeue(scoped_ptr<SpdyFrameProducer>* frame_producer,
                             scoped_refptr<SpdyStream>* stream) {
  for (int i = NUM_PRIORITIES - 1; i >= 0; --i) {
    if (!queue_[i].empty()) {
      PendingWrite pending_write = queue_[i].front();
      queue_[i].pop_front();
      frame_producer->reset(pending_write.frame_producer);
      *stream = pending_write.stream;
      return true;
    }
  }
  return false;
}

void SpdyWriteQueue::RemovePendingWritesForStream(
    const scoped_refptr<SpdyStream>& stream) {
  DCHECK(stream.get());
  if (DCHECK_IS_ON()) {
    // |stream| should not have pending writes in a queue not matching
    // its priority.
    for (int i = 0; i < NUM_PRIORITIES; ++i) {
      if (stream->priority() == i)
        continue;
      for (std::deque<PendingWrite>::const_iterator it = queue_[i].begin();
           it != queue_[i].end(); ++it) {
        DCHECK_NE(it->stream, stream);
      }
    }
  }

  // Do the actual deletion and removal, preserving FIFO-ness.
  std::deque<PendingWrite>* queue = &queue_[stream->priority()];
  std::deque<PendingWrite>::iterator out_it = queue->begin();
  for (std::deque<PendingWrite>::const_iterator it = queue->begin();
       it != queue->end(); ++it) {
    if (it->stream == stream) {
      delete it->frame_producer;
    } else {
      *out_it = *it;
      ++out_it;
    }
  }
  queue->erase(out_it, queue->end());
}

void SpdyWriteQueue::Clear() {
  for (int i = 0; i < NUM_PRIORITIES; ++i) {
    for (std::deque<PendingWrite>::iterator it = queue_[i].begin();
         it != queue_[i].end(); ++it) {
      delete it->frame_producer;
    }
    queue_[i].clear();
  }
}

}  // namespace net
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef NET_SPDY_SPDY_WRITE_QUEUE_H_
#define NET_SPDY_SPDY_WRITE_QUEUE_H_

#include <deque>

#include "base/basictypes.h"
#include "base/memory/ref_counted.h"
#include "base/memory/scoped_ptr.h"
#include "net/base/net_export.h"
#include "net/base/request_priority.h"

namespace net {

class SpdyFrameProducer;
class SpdyStream;

// A queue of SpdyFrameProducers to produce frames to write. Ordered
// by priority, and then FIFO.
class NET_EXPORT_PRIVATE SpdyWriteQueue {
 public:
  SpdyWriteQueue();
  ~SpdyWriteQueue();

  // Enqueues the given frame producer at the given priority
  // associated with the given stream, which may be NULL if the frame
  // producer is not associated with a stream. If |stream| is
  // non-NULL, its priority must be equal to |priority|.
  void Enqueue(RequestPriority priority,
               scoped_ptr<SpdyFrameProducer> frame_producer,
               const scoped_refptr<SpdyStream>& stream);

  // Dequeues the frame producer with the highest priority that was
  // enqueued the earliest and its associated stream. Returns true and
  // fills in |frame_producer| and |stream| if successful --
  // otherwise, just returns false.
  bool Dequeue(scoped_ptr<SpdyFrameProducer>* frame_producer,
               scoped_refptr<SpdyStream>* stream);

  // Removes all pending writes for the given stream, which must be
  // non-NULL.
  void RemovePendingWritesForStream(const scoped_refptr<SpdyStream>& stream);

  // Removes all pending writes.
  void Clear();

 private:
  // A struct holding a frame producer and its associated stream.
  struct PendingWrite {
    // This has to be a raw pointer since we store this in an STL
    // container.
    SpdyFrameProducer* frame_producer;
    scoped_refptr<SpdyStream> stream;

    PendingWrite();
    PendingWrite(SpdyFrameProducer* frame_producer,
                 const scoped_refptr<SpdyStream>& stream);
    ~PendingWrite();
  };

  // The actual write queue, binned by priority.
  std::deque<PendingWrite> queue_[NUM_PRIORITIES];

  DISALLOW_COPY_AND_ASSIGN(SpdyWriteQueue);
};

}  // namespace net

#endif  // NET_SPDY_SPDY_WRITE_QUEUE_H_
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "net/spdy/spdy_write_queue.h"

#include <cstddef>
#include <cstring>
#include <string>

#include "base/basictypes.h"
#include "base/memory/ref_counted.h"
#include "base/memory/scoped_ptr.h"
#include "base/strings/string_number_conversions.h"
#include "net/base/net_log.h"
#include "net/base/request_priority.h"
#include "net/spdy/spdy_frame_producer.h"
#include "net/spdy/spdy_stream.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace net {

namespace {

class SpdyWriteQueueTest : public ::testing::Test {};

// Makes a SpdyFrameProducer producing a frame with the data in the
// given string.
scoped_ptr<SpdyFrameProducer> StringToProducer(const std::string& s) {
  scoped_ptr<char[]> data(new char[s.size()]);
  std::memcpy(data.get(), s.data(), s.size());
  return scoped_ptr<SpdyFrameProducer>(
      new SimpleFrameProducer(
          scoped_ptr<SpdyFrame>(
              new SpdyFrame(data.release(), s.size(), true))));
}

// Makes a SpdyFrameProducer producing a frame with the data in the
// given int (converted to a string).
scoped_ptr<SpdyFrameProducer> IntToProducer(int i) {
  return StringToProducer(base::IntToString(i));
}

// Produces a frame with the given producer and returns a copy of its
// data as a string.
std::string ProducerToString(scoped_ptr<SpdyFrameProducer> producer) {
  scoped_ptr<SpdyFrame> frame = producer->ProduceFrame();
  return std::string(frame->data(), frame->size());
}

// Produces a frame with the given producer and returns a copy of its
// data as an int (converted from a string).
int ProducerToInt(scoped_ptr<SpdyFrameProducer> producer) {
  int i = 0;
  EXPECT_TRUE(base::StringToInt(ProducerToString(producer.Pass()), &i));
  return i;
}

// Makes a SpdyStream with the given priority and a NULL SpdySession
// -- be careful to not call any functions that expect the session to
// be there.
SpdyStream* MakeTestStream(RequestPriority priority) {
  return new SpdyStream(NULL, "", priority, 0, 0, false, BoundNetLog());
}

// Add some frame producers of different priority. The producers
// should be dequeued in priority order with their associated stream.
TEST_F(SpdyWriteQueueTest, DequeuesByPriority) {
  SpdyWriteQueue write_queue;

  scoped_ptr<SpdyFrameProducer> producer_low = StringToProducer("LOW");
  scoped_ptr<SpdyFrameProducer> producer_medium = StringToProducer("MEDIUM");
  scoped_ptr<SpdyFrameProducer> producer_highest = StringToProducer("HIGHEST");

  // A NULL stream should still work.
  scoped_refptr<SpdyStream> stream_low(NULL);
  scoped_refptr<SpdyStream> stream_medium(MakeTestStream(MEDIUM));
  scoped_refptr<SpdyStream> stream_highest(MakeTestStream(HIGHEST));

  write_queue.Enqueue(LOW, producer_low.Pass(), stream_low);
  write_queue.Enqueue(MEDIUM, producer_medium.Pass(), stream_medium);
  write_queue.Enqueue(HIGHEST, producer_highest.Pass(), stream_highest);

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ("HIGHEST", ProducerToString(frame_producer.Pass()));
  EXPECT_EQ(stream_highest, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ("MEDIUM", ProducerToString(frame_producer.Pass()));
  EXPECT_EQ(stream_medium, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ("LOW", ProducerToString(frame_producer.Pass()));
  EXPECT_EQ(stream_low, stream);

  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

// Add some frame producers with the same priority. The producers
// should be dequeued in FIFO order with their associated stream.
TEST_F(SpdyWriteQueueTest, DequeuesFIFO) {
  SpdyWriteQueue write_queue;

  scoped_ptr<SpdyFrameProducer> producer1 = IntToProducer(1);
  scoped_ptr<SpdyFrameProducer> producer2 = IntToProducer(2);
  scoped_ptr<SpdyFrameProducer> producer3 = IntToProducer(3);

  scoped_refptr<SpdyStream> stream1(MakeTestStream(DEFAULT_PRIORITY));
  scoped_refptr<SpdyStream> stream2(MakeTestStream(DEFAULT_PRIORITY));
  scoped_refptr<SpdyStream> stream3(MakeTestStream(DEFAULT_PRIORITY));

  write_queue.Enqueue(DEFAULT_PRIORITY, producer1.Pass(), stream1);
  write_queue.Enqueue(DEFAULT_PRIORITY, producer2.Pass(), stream2);
  write_queue.Enqueue(DEFAULT_PRIORITY, producer3.Pass(), stream3);

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ(1, ProducerToInt(frame_producer.Pass()));
  EXPECT_EQ(stream1, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ(2, ProducerToInt(frame_producer.Pass()));
  EXPECT_EQ(stream2, stream);

  ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
  EXPECT_EQ(3, ProducerToInt(frame_producer.Pass()));
  EXPECT_EQ(stream3, stream);

  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

// Enqueue a bunch of writes and then call
// RemovePendingWritesForStream() on one of the streams. No dequeued
// write should be for that stream.
TEST_F(SpdyWriteQueueTest, RemovePendingWritesForStream) {
  SpdyWriteQueue write_queue;

  scoped_refptr<SpdyStream> stream1(MakeTestStream(DEFAULT_PRIORITY));
  scoped_refptr<SpdyStream> stream2(MakeTestStream(DEFAULT_PRIORITY));

  for (int i = 0; i < 100; ++i) {
    scoped_refptr<SpdyStream> stream = ((i % 3) == 0) ? stream1 : stream2;
    write_queue.Enqueue(DEFAULT_PRIORITY, IntToProducer(i), stream);
  }

  write_queue.RemovePendingWritesForStream(stream2);

  for (int i = 0; i < 100; i += 3) {
    scoped_ptr<SpdyFrameProducer> frame_producer;
    scoped_refptr<SpdyStream> stream;
    ASSERT_TRUE(write_queue.Dequeue(&frame_producer, &stream));
    EXPECT_EQ(i, ProducerToInt(frame_producer.Pass()));
    EXPECT_EQ(stream1, stream);
  }

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

// Enqueue a bunch of writes and then call Clear(). The write queue
// should clean up the memory properly, and Dequeue() should return
// false.
TEST_F(SpdyWriteQueueTest, Clear) {
  SpdyWriteQueue write_queue;

  for (int i = 0; i < 100; ++i) {
    write_queue.Enqueue(DEFAULT_PRIORITY, IntToProducer(i), NULL);
  }

  write_queue.Clear();

  scoped_ptr<SpdyFrameProducer> frame_producer;
  scoped_refptr<SpdyStream> stream;
  EXPECT_FALSE(write_queue.Dequeue(&frame_producer, &stream));
}

}

}  // namespace net
#include "chrome/browser/autofill_manager.h"
#include "chrome/browser/password_manager/password_manager.h"
#include "chrome/browser/plugin_installer.h"
#include "chrome/browser/tab_contents/tab_contents_view.h"
// static
int TabContents::find_request_id_counter_ = -1;

// TODO(brettw) many of the data members here have casts to WebContents.
// This object is the same as WebContents and is currently being merged.
// When this merge is done, the casts can be removed.
      view_(TabContentsView::Create(static_cast<WebContents*>(this))),
      ALLOW_THIS_IN_INITIALIZER_LIST(render_manager_(
          static_cast<WebContents*>(this),
          static_cast<WebContents*>(this))),
      property_bag_(),
      registrar_(),
      printing_(*static_cast<WebContents*>(this)),
      save_package_(),
      cancelable_consumer_(),
      autofill_manager_(),
      password_manager_(),
      plugin_installer_(),
      ALLOW_THIS_IN_INITIALIZER_LIST(fav_icon_helper_(
          static_cast<WebContents*>(this))),
      select_file_dialog_(),
      pending_install_(),
      current_load_start_(),
      load_state_(net::LOAD_STATE_IDLE),
      load_state_host_(),
      received_page_title_(false),
      is_starred_(false),
      contents_mime_type_(),
      encoding_(),
      download_shelf_(),
      shelf_visible_(false),
      infobar_delegates_(),
      last_download_shelf_show_(),
      find_ui_active_(false),
      find_op_aborted_(false),
      current_find_request_id_(find_request_id_counter_++),
      find_text_(),
      find_prepopulate_text_(NULL),
      find_result_(),
      capturing_contents_(false),
      is_being_destroyed_(false),
      notify_disconnection_(false),
      history_requests_(),
#if defined(OS_WIN)
      message_box_active_(CreateEvent(NULL, TRUE, FALSE, NULL)),
#endif
      last_javascript_message_dismissal_(),
      suppress_javascript_messages_(false) {

void TabContents::OnGearsCreateShortcutDone(
    const GearsShortcutData2& shortcut_data, bool success) {
  NavigationEntry* current_entry = controller_.GetLastCommittedEntry();
  bool same_page =
      current_entry && pending_install_.page_id == current_entry->page_id();

  if (success && same_page) {
    // Only switch to app mode if the user chose to create a shortcut and
    // we're still on the same page that it corresponded to.
    if (delegate())
      delegate()->ConvertContentsToApplication(this);
  }

  // Reset the page id to indicate no requests are pending.
  pending_install_.page_id = 0;
  pending_install_.callback_functor = NULL;
}
#include "base/basictypes.h"
#include "chrome/browser/cancelable_request.h"
#include "chrome/browser/download/save_package.h"
#include "chrome/browser/fav_icon_helper.h"
#include "chrome/browser/find_notification_details.h"
#include "chrome/browser/shell_dialogs.h"
#include "chrome/browser/renderer_host/render_view_host_delegate.h"
#include "chrome/browser/tab_contents/render_view_host_manager.h"
#include "chrome/common/gears_api.h"
#include "net/base/load_states.h"
#include "webkit/glue/password_form.h"
#include "webkit/glue/webpreferences.h"


#if defined(OS_MACOSX) || defined(OS_LINUX)
// Remove when we've finished porting the supporting classes.
#include "chrome/common/temp_scaffolding_stubs.h"
#elif defined(OS_WIN)
#include "chrome/browser/printing/print_view_manager.h"
#endif
class AutofillManager;
class PasswordManager;
class PluginInstaller;
class TabContentsView;
  // When CreateShortcut is invoked RenderViewHost::GetApplicationInfo is
  // invoked. CreateShortcut caches the state of the page needed to create the
  // shortcut in PendingInstall. When OnDidGetApplicationInfo is invoked, it
  // uses the information from PendingInstall and the WebApplicationInfo
  // to create the shortcut.
  class GearsCreateShortcutCallbackFunctor;
  struct PendingInstall {
    int32 page_id;
    SkBitmap icon;
    std::wstring title;
    GURL url;
    // This object receives the GearsCreateShortcutCallback and routes the
    // message back to the WebContents, if we haven't been deleted.
    GearsCreateShortcutCallbackFunctor* callback_functor;
  };

  // TODO(brettw) move thos to tab_contents.cc once WebContents and
  // TabContents are merged.
  class GearsCreateShortcutCallbackFunctor {
   public:
    explicit GearsCreateShortcutCallbackFunctor(TabContents* contents)
       : contents_(contents) {}

    void Run(const GearsShortcutData2& shortcut_data, bool success) {
      if (contents_)
        contents_->OnGearsCreateShortcutDone(shortcut_data, success);
      delete this;
    }
    void Cancel() {
      contents_ = NULL;
    }

   private:
    TabContents* contents_;
  };


  // Called when the user dismisses the shortcut creation dialog.  'success' is
  // true if the shortcut was created.
  void OnGearsCreateShortcutDone(const GearsShortcutData2& shortcut_data,
                                 bool success);

  // Data for core operation ---------------------------------------------------
  // Delegate for notifying our owner about stuff. Not owned by us.

  // Handles the back/forward list and loading.
  // The corresponding view.
  scoped_ptr<TabContentsView> view_;

  // Helper classes ------------------------------------------------------------

  // Manages creation and swapping of render views.
  RenderViewHostManager render_manager_;

  // Stores random bits of data for others to associate with this object.
  // Registers and unregisters us for notifications.
  // Handles print preview and print job for this contents.
  printing::PrintViewManager printing_;

  // SavePackage, lazily created.
  scoped_refptr<SavePackage> save_package_;

  // Tracks our pending CancelableRequests. This maps pending requests to
  // page IDs so that we know whether a given callback still applies. The
  // page ID -1 means no page ID was set.
  CancelableRequestConsumerT<int32, -1> cancelable_consumer_;

  // AutofillManager, lazily created.
  scoped_ptr<AutofillManager> autofill_manager_;

  // PasswordManager, lazily created.
  scoped_ptr<PasswordManager> password_manager_;

  // PluginInstaller, lazily created.
  scoped_ptr<PluginInstaller> plugin_installer_;

  // Handles downloading favicons.
  FavIconHelper fav_icon_helper_;

  // Dialog box used for choosing files to upload from file form fields.
  scoped_refptr<SelectFileDialog> select_file_dialog_;

  // Web app installation.
  PendingInstall pending_install_;

  // Data for loading state ----------------------------------------------------

  // Indicates if the tab is considered crashed.
  bool is_crashed_;
  // TODO(brettw) this seems like it can be removed according to the comment.
  // System time at which the current load was started.
  base::TimeTicks current_load_start_;

  // The current load state and the URL associated with it.
  net::LoadState load_state_;
  std::wstring load_state_host_;

  // Data for current page -----------------------------------------------------

  // Whether we have a (non-empty) title for the current page.
  // Used to prevent subsequent title updates from affecting history. This
  // prevents some weirdness because some AJAXy apps use titles for status
  // messages.
  bool received_page_title_;

  // Whether the current URL is starred
  bool is_starred_;

  // When a navigation occurs, we record its contents MIME type. It can be
  // used to check whether we can do something for some special contents.
  std::string contents_mime_type_;

  // Character encoding. TODO(jungshik) : convert to std::string
  std::wstring encoding_;

  // Data for shelves and stuff ------------------------------------------------

  // The download shelf view (view at the bottom of the page).
  scoped_ptr<DownloadShelf> download_shelf_;

  // Whether the shelf view is visible.
  bool shelf_visible_;
  // popups. This pointer also goes in |child_windows_| for ownership,
  // The last time that the download shelf was made visible.
  base::TimeTicks last_download_shelf_show_;

  // Data for find in page -----------------------------------------------------

  // TODO(brettw) this should be separated into a helper class.

  // Each time a search request comes in we assign it an id before passing it
  // over the IPC so that when the results come in we can evaluate whether we
  // still care about the results of the search (in some cases we don't because
  // the user has issued a new search).
  static int find_request_id_counter_;

  // True if the Find UI is active for this Tab.
  bool find_ui_active_;

  // True if a Find operation was aborted. This can happen if the Find box is
  // closed or if the search term inside the Find box is erased while a search
  // is in progress. This can also be set if a page has been reloaded, and will
  // on FindNext result in a full Find operation so that the highlighting for
  // inactive matches can be repainted.
  bool find_op_aborted_;

  // This variable keeps track of what the most recent request id is.
  int current_find_request_id_;

  // The last string we searched for. This is used to figure out if this is a
  // Find or a FindNext operation (FindNext should not increase the request id).
  string16 find_text_;

  // Keeps track of the last search string that was used to search in any tab.
  string16* find_prepopulate_text_;

  // The last find result. This object contains details about the number of
  // matches, the find selection rectangle, etc. The UI can access this
  // information to build its presentation.
  FindNotificationDetails find_result_;

  // Data for misc internal state ----------------------------------------------

  // See capturing_contents() above.
  bool capturing_contents_;

  // Indicates whether we should notify about disconnection of this
  // TabContents. This is used to ensure disconnection notifications only
  // happen if a connection notification has happened and that they happen only
  // once.
  bool notify_disconnection_;

  // Maps from handle to page_id.
  typedef std::map<HistoryService::Handle, int32> HistoryRequestMap;
  HistoryRequestMap history_requests_;

#if defined(OS_WIN)
  // Handle to an event that's set when the page is showing a message box (or
  // equivalent constrained window).  Plugin processes check this to know if
  // they should pump messages then.
  ScopedHandle message_box_active_;
#endif

  // The time that the last javascript message was dismissed.
  base::TimeTicks last_javascript_message_dismissal_;

  // True if the user has decided to block future javascript messages. This is
  // reset on navigations to false on navigations.
  bool suppress_javascript_messages_;

  // ---------------------------------------------------------------------------

    : TabContents(profile) {
DevToolsManager::DevToolsManager() : tab_contents_listeners_(NULL) {
  DCHECK(!tab_contents_listeners_.get()) <<
    Source<TabContents> src(source);
    const TabContents& tab_contents) {
  const NavigationController& navigation_controller = tab_contents.controller();
    TabContents& tab_contents,
  DCHECK(!GetDevToolsClientHostFor(tab_contents));
  NavigationController* navigation_controller = &tab_contents.controller();
  SendAttachToAgent(tab_contents, tab_contents.render_view_host());
  RenderViewHost* target_host = tc->render_view_host();
  TabContents* wc = from.delegate()->GetAsWebContents();
void DevToolsManager::OpenDevToolsWindow(TabContents* wc) {
void DevToolsManager::InspectElement(TabContents* wc, int x, int y) {
  SendDetachToAgent(*tab_contents);
  if (!tab_contents_listeners_.get()) {
    tab_contents_listeners_.reset(new NotificationRegistrar);
    tab_contents_listeners_->Add(
  DCHECK(tab_contents_listeners_.get());
    tab_contents_listeners_.reset();
void DevToolsManager::SendAttachToAgent(const TabContents& wc,
void DevToolsManager::SendDetachToAgent(const TabContents& wc) {
class TabContents;
  // Returns DevToolsClientHost registered for |tab_contents| or NULL if
  // there is no alive DevToolsClientHost registered for |tab_contents|.
  DevToolsClientHost* GetDevToolsClientHostFor(const TabContents& tab_contents);
  // Registers new DevToolsClientHost for |tab_contents|. There must be no
  // other DevToolsClientHosts registered for the TabContents at the moment.
  void RegisterDevToolsClientHostFor(TabContents& tab_contents,
  void OpenDevToolsWindow(TabContents* wc);
  void InspectElement(TabContents* tab_contents, int x, int y);
  // there is a DevToolsClientHost registered for the |tab_contents|.
      const TabContents& tab_contents,
  void SendDetachToAgent(const TabContents& tab_contents);
  scoped_ptr<NotificationRegistrar> tab_contents_listeners_;
#include "base/string16.h"
#include "base/time.h"
#include "chrome/browser/browser_process.h"
#include "chrome/browser/debugger/devtools_manager.h"
#include "chrome/browser/dom_ui/dom_ui.h"
#include "chrome/browser/dom_ui/dom_ui_factory.h"
#include "chrome/browser/renderer_host/render_widget_host_view.h"
#include "chrome/browser/renderer_host/web_cache_manager.h"
#include "chrome/common/url_constants.h"
const string16& TabContents::GetTitle() const {
  DOMUI* our_dom_ui = render_manager_.pending_dom_ui() ?
      render_manager_.pending_dom_ui() : render_manager_.dom_ui();
  if (our_dom_ui) {
    // Don't override the title in view source mode.
    NavigationEntry* entry = controller_.GetActiveEntry();
    if (!(entry && entry->IsViewSourceMode())) {
      // Give the DOM UI the chance to override our title.
      const string16& title = our_dom_ui->overridden_title();
      if (!title.empty())
        return title;
    }
  }

  // We use the title for the last committed entry rather than a pending
  // navigation entry. For example, when the user types in a URL, we want to
  // keep the old page's title until the new load has committed and we get a new
  // title.
  // The exception is with transient pages, for which we really want to use
  // their title, as they are not committed.
  NavigationEntry* entry = controller_.GetTransientEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);

  entry = controller_.GetLastCommittedEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);
  else if (controller_.LoadingURLLazily())
    return controller_.GetLazyTitle();
  return EmptyString16();
}

SiteInstance* TabContents::GetSiteInstance() const {
  return render_manager_.current_host()->site_instance();
}

bool TabContents::ShouldDisplayURL() {
  // Don't hide the url in view source mode.
  NavigationEntry* entry = controller_.GetActiveEntry();
  if (entry && entry->IsViewSourceMode())
    return true;
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->should_hide_url();
  return true;
}

bool TabContents::ShouldDisplayFavIcon() {
  // Always display a throbber during pending loads.
  if (controller_.GetLastCommittedEntry() && controller_.pending_entry())
    return true;

  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->hide_favicon();
  return true;
}

std::wstring TabContents::GetStatusText() const {
  if (!is_loading() || load_state_ == net::LOAD_STATE_IDLE)
    return std::wstring();

  switch (load_state_) {
    case net::LOAD_STATE_WAITING_FOR_CACHE:
      return l10n_util::GetString(IDS_LOAD_STATE_WAITING_FOR_CACHE);
    case net::LOAD_STATE_RESOLVING_PROXY_FOR_URL:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_PROXY_FOR_URL);
    case net::LOAD_STATE_RESOLVING_HOST:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_HOST);
    case net::LOAD_STATE_CONNECTING:
      return l10n_util::GetString(IDS_LOAD_STATE_CONNECTING);
    case net::LOAD_STATE_SENDING_REQUEST:
      return l10n_util::GetString(IDS_LOAD_STATE_SENDING_REQUEST);
    case net::LOAD_STATE_WAITING_FOR_RESPONSE:
      return l10n_util::GetStringF(IDS_LOAD_STATE_WAITING_FOR_RESPONSE,
                                   load_state_host_);
    // Ignore net::LOAD_STATE_READING_RESPONSE and net::LOAD_STATE_IDLE
    case net::LOAD_STATE_IDLE:
    case net::LOAD_STATE_READING_RESPONSE:
      break;
  }

  return std::wstring();
}

void TabContents::DidBecomeSelected() {
  controller_.SetActive(true);

  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // If pid() is -1, that means the RenderProcessHost still hasn't been
  // initialized.  It'll register with CacheManagerHost when it is.
  if (process()->pid() != -1)
    WebCacheManager::GetInstance()->ObserveActivity(process()->pid());
}

void TabContents::WasHidden() {
  if (!capturing_contents()) {
    // |render_view_host()| can be NULL if the user middle clicks a link to open
    // a tab in then background, then closes the tab before selecting it.  This
    // is because closing the tab calls TabContents::Destroy(), which removes
    // the |render_view_host()|; then when we actually destroy the window,
    // OnWindowPosChanged() notices and calls HideContents() (which calls us).
    if (render_widget_host_view())
      render_widget_host_view()->WasHidden();

    // Loop through children and send WasHidden to them, too.
    int count = static_cast<int>(child_windows_.size());
    for (int i = count - 1; i >= 0; --i) {
      ConstrainedWindow* window = child_windows_.at(i);
      window->WasHidden();
    }
  }

  NotificationService::current()->Notify(
      NotificationType::TAB_CONTENTS_HIDDEN,
      Source<TabContents>(this),
      NotificationService::NoDetails());
}

void TabContents::ShowContents() {
  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // Loop through children and send DidBecomeSelected to them, too.
  int count = static_cast<int>(child_windows_.size());
  for (int i = count - 1; i >= 0; --i) {
    ConstrainedWindow* window = child_windows_.at(i);
    window->DidBecomeSelected();
  }
}

void TabContents::HideContents() {
  // TODO(pkasting): http://b/1239839  Right now we purposefully don't call
  // our superclass HideContents(), because some callers want to be very picky
  // about the order in which these get called.  In addition to making the code
  // here practically impossible to understand, this also means we end up
  // calling TabContents::WasHidden() twice if callers call both versions of
  // HideContents() on a WebContents.
  WasHidden();
}

  const NavigationEntry& entry = *controller_.pending_entry();

  RenderViewHost* dest_render_view_host = render_manager_.Navigate(entry);
  if (!dest_render_view_host)
    return false;  // Unable to create the desired render view host.

  // Tell DevTools agent that it is attached prior to the navigation.
  DevToolsManager* dev_tools_manager = g_browser_process->devtools_manager();
  if (dev_tools_manager)  // NULL in unit tests.
    dev_tools_manager->SendAttachToAgent(*this, dest_render_view_host);

  // Used for page load time metrics.
  current_load_start_ = base::TimeTicks::Now();

  // Navigate in the desired RenderViewHost.
  dest_render_view_host->NavigateToEntry(entry, reload);

  if (entry.page_id() == -1) {
    // HACK!!  This code suppresses javascript: URLs from being added to
    // session history, which is what we want to do for javascript: URLs that
    // do not generate content.  What we really need is a message from the
    // renderer telling us that a new page was not created.  The same message
    // could be used for mailto: URLs and the like.
    if (entry.url().SchemeIs(chrome::kJavaScriptScheme))
      return false;
  }

  // Clear any provisional password saves - this stops password infobars
  // showing up on pages the user navigates to while the right page is
  // loading.
  GetPasswordManager()->ClearProvisionalSave();

  if (reload && !profile()->IsOffTheRecord()) {
    HistoryService* history =
        profile()->GetHistoryService(Profile::IMPLICIT_ACCESS);
    if (history)
      history->SetFavIconOutOfDateForPage(entry.url());
  }

void TabContents::Stop() {
  render_manager_.Stop();
  printing_.Stop();
}

void TabContents::Cut() {
  render_view_host()->Cut();
}

void TabContents::Copy() {
  render_view_host()->Copy();
}

void TabContents::Paste() {
  render_view_host()->Paste();
}

void TabContents::DisassociateFromPopupCount() {
  render_view_host()->DisassociateFromPopupCount();
}

TabContents* TabContents::Clone() {
  // We create a new SiteInstance so that the new tab won't share processes
  // with the old one. This can be changed in the future if we need it to share
  // processes for some reason.
  TabContents* tc = new WebContents(profile(),
                                    SiteInstance::CreateSiteInstance(profile()),
                                    MSG_ROUTING_NONE, NULL);
  tc->controller().CopyStateFrom(controller_);
  return tc;
}

void TabContents::PopupNotificationVisibilityChanged(bool visible) {
  render_view_host()->PopupNotificationVisibilityChanged(visible);
}

gfx::NativeView TabContents::GetContentNativeView() {
  return view_->GetContentNativeView();
}

gfx::NativeView TabContents::GetNativeView() const {
  return view_->GetNativeView();
}

void TabContents::GetContainerBounds(gfx::Rect *out) const {
  view_->GetContainerBounds(out);
}

void TabContents::Focus() {
  view_->Focus();
}

void TabContents::SetInitialFocus(bool reverse) {
  render_view_host()->SetInitialFocus(reverse);
}

bool TabContents::FocusLocationBarByDefault() {
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return dom_ui->focus_location_bar_by_default();
  return false;
}

bool TabContents::IsBookmarkBarAlwaysVisible() {
  // See GetDOMUIForCurrentState() comment for more info. This case is very
  // similar, but for non-first loads, we want to use the committed entry. This
  // is so the bookmarks bar disappears at the same time the page does.
  if (controller_.GetLastCommittedEntry()) {
    // Not the first load, always use the committed DOM UI.
    if (render_manager_.dom_ui())
      return render_manager_.dom_ui()->force_bookmark_bar_visible();
    return false;  // Default.
  }

  // When it's the first load, we know either the pending one or the committed
  // one will have the DOM UI in it (see GetDOMUIForCurrentState), and only one
  // of them will be valid, so we can just check both.
  if (render_manager_.pending_dom_ui())
    return render_manager_.pending_dom_ui()->force_bookmark_bar_visible();
  if (render_manager_.dom_ui())
    return render_manager_.dom_ui()->force_bookmark_bar_visible();
  return false;  // Default.
}

void TabContents::SetDownloadShelfVisible(bool visible) {
  if (shelf_visible_ != visible) {
    if (visible) {
      // Invoke GetDownloadShelf to force the shelf to be created.
      GetDownloadShelf();
    }
    shelf_visible_ = visible;

    if (delegate_)
      delegate_->ContentsStateChanged(this);
  }

  // SetShelfVisible can force-close the shelf, so make sure we lay out
  // everything correctly, as if the animation had finished. This doesn't
  // matter for showing the shelf, as the show animation will do it.
  ToolbarSizeChanged(false);

  if (visible) {
    // Always set this value as it reflects the last time the download shelf
    // was made visible (even if it was already visible).
    last_download_shelf_show_ = base::TimeTicks::Now();
  }
}

// Notifies the RenderWidgetHost instance about the fact that the page is
// loading, or done loading and calls the base implementation.
void TabContents::SetIsLoading(bool is_loading,
                               LoadNotificationDetails* details) {
  if (is_loading == is_loading_)
    return;

  if (!is_loading) {
    load_state_ = net::LOAD_STATE_IDLE;
    load_state_host_.clear();
  }

  render_manager_.SetIsLoading(is_loading);

  is_loading_ = is_loading;
  waiting_for_response_ = is_loading;

  if (delegate_)
    delegate_->LoadingStateChanged(this);

  NotificationType type = is_loading ? NotificationType::LOAD_START :
      NotificationType::LOAD_STOP;
  NotificationDetails det = NotificationService::NoDetails();;
  if (details)
      det = Details<LoadNotificationDetails>(details);
  NotificationService::current()->Notify(type,
      Source<NavigationController>(&controller_),
      det);
}


DOMUI* TabContents::GetDOMUIForCurrentState() {
  // When there is a pending navigation entry, we want to use the pending DOMUI
  // that goes along with it to control the basic flags. For example, we want to
  // show the pending URL in the URL bar, so we want the display_url flag to
  // be from the pending entry.
  //
  // The confusion comes because there are multiple possibilities for the
  // initial load in a tab as a side effect of the way the RenderViewHostManager
  // works.
  //
  //  - For the very first tab the load looks "normal". The new tab DOM UI is
  //    the pending one, and we want it to apply here.
  //
  //  - For subsequent new tabs, they'll get a new SiteInstance which will then
  //    get switched to the one previously associated with the new tab pages.
  //    This switching will cause the manager to commit the RVH/DOMUI. So we'll
  //    have a committed DOM UI in this case.
  //
  // This condition handles all of these cases:
  //
  //  - First load in first tab: no committed nav entry + pending nav entry +
  //    pending dom ui:
  //    -> Use pending DOM UI if any.
  //
  //  - First load in second tab: no committed nav entry + pending nav entry +
  //    no pending DOM UI:
  //    -> Use the committed DOM UI if any.
  //
  //  - Second navigation in any tab: committed nav entry + pending nav entry:
  //    -> Use pending DOM UI if any.
  //
  //  - Normal state with no load: committed nav entry + no pending nav entry:
  //    -> Use committed DOM UI.
  if (controller_.pending_entry() &&
      (controller_.GetLastCommittedEntry() ||
       render_manager_.pending_dom_ui()))
    return render_manager_.pending_dom_ui();
  return render_manager_.dom_ui();
}
  virtual const string16& GetTitle() const;
  virtual SiteInstance* GetSiteInstance() const;
  virtual bool ShouldDisplayURL();
  virtual bool ShouldDisplayFavIcon();
  virtual std::wstring GetStatusText() const;
  virtual void DidBecomeSelected();
  virtual void WasHidden();
  // TODO(brettw) document these.
  virtual void ShowContents();
  virtual void HideContents();

  virtual bool NavigateToPendingEntry(bool reload);
  virtual void Stop();
  virtual void Cut();
  virtual void Copy();
  virtual void Paste();
  virtual void DisassociateFromPopupCount();
  virtual TabContents* Clone();
  virtual void PopupNotificationVisibilityChanged(bool visible);
  // TODO(brettw): Most of these should be removed and the caller should call
  // the view directly.
  gfx::NativeView GetContentNativeView();
  gfx::NativeView GetNativeView() const;
  void GetContainerBounds(gfx::Rect *out) const;
  void Focus();
  void SetInitialFocus(bool reverse);

  // Returns true if the location bar should be focused by default rather than
  // the page contents. The view will call this function when the tab is
  // to see what it should do.
  bool FocusLocationBarByDefault();
  virtual bool IsBookmarkBarAlwaysVisible();
  virtual void SetDownloadShelfVisible(bool visible);
  RenderWidgetHostView* render_widget_host_view() const {
    return render_manager_.current_view();
  }

  void SetIsLoading(bool is_loading,
                    LoadNotificationDetails* details);

  // Returns the DOMUI for the current state of the tab. This will either be
  // the pending DOMUI, the committed DOMUI, or NULL.
  DOMUI* GetDOMUIForCurrentState();

        m_databaseThread->start();
#include "platform/Logging.h"
#include "public/platform/Platform.h"
    : m_transactionClient(adoptPtr(new SQLTransactionClient()))
    , m_terminationRequested(false)
    if (!m_terminationRequested)
        requestTermination(0);
    m_thread.clear();
void DatabaseThread::start()
    if (m_thread)
        return;
    m_thread = adoptPtr(blink::Platform::current()->createThread("WebCore: Database"));
    ASSERT(!m_terminationRequested);
    m_terminationRequested = true;
    m_thread->postTask(new Task(WTF::bind(&DatabaseThread::cleanupDatabaseThread, this)));
    return m_terminationRequested;
void DatabaseThread::cleanupDatabaseThread()
    LOG(StorageAPI, "Cleaning up DatabaseThread %p", this);
    if (m_cleanupSync) // Someone wanted to know when we were done cleaning up.
        m_cleanupSync->taskCompleted();
    ASSERT(m_terminationRequested || m_openDatabaseSet.contains(database));
    return !m_terminationRequested && m_openDatabaseSet.contains(database);
    ASSERT(m_thread);
    // WebThread takes ownership of the task.
    m_thread->postTask(task.leakPtr());
#include "public/platform/WebThread.h"
    void start();
    bool isDatabaseThread() { return m_thread && m_thread->isCurrentThread(); }
    void cleanupDatabaseThread();
    OwnPtr<blink::WebThread> m_thread;
    bool m_terminationRequested;
bool GetFileUrl(IDataObject* data_object, std::wstring* url,
                std::wstring* title) {
  STGMEDIUM store;
  if (SUCCEEDED(data_object->GetData(ClipboardUtil::GetFilenameWFormat(),
                                     &store))) {
    bool success = false;
    {
      // filename using unicode
      ScopedHGlobal<wchar_t> data(store.hGlobal);
      if (data.get() && data.get()[0] &&
          (PathFileExists(data.get()) || PathIsUNC(data.get()))) {
        wchar_t file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathW(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(file_url);
          title->assign(file_url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }

  if (SUCCEEDED(data_object->GetData(ClipboardUtil::GetFilenameFormat(),
                                     &store))) {
    bool success = false;
    {
      // filename using ascii
      ScopedHGlobal<char> data(store.hGlobal);
      if (data.get() && data.get()[0] && (PathFileExistsA(data.get()) ||
                                          PathIsUNCA(data.get()))) {
        char file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathA(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(UTF8ToWide(file_url));
          title->assign(*url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }
  return false;
}

    std::wstring* url, std::wstring* title, bool convert_filenames) {
  if (convert_filenames) {
    return GetFileUrl(data_object, url, title);
  } else {
    return false;
  return GetUrl(data_object, plain_text, &title, false);
      std::wstring* url, std::wstring* title, bool convert_filenames);
  bool success = ClipboardUtil::GetUrl(source_object_, &url_str, title, true);
      ClipboardUtil::GetUrl(data_object, &url, &title, true);
  if (ClipboardUtil::GetUrl(data_object, &url_str, &drop_data->url_title,
                            false)) {
#include "content/public/browser/web_contents.h"
#include "ui/views/color_chooser/color_chooser_listener.h"
#include "ui/views/color_chooser/color_chooser_view.h"
#include "ui/views/widget/widget.h"

namespace {

class ColorChooserAura : public content::ColorChooser,
                         public views::ColorChooserListener {
 public:
  ColorChooserAura(int identifier,
                   content::WebContents* tab,
                   SkColor initial_color);

 private:
  // content::ColorChooser overrides:
  virtual void End() OVERRIDE;
  virtual void SetSelectedColor(SkColor color) OVERRIDE;

  // views::ColorChooserListener overrides:
  virtual void OnColorChosen(SkColor color) OVERRIDE;
  virtual void OnColorChooserDialogClosed() OVERRIDE;

  // The web contents invoking the color chooser.  No ownership because it will
  // outlive this class.
  content::WebContents* tab_;

  // The actual view of the color chooser.  No ownership because its parent
  // view will take care of its lifetime.
  views::ColorChooserView* view_;

  // The widget for the color chooser.  No ownership because it's released
  // automatically when closed.
  views::Widget* widget_;

  DISALLOW_COPY_AND_ASSIGN(ColorChooserAura);
};

ColorChooserAura::ColorChooserAura(int identifier,
                                   content::WebContents* tab,
                                   SkColor initial_color)
    : ColorChooser(identifier),
      tab_(tab) {
  view_ = new views::ColorChooserView(this, initial_color);
  widget_ = views::Widget::CreateWindow(view_);
  widget_->SetAlwaysOnTop(true);
  widget_->Show();
}

void ColorChooserAura::OnColorChosen(SkColor color) {
  if (tab_)
    tab_->DidChooseColorInColorChooser(identifier(), color);
}

void ColorChooserAura::OnColorChooserDialogClosed() {
  if (tab_)
    tab_->DidEndColorChooser(identifier());
  view_ = NULL;
  widget_ = NULL;
}

void ColorChooserAura::End() {
  if (widget_ && widget_->IsVisible()) {
    widget_->Close();
    view_ = NULL;
    widget_ = NULL;
  }
}

void ColorChooserAura::SetSelectedColor(SkColor color) {
  if (view_)
    view_->OnColorChanged(color);
}

}  // namespace
  return new ColorChooserAura(identifier, tab, initial_color);
#include "ui/views/color_chooser/color_chooser_listener.h"
ColorChooserDialog::ColorChooserDialog(views::ColorChooserListener* listener,
    listener_->OnColorChosen(color);
  listener_->OnColorChooserDialogClosed();
namespace views {
class ColorChooserListener;
}

  ColorChooserDialog(views::ColorChooserListener* listener,
  views::ColorChooserListener* listener_;
#include "ui/views/color_chooser/color_chooser_listener.h"
                        public views::ColorChooserListener {
  // content::ColorChooser overrides:
  // views::ColorChooserListener overrides:
  virtual void OnColorChosen(SkColor color);
  virtual void OnColorChooserDialogClosed();
  // The web contents invoking the color chooser.  No ownership. because it will
  // outlive this class.
  content::WebContents* tab_;

  // The color chooser dialog which maintains the native color chooser UI.
      tab_(tab) {
      tab_->GetRenderViewHost()->GetView()->GetNativeView());
void ColorChooserWin::OnColorChosen(SkColor color) {
  if (tab_)
    tab_->DidChooseColorInColorChooser(identifier(), color);
void ColorChooserWin::OnColorChooserDialogClosed() {
  if (tab_)
    tab_->DidEndColorChooser(identifier());
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef UI_VIEWS_COLOR_CHOOSER_COLOR_CHOOSER_LISTENER_H_
#define UI_VIEWS_COLOR_CHOOSER_COLOR_CHOOSER_LISTENER_H_
#pragma once

#include "third_party/skia/include/core/SkColor.h"
#include "ui/views/views_export.h"

namespace views {

// An interface implemented by a Listener object wishing to know about the
// the results from the color chooser dialog.
class VIEWS_EXPORT ColorChooserListener {
 public:
  virtual void OnColorChosen(SkColor color) = 0;
  virtual void OnColorChooserDialogClosed() = 0;

 protected:
  virtual ~ColorChooserListener() {}
};

}  // namespace views

#endif  // UI_VIEWS_COLOR_CHOOSER_COLOR_CHOOSER_LISTENER_H_
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "ui/views/color_chooser/color_chooser_view.h"

#include "base/logging.h"
#include "base/string_number_conversions.h"
#include "base/stringprintf.h"
#include "base/utf_string_conversions.h"
#include "ui/gfx/canvas.h"
#include "ui/base/keycodes/keyboard_codes.h"
#include "ui/views/color_chooser/color_chooser_listener.h"
#include "ui/views/controls/textfield/textfield.h"
#include "ui/views/controls/textfield/textfield_controller.h"
#include "ui/views/events/event.h"
#include "ui/views/layout/box_layout.h"
#include "ui/views/widget/widget.h"

namespace {

const int kHueBarWidth = 20;
const int kSaturationValueSize = 200;
const int kMarginWidth = 5;
const int kSaturationValueIndicatorSize = 3;
const int kHueIndicatorSize = 3;

string16 GetColorText(SkColor color) {
  return ASCIIToUTF16(base::StringPrintf("#%02x%02x%02x",
                                         SkColorGetR(color),
                                         SkColorGetG(color),
                                         SkColorGetB(color)));
}

bool GetColorFromText(const string16& text, SkColor* result) {
  if (text.size() != 6 && !(text.size() == 7 && text[0] == '#'))
    return false;

  std::string input = UTF16ToUTF8((text.size() == 6) ? text : text.substr(1));
  std::vector<uint8> hex;
  if (!base::HexStringToBytes(input, &hex))
    return false;

  *result = SkColorSetRGB(hex[0], hex[1], hex[2]);
  return true;
}

}  // namespace

namespace views {

// The class to choose the hue of the color.  It draws a vertical bar and
// the indicator for the currently selected hue.
class ColorChooserView::HueView : public View {
 public:
  explicit HueView(ColorChooserView* chooser_view);

  void OnHueChanged(SkScalar hue);

 private:
  // View overrides:
  virtual gfx::Size GetPreferredSize() OVERRIDE;
  virtual void OnPaint(gfx::Canvas* canvas) OVERRIDE;
  virtual bool OnMousePressed(const MouseEvent& event) OVERRIDE;
  virtual bool OnMouseDragged(const MouseEvent& event) OVERRIDE;

  ColorChooserView* chooser_view_;
  int level_;

  DISALLOW_COPY_AND_ASSIGN(HueView);
};

ColorChooserView::HueView::HueView(ColorChooserView* chooser_view)
    : chooser_view_(chooser_view),
      level_(0) {
  set_focusable(false);
}

void ColorChooserView::HueView::OnHueChanged(SkScalar hue) {
  SkScalar height = SkIntToScalar(GetPreferredSize().height() - 1);
  SkScalar hue_max = SkIntToScalar(360);
  int level = SkScalarDiv(SkScalarMul(hue_max - hue, height), hue_max);
  if (level_ != level) {
    level_ = level;
    SchedulePaint();
  }
}

gfx::Size ColorChooserView::HueView::GetPreferredSize() {
  // We put indicators on the both sides of the hue bar.
  return gfx::Size(kHueBarWidth + kHueIndicatorSize * 2, kSaturationValueSize);
}

void ColorChooserView::HueView::OnPaint(gfx::Canvas* canvas) {
  SkScalar hsv[3];
  // In the hue bar, saturation and value for the color should be always 100%.
  hsv[1] = SK_Scalar1;
  hsv[2] = SK_Scalar1;

  for (int y = 0; y < height(); ++y) {
    hsv[0] = SkScalarDiv(SkScalarMul(SkIntToScalar(360),
                                     SkIntToScalar(height() - 1 - y)),
                    SkIntToScalar(height() - 1));
    canvas->DrawLine(gfx::Point(kHueIndicatorSize, y),
                     gfx::Point(width() - kHueIndicatorSize, y),
                     SkHSVToColor(hsv));
  }

  // Put the triangular indicators besides.
  SkPath left_indicator_path;
  SkPath right_indicator_path;
  left_indicator_path.moveTo(
      SK_ScalarHalf, SkIntToScalar(level_ - kHueIndicatorSize));
  left_indicator_path.lineTo(
      kHueIndicatorSize, SkIntToScalar(level_));
  left_indicator_path.lineTo(
      SK_ScalarHalf, SkIntToScalar(level_ + kHueIndicatorSize));
  left_indicator_path.lineTo(
      SK_ScalarHalf, SkIntToScalar(level_ - kHueIndicatorSize));
  right_indicator_path.moveTo(
      SkIntToScalar(width()) - SK_ScalarHalf,
      SkIntToScalar(level_ - kHueIndicatorSize));
  right_indicator_path.lineTo(
      SkIntToScalar(width() - kHueIndicatorSize) - SK_ScalarHalf,
      SkIntToScalar(level_));
  right_indicator_path.lineTo(
      SkIntToScalar(width()) - SK_ScalarHalf,
      SkIntToScalar(level_ + kHueIndicatorSize));
  right_indicator_path.lineTo(
      SkIntToScalar(width()) - SK_ScalarHalf,
      SkIntToScalar(level_ - kHueIndicatorSize));

  SkPaint indicator_paint;
  indicator_paint.setColor(SK_ColorBLACK);
  indicator_paint.setStyle(SkPaint::kStroke_Style);
  canvas->DrawPath(left_indicator_path, indicator_paint);
  canvas->DrawPath(right_indicator_path, indicator_paint);
}

bool ColorChooserView::HueView::OnMousePressed(const MouseEvent& event) {
  level_ = std::max(0, std::min(height() - 1, event.y()));
  chooser_view_->OnHueChosen(SkScalarDiv(
      SkScalarMul(SkIntToScalar(360), SkIntToScalar(height() - 1 - level_)),
      SkIntToScalar(height() - 1)));
  return true;
}

bool ColorChooserView::HueView::OnMouseDragged(const MouseEvent& event) {
  return OnMousePressed(event);
}

// The class to choose the saturation and the value of the color.  It draws
// a square area and the indicator for the currently selected saturation and
// value.
class ColorChooserView::SaturationValueView : public View {
 public:
  explicit SaturationValueView(ColorChooserView* chooser_view);

  void OnHueChanged(SkScalar hue);
  void OnSaturationValueChanged(SkScalar saturation, SkScalar value);

 private:
  // View overrides:
  virtual gfx::Size GetPreferredSize() OVERRIDE;
  virtual void OnPaint(gfx::Canvas* canvas) OVERRIDE;
  virtual bool OnMousePressed(const MouseEvent& event) OVERRIDE;
  virtual bool OnMouseDragged(const MouseEvent& event) OVERRIDE;

  ColorChooserView* chooser_view_;
  SkScalar hue_;
  gfx::Point marker_position_;

  DISALLOW_COPY_AND_ASSIGN(SaturationValueView);
};

ColorChooserView::SaturationValueView::SaturationValueView(
    ColorChooserView* chooser_view)
    : chooser_view_(chooser_view), hue_(0) {
  set_focusable(false);
}

void ColorChooserView::SaturationValueView::OnHueChanged(SkScalar hue) {
  if (hue_ != hue) {
    hue_ = hue;
    SchedulePaint();
  }
}

void ColorChooserView::SaturationValueView::OnSaturationValueChanged(
    SkScalar saturation,
    SkScalar value) {
  SkScalar scalar_size = SkIntToScalar(kSaturationValueSize - 1);
  int x = SkScalarFloorToInt(SkScalarMul(saturation, scalar_size));
  int y = SkScalarFloorToInt(SkScalarMul(SK_Scalar1 - value, scalar_size));
  if (gfx::Point(x, y) == marker_position_)
    return;

  marker_position_.set_x(x);
  marker_position_.set_y(y);
  SchedulePaint();
  chooser_view_->OnSaturationValueChosen(saturation, value);
}

gfx::Size ColorChooserView::SaturationValueView::GetPreferredSize() {
  return gfx::Size(kSaturationValueSize, kSaturationValueSize);
}

void ColorChooserView::SaturationValueView::OnPaint(gfx::Canvas* canvas) {
  SkScalar hsv[3];
  hsv[0] = hue_;
  SkScalar scalar_size = SkIntToScalar(kSaturationValueSize - 1);
  for (int x = 0; x < width(); ++x) {
    hsv[1] = SkScalarDiv(SkIntToScalar(x), scalar_size);
    for (int y = 0; y < height(); ++y) {
      hsv[2] = SK_Scalar1 - SkScalarDiv(SkIntToScalar(y), scalar_size);
      SkPaint paint;
      paint.setColor(SkHSVToColor(255, hsv));
      canvas->DrawPoint(gfx::Point(x, y), paint);
    }
  }

  // The background is very dark at the bottom of the view.  Use a white
  // marker in that case.
  SkColor indicator_color =
      (marker_position_.y() > width() * 3 / 4) ? SK_ColorWHITE : SK_ColorBLACK;
  // Draw a crosshair indicator but do not draw its center to see the selected
  // saturation/value.  Note that the DrawLine() doesn't draw the right-bottom
  // pixel.
  canvas->DrawLine(
      gfx::Point(marker_position_.x(),
                 marker_position_.y() - kSaturationValueIndicatorSize),
      gfx::Point(marker_position_.x(),
                 marker_position_.y()),
      indicator_color);
  canvas->DrawLine(
      gfx::Point(marker_position_.x(),
                 marker_position_.y() + kSaturationValueIndicatorSize + 1),
      gfx::Point(marker_position_.x(),
                 marker_position_.y() + 1),
      indicator_color);
  canvas->DrawLine(
      gfx::Point(marker_position_.x() - kSaturationValueIndicatorSize,
                 marker_position_.y()),
      gfx::Point(marker_position_.x(),
                 marker_position_.y()),
      indicator_color);
  canvas->DrawLine(
      gfx::Point(marker_position_.x() + kSaturationValueIndicatorSize + 1,
                 marker_position_.y()),
      gfx::Point(marker_position_.x() + 1,
                 marker_position_.y()),
      indicator_color);
}

bool ColorChooserView::SaturationValueView::OnMousePressed(
    const MouseEvent& event) {
  SkScalar scalar_size = SkIntToScalar(kSaturationValueSize);
  SkScalar saturation = SkScalarDiv(SkIntToScalar(event.x()), scalar_size);
  SkScalar value = SK_Scalar1 - SkScalarDiv(
      SkIntToScalar(event.y()), scalar_size);
  saturation = SkScalarPin(saturation, 0, SK_Scalar1);
  value = SkScalarPin(value, 0, SK_Scalar1);
  OnSaturationValueChanged(saturation, value);
  return true;
}

bool ColorChooserView::SaturationValueView::OnMouseDragged(
    const MouseEvent& event) {
  return OnMousePressed(event);
}


ColorChooserView::ColorChooserView(ColorChooserListener* listener,
                                   SkColor initial_color)
    : listener_(listener) {
  DCHECK(listener_);

  set_focusable(false);
  set_background(Background::CreateSolidBackground(SK_ColorLTGRAY));
  SetLayoutManager(new BoxLayout(BoxLayout::kVertical, kMarginWidth,
                                 kMarginWidth, kMarginWidth));

  View* container = new View();
  container->SetLayoutManager(new BoxLayout(BoxLayout::kHorizontal, 0, 0,
                                            kMarginWidth));
  saturation_value_ = new SaturationValueView(this);
  container->AddChildView(saturation_value_);
  hue_ = new HueView(this);
  container->AddChildView(hue_);
  AddChildView(container);

  textfield_ = new Textfield();
  textfield_->SetController(this);
  AddChildView(textfield_);

  OnColorChanged(initial_color);
}

ColorChooserView::~ColorChooserView() {
}

void ColorChooserView::OnColorChanged(SkColor color) {
  SkColorToHSV(color, hsv_);
  hue_->OnHueChanged(hsv_[0]);
  saturation_value_->OnHueChanged(hsv_[0]);
  saturation_value_->OnSaturationValueChanged(hsv_[1], hsv_[2]);
  textfield_->SetText(GetColorText(color));
}

void ColorChooserView::OnHueChosen(SkScalar hue) {
  hsv_[0] = hue;
  SkColor color = SkHSVToColor(255, hsv_);
  listener_->OnColorChosen(color);
  saturation_value_->OnHueChanged(hue);
  textfield_->SetText(GetColorText(color));
}

void ColorChooserView::OnSaturationValueChosen(SkScalar saturation,
                                               SkScalar value) {
  hsv_[1] = saturation;
  hsv_[2] = value;
  SkColor color = SkHSVToColor(255, hsv_);
  listener_->OnColorChosen(color);
  textfield_->SetText(GetColorText(color));
}

View* ColorChooserView::GetInitiallyFocusedView() {
  return textfield_;
}

ui::ModalType ColorChooserView::GetModalType() const {
  return ui::MODAL_TYPE_WINDOW;
}

void ColorChooserView::WindowClosing() {
  if (listener_)
    listener_->OnColorChooserDialogClosed();
}

View* ColorChooserView::GetContentsView() {
  return this;
}

void ColorChooserView::ContentsChanged(Textfield* sender,
                                       const string16& new_contents) {
  SkColor color = SK_ColorBLACK;
  if (GetColorFromText(new_contents, &color)) {
    SkColorToHSV(color, hsv_);
    listener_->OnColorChosen(color);
    hue_->OnHueChanged(hsv_[0]);
    saturation_value_->OnHueChanged(hsv_[0]);
    saturation_value_->OnSaturationValueChanged(hsv_[1], hsv_[2]);
  }
}

bool ColorChooserView::HandleKeyEvent(Textfield* sender,
                                      const KeyEvent& key_event) {
  if (key_event.key_code() != ui::VKEY_RETURN &&
      key_event.key_code() != ui::VKEY_ESCAPE)
    return false;

  GetWidget()->Close();
  return true;
}

}  // namespace views
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef UI_VIEWS_COLOR_CHOOSER_COLOR_CHOOSER_VIEW_H_
#define UI_VIEWS_COLOR_CHOOSER_COLOR_CHOOSER_VIEW_H_
#pragma once

#include "base/basictypes.h"
#include "base/compiler_specific.h"
#include "third_party/skia/include/core/SkColor.h"
#include "third_party/skia/include/core/SkScalar.h"
#include "ui/views/controls/textfield/textfield_controller.h"
#include "ui/views/views_export.h"
#include "ui/views/widget/widget_delegate.h"

namespace views {

class ColorChooserListener;
class KeyEvent;
class Textfield;

// ColorChooserView provides the UI to choose a color by mouse and/or keyboard.
// It is typically used for <input type="color">.  Currently the user can
// choose a color by dragging over the bar for hue and the area for saturation
// and value.
class VIEWS_EXPORT ColorChooserView : public WidgetDelegateView,
                                      public TextfieldController {
 public:
  ColorChooserView(ColorChooserListener* listener, SkColor initial_color);
  virtual ~ColorChooserView();

  // Called when its color value is changed in the web contents.
  void OnColorChanged(SkColor color);

  // Called when the user chooses a hue from the UI.
  void OnHueChosen(SkScalar hue);

  // Called when the user chooses saturation/value from the UI.
  void OnSaturationValueChosen(SkScalar saturation, SkScalar value);

  float hue() const { return hsv_[0]; }
  float saturation() const { return hsv_[1]; }
  float value() const { return hsv_[2]; }

 private:
  class HueView;
  class SaturationValueView;

  // WidgetDelegate overrides:
  virtual View* GetInitiallyFocusedView() OVERRIDE;
  virtual ui::ModalType GetModalType() const OVERRIDE;
  virtual void WindowClosing() OVERRIDE;
  virtual View* GetContentsView() OVERRIDE;

  // TextfieldController overrides:
  virtual void ContentsChanged(Textfield* sender,
                               const string16& new_contents) OVERRIDE;
  virtual bool HandleKeyEvent(Textfield* sender,
                              const KeyEvent& key_event) OVERRIDE;

  // The current color in HSV coordinate.
  SkScalar hsv_[3];

  // The pointer to the current color chooser for callbacks.  It doesn't take
  // ownership on |listener_| so the user of this class should take care of
  // its lifetime.  See chrome/browser/ui/browser.cc for example.
  ColorChooserListener* listener_;

  // Child views. These are owned as part of the normal views hierarchy.
  // The view of hue chooser.
  HueView* hue_;

  // The view of saturation/value choosing area.
  SaturationValueView* saturation_value_;

  // The textfield to write the color explicitly.
  Textfield* textfield_;

  DISALLOW_COPY_AND_ASSIGN(ColorChooserView);
};

}  // namespace views

#endif  // UI_VIEWS_COLOR_CHOOSER_COLOR_CHOOSER_VIEW_H_
#include "chrome/browser/extensions/extension_install_ui.h"
  ExtensionsService* service = profile_->GetExtensionsService();
  if (service) {
    CrxInstaller::Start(full_path,
                        service->install_directory(),
                        Extension::INTERNAL,
                        "",  // no expected id
                        true,  // please delete crx on completion
                        g_browser_process->file_thread()->message_loop(),
                        service,
                        new ExtensionInstallUI(profile_));
  }
namespace {
  // Helper function to delete files. This is used to avoid ugly casts which
  // would be necessary with PostMessage since file_util::Delete is overloaded.
  static void DeleteFileHelper(const FilePath& path, bool recursive) {
    file_util::Delete(path, recursive);
  }
}

void CrxInstaller::Start(const FilePath& crx_path,
                         const FilePath& install_directory,
                         Extension::Location install_source,
                         const std::string& expected_id,
                         bool delete_crx,
                         MessageLoop* file_loop,
                         ExtensionsService* frontend,
                         CrxInstallerClient* client) {
  // Note: We don't keep a reference because this object manages its own
  // lifetime.
  new CrxInstaller(crx_path, install_directory, install_source, expected_id,
                   delete_crx, file_loop, frontend, client);
}
                           ExtensionsService* frontend,
                           CrxInstallerClient* client)
      frontend_(frontend),
      client_(client),
  extensions_enabled_ = frontend_->extensions_enabled();

CrxInstaller::~CrxInstaller() {
  // Delete the temp directory and crx file as necessary. Note that the
  // destructor might be called on any thread, so we post a task to the file
  // thread to make sure the delete happens there.
  if (!temp_dir_.value().empty()) {
    file_loop_->PostTask(FROM_HERE, NewRunnableFunction(&DeleteFileHelper,
        temp_dir_, true));  // recursive delete
  }

  if (delete_crx_) {
    file_loop_->PostTask(FROM_HERE, NewRunnableFunction(&DeleteFileHelper,
        crx_path_, false));  // non-recursive delete
  }
}

  DCHECK(MessageLoop::current() == file_loop_);
  DCHECK(MessageLoop::current() == file_loop_);

    ReportFailureFromFileThread(StringPrintf(
        "ID in new extension manifest (%s) does not match expected id (%s)",
        extension->id().c_str(),
        expected_id_.c_str()));
  if (client_.get()) {
    ui_loop_->PostTask(FROM_HERE, NewRunnableMethod(this,
        &CrxInstaller::ConfirmInstall));
  } else {
    CompleteInstall();
void CrxInstaller::ConfirmInstall() {
  if (!client_->ConfirmInstall(extension_.get())) {
    // We're done. Since we don't post any more tasks to ourselves, our ref
    // count should go to zero and we die. The destructor will clean up the temp
    // dir.
    return;
  file_loop_->PostTask(FROM_HERE, NewRunnableMethod(this,
      &CrxInstaller::CompleteInstall));
  DCHECK(MessageLoop::current() == file_loop_);

  DCHECK(MessageLoop::current() == file_loop_);
  DCHECK(MessageLoop::current() == ui_loop_);

  // This isn't really necessary, it is only used because unit tests expect to
  // see errors get reported via this interface.
  //
  // TODO(aa): Need to go through unit tests and clean them up too, probably get
  // rid of this line.
  ExtensionErrorReporter::GetInstance()->ReportError(error, false);  // quiet

  if (client_)
    client_->OnInstallFailure(error);
  DCHECK(MessageLoop::current() == file_loop_);
  ui_loop_->PostTask(FROM_HERE, NewRunnableMethod(this,
      &CrxInstaller::ReportOverinstallFromUIThread));
}

void CrxInstaller::ReportOverinstallFromUIThread() {
  DCHECK(MessageLoop::current() == ui_loop_);

  if (client_.get())
    client_->OnOverinstallAttempted(extension_.get());

  frontend_->OnExtensionOverinstallAttempted(extension_->id());
  DCHECK(MessageLoop::current() == file_loop_);
  ui_loop_->PostTask(FROM_HERE, NewRunnableMethod(this,
      &CrxInstaller::ReportSuccessFromUIThread));
}

void CrxInstaller::ReportSuccessFromUIThread() {
  DCHECK(MessageLoop::current() == ui_loop_);

  // If there is a client, tell the client about installation.
  if (client_.get())
    client_->OnInstallSuccess(extension_.get());

  frontend_->OnExtensionInstalled(extension_.release());

  // We're done. We don't post any more tasks to ourselves so we are deleted
  // soon.
// Classes that want to know about install completion, or that want to have an
// opportunity to reject the unpacked extension before installation, should
// implement this interface.
class CrxInstallerClient
    : public base::RefCountedThreadSafe<CrxInstallerClient> {
 public:
  virtual ~CrxInstallerClient() {}

  // Return true to indicate that installation should proceed, false otherwise.
  virtual bool ConfirmInstall(Extension* extension) = 0;

  // Installation was successful.
  virtual void OnInstallSuccess(Extension* extension) = 0;

  // Intallation failed.
  virtual void OnInstallFailure(const std::string& error) = 0;

  // The install was rejected because the same extension/version is already
  // installed.
  virtual void OnOverinstallAttempted(Extension* extension) = 0;
};

  // Starts the installation of the crx file in |crx_path| into
  // |install_directory|.
  //
  // Other params:
  //  install_source: The source of the install (external, --load-extension, etc
  //  expected_id: Optional. If the caller knows what the ID of this extension
  //               should be after unpacking, it can be specified here as a
  //               sanity check.
  //  delete_crx: Whether the crx should be deleted on completion.
  //  file_loop: The message loop to do file IO on.
  //  frontend: The ExtensionsService to report the successfully installed
  //            extension to.
  //  client: Optional. If specified, will be used to confirm installation and
  //          also notified of success/fail. Note that we hold a reference to
  //          this, so it can outlive its creator (eg the UI).
  static void Start(const FilePath& crx_path,
                    const FilePath& install_directory,
                    Extension::Location install_source,
                    const std::string& expected_id,
                    bool delete_crx,
                    MessageLoop* file_loop,
                    ExtensionsService* frontend,
                    CrxInstallerClient* client);

 private:
               ExtensionsService* frontend,
               CrxInstallerClient* client);
  ~CrxInstaller();
  // Runs on the UI thread. Confirms with the user (via CrxInstallerClient) that
  // it is OK to install this extension.
  void ConfirmInstall();
  void ReportOverinstallFromUIThread();
  void ReportSuccessFromUIThread();
  // Whether manual extension installation is enabled. We can't just check this
  // before trying to install because themes are special-cased to always be
  // allowed.
  // The client we will work with to do the installation. This can be NULL, in
  // which case the install is silent.
  scoped_refptr<CrxInstallerClient> client_;

// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/extensions/extension_install_ui.h"

#include "app/l10n_util.h"
#include "grit/chromium_strings.h"
#include "chrome/browser/browser_list.h"
#include "chrome/browser/extensions/theme_preview_infobar_delegate.h"
#include "chrome/browser/profile.h"
#include "chrome/browser/tab_contents/tab_contents.h"

#if defined(OS_WIN)
#include "app/win_util.h"
#elif defined(OS_MACOSX)
#include "base/scoped_cftyperef.h"
#include "base/sys_string_conversions.h"
#include <CoreFoundation/CFUserNotification.h>
#endif

ExtensionInstallUI::ExtensionInstallUI(Profile* profile)
    : profile_(profile), ui_loop_(MessageLoop::current()) {
}

bool ExtensionInstallUI::ConfirmInstall(Extension* extension) {
  DCHECK(ui_loop_ == MessageLoop::current());

  // We special-case themes to not show any confirm UI. Instead they are
  // immediately installed, and then we show an infobar (see OnInstallSuccess)
  // to allow the user to revert if they don't like it.
  if (extension->IsTheme())
    return true;

#if defined(OS_WIN)
  if (win_util::MessageBox(GetForegroundWindow(),
          L"Are you sure you want to install this extension?\n\n"
          L"You should only install extensions from sources you trust.",
          l10n_util::GetString(IDS_PRODUCT_NAME).c_str(),
          MB_OKCANCEL) != IDOK) {
    return false;
  }
#elif defined(OS_MACOSX)
  // Using CoreFoundation to do this dialog is unimaginably lame but will do
  // until the UI is redone.
  scoped_cftyperef<CFStringRef> product_name(
      base::SysWideToCFStringRef(l10n_util::GetString(IDS_PRODUCT_NAME)));
  CFOptionFlags response;
  if (kCFUserNotificationAlternateResponse == CFUserNotificationDisplayAlert(
      0, kCFUserNotificationCautionAlertLevel, NULL, NULL, NULL,
      product_name,
      CFSTR("Are you sure you want to install this extension?\n\n"
           "This is a temporary message and it will be removed when "
           "extensions UI is finalized."),
      NULL, CFSTR("Cancel"), NULL, &response)) {
    return false;
  }
#else
  NOTREACHED();
#endif  // OS_*

  return true;
}

void ExtensionInstallUI::OnInstallSuccess(Extension* extension) {
  ShowThemeInfoBar(extension);
}

void ExtensionInstallUI::OnInstallFailure(const std::string& error) {
  DCHECK(ui_loop_ == MessageLoop::current());

#if defined(OS_WIN)
  win_util::MessageBox(NULL, UTF8ToWide(error), L"Extension Install Error",
      MB_OK | MB_SETFOREGROUND);
#elif defined(OS_MACOSX)
  // There must be a better way to do this, for all platforms.
  scoped_cftyperef<CFStringRef> message_cf(
      base::SysUTF8ToCFStringRef(error));
  CFOptionFlags response;
  CFUserNotificationDisplayAlert(
      0, kCFUserNotificationCautionAlertLevel, NULL, NULL, NULL,
      CFSTR("Extension Install Error"), message_cf,
      NULL, NULL, NULL, &response);
#else
  LOG(ERROR) << "Extension install failed: " << error.c_str();
  NOTREACHED();
#endif
}

void ExtensionInstallUI::OnOverinstallAttempted(Extension* extension) {
  ShowThemeInfoBar(extension);
}

void ExtensionInstallUI::ShowThemeInfoBar(Extension* extension) {
  if (!extension->IsTheme())
    return;

  Browser* browser = BrowserList::GetLastActiveWithProfile(profile_);
  if (!browser)
    return;

  TabContents* tab_contents = browser->GetSelectedTabContents();
  if (!tab_contents)
    return;

  // First remove any previous theme preview infobar.
  for (int i = 0; i < tab_contents->infobar_delegate_count(); ++i) {
    InfoBarDelegate* delegate = tab_contents->GetInfoBarDelegateAt(i);
    if (delegate->AsThemePreviewInfobarDelegate()) {
      tab_contents->RemoveInfoBar(delegate);
      break;
    }
  }

  // Now add the new one.
  tab_contents->AddInfoBar(new ThemePreviewInfobarDelegate(
      tab_contents, extension->name()));
}
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_EXTENSIONS_EXTENSION_INSTALL_UI_H_
#define CHROME_BROWSER_EXTENSIONS_EXTENSION_INSTALL_UI_H_

#include "base/file_path.h"
#include "base/gfx/native_widget_types.h"
#include "base/ref_counted.h"
#include "chrome/browser/extensions/crx_installer.h"

class ExtensionsService;
class MessageLoop;
class Profile;
class SandboxedExtensionUnpacker;

// Displays all the UI around extension installation.
//
// TODO(aa): This will become a view and move to browser/views/extensions in the
// future.
class ExtensionInstallUI : public CrxInstallerClient {
 public:
  ExtensionInstallUI(Profile* profile);

 private:
  // CrxInstallerClient
  virtual bool ConfirmInstall(Extension* extension);
  virtual void OnInstallSuccess(Extension* extension);
  virtual void OnInstallFailure(const std::string& error);
  virtual void OnOverinstallAttempted(Extension* extension);

  void ShowThemeInfoBar(Extension* extension);

  Profile* profile_;
  MessageLoop* ui_loop_;
};

#endif  // CHROME_BROWSER_EXTENSIONS_EXTENSION_INSTALL_UI_H_
/*
*/
const char* ExtensionsService::kGalleryDownloadURLPrefix =
    "http://www.corp.google.com/~glen/chrome/";
const char* ExtensionsService::kGalleryURLPrefix =
    "http://www.corp.google.com/~glen/chrome/";
  CrxInstaller::Start(extension_path, install_directory_, Extension::INTERNAL,
                      "",   // no expected id
                      false,  // don't delete crx when complete
                      backend_loop_,
                      this,
                      NULL);  // no client (silent install)
  CrxInstaller::Start(extension_path, install_directory_, Extension::INTERNAL,
                      id,
                      true,  // delete crx when complete
                      backend_loop_,
                      this,
                      NULL);  // no client (silent install)
  CrxInstaller::Start(path, install_directory_, location, id,
                      false,  // don't delete crx when complete
                      backend_loop_,
                      this,
                      NULL);  // no client (silent install)
  const FilePath& install_directory() const { return install_directory_; }

  // TODO(aa): This method can be removed. It is only used by the unit tests,
  // and they could use CrxInstaller directly instead.
  // TODO(aa): This method can be removed. ExtensionUpdater could use
  // CrxInstaller directly instead.
      : crx_path_(crx_path), file_loop_(NULL), rdh_(rdh), client_(client),
        got_response_(false) {
  // We assume that we are started on the thread that the client wants us to do
  // file IO on.
  file_loop_ = MessageLoop::current();

  UtilityProcessHost* host = new UtilityProcessHost(rdh_, this, file_loop_);
  DCHECK(file_loop_ == MessageLoop::current());
  DCHECK(file_loop_ == MessageLoop::current());
  MessageLoop* file_loop_;
  if (context_->is_valid())
  context_->Invalidate();
// A gin::Runner that delegates to its ScriptContext.
class ScriptContext::Runner : public gin::Runner {
 public:
  explicit Runner(ScriptContext* context);

  // gin::Runner overrides.
  void Run(const std::string& source,
           const std::string& resource_name) override;
  v8::Handle<v8::Value> Call(v8::Handle<v8::Function> function,
                             v8::Handle<v8::Value> receiver,
                             int argc,
                             v8::Handle<v8::Value> argv[]) override;
  gin::ContextHolder* GetContextHolder() override;

 private:
  ScriptContext* context_;
};

      url_(web_frame_ ? GetDataSourceURLForFrame(web_frame_) : GURL()),
      runner_(new Runner(this)) {
  gin::PerContextData::From(v8_context)->set_runner(runner_.get());
  runner_.reset();
ScriptContext::Runner::Runner(ScriptContext* context) : context_(context) {
}
void ScriptContext::Runner::Run(const std::string& source,
                                const std::string& resource_name) {
  context_->module_system()->RunString(source, resource_name);
}

v8::Handle<v8::Value> ScriptContext::Runner::Call(
    v8::Handle<v8::Function> function,
    v8::Handle<v8::Value> receiver,
    int argc,
    v8::Handle<v8::Value> argv[]) {
  return context_->CallFunction(function, argc, argv);
}

gin::ContextHolder* ScriptContext::Runner::GetContextHolder() {
  v8::HandleScope handle_scope(context_->isolate());
  return gin::PerContextData::From(context_->v8_context())->context_holder();
}

class ScriptContext : public RequestSender::Source {
  class Runner;

  scoped_ptr<Runner> runner_;

// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/module_system_test.h"
#include "extensions/renderer/script_context.h"
#include "gin/per_context_data.h"
#include "gin/runner.h"

namespace extensions {

using ScriptContextTest = ModuleSystemTest;

TEST_F(ScriptContextTest, GinRunnerLifetime) {
  ExpectNoAssertionsMade();
  base::WeakPtr<gin::Runner> weak_runner =
      gin::PerContextData::From(env()->context()->v8_context())
          ->runner()
          ->GetWeakPtr();
  env()->ShutdownModuleSystem();
  EXPECT_FALSE(weak_runner);
}

}  // namespace extensions
static bool schemeRequiresAuthority(const KURL& url)
    // We expect URLs with these schemes to have authority components. If the
    // URL lacks an authority component, we get concerned and mark the origin
    // as unique.
    return url.protocolIsInHTTPFamily() || url.protocolIs("ftp");
}

// Some URL schemes use nested URLs for their security context. For example,
// filesystem URLs look like the following:
//
//   filesystem:http://example.com/temporary/path/to/file.png
//
// We're supposed to use "http://example.com" as the origin.
//
// Generally, we add URL schemes to this list when WebKit support them. For
// example, we don't include the "jar" scheme, even though Firefox understands
// that jar uses an inner URL for it's security origin.
//
static bool shouldUseInnerURL(const KURL& url)
{
#if ENABLE(BLOB)
    if (url.protocolIs("blob"))
        return true;
#endif
#if ENABLE(FILE_SYSTEM)
    if (url.protocolIs("filesystem"))
        return true;
#endif
    return false;
}

// In general, extracting the inner URL varies by scheme. It just so happens
// that all the URL schemes we currently support that use inner URLs for their
// security origin can be parsed using this algorithm.
static KURL extractInnerURL(const KURL& url)
{
    // FIXME: Update this callsite to use the innerURL member function when
    // we finish implementing it.
    return KURL(ParsedURLString, decodeURLEscapeSequences(url.path()));
}

static bool isDirectory(const String& path)
{
    return path.endsWith("/");
}

static bool shouldTreatAsUniqueOrigin(const KURL& url)
{
    if (!url.isValid())
        return true;

    // FIXME: Do we need to unwrap the URL further?
    KURL innerURL = shouldUseInnerURL(url) ? extractInnerURL(url) : url;

    // FIXME: Check whether innerURL is valid.
    // For edge case URLs that were probably misparsed, make sure that the origin is unique.
    // FIXME: Do we really need to do this? This looks to be a hack around a
    // security bug in CFNetwork that might have been fixed.
    if (schemeRequiresAuthority(innerURL) && innerURL.host().isEmpty())
        return true;

    // SchemeRegistry needs a lower case protocol because it uses HashMaps
    // that assume the scheme has already been canonicalized.
    String protocol = innerURL.protocol().lower();

    if (SchemeRegistry::shouldTreatURLSchemeAsNoAccess(protocol))
        return true;

    // We use unique origins for directory listings to make it harder to crawl
    // a local filesystem. Notice that we apply this protection only when we
    // use the outer URL for the security context because schemes that wrap
    // other URLs don't have directory listings.
    if (SchemeRegistry::shouldTreatURLSchemeAsLocal(protocol) && !shouldUseInnerURL(url)) {
        if (!innerURL.hasPath() || isDirectory(innerURL.path()))
            return true;
    // This is the common case.
    return false;
SecurityOrigin::SecurityOrigin(const KURL& url)
    , m_isUnique(false)
    , m_needsDatabaseIdentifierQuirkForFiles(false)
    ASSERT(url.isValid());
    // By default, only local SecurityOrigins can load local resources.
    m_canLoadLocalResources = isLocal();

    if (m_canLoadLocalResources)
        m_filePath = url.path(); // In case enforceFilePathSeparation() is called.
}
SecurityOrigin::SecurityOrigin()
    : m_protocol("")
    , m_host("")
    , m_domain("")
    , m_port(InvalidPort)
    , m_isUnique(true)
    , m_universalAccess(false)
    , m_domainWasSetInDOM(false)
    , m_canLoadLocalResources(false)
    , m_enforceFilePathSeparation(false)
    , m_needsDatabaseIdentifierQuirkForFiles(false)
{
    , m_needsDatabaseIdentifierQuirkForFiles(other->m_needsDatabaseIdentifierQuirkForFiles)
    if (forceUnique || shouldTreatAsUniqueOrigin(url)) {
        RefPtr<SecurityOrigin> origin = adoptRef(new SecurityOrigin());

        if (url.protocolIs("file")) {
            // Unfortunately, we can't represent all unique origins exactly
            // the same way because we need to produce a quirky database
            // identifier for file URLs due to persistent storage in some
            // embedders of WebKit.
            origin->m_needsDatabaseIdentifierQuirkForFiles = true;
        }

        return origin.release();
    }

    if (shouldUseInnerURL(url))
        return adoptRef(new SecurityOrigin(extractInnerURL(url)));

    return adoptRef(new SecurityOrigin(url));
    RefPtr<SecurityOrigin> origin = adoptRef(new SecurityOrigin());
    if (m_needsDatabaseIdentifierQuirkForFiles)
    SecurityOrigin();
    explicit SecurityOrigin(const KURL&);
    bool m_needsDatabaseIdentifierQuirkForFiles;
  ASSERT_TRUE(shared_buf.Create("", false, true, bytes));
  if (!dib->shared_memory_.Create("", false /* read write */,
  if (!dib->shared_memory_.Create("", false /* read write */,
  bool Create(const std::string& name, bool read_only, bool open_existing,
  bool Delete(const std::string& name);
  bool Open(const std::string& name, bool read_only);
  bool CreateOrOpen(const std::string& name, int posix_flags, uint32 size);
  bool FilePathForMemoryName(const std::string& mem_name, FilePath* path);
bool SharedMemory::Create(const std::string& name, bool read_only,
bool SharedMemory::Delete(const std::string& name) {
bool SharedMemory::Open(const std::string& name, bool read_only) {
// For the given shmem named |mem_name|, return a filename to mmap()
bool SharedMemory::FilePathForMemoryName(const std::string& mem_name,
  DCHECK(mem_name.find('/') == std::string::npos);
  DCHECK(mem_name.find('\0') == std::string::npos);
  if (!file_util::GetShmemTempDir(&temp_dir))
  *path = temp_dir.AppendASCII("com.google.chrome.shmem." + mem_name);
bool SharedMemory::CreateOrOpen(const std::string& name,
  if (name.empty()) {
  static const char* const s_test_name_;
const char* const MultipleThreadMain::s_test_name_ =
    "SharedMemoryOpenThreadTest";
      EXPECT_TRUE(memory1.Create("SharedMemoryMultipleLockThreadTest",
  std::string test_name = "SharedMemoryOpenCloseTest";
    rv = memories[i].Create("", false, true, kDataSize);
  static const char* const s_test_name_;
const char* const SharedMemoryProcessTest::s_test_name_ = "MPMem";
#include "base/utf_string_conversions.h"
bool SharedMemory::Create(const std::string& name, bool read_only,
  name_ = ASCIIToWide(name);
      name_.empty() ? NULL : name_.c_str());
bool SharedMemory::Delete(const std::string& name) {
bool SharedMemory::Open(const std::string& name, bool read_only) {
  name_ = ASCIIToWide(name);
      name_.empty() ? NULL : name_.c_str());
  if (!priv->shared_memory_.Create(name, false, true, size))
  void DeleteShmem(const std::string& name) {
    mem.Delete(name);
  if (!shared_memory->Create(std::string(),  // anonymous
    if (shared_memory_.Create(std::string(), false, false, buffer_size_) &&
  if (!entry->shared_memory.Create("", false, false, hardware_packet_size) ||
    if (shm.Create("", false, false, shm_size))
  if (!shared_memory->Create("", false /* read write */,
  shared_buf.Create("", false, false, buffer_size);
  if (!shared_memory_->Create(std::string() /* anonymous */,
      EXPECT_TRUE(shared_mem.Create(std::string(), false, false,
                                    test_page_contents_len));
    EXPECT_EQ(true, shared_handle_.Create("DeferredResourceLoaderTest", false,
  if (!input_transfer_buffer_->Create(std::string(), false, false, size))
  if (!shared_buf->Create(std::string(), false, false, size)) {
    CHECK(shared_mem_.Create("", false, false, kSize));
  shared_buf.Create("", false, false, buffer_size);
    if (shared_buf.Create("", false, false, buf_size) &&
      "", false /* read write */, true /* open existing */, buf_size);
  ASSERT_TRUE(shared_memory.Create(std::string(), false, false, body.size()));
  memory.Delete(filename);
  if (ring_buffer_->Create(std::string(), false, false, size)) {
  if (!buffer->Create(std::string(), false, false, size))
    shared_memory_->Create(std::string(), false, false, kRingBufferSize);
  memory.Delete(filename);

// Creates a symbolic link at |symlink| pointing to |target|.  Returns
// false on failure.
bool CreateSymbolicLink(const FilePath& target, const FilePath& symlink);

// Reads the given |symlink| and returns where it points to in |target|.
// Returns false upon failure.
bool ReadSymbolicLink(const FilePath& symlink, FilePath* target);
bool CreateSymbolicLink(const FilePath& target_path,
                        const FilePath& symlink_path) {
  DCHECK(!symlink_path.empty());
  DCHECK(!target_path.empty());
  return ::symlink(target_path.value().c_str(),
                   symlink_path.value().c_str()) != -1;
}

bool ReadSymbolicLink(const FilePath& symlink_path,
                      FilePath* target_path) {
  DCHECK(!symlink_path.empty());
  DCHECK(target_path);
  char buf[PATH_MAX];
  ssize_t count = ::readlink(symlink_path.value().c_str(), buf, arraysize(buf));

  if (count <= 0)
    return false;

  *target_path = FilePath(FilePath::StringType(buf, count));

  return true;
}

TEST_F(FileUtilTest, CreateAndReadSymlinks) {
  FilePath link_from = temp_dir_.path().Append(FPL("from_file"));
  FilePath link_to = temp_dir_.path().Append(FPL("to_file"));
  CreateTextFile(link_to, bogus_content);

  ASSERT_TRUE(file_util::CreateSymbolicLink(link_to, link_from))
    << "Failed to create file symlink.";

  // If we created the link properly, we should be able to read the
  // contents through it.
  std::wstring contents = ReadTextFile(link_from);
  ASSERT_EQ(contents, bogus_content);

  FilePath result;
  ASSERT_TRUE(file_util::ReadSymbolicLink(link_from, &result));
  ASSERT_EQ(link_to.value(), result.value());

  // Link to a directory.
  link_from = temp_dir_.path().Append(FPL("from_dir"));
  link_to = temp_dir_.path().Append(FPL("to_dir"));
  file_util::CreateDirectory(link_to);

  ASSERT_TRUE(file_util::CreateSymbolicLink(link_to, link_from))
    << "Failed to create directory symlink.";

  // Test failures.
  ASSERT_FALSE(file_util::CreateSymbolicLink(link_to, link_to));
  ASSERT_FALSE(file_util::ReadSymbolicLink(link_to, &result));
  FilePath missing = temp_dir_.path().Append(FPL("missing"));
  ASSERT_FALSE(file_util::ReadSymbolicLink(missing, &result));

// The following test of NormalizeFilePath() require that we create a symlink.
// This can not be done on Windows before Vista.  On Vista, creating a symlink
// requires privilege "SeCreateSymbolicLinkPrivilege".
// TODO(skerner): Investigate the possibility of giving base_unittests the
// privileges required to create a symlink.
  ASSERT_TRUE(file_util::CreateSymbolicLink(link_to, link_from))
  ASSERT_TRUE(file_util::CreateSymbolicLink(link_to, link_from))
  ASSERT_TRUE(file_util::CreateSymbolicLink(link_to, link_from))
  ASSERT_TRUE(file_util::CreateSymbolicLink(link_from, link_to))
  // True if the file corresponds to a symbolic link.
  bool is_symbolic_link;

  info->is_symbolic_link = S_ISLNK(file_info.st_mode);
  EXPECT_FALSE(info.is_symbolic_link);
  EXPECT_FALSE(info.is_symbolic_link);
  info->is_symbolic_link = false; // Windows doesn't have symbolic links.
  RenderThread::Get()->RegisterExtension(
      extensions::SafeBuiltins::CreateV8Extension());
#include "extensions/renderer/safe_builtins.h"
  RenderThread::Get()->RegisterExtension(SafeBuiltins::CreateV8Extension());

using v8_helpers::IsEmptyOrUndefied;
  if (!IsEmptyOrUndefied(retval)) {
  if (IsEmptyOrUndefied(has_port))
#include "extensions/renderer/safe_builtins.h"
class V8ExtensionConfigurator {
 public:
  V8ExtensionConfigurator()
      : safe_builtins_(SafeBuiltins::CreateV8Extension()),
        names_(1, safe_builtins_->name()),
        configuration_(
            new v8::ExtensionConfiguration(static_cast<int>(names_.size()),
                                           vector_as_array(&names_))) {
    v8::RegisterExtension(safe_builtins_.get());
  }

  v8::ExtensionConfiguration* GetConfiguration() {
    return configuration_.get();
  }

 private:
  scoped_ptr<v8::Extension> safe_builtins_;
  std::vector<const char*> names_;
  scoped_ptr<v8::ExtensionConfiguration> configuration_;
};

base::LazyInstance<V8ExtensionConfigurator>::Leaky g_v8_extension_configurator =
    LAZY_INSTANCE_INITIALIZER;

  context_holder_->SetContext(v8::Context::New(
      isolate, g_v8_extension_configurator.Get().GetConfiguration()));
  if (handler_function_value.IsEmpty() ||
      handler_function_value->IsUndefined()) {
  v8::Context::Scope context_scope(context_->v8_context());
  data->Set(
      v8::String::NewFromUtf8(isolate, kHandlerFunction),
  v8::Context::Scope context_scope(context_->v8_context());
        data->Get(v8::String::NewFromUtf8(isolate, kHandlerFunction));
    data->Delete(v8::String::NewFromUtf8(isolate, kHandlerFunction));
const char kClassName[] = "extensions::SafeBuiltins";
// Documentation for makeCallback in the JavaScript, out here to reduce the
// (very small) amount of effort that the v8 parser needs to do:
//
// Returns a new object with every function on |obj| configured to call()\n"
// itself with the given arguments.\n"
// E.g. given\n"
//    var result = makeCallable(Function.prototype)\n"
// |result| will be a object including 'bind' such that\n"
//    result.bind(foo, 1, 2, 3);\n"
// is equivalent to Function.prototype.bind.call(foo, 1, 2, 3), and so on.\n"
// This is a convenient way to save functions that user scripts may clobber.\n"
    "(function() {\n"
    "native function Apply();\n"
    "native function Save();\n"
    "      return Apply(\n"
    "  Save(builtin.name, safe);\n"
    "Save('JSON', {\n"
    "}());\n";
                          base::StringPrintf("%s::%s", kClassName, name));
void SaveImpl(const char* name,
              v8::Local<v8::Value> value,
              v8::Local<v8::Context> context) {
  CHECK(!value.IsEmpty() && value->IsObject()) << name;
  context->Global()->SetHiddenValue(MakeKey(name, context->GetIsolate()),
                                    value);
}

v8::Local<v8::Object> Load(const char* name, v8::Local<v8::Context> context) {
  v8::Local<v8::Value> value =
      context->Global()->GetHiddenValue(MakeKey(name, context->GetIsolate()));
  CHECK(!value.IsEmpty() && value->IsObject()) << name;
  return v8::Local<v8::Object>::Cast(value);
}
class ExtensionImpl : public v8::Extension {
 public:
  ExtensionImpl() : v8::Extension(kClassName, kScript) {}
  v8::Local<v8::FunctionTemplate> GetNativeFunctionTemplate(
      v8::Isolate* isolate,
      v8::Local<v8::String> name) override {
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    if (IsTrue(name->Equals(context, ToV8StringUnsafe(isolate, "Apply"))))
      return v8::FunctionTemplate::New(isolate, Apply);
    if (IsTrue(name->Equals(context, ToV8StringUnsafe(isolate, "Save"))))
      return v8::FunctionTemplate::New(isolate, Save);
    NOTREACHED() << *v8::String::Utf8Value(name);
    return v8::Local<v8::FunctionTemplate>();
  }

  static void Apply(const v8::FunctionCallbackInfo<v8::Value>& info) {
    CHECK(info.Length() == 5 && info[0]->IsFunction() &&  // function
          // info[1] could be an object or a string
          info[2]->IsObject() &&  // args
          info[3]->IsInt32() &&   // first_arg_index
          info[4]->IsInt32());    // args_length
    v8::Local<v8::Object> recv;
    if (info[1]->IsObject()) {
      recv = v8::Local<v8::Object>::Cast(info[1]);
    } else if (info[1]->IsString()) {
      recv = v8::StringObject::New(v8::Local<v8::String>::Cast(info[1]))
                 .As<v8::Object>();
    } else {
      info.GetIsolate()->ThrowException(
          v8::Exception::TypeError(ToV8StringUnsafe(
              info.GetIsolate(),
              "The first argument is the receiver and must be an object")));
      return;
    }
    v8::Local<v8::Object> args = v8::Local<v8::Object>::Cast(info[2]);
    v8::Local<v8::Context> context = info.GetIsolate()->GetCurrentContext();
      CHECK(IsTrue(args->Has(context, i + first_arg_index)));
      if (!GetProperty(context, args, i + first_arg_index, &argv[i]))
    if (function->Call(context, recv, argc, argv.get()).ToLocal(&return_value))
  static void Save(const v8::FunctionCallbackInfo<v8::Value>& info) {
    SaveImpl(*v8::String::Utf8Value(info[0]),
             info[1],
             info.GetIsolate()->GetCallingContext());
v8::Extension* SafeBuiltins::CreateV8Extension() { return new ExtensionImpl(); }
SafeBuiltins::SafeBuiltins(ScriptContext* context) : context_(context) {}
SafeBuiltins::~SafeBuiltins() {}
  return Load("Array", context_->v8_context());
  return Load("Function", context_->v8_context());
  return Load("JSON", context_->v8_context());
  return Load("Object", context_->v8_context());
  return Load("RegExp", context_->v8_context());
  return Load("String", context_->v8_context());
  return Load("Error", context_->v8_context());
// A collection of safe builtin objects, in that they won't be tained by
// extensions overriding methods on them.
  // Creates the v8::Extension which manages SafeBuiltins instances.
  static v8::Extension* CreateV8Extension();
  explicit SafeBuiltins(ScriptContext* context);

  virtual ~SafeBuiltins();
      safe_builtins_(this),
#include "extensions/renderer/safe_builtins.h"
  SafeBuiltins* safe_builtins() { return &safe_builtins_; }
  const SafeBuiltins* safe_builtins() const { return &safe_builtins_; }
  SafeBuiltins safe_builtins_;
inline bool IsEmptyOrUndefied(v8::Local<v8::Value> value) {
using blink::WebFrame;
  WebFrame* frame = context()->web_frame();
    WebFrame* frame,
#include "third_party/WebKit/public/web/WebFrame.h"
      blink::WebFrame* frame,
#include "extensions/common/extension.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "extensions/renderer/extension_groups.h"
const Extension* Dispatcher::GetExtensionFromFrameAndWorld(
    const blink::WebFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.

    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_.GetExtensionOrAppIDByURL(frame_url);
  }

  const Extension* extension = extensions_.GetByID(extension_id);
  if (!extension && !extension_id.empty()) {
    // There are conditions where despite a context being associated with an
    // extension, no extension actually gets found.  Ignore "invalid" because
    // CSP blocks extension page loading by switching the extension ID to
    // "invalid". This isn't interesting.
    if (extension_id != "invalid") {
      LOG(ERROR) << "Extension \"" << extension_id << "\" not found";
      RenderThread::Get()->RecordAction(
          UserMetricsAction("ExtensionNotFound_ED"));
    }
  }
  return extension;
}

  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());

  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  script_context_set_.Add(context);
  if (context_type == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(extension);
  switch (context_type) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  ScriptContext* context = script_context_set_.GetByV8Context(v8_context);
  script_context_set_.Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  if (IsSandboxedPage(ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_.ForEach(
  script_context_set_.ForEach(
  MessagingBindings::DeliverMessage(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(script_context_set_, port_id,
  ScriptContextSet::ContextSet removed_contexts =
      script_context_set_.OnExtensionUnloaded(id);
  for (ScriptContextSet::ContextSet::iterator it = removed_contexts.begin();
       it != removed_contexts.end(); ++it) {
    request_sender_->InvalidateSource(*it);
// TODO(kalman): This is checking for the wrong thing, it should be checking if
// the frame's security origin is unique. The extension sandbox directive is
// checked for in extensions/common/manifest_handlers/csp_info.cc.
bool Dispatcher::IsSandboxedPage(const GURL& url) const {
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions_.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

Feature::Context Dispatcher::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (IsSandboxedPage(url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && IsExtensionActive(extension->id())) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of IsSandboxedPage().
  if (!origin.isUnique() && extensions_.ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

class Extension;
    return script_context_set_;
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(const blink::WebFrame* frame,
                                                 int world_id,
                                                 bool use_effective_url);

  bool IsSandboxedPage(const GURL& url) const;

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  ScriptContextSet script_context_set_;
  std::set<std::string> active_extension_ids_;
#include "third_party/WebKit/public/web/WebFrame.h"
    bool* port_created,
    *port_created |= retval->BooleanValue();
  // TODO(robwu): ScriptContextSet.ForEach should accept RenderFrame*.
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  bool port_created = false;
  context_set.ForEach(
      info.target_id, restrict_to_render_view,
                 channel_name, &source, info, tls_channel_id, &port_created));

  // If we didn't create a port, notify the other end of the channel (treat it
  // as a disconnect).
  if (!port_created) {
    content::RenderThread::Get()->Send(new ExtensionHostMsg_CloseChannel(
        target_port_id, kReceivingEndDoesntExistError));
  }
  scoped_ptr<blink::WebScopedUserGesture> web_user_gesture;
  scoped_ptr<blink::WebScopedWindowFocusAllowedIndicator> allow_window_focus;
  if (message.user_gesture) {
    web_user_gesture.reset(new blink::WebScopedUserGesture);
    allow_window_focus.reset(new blink::WebScopedWindowFocusAllowedIndicator);
  }

  // TODO(robwu): ScriptContextSet.ForEach should accept RenderFrame*.
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  context_set.ForEach(
      restrict_to_render_view,
      base::Bind(&DeliverMessageToScriptContext, message.data, target_port_id));
  // TODO(robwu): ScriptContextSet.ForEach should accept RenderFrame*.
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  context_set.ForEach(
      restrict_to_render_view,
#include "third_party/WebKit/public/web/WebFrame.h"
  if (blink::WebFrame* webframe = context->web_frame())
                             blink::WebFrame* web_frame,
  gin::PerContextData::From(v8_context)->set_runner(runner_.get());
                blink::WebFrame* frame,
  blink::WebFrame* web_frame() const { return web_frame_; }
  // The WebFrame associated with this context. This can be NULL because this
  // object can outlive is destroyed asynchronously.
  blink::WebFrame* web_frame_;
ScriptContextSet::ScriptContextSet() {
int ScriptContextSet::size() const {
  return static_cast<int>(contexts_.size());
}
void ScriptContextSet::Add(ScriptContext* context) {
#if DCHECK_IS_ON()
  // It's OK to insert the same context twice, but we should only ever have
  // one ScriptContext per v8::Context.
  for (ContextSet::iterator iter = contexts_.begin(); iter != contexts_.end();
       ++iter) {
    ScriptContext* candidate = *iter;
    if (candidate != context)
      DCHECK(candidate->v8_context() != context->v8_context());
  }
#endif
  contexts_.insert(context);
    base::MessageLoop::current()->DeleteSoon(FROM_HERE, context);
ScriptContextSet::ContextSet ScriptContextSet::GetAll() const {
  return contexts_;
}

                              : NULL;
  return calling.IsEmpty() ? NULL : GetByV8Context(calling);
    v8::Handle<v8::Context> v8_context) const {
  for (ContextSet::const_iterator iter = contexts_.begin();
       iter != contexts_.end(); ++iter) {
    if ((*iter)->v8_context() == v8_context)
      return *iter;
  return NULL;
void ScriptContextSet::ForEach(
    content::RenderView* render_view,
  ContextSet contexts = GetAll();

  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    ScriptContext* context = *it;

    if (render_view && render_view != context_render_view)
    callback.Run(context);
  }
}
ScriptContextSet::ContextSet ScriptContextSet::OnExtensionUnloaded(
    const std::string& extension_id) {
  ContextSet contexts = GetAll();
  ContextSet removed;

  // Clean up contexts belonging to the unloaded extension. This is done so
  // that content scripts (which remain injected into the page) don't continue
  // receiving events and sending messages.
  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    if ((*it)->extension() && (*it)->extension()->id() == extension_id) {
      (*it)->DispatchOnUnloadEvent();
      removed.insert(*it);
      Remove(*it);

  return removed;
#include "base/basictypes.h"
#include "base/bind.h"
namespace v8 {
class Context;
}

// A container of ExtensionBindingsContext. Since calling JavaScript within a
// context can cause any number of contexts to be created or destroyed, this
// has additional smarts to help with the set changing underneath callers.
  ScriptContextSet();
  int size() const;
  // Takes ownership of |context|.
  void Add(ScriptContext* context);
  // Returns a copy to protect against changes.
  typedef std::set<ScriptContext*> ContextSet;
  ContextSet GetAll() const;

  ScriptContext* GetByV8Context(v8::Handle<v8::Context> context) const;
  // |extension_id| in |render_view|.
  // An empty |extension_id| will match all extensions, and a NULL |render_view|
  // will match all render views, but try to use the inline variants of these
  // methods instead.
               content::RenderView* render_view,
  void ForEach(content::RenderView* render_view,
    ForEach("", render_view, callback);
  ContextSet OnExtensionUnloaded(const std::string& extension_id);
  ContextSet contexts_;
#include "third_party/WebKit/public/web/WebFrame.h"
TEST(ScriptContextSet, Lifecycle) {
  ScriptContextSet context_set;
  context_holder.SetContext(v8::Context::New(isolate));

  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  const Extension* extension = NULL;
  ScriptContext* context =
      new ScriptContext(context_holder.context(), frame, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT);
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  EXPECT_EQ(context, context_set.GetByV8Context(context->v8_context()));
  // Adding the same item multiple times should be OK and deduped.
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  // GetAll() returns a copy so removing from one should not remove from others.
  ScriptContextSet::ContextSet set_copy = context_set.GetAll();
  EXPECT_EQ(1u, set_copy.count(context));
  EXPECT_EQ(0, context_set.size());
  EXPECT_FALSE(context_set.GetByV8Context(context->v8_context()));
  EXPECT_EQ(1u, set_copy.size());
  // After removal, the context should be marked for destruction.
  EXPECT_FALSE(context->web_frame());
    return currentSpeechUtterance();
void SpeechSynthesis::startSpeakingImmediately()
    SpeechSynthesisUtterance* utterance = currentSpeechUtterance();
    ASSERT(utterance);

    // If the queue was empty, speak this immediately.
        startSpeakingImmediately();
    // Remove all the items from the utterance queue. The platform
    // may still have references to some of these utterances and may
    // fire events on them asynchronously.
    if (!currentSpeechUtterance())
    bool didJustFinishCurrentUtterance = false;
    // If the utterance that completed was the one we're currently speaking,
    // remove it from the queue and start speaking the next one.
    if (utterance == currentSpeechUtterance()) {
        m_utteranceQueue.removeFirst();
        didJustFinishCurrentUtterance = true;
    }
    // Always fire the event, because the platform may have asynchronously
    // sent an event on an utterance before it got the message that we
    // canceled it, and we should always report to the user what actually
    // happened.
    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());
    // Start the next utterance if we just finished one and one was pending.
    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
SpeechSynthesisUtterance* SpeechSynthesis::currentSpeechUtterance() const
{
    if (!m_utteranceQueue.isEmpty())
        return m_utteranceQueue.first().get();
    return nullptr;
}

    void startSpeakingImmediately();
    // Returns the utterance at the front of the queue.
    SpeechSynthesisUtterance* currentSpeechUtterance() const;

    , m_speakingErrorOccurredTimer(this, &PlatformSpeechSynthesizerMock::speakingErrorOccurred)
    m_speakingErrorOccurredTimer.stop();
void PlatformSpeechSynthesizerMock::speakingErrorOccurred(Timer<PlatformSpeechSynthesizerMock>*)
{
    ASSERT(m_utterance.get());
    client()->speakingErrorOccurred(m_utterance);
    m_utterance = nullptr;
}

    m_speakingErrorOccurredTimer.startOneShot(.1);
    void speakingErrorOccurred(Timer<PlatformSpeechSynthesizerMock>*);
    Timer<PlatformSpeechSynthesizerMock> m_speakingErrorOccurredTimer;

  // Disconnect with ImageDownloader Mojo service in RenderFrame.
  mojo_image_downloader_.reset();
const image_downloader::ImageDownloaderPtr&
RenderFrameHostImpl::GetMojoImageDownloader() {
  if (!mojo_image_downloader_.get()) {
    GetServiceRegistry()->ConnectToRemoteService(
        mojo::GetProxy(&mojo_image_downloader_));
  }
  return mojo_image_downloader_;
}

#include "content/common/image_downloader/image_downloader.mojom.h"
  // Returns the Mojo ImageDownloader service pointer.
  const image_downloader::ImageDownloaderPtr& GetMojoImageDownloader();

  // Holder of Mojo connection with ImageDownloader service in RenderFrame.
  image_downloader::ImageDownloaderPtr mojo_image_downloader_;

#include "mojo/common/url_type_converters.h"
#include "mojo/converters/geometry/geometry_type_converters.h"
#include "skia/public/type_converters.h"
#include "third_party/skia/include/core/SkBitmap.h"
static void DidDownloadImage(const WebContents::ImageDownloadCallback& callback,
                             int id,
                             const GURL& image_url,
                             image_downloader::DownloadResultPtr result) {
  DCHECK(result);

  const std::vector<SkBitmap> images =
      result->images.To<std::vector<SkBitmap>>();
  const std::vector<gfx::Size> original_image_sizes =
      result->original_image_sizes.To<std::vector<gfx::Size>>();

  callback.Run(id, result->http_status_code, image_url, images,
               original_image_sizes);
int WebContentsImpl::DownloadImage(
    const GURL& url,
    bool is_favicon,
    uint32_t max_bitmap_size,
    bool bypass_cache,
    const WebContents::ImageDownloadCallback& callback) {
  static int next_image_download_id = 0;
  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =
      GetMainFrame()->GetMojoImageDownloader();
  image_downloader::DownloadRequestPtr req =
      image_downloader::DownloadRequest::New();

  req->url = mojo::String::From(url);
  req->is_favicon = is_favicon;
  req->max_bitmap_size = max_bitmap_size;
  req->bypass_cache = bypass_cache;

  mojo_image_downloader->DownloadImage(
      req.Pass(),
      base::Bind(&DidDownloadImage, callback, ++next_image_download_id, url));
  return next_image_download_id;
// Copyright 2015 The Chromium Authors. All rights reserved.
#include "content/renderer/image_downloader/image_downloader_impl.h"
#include "base/logging.h"
#include "mojo/common/url_type_converters.h"
#include "mojo/converters/geometry/geometry_type_converters.h"
#include "skia/public/type_converters.h"
// Decodes a data: URL image or returns an empty image in case of failure.
SkBitmap ImageFromDataUrl(const GURL& url) {
  std::string mime_type, char_set, data;
  if (net::DataURL::Parse(url, &mime_type, &char_set, &data) && !data.empty()) {
    // Decode the image using Blink's image decoder.
    content::ImageDecoder decoder(
        gfx::Size(gfx::kFaviconSize, gfx::kFaviconSize));
    const unsigned char* src_data =
        reinterpret_cast<const unsigned char*>(data.data());

    return decoder.Decode(src_data, data.size());
  }
  return SkBitmap();
}

      image, skia::ImageOperations::RESIZE_BEST,
       it != unfiltered.end(); ++it) {
ImageDownloaderImpl::ImageDownloaderImpl(
    RenderFrame* render_frame,
    mojo::InterfaceRequest<image_downloader::ImageDownloader> request)
    : RenderFrameObserver(render_frame), binding_(this, request.Pass()) {
  DCHECK(render_frame);
ImageDownloaderImpl::~ImageDownloaderImpl() {
// static
void ImageDownloaderImpl::CreateMojoService(
    RenderFrame* render_frame,
    mojo::InterfaceRequest<image_downloader::ImageDownloader> request) {
  DVLOG(1) << "ImageDownloaderImpl::CreateService";
  DCHECK(render_frame);

  new ImageDownloaderImpl(render_frame, request.Pass());
}

// ImageDownloader methods:
void ImageDownloaderImpl::DownloadImage(
    image_downloader::DownloadRequestPtr req,
    const DownloadImageCallback& callback) {
  const GURL image_url = req->url.To<GURL>();
  bool is_favicon = req->is_favicon;
  uint32_t max_image_size = req->max_bitmap_size;
  bool bypass_cache = req->bypass_cache;


    if (FetchImage(image_url, is_favicon, max_image_size, bypass_cache,
                   callback)) {
      // Will complete asynchronously via ImageDownloaderImpl::DidFetchImage
  ReplyDownloadResult(0, result_images, result_original_image_sizes, callback);
bool ImageDownloaderImpl::FetchImage(const GURL& image_url,
                                     bool is_favicon,
                                     uint32_t max_image_size,
                                     bool bypass_cache,
                                     const DownloadImageCallback& callback) {
  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();
  DCHECK(frame);

      image_url, frame, 0, is_favicon ? WebURLRequest::RequestContextFavicon
                                      : WebURLRequest::RequestContextImage,
      base::Bind(&ImageDownloaderImpl::DidFetchImage, base::Unretained(this),
                 max_image_size, callback)));
void ImageDownloaderImpl::DidFetchImage(
    const DownloadImageCallback& callback,
                                      &result_original_image_sizes);
  ReplyDownloadResult(fetcher->http_status_code(), result_images,
                      result_original_image_sizes, callback);
void ImageDownloaderImpl::ReplyDownloadResult(
    int32_t http_status_code,
    const std::vector<SkBitmap>& result_images,
    const std::vector<gfx::Size>& result_original_image_sizes,
    const DownloadImageCallback& callback) {
  image_downloader::DownloadResultPtr result =
      image_downloader::DownloadResult::New();
  result->http_status_code = http_status_code;
  result->images = mojo::Array<skia::BitmapPtr>::From(result_images);
  result->original_image_sizes =
      mojo::Array<mojo::SizePtr>::From(result_original_image_sizes);
  callback.Run(result.Pass());
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_RENDERER_IMAGE_DOWNLOADER_IMAGE_DOWNLOADER_IMPL_H_
#define CONTENT_RENDERER_IMAGE_DOWNLOADER_IMAGE_DOWNLOADER_IMPL_H_

#include <vector>

#include "base/memory/scoped_vector.h"
#include "content/common/image_downloader/image_downloader.mojom.h"
#include "content/public/renderer/render_frame_observer.h"
#include "third_party/mojo/src/mojo/public/cpp/bindings/strong_binding.h"
#include "url/gurl.h"

class SkBitmap;

namespace gfx {
class Size;
}

namespace content {

class MultiResolutionImageResourceFetcher;
class RenderFrame;

class ImageDownloaderImpl : public image_downloader::ImageDownloader,
                            public RenderFrameObserver {
 public:
  static void CreateMojoService(
      RenderFrame* render_frame,
      mojo::InterfaceRequest<image_downloader::ImageDownloader> request);

 private:
  ImageDownloaderImpl(
      RenderFrame* render_frame,
      mojo::InterfaceRequest<image_downloader::ImageDownloader> request);
  ~ImageDownloaderImpl() override;

  // ImageDownloader methods:
  void DownloadImage(image_downloader::DownloadRequestPtr req,
                     const DownloadImageCallback& callback) override;

  // Requests to fetch an image. When done, the ImageDownloaderImpl
  // is notified by way of DidFetchImage. Returns true if the
  // request was successfully started, false otherwise.
  // If the image is a favicon, cookies will not be
  // sent nor accepted during download. If the image has multiple frames, all
  // the frames whose size <= |max_image_size| are returned. If all of the
  // frames are larger than |max_image_size|, the smallest frame is resized to
  // |max_image_size| and is the only result. |max_image_size| == 0 is
  // interpreted as no max image size.
  bool FetchImage(const GURL& image_url,
                  bool is_favicon,
                  uint32_t max_image_size,
                  bool bypass_cache,
                  const DownloadImageCallback& callback);

  // This callback is triggered when FetchImage completes, either
  // succesfully or with a failure. See FetchImage for more
  // details.
  void DidFetchImage(uint32_t max_image_size,
                     const DownloadImageCallback& callback,
                     MultiResolutionImageResourceFetcher* fetcher,
                     const std::vector<SkBitmap>& images);

  // Reply download result
  void ReplyDownloadResult(
      int32_t http_status_code,
      const std::vector<SkBitmap>& result_images,
      const std::vector<gfx::Size>& result_original_image_sizes,
      const DownloadImageCallback& callback);

  // We use StrongBinding to ensure deletion of "this" when connection closed
  mojo::StrongBinding<ImageDownloader> binding_;

  typedef ScopedVector<MultiResolutionImageResourceFetcher>
      ImageResourceFetcherList;

  // ImageResourceFetchers schedule via FetchImage.
  ImageResourceFetcherList image_fetchers_;

  DISALLOW_COPY_AND_ASSIGN(ImageDownloaderImpl);
};

}  // namespace content

#endif  // CONTENT_RENDERER_IMAGE_DOWNLOADER_IMAGE_DOWNLOADER_IMPL_H_
#include "content/renderer/image_downloader/image_downloader_impl.h"
  RegisterMojoServices();

void RenderFrameImpl::RegisterMojoServices() {
  // Only main frame have ImageDownloader service.
  if (!frame_->parent()) {
    GetServiceRegistry()->AddService<image_downloader::ImageDownloader>(
        base::Bind(&ImageDownloaderImpl::CreateMojoService,
                   base::Unretained(this)));
  }
}

  void RegisterMojoServices();

int TestWebContents::DownloadImage(const GURL& url,
                                   bool is_favicon,
                                   uint32_t max_bitmap_size,
                                   bool bypass_cache,
                                   const ImageDownloadCallback& callback) {
  static int g_next_image_download_id = 0;
  return ++g_next_image_download_id;
}

  // Overrides to avoid establishing Mojo connection with renderer process.
  int DownloadImage(const GURL& url,
                    bool is_favicon,
                    uint32_t max_bitmap_size,
                    bool bypass_cache,
                    const ImageDownloadCallback& callback) override;
  if (path.ReferencesParent())
    return false;
// This function fails if the |path| contains path traversal components ('..').
PlatformFile CreatePlatformFile(const FilePath& name,
                                int flags,
                                bool* created,
                                PlatformFileError* error) {
  if (name.ReferencesParent()) {
    *error = PLATFORM_FILE_ERROR_ACCESS_DENIED;
    return kInvalidPlatformFileValue;
  }
  return CreatePlatformFileUnsafe(name, flags, created, error);
}

// false otherwise.  |error| can be NULL.
//
// This function fails with 'access denied' if the |name| contains path
// traversal ('..') components.
                                            PlatformFileError* error);

// Same as CreatePlatformFile but allows paths with traversal (like \..\)
// components. Use only with extreme care.
BASE_EXPORT PlatformFile CreatePlatformFileUnsafe(const FilePath& name,
                                                  int flags,
                                                  bool* created,
                                                  PlatformFileError* error);
PlatformFile CreatePlatformFileUnsafe(const FilePath& name,
                                      int flags,
                                      bool* created,
                                      PlatformFileError* error) {
    if (error)
      *error = PLATFORM_FILE_ERROR_FAILED;
  if (error) {
      *error = PLATFORM_FILE_OK;
          *error = PLATFORM_FILE_ERROR_ACCESS_DENIED;
          *error = PLATFORM_FILE_ERROR_IN_USE;
          *error = PLATFORM_FILE_ERROR_EXISTS;
          *error = PLATFORM_FILE_ERROR_NOT_FOUND;
          *error = PLATFORM_FILE_ERROR_TOO_MANY_OPENED;
          *error = PLATFORM_FILE_ERROR_NO_MEMORY;
          *error = PLATFORM_FILE_ERROR_NO_SPACE;
          *error = PLATFORM_FILE_ERROR_NOT_A_DIRECTORY;
          *error = PLATFORM_FILE_ERROR_FAILED;
PlatformFile CreatePlatformFileUnsafe(const FilePath& name,
                                      int flags,
                                      bool* created,
                                      PlatformFileError* error) {
  if (error) {
      *error = PLATFORM_FILE_OK;
          *error = PLATFORM_FILE_ERROR_IN_USE;
          *error = PLATFORM_FILE_ERROR_EXISTS;
          *error = PLATFORM_FILE_ERROR_NOT_FOUND;
          *error = PLATFORM_FILE_ERROR_ACCESS_DENIED;
          *error = PLATFORM_FILE_ERROR_FAILED;
    file_util::AbsolutePath(&library_file);
  FilePath absolute_path(filename);
  file_util::AbsolutePath(&absolute_path);
  file_util::ReadFileToString(absolute_path, &compressed);
using blink::WebFrame;
  WebFrame* frame = context()->web_frame();
    WebFrame* frame,
#include "third_party/WebKit/public/web/WebFrame.h"
      blink::WebFrame* frame,
#include "extensions/common/extension.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "extensions/renderer/extension_groups.h"
const Extension* Dispatcher::GetExtensionFromFrameAndWorld(
    const blink::WebFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.

    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_.GetExtensionOrAppIDByURL(frame_url);
  }

  const Extension* extension = extensions_.GetByID(extension_id);
  if (!extension && !extension_id.empty()) {
    // There are conditions where despite a context being associated with an
    // extension, no extension actually gets found.  Ignore "invalid" because
    // CSP blocks extension page loading by switching the extension ID to
    // "invalid". This isn't interesting.
    if (extension_id != "invalid") {
      LOG(ERROR) << "Extension \"" << extension_id << "\" not found";
      RenderThread::Get()->RecordAction(
          UserMetricsAction("ExtensionNotFound_ED"));
    }
  }
  return extension;
}

  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());

  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  script_context_set_.Add(context);
  if (context_type == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(extension);
  switch (context_type) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  ScriptContext* context = script_context_set_.GetByV8Context(v8_context);
  script_context_set_.Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  if (IsSandboxedPage(ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_.ForEach(
  script_context_set_.ForEach(
  MessagingBindings::DeliverMessage(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(script_context_set_, port_id,
  ScriptContextSet::ContextSet removed_contexts =
      script_context_set_.OnExtensionUnloaded(id);
  for (ScriptContextSet::ContextSet::iterator it = removed_contexts.begin();
       it != removed_contexts.end(); ++it) {
    request_sender_->InvalidateSource(*it);
// TODO(kalman): This is checking for the wrong thing, it should be checking if
// the frame's security origin is unique. The extension sandbox directive is
// checked for in extensions/common/manifest_handlers/csp_info.cc.
bool Dispatcher::IsSandboxedPage(const GURL& url) const {
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions_.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

Feature::Context Dispatcher::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (IsSandboxedPage(url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && IsExtensionActive(extension->id())) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of IsSandboxedPage().
  if (!origin.isUnique() && extensions_.ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

class Extension;
    return script_context_set_;
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(const blink::WebFrame* frame,
                                                 int world_id,
                                                 bool use_effective_url);

  bool IsSandboxedPage(const GURL& url) const;

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  ScriptContextSet script_context_set_;
  std::set<std::string> active_extension_ids_;
#include "third_party/WebKit/public/web/WebFrame.h"
    bool* port_created,
    *port_created |= retval->BooleanValue();
  // TODO(robwu): ScriptContextSet.ForEach should accept RenderFrame*.
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  bool port_created = false;
  context_set.ForEach(
      info.target_id, restrict_to_render_view,
                 channel_name, &source, info, tls_channel_id, &port_created));

  // If we didn't create a port, notify the other end of the channel (treat it
  // as a disconnect).
  if (!port_created) {
    content::RenderThread::Get()->Send(new ExtensionHostMsg_CloseChannel(
        target_port_id, kReceivingEndDoesntExistError));
  }
  scoped_ptr<blink::WebScopedUserGesture> web_user_gesture;
  scoped_ptr<blink::WebScopedWindowFocusAllowedIndicator> allow_window_focus;
  if (message.user_gesture) {
    web_user_gesture.reset(new blink::WebScopedUserGesture);
    allow_window_focus.reset(new blink::WebScopedWindowFocusAllowedIndicator);
  }

  // TODO(robwu): ScriptContextSet.ForEach should accept RenderFrame*.
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  context_set.ForEach(
      restrict_to_render_view,
      base::Bind(&DeliverMessageToScriptContext, message.data, target_port_id));
  // TODO(robwu): ScriptContextSet.ForEach should accept RenderFrame*.
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  context_set.ForEach(
      restrict_to_render_view,
#include "third_party/WebKit/public/web/WebFrame.h"
  if (blink::WebFrame* webframe = context->web_frame())
                             blink::WebFrame* web_frame,
  gin::PerContextData::From(v8_context)->set_runner(runner_.get());
                blink::WebFrame* frame,
  blink::WebFrame* web_frame() const { return web_frame_; }
  // The WebFrame associated with this context. This can be NULL because this
  // object can outlive is destroyed asynchronously.
  blink::WebFrame* web_frame_;
ScriptContextSet::ScriptContextSet() {
int ScriptContextSet::size() const {
  return static_cast<int>(contexts_.size());
}
void ScriptContextSet::Add(ScriptContext* context) {
#if DCHECK_IS_ON()
  // It's OK to insert the same context twice, but we should only ever have
  // one ScriptContext per v8::Context.
  for (ContextSet::iterator iter = contexts_.begin(); iter != contexts_.end();
       ++iter) {
    ScriptContext* candidate = *iter;
    if (candidate != context)
      DCHECK(candidate->v8_context() != context->v8_context());
  }
#endif
  contexts_.insert(context);
    base::MessageLoop::current()->DeleteSoon(FROM_HERE, context);
ScriptContextSet::ContextSet ScriptContextSet::GetAll() const {
  return contexts_;
}

                              : NULL;
  return calling.IsEmpty() ? NULL : GetByV8Context(calling);
    v8::Handle<v8::Context> v8_context) const {
  for (ContextSet::const_iterator iter = contexts_.begin();
       iter != contexts_.end(); ++iter) {
    if ((*iter)->v8_context() == v8_context)
      return *iter;
  return NULL;
void ScriptContextSet::ForEach(
    content::RenderView* render_view,
  ContextSet contexts = GetAll();

  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    ScriptContext* context = *it;

    if (render_view && render_view != context_render_view)
    callback.Run(context);
  }
}
ScriptContextSet::ContextSet ScriptContextSet::OnExtensionUnloaded(
    const std::string& extension_id) {
  ContextSet contexts = GetAll();
  ContextSet removed;

  // Clean up contexts belonging to the unloaded extension. This is done so
  // that content scripts (which remain injected into the page) don't continue
  // receiving events and sending messages.
  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    if ((*it)->extension() && (*it)->extension()->id() == extension_id) {
      (*it)->DispatchOnUnloadEvent();
      removed.insert(*it);
      Remove(*it);

  return removed;
#include "base/basictypes.h"
#include "base/bind.h"
namespace v8 {
class Context;
}

// A container of ExtensionBindingsContext. Since calling JavaScript within a
// context can cause any number of contexts to be created or destroyed, this
// has additional smarts to help with the set changing underneath callers.
  ScriptContextSet();
  int size() const;
  // Takes ownership of |context|.
  void Add(ScriptContext* context);
  // Returns a copy to protect against changes.
  typedef std::set<ScriptContext*> ContextSet;
  ContextSet GetAll() const;

  ScriptContext* GetByV8Context(v8::Handle<v8::Context> context) const;
  // |extension_id| in |render_view|.
  // An empty |extension_id| will match all extensions, and a NULL |render_view|
  // will match all render views, but try to use the inline variants of these
  // methods instead.
               content::RenderView* render_view,
  void ForEach(content::RenderView* render_view,
    ForEach("", render_view, callback);
  ContextSet OnExtensionUnloaded(const std::string& extension_id);
  ContextSet contexts_;
#include "third_party/WebKit/public/web/WebFrame.h"
TEST(ScriptContextSet, Lifecycle) {
  ScriptContextSet context_set;
  context_holder.SetContext(v8::Context::New(isolate));

  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  const Extension* extension = NULL;
  ScriptContext* context =
      new ScriptContext(context_holder.context(), frame, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT);
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  EXPECT_EQ(context, context_set.GetByV8Context(context->v8_context()));
  // Adding the same item multiple times should be OK and deduped.
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  // GetAll() returns a copy so removing from one should not remove from others.
  ScriptContextSet::ContextSet set_copy = context_set.GetAll();
  EXPECT_EQ(1u, set_copy.count(context));
  EXPECT_EQ(0, context_set.size());
  EXPECT_FALSE(context_set.GetByV8Context(context->v8_context()));
  EXPECT_EQ(1u, set_copy.size());
  // After removal, the context should be marked for destruction.
  EXPECT_FALSE(context->web_frame());
  // We have to mimic windows behavior here. |to_path| may not exist yet,
  // start the loop with |to_path|.  If this is a recursive copy and
  // the destination already exists, we have to copy the source directory
  // as well.
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &info.stat) == 0) {
    // If the destination already exists, then the top level of source
    // needs to be copied.
    from_path_base = from_path.DirName();
  }
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
TEST_F(FileUtilTest, MoveNew) {
TEST_F(FileUtilTest, MoveExist) {
  // Create a directory
  FilePath dir_name_from =
      test_dir_.Append(FILE_PATH_LITERAL("Move_From_Subdir"));
  file_util::CreateDirectory(dir_name_from);
  ASSERT_TRUE(file_util::PathExists(dir_name_from));

  // Create a file under the directory
  FilePath file_name_from =
      dir_name_from.Append(FILE_PATH_LITERAL("Move_Test_File.txt"));
  CreateTextFile(file_name_from, L"Gooooooooooooooooooooogle");
  ASSERT_TRUE(file_util::PathExists(file_name_from));

  // Move the directory
  FilePath dir_name_exists =
      test_dir_.Append(FILE_PATH_LITERAL("Destination"));

  FilePath dir_name_to =
      dir_name_exists.Append(FILE_PATH_LITERAL("Move_To_Subdir"));
  FilePath file_name_to =
      dir_name_to.Append(FILE_PATH_LITERAL("Move_Test_File.txt"));

  // Create the destination directory.
  file_util::CreateDirectory(dir_name_exists);
  ASSERT_TRUE(file_util::PathExists(dir_name_exists));

  EXPECT_TRUE(file_util::Move(dir_name_from, dir_name_to));

  // Check everything has been moved.
  EXPECT_FALSE(file_util::PathExists(dir_name_from));
  EXPECT_FALSE(file_util::PathExists(file_name_from));
  EXPECT_TRUE(file_util::PathExists(dir_name_to));
  EXPECT_TRUE(file_util::PathExists(file_name_to));
}

TEST_F(FileUtilTest, CopyDirectoryRecursivelyNew) {
TEST_F(FileUtilTest, CopyDirectoryRecursivelyExists) {
  // Create a directory.
  FilePath dir_name_from =
      test_dir_.Append(FILE_PATH_LITERAL("Copy_From_Subdir"));
  file_util::CreateDirectory(dir_name_from);
  ASSERT_TRUE(file_util::PathExists(dir_name_from));

  // Create a file under the directory.
  FilePath file_name_from =
      dir_name_from.Append(FILE_PATH_LITERAL("Copy_Test_File.txt"));
  CreateTextFile(file_name_from, L"Gooooooooooooooooooooogle");
  ASSERT_TRUE(file_util::PathExists(file_name_from));

  // Create a subdirectory.
  FilePath subdir_name_from =
      dir_name_from.Append(FILE_PATH_LITERAL("Subdir"));
  file_util::CreateDirectory(subdir_name_from);
  ASSERT_TRUE(file_util::PathExists(subdir_name_from));

  // Create a file under the subdirectory.
  FilePath file_name2_from =
      subdir_name_from.Append(FILE_PATH_LITERAL("Copy_Test_File.txt"));
  CreateTextFile(file_name2_from, L"Gooooooooooooooooooooogle");
  ASSERT_TRUE(file_util::PathExists(file_name2_from));

  // Copy the directory recursively.
  FilePath dir_name_exists =
      test_dir_.Append(FILE_PATH_LITERAL("Destination"));

  FilePath dir_name_to =
      dir_name_exists.Append(FILE_PATH_LITERAL("Copy_From_Subdir"));
  FilePath file_name_to =
      dir_name_to.Append(FILE_PATH_LITERAL("Copy_Test_File.txt"));
  FilePath subdir_name_to =
      dir_name_to.Append(FILE_PATH_LITERAL("Subdir"));
  FilePath file_name2_to =
      subdir_name_to.Append(FILE_PATH_LITERAL("Copy_Test_File.txt"));

  // Create the destination directory.
  file_util::CreateDirectory(dir_name_exists);
  ASSERT_TRUE(file_util::PathExists(dir_name_exists));

  EXPECT_TRUE(file_util::CopyDirectory(dir_name_from, dir_name_exists, true));

  // Check everything has been copied.
  EXPECT_TRUE(file_util::PathExists(dir_name_from));
  EXPECT_TRUE(file_util::PathExists(file_name_from));
  EXPECT_TRUE(file_util::PathExists(subdir_name_from));
  EXPECT_TRUE(file_util::PathExists(file_name2_from));
  EXPECT_TRUE(file_util::PathExists(dir_name_to));
  EXPECT_TRUE(file_util::PathExists(file_name_to));
  EXPECT_TRUE(file_util::PathExists(subdir_name_to));
  EXPECT_TRUE(file_util::PathExists(file_name2_to));
}

TEST_F(FileUtilTest, CopyDirectoryNew) {
  EXPECT_FALSE(file_util::PathExists(subdir_name_to));
}

TEST_F(FileUtilTest, CopyDirectoryExists) {
  // Create a directory.
  FilePath dir_name_from =
      test_dir_.Append(FILE_PATH_LITERAL("Copy_From_Subdir"));
  file_util::CreateDirectory(dir_name_from);
  ASSERT_TRUE(file_util::PathExists(dir_name_from));

  // Create a file under the directory.
  FilePath file_name_from =
      dir_name_from.Append(FILE_PATH_LITERAL("Copy_Test_File.txt"));
  CreateTextFile(file_name_from, L"Gooooooooooooooooooooogle");
  ASSERT_TRUE(file_util::PathExists(file_name_from));

  // Create a subdirectory.
  FilePath subdir_name_from =
      dir_name_from.Append(FILE_PATH_LITERAL("Subdir"));
  file_util::CreateDirectory(subdir_name_from);
  ASSERT_TRUE(file_util::PathExists(subdir_name_from));

  // Create a file under the subdirectory.
  FilePath file_name2_from =
      subdir_name_from.Append(FILE_PATH_LITERAL("Copy_Test_File.txt"));
  CreateTextFile(file_name2_from, L"Gooooooooooooooooooooogle");
  ASSERT_TRUE(file_util::PathExists(file_name2_from));

  // Copy the directory not recursively.
  FilePath dir_name_to =
      test_dir_.Append(FILE_PATH_LITERAL("Copy_To_Subdir"));
  FilePath file_name_to =
      dir_name_to.Append(FILE_PATH_LITERAL("Copy_Test_File.txt"));
  FilePath subdir_name_to =
      dir_name_to.Append(FILE_PATH_LITERAL("Subdir"));

  // Create the destination directory.
  file_util::CreateDirectory(dir_name_to);
  ASSERT_TRUE(file_util::PathExists(dir_name_to));

  EXPECT_TRUE(file_util::CopyDirectory(dir_name_from, dir_name_to, false));

  // Check everything has been copied.
  EXPECT_TRUE(file_util::PathExists(dir_name_from));
  EXPECT_TRUE(file_util::PathExists(file_name_from));
  EXPECT_TRUE(file_util::PathExists(subdir_name_from));
  EXPECT_TRUE(file_util::PathExists(file_name2_from));
  EXPECT_TRUE(file_util::PathExists(dir_name_to));
  EXPECT_TRUE(file_util::PathExists(file_name_to));
        // TODO(japhet): Link clicks can be emulated via JS without a user gesture.
        // Why doesn't this go through NavigationScheduler?
    if (m_provisionalDocumentLoader) {
        FrameNavigationDisabler navigationDisabler(*m_frame);
        detachDocumentLoader(m_provisionalDocumentLoader);
    }
#include "ui/gl/gl_implementation.h"
      allow_fixed_attribs_(false),
  const bool is_client_side_array = IsUsageClientSideArray(usage);
  const bool support_fixed_attribs =
    gfx::GetGLImplementation() == gfx::kGLImplementationEGLGLES2;
  const bool shadow = buffer->target() == GL_ELEMENT_ARRAY_BUFFER ||
                      allow_buffers_on_multiple_targets_ ||
                      (allow_fixed_attribs_ && !support_fixed_attribs) ||
                      is_client_side_array;
  void set_allow_fixed_attribs(bool allow) {
    allow_fixed_attribs_ = allow;
  }

  // Whether or not allow using GL_FIXED type for vertex attribs.
  bool allow_fixed_attribs_;

    buffer_manager()->set_allow_fixed_attribs(true);
