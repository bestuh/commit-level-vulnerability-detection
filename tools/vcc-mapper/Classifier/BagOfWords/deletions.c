                /* strip connection listed hop-by-hop headers from response */
#include "mpm.h"
static apr_socket_t *csd;
static apr_socket_t **listensocks;
    int sockdes, i;
    apr_socket_t *sd;
    for (lr = ap_listeners, i = 0; i < num_listensocks; lr = lr->next, i++)
        listensocks[i]=lr->sd;
        apr_poll_socket_add(pollset, listensocks[i], APR_POLLIN);
                sd = ap_listeners->sd;
                    apr_poll_revents_get(&event, listensocks[curr_pollfd], pollset);
                        sd=listensocks[curr_pollfd];
	    status = apr_accept(&csd, sd, ptrans);
   	    if (status == APR_SUCCESS || !APR_STATUS_IS_EINTR(status))
	        break;
	    }

	    if (status == APR_SUCCESS)
		break;		/* We have a socket ready for reading */
	    else {
		/* Our old behaviour here was to continue after accept()
		 * errors.  But this leads us into lots of troubles
		 * because most of the errors are quite fatal.  For
		 * example, EMFILE can be caused by slow descriptor
		 * leaks (say in a 3rd party module, or libc).  It's
		 * foolish for us to continue after an EMFILE.  We also
		 * seem to tickle kernel bugs on some platforms which
		 * lead to never-ending loops here.  So it seems best
		 * to just exit in most cases.
		 */
                switch (status) {
#ifdef EPROTO
		    /* EPROTO on certain older kernels really means
		     * ECONNABORTED, so we need to ignore it for them.
		     * See discussion in new-httpd archives nh.9701
		     * search for EPROTO.
		     *
		     * Also see nh.9603, search for EPROTO:
		     * There is potentially a bug in Solaris 2.x x<6,
		     * and other boxes that implement tcp sockets in
		     * userland (i.e. on top of STREAMS).  On these
		     * systems, EPROTO can actually result in a fatal
		     * loop.  See PR#981 for example.  It's hard to
		     * handle both uses of EPROTO.
		     */
                case EPROTO:
#endif
#ifdef ECONNABORTED
                case ECONNABORTED:
#endif
		    /* Linux generates the rest of these, other tcp
		     * stacks (i.e. bsd) tend to hide them behind
		     * getsockopt() interfaces.  They occur when
		     * the net goes sour or the client disconnects
		     * after the three-way handshake has been done
		     * in the kernel but before userland has picked
		     * up the socket.
		     */
#ifdef ECONNRESET
                case ECONNRESET:
#endif
#ifdef ETIMEDOUT
                case ETIMEDOUT:
#endif
#ifdef EHOSTUNREACH
		case EHOSTUNREACH:
#endif
#ifdef ENETUNREACH
		case ENETUNREACH:
#endif
                    break;
#ifdef ENETDOWN
		case ENETDOWN:
		     /*
		      * When the network layer has been shut down, there
		      * is not much use in simply exiting: the parent
		      * would simply re-create us (and we'd fail again).
		      * Use the CHILDFATAL code to tear the server down.
		      * @@@ Martin's idea for possible improvement:
		      * A different approach would be to define
		      * a new APEXIT_NETDOWN exit code, the reception
		      * of which would make the parent shutdown all
		      * children, then idle-loop until it detected that
		      * the network is up again, and restart the children.
		      * Ben Hyde noted that temporary ENETDOWN situations
		      * occur in mobile IP.
		      */
		    ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
			"apr_accept: giving up.");
		    clean_child_exit(APEXIT_CHILDFATAL);
#endif /*ENETDOWN*/

#ifdef TPF
		case EINACT:
		    ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
			"offload device inactive");
		    clean_child_exit(APEXIT_CHILDFATAL);
		    break;
		default:
		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, ap_server_conf,
			"select/accept error (%d)", status);
		    clean_child_exit(APEXIT_CHILDFATAL);
#else
		default:
		    ap_log_error(APLOG_MARK, APLOG_ERR, status, ap_server_conf,
				"apr_accept: (client socket)");
		    clean_child_exit(1);
#endif
		}
	    }
	}

        apr_os_sock_get(&sockdes, csd);

        if (sockdes >= FD_SETSIZE) {
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
                         "new file descriptor %d is too large; you probably need "
                         "to rebuild Apache with a larger FD_SETSIZE "
                         "(currently %d)", 
                         sockdes, FD_SETSIZE);
	    apr_socket_close(csd);
            ap_sync_scoreboard_image();
	    continue;
        }

#ifdef TPF
	if (sockdes == 0) {                  /* 0 is invalid socket for TPF */
	    ap_sync_scoreboard_image();
            continue;
        }
#endif

        path = dir = apr_pstrcat(p, path, "/", NULL);
        while ((n = strlen(path)) > 1 && path[n - 1] == '/' && path[n - 2] == '/')
                           "\n\n<html>\n<head>\n<title>%s%s</title>\n"
                           "<base href=\"%s%s\">\n</head>\n\n"
                           "<body>\n\n<h2>Directory of "
                           "<a href=\"/\">%s</a>/",
                           site, ap_escape_html(p, path),
                           site, ap_escape_uri(p, path), site);
        while ((dir = strchr(dir + 1, '/')) != NULL) {
            if ((reldir = strrchr(path + 1, '/')) == NULL)
                reldir = path + 1;
            str = apr_psprintf(p, "<a href=\"/%s/\">%s</a>/",
                               ap_escape_uri(p, path + 1),
                               ap_escape_html(p, reldir));
            e = apr_bucket_pool_create(str, strlen(str), p);
            APR_BRIGADE_INSERT_TAIL(out, e);
            str = apr_psprintf(p, "</h2>\n\n<hr />\n\n<pre>");
            str = apr_psprintf(p, "</h2>\n\n(%s)\n\n<hr />\n\n<pre>", pwd);
/* strncat works here, but apr_cpystrn does not - the last char gets chopped, dunno why */
/*            strncat(ctx->buffer, response, len);*/
            /* +1 to leave spave for the trailing nil char */
            if (ctx->buffer[n-1] == '\n')  /* strip trailing '\n' */
            if (ctx->buffer[n-1] == '\r')  /* strip trailing '\r' if present */
        str = apr_psprintf(p, "</pre>\n\n<hr />\n\n%s\n\n</body>\n</html>\n", ap_psignature("", r));
	     * should be created with the correct family in the first place.
	     */
	 * So we need to escape the URI metacharacters.
	        ;
                           r->parsed_uri.path, "?", NULL);
                           r->parsed_uri.path, "?", r->parsed_uri.query, NULL);
 * 20051231.0 (2.3.0-dev)  Added num_blank_lines, pending_header_line, and
 *                         pending_header_size to request_rec
    /** Number of leading blank lines encountered before request header */
    int num_blank_lines;

    /** A buffered header line, used to support header folding while
     *  reading the request */
    char *pending_header_line;

    /** If nonzero, the number of bytes allocated to hold pending_header_line */
    apr_size_t pending_header_size;

static void set_the_request(request_rec *r, char *line)
    apr_socket_t *csd;
    ll = r->the_request = line;
             && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */
    }
    else {
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(r->connection->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->connection->base_server->timeout);

    return;
}

static apr_status_t set_mime_header(request_rec *r, char *line)
{
    char *value, *tmp_field;

    if (r->server->limit_req_fields) {
        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);
        if (mime_headers->nelts >= r->server->limit_req_fields) {
            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields "
                           "exceeds this server's limit.");
            r->status = HTTP_BAD_REQUEST;
            return APR_ENOSPC;
        }
    }
    
    if (!(value = strchr(line, ':'))) { /* Find ':' or    */
        r->status = HTTP_BAD_REQUEST;      /* abort bad request */
        apr_table_setn(r->notes, "error-notes",
                       apr_pstrcat(r->pool,
                                   "Request header field is "
                                   "missing ':' separator.<br />\n"
                                   "<pre>\n",
                                   ap_escape_html(r->pool, line),
                                   "</pre>\n", NULL));
        return APR_EGENERAL;
    }

    tmp_field = value - 1; /* last character of field-name */

    *value++ = '\0'; /* NUL-terminate at colon */

    while (*value == ' ' || *value == '\t') {
        ++value;            /* Skip to start of value   */
    }

    /* Strip LWS after field-name: */
    while (tmp_field > line
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }

    /* Strip LWS after field-value: */
    tmp_field = strchr(value, '\0') - 1;
    while (tmp_field > value
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }
    apr_table_addn(r->headers_in, line, value);
    return APR_SUCCESS;
}

static apr_status_t process_request_line(request_rec *r, char *line,
                                         int skip_first)
{
    if (!skip_first && (r->the_request == NULL)) {
        /* This is the first line of the request */
        if ((line == NULL) || (*line == '\0')) {
            /* We skip empty lines because browsers have to tack a CRLF on to the end
             * of POSTs to support old CERN webservers.
             */
            int max_blank_lines = r->server->limit_req_fields;
            if (max_blank_lines <= 0) {
                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
            }
            r->num_blank_lines++;
            if (r->num_blank_lines < max_blank_lines) {
                return APR_SUCCESS;
            }
        }
        set_the_request(r, line);
    }
    else {
        /* We've already read the first line of the request.  This is either
         * a header field or the blank line terminating the header
         */
        if ((line == NULL) || (*line == '\0')) {
            if (r->pending_header_line != NULL) {
                apr_status_t rv = set_mime_header(r, r->pending_header_line);
                if (rv != APR_SUCCESS) {
                    return rv;
                }
                r->pending_header_line = NULL;
            }
            if (r->status == HTTP_REQUEST_TIME_OUT) {
                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
                r->status = HTTP_OK;
            }
        }
        else {
            if ((*line == ' ') || (*line == '\t')) {
                /* This line is a continuation of the previous one */
                if (r->pending_header_line == NULL) {
                    r->pending_header_line = line;
                    r->pending_header_size = 0;
                }
                else {
                    apr_size_t pending_len = strlen(r->pending_header_line);
                    apr_size_t fold_len = strlen(line);
                    if ((r->server->limit_req_fieldsize > 0)
						&& (pending_len + fold_len >
                               (apr_size_t) r->server->limit_req_fieldsize)) {
                        /* CVE-2004-0942 */
                        r->status = HTTP_BAD_REQUEST;
                        return APR_ENOSPC;
                    }
                    if (pending_len + fold_len + 1 > r->pending_header_size) {
                        /* Allocate a new buffer big enough to hold the
                         * concatenated lines
                         */
                        apr_size_t new_size = r->pending_header_size;
                        char *new_buf;
                        if (new_size == 0) {
                            new_size = pending_len + fold_len + 1;
                        }
                        else {
                            do {
                                new_size *= 2;
                            } while (new_size < pending_len + fold_len + 1);
                        }
                        new_buf = (char *)apr_palloc(r->pool, new_size);
                        memcpy(new_buf, r->pending_header_line, pending_len);
                        r->pending_header_line = new_buf;
                        r->pending_header_size = new_size;
                    }
                    memcpy(r->pending_header_line + pending_len, line,
                           fold_len + 1);
                }
            }
            else {
                /* Set aside this line in case the next line is a continuation
                 */
                if (r->pending_header_line != NULL) {
                    apr_status_t rv = set_mime_header(r, r->pending_header_line);
                    if (rv != APR_SUCCESS) {
                        return rv;
                    }
                }
                r->pending_header_line = line;
                r->pending_header_size = 0;
            }
        }
    }
    return APR_SUCCESS;
        rv = process_request_line(r, field, 1);
        if (rv != APR_SUCCESS) {
            return;
        if ((field == NULL) || (*field == '\0')) {
            return;
static request_rec *init_request(conn_rec *conn)
    
    return r;
}
static request_rec *request_post_read(request_rec *r, conn_rec *conn)
{
    apr_socket_t *csd;
    const char *expect;
    int access_status;
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->server->timeout);

    if (apr_table_get(r->headers_in, "Transfer-Encoding") &&
        apr_table_get(r->headers_in, "Content-Length")) {
        /* 2616 section 4.4, point 3: "if both Transfer-Encoding
         * and Content-Length are received, the latter MUST be
         * ignored"; so unset it here to prevent any confusion
         * later.
         */
        apr_table_unset(r->headers_in, "Content-Length");
static apr_status_t read_partial_request(request_rec *r) {
    apr_bucket_brigade *tmp_bb;
    apr_status_t rv = APR_SUCCESS;

    /* Read and process lines of the request until we
     * encounter a complete request header, an error, or EAGAIN
     */
    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    while (r->status == HTTP_REQUEST_TIME_OUT) {
        char *line = NULL;
        apr_size_t line_length;
        apr_size_t length_limit;
        int first_line = (r->the_request == NULL);
        if (first_line) {
            length_limit = r->server->limit_req_line;
        }
        else {
            if (r->assbackwards) {
                r->status = HTTP_OK;
                break;
            }
            length_limit = r->server->limit_req_fieldsize;
        }
        /* TODO: use a nonblocking call in place of ap_rgetline */
        rv = ap_rgetline(&line, length_limit + 2,
                         &line_length, r, 0, tmp_bb);
        if (rv == APR_SUCCESS) {
            rv = process_request_line(r, line, 0);
        }
        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();
            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                if (first_line) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: URI too long (longer than %d)",
                                  r->server->limit_req_line);
                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                    r->proto_num = HTTP_VERSION(1,0);
                    r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
                }
                else {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: header line too long "
                                  "(longer than %d)",
                                  r->server->limit_req_fieldsize);
                    r->status = HTTP_BAD_REQUEST;
                }
            }
            break;
        }
    }
    apr_brigade_destroy(tmp_bb);
    return rv;
}

request_rec *ap_read_request(conn_rec *conn)
{
    request_rec *r;
    apr_status_t rv;

    r = init_request(conn);

    rv = read_partial_request(r);
    /* TODO poll if EAGAIN */
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return NULL;
    }

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers! Have to dink things just to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "client sent invalid HTTP/0.9 request: HEAD %s",
                      r->uri);
        r->header_only = 0;
        r->status = HTTP_BAD_REQUEST;
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return r;
    }

    return request_post_read(r, conn);
}

 * 20051231.0 (2.3.0-dev)  Added num_blank_lines, pending_header_line, and
 *                         pending_header_size to request_rec
    /** Number of leading blank lines encountered before request header */
    int num_blank_lines;

    /** A buffered header line, used to support header folding while
     *  reading the request */
    char *pending_header_line;

    /** If nonzero, the number of bytes allocated to hold pending_header_line */
    apr_size_t pending_header_size;

static void set_the_request(request_rec *r, char *line)
    apr_socket_t *csd;
    ll = r->the_request = line;
             && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */
    }
    else {
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(r->connection->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->connection->base_server->timeout);

    return;
}

static apr_status_t set_mime_header(request_rec *r, char *line)
{
    char *value, *tmp_field;

    if (r->server->limit_req_fields) {
        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);
        if (mime_headers->nelts >= r->server->limit_req_fields) {
            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields "
                           "exceeds this server's limit.");
            r->status = HTTP_BAD_REQUEST;
            return APR_ENOSPC;
        }
    }
    
    if (!(value = strchr(line, ':'))) { /* Find ':' or    */
        r->status = HTTP_BAD_REQUEST;      /* abort bad request */
        apr_table_setn(r->notes, "error-notes",
                       apr_pstrcat(r->pool,
                                   "Request header field is "
                                   "missing ':' separator.<br />\n"
                                   "<pre>\n",
                                   ap_escape_html(r->pool, line),
                                   "</pre>\n", NULL));
        return APR_EGENERAL;
    }

    tmp_field = value - 1; /* last character of field-name */

    *value++ = '\0'; /* NUL-terminate at colon */

    while (*value == ' ' || *value == '\t') {
        ++value;            /* Skip to start of value   */
    }

    /* Strip LWS after field-name: */
    while (tmp_field > line
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }

    /* Strip LWS after field-value: */
    tmp_field = strchr(value, '\0') - 1;
    while (tmp_field > value
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }
    apr_table_addn(r->headers_in, line, value);
    return APR_SUCCESS;
}

static apr_status_t process_request_line(request_rec *r, char *line,
                                         int skip_first)
{
    if (!skip_first && (r->the_request == NULL)) {
        /* This is the first line of the request */
        if ((line == NULL) || (*line == '\0')) {
            /* We skip empty lines because browsers have to tack a CRLF on to the end
             * of POSTs to support old CERN webservers.
             */
            int max_blank_lines = r->server->limit_req_fields;
            if (max_blank_lines <= 0) {
                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
            }
            r->num_blank_lines++;
            if (r->num_blank_lines < max_blank_lines) {
                return APR_SUCCESS;
            }
        }
        set_the_request(r, line);
    }
    else {
        /* We've already read the first line of the request.  This is either
         * a header field or the blank line terminating the header
         */
        if ((line == NULL) || (*line == '\0')) {
            if (r->pending_header_line != NULL) {
                apr_status_t rv = set_mime_header(r, r->pending_header_line);
                if (rv != APR_SUCCESS) {
                    return rv;
                }
                r->pending_header_line = NULL;
            }
            if (r->status == HTTP_REQUEST_TIME_OUT) {
                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
                r->status = HTTP_OK;
            }
        }
        else {
            if ((*line == ' ') || (*line == '\t')) {
                /* This line is a continuation of the previous one */
                if (r->pending_header_line == NULL) {
                    r->pending_header_line = line;
                    r->pending_header_size = 0;
                }
                else {
                    apr_size_t pending_len = strlen(r->pending_header_line);
                    apr_size_t fold_len = strlen(line);
                    if ((r->server->limit_req_fieldsize > 0)
						&& (pending_len + fold_len >
                               (apr_size_t) r->server->limit_req_fieldsize)) {
                        /* CVE-2004-0942 */
                        r->status = HTTP_BAD_REQUEST;
                        return APR_ENOSPC;
                    }
                    if (pending_len + fold_len + 1 > r->pending_header_size) {
                        /* Allocate a new buffer big enough to hold the
                         * concatenated lines
                         */
                        apr_size_t new_size = r->pending_header_size;
                        char *new_buf;
                        if (new_size == 0) {
                            new_size = pending_len + fold_len + 1;
                        }
                        else {
                            do {
                                new_size *= 2;
                            } while (new_size < pending_len + fold_len + 1);
                        }
                        new_buf = (char *)apr_palloc(r->pool, new_size);
                        memcpy(new_buf, r->pending_header_line, pending_len);
                        r->pending_header_line = new_buf;
                        r->pending_header_size = new_size;
                    }
                    memcpy(r->pending_header_line + pending_len, line,
                           fold_len + 1);
                }
            }
            else {
                /* Set aside this line in case the next line is a continuation
                 */
                if (r->pending_header_line != NULL) {
                    apr_status_t rv = set_mime_header(r, r->pending_header_line);
                    if (rv != APR_SUCCESS) {
                        return rv;
                    }
                }
                r->pending_header_line = line;
                r->pending_header_size = 0;
            }
        }
    }
    return APR_SUCCESS;
        rv = process_request_line(r, field, 1);
        if (rv != APR_SUCCESS) {
            return;
        if ((field == NULL) || (*field == '\0')) {
            return;
static request_rec *init_request(conn_rec *conn)
    
    return r;
}
static request_rec *request_post_read(request_rec *r, conn_rec *conn)
{
    apr_socket_t *csd;
    const char *expect;
    int access_status;
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->server->timeout);

    if (apr_table_get(r->headers_in, "Transfer-Encoding") &&
        apr_table_get(r->headers_in, "Content-Length")) {
        /* 2616 section 4.4, point 3: "if both Transfer-Encoding
         * and Content-Length are received, the latter MUST be
         * ignored"; so unset it here to prevent any confusion
         * later.
         */
        apr_table_unset(r->headers_in, "Content-Length");
static apr_status_t read_partial_request(request_rec *r) {
    apr_bucket_brigade *tmp_bb;
    apr_status_t rv = APR_SUCCESS;

    /* Read and process lines of the request until we
     * encounter a complete request header, an error, or EAGAIN
     */
    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    while (r->status == HTTP_REQUEST_TIME_OUT) {
        char *line = NULL;
        apr_size_t line_length;
        apr_size_t length_limit;
        int first_line = (r->the_request == NULL);
        if (first_line) {
            length_limit = r->server->limit_req_line;
        }
        else {
            if (r->assbackwards) {
                r->status = HTTP_OK;
                break;
            }
            length_limit = r->server->limit_req_fieldsize;
        }
        /* TODO: use a nonblocking call in place of ap_rgetline */
        rv = ap_rgetline(&line, length_limit + 2,
                         &line_length, r, 0, tmp_bb);
        if (rv == APR_SUCCESS) {
            rv = process_request_line(r, line, 0);
        }
        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();
            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                if (first_line) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: URI too long (longer than %d)",
                                  r->server->limit_req_line);
                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                    r->proto_num = HTTP_VERSION(1,0);
                    r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
                }
                else {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: header line too long "
                                  "(longer than %d)",
                                  r->server->limit_req_fieldsize);
                    r->status = HTTP_BAD_REQUEST;
                }
            }
            break;
        }
    }
    apr_brigade_destroy(tmp_bb);
    return rv;
}

request_rec *ap_read_request(conn_rec *conn)
{
    request_rec *r;
    apr_status_t rv;

    r = init_request(conn);

    rv = read_partial_request(r);
    /* TODO poll if EAGAIN */
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return NULL;
    }

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers! Have to dink things just to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "client sent invalid HTTP/0.9 request: HEAD %s",
                      r->uri);
        r->header_only = 0;
        r->status = HTTP_BAD_REQUEST;
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return r;
    }

    return request_post_read(r, conn);
}

        switch(rv) {
        case APR_SUCCESS:
            break;
        case APR_EINVAL: /* looked nothing like an IP address */
        default:
    else if ((rv = apr_ipsubnet_create(&a->x.ip, where, NULL, cmd->pool)) != APR_EINVAL) {
		if (stat == APR_SUCCESS || stat != APR_EINTR)
apr_inline void ap_sync_scoreboard_image(void);
    ap_sync_scoreboard_image();
static int ap_threads_per_child = 0;
extern int ap_threads_per_child;
extern int ap_extended_status;



static void setup_shared_mem(apr_pool_t *p)
    apr_register_cleanup(p, NULL, ap_cleanup_shared_mem, apr_null_cleanup);
void reopen_scoreboard(apr_pool_t *p)
#endif   /* APR_SHARED_MEM */
/* Called by parent process */
void reinit_scoreboard(apr_pool_t *p)
        setup_shared_mem(p);
apr_inline void ap_sync_scoreboard_image(void)
#define PROXY_WORKER_IS_INITIALIZED(f)   ( (f)->s->status & \
  PROXY_WORKER_INITIALIZED )
#define PROXY_WORKER_IS_STANDBY(f)   ( (f)->s->status & \
  PROXY_WORKER_HOT_STANDBY )
#define PROXY_WORKER_IS_USABLE(f)   ( !((f)->s->status & \
  (PROXY_WORKER_NOT_USABLE_BITMAP)) && PROXY_WORKER_IS_INITIALIZED(f) )
                                       base->forced_types);
static const char *add_type(cmd_parms *cmd, mime_dir_config * m, char *ct,
        ++ext;
static const char *add_encoding(cmd_parms *cmd, mime_dir_config * m, char *enc,
static const char *add_language(cmd_parms *cmd, mime_dir_config * m, char *lang,
    if (*ext == '.')
        ++ext;
static const char *add_handler(cmd_parms *cmd, mime_dir_config * m, char *hdlr,
    if (fn == NULL)
        fn = r->filename;
        if ((type = ap_table_get(conf->handlers, ext)) && !r->proxyreq) {
        }
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type("text/xml", r);
    ap_rset_content_type(apr_pstrdup(r->pool, info->content_type), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html;charset=utf-8", r);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html", r);
                    ap_rset_content_type("text/plain", r);
    ap_rset_content_type("message/http", r);
AP_DECLARE(void) ap_rset_content_type(const char *ct, request_rec *r)
        ap_rset_content_type("text/html; charset=iso-8859-1", r);
            ap_rset_content_type(apr_pstrcat(r->pool, "multipart",
                                             use_range_x(r) ? "/x-" : "/",
                                             "byteranges; boundary=",
                                             r->boundary, NULL), r);
    ap_rset_content_type(rr->content_type, r);
        ap_rset_content_type(r->content_type, new);
        ap_rset_content_type(DIR_MAGIC_TYPE, r);
                ap_rset_content_type((char*) type, r);
                ap_rset_content_type(exinfo->forced_type, r);
	    ap_rset_content_type(apr_pstrcat(r->pool, ctp->type, "/",
                                             ctp->subtype, NULL), r);
			ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                         "; charset=", charset,
                                                         NULL), r);
		    ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                     "; ", pp->attr,
                                                     "=", pp->val,
                                                     NULL), r);
		ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                 "; charset=", charset,
                                                 NULL), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type(CGI_MAGIC_TYPE, sub_req);
        ap_rset_content_type(t, r);
                ap_rset_content_type(p->forced_mimetype, r);
	    ap_rset_content_type(tmp, r);
	ap_rset_content_type(tmp, r);
	ap_rset_content_type(apr_pstrdup(r->pool, sub->content_type), r);
        ap_rset_content_type("text/html", r);
            ap_rset_content_type(ap_default_type(r), r);
                    ap_rset_content_type(apr_pstrdup(p, buf), r);
/* Disable shmem until pools/init gets sorted out
 * remove following two lines when fixed
 */
#undef APR_HAS_SHARED_MEMORY
#define APR_HAS_SHARED_MEMORY 0
static char           client_lock_name[L_tmpnam];
static char           opaque_lock_name[L_tmpnam];
static void initialize_tables(server_rec *s, apr_pool_t *ctx)
    sts = apr_shm_create(&client_shm, shmem_size, tmpnam(NULL), ctx);
        log_error_and_cleanup("failed to create shared memory segments", sts, s);
        return;
    client_list = apr_rmm_malloc(client_rmm, sizeof(*client_list) +
                                            sizeof(client_entry*)*num_buckets);
        return;
    tmpnam(client_lock_name);
        return;
    opaque_cntr = apr_rmm_malloc(client_rmm, sizeof(*opaque_cntr));
        return;
    tmpnam(opaque_lock_name);
    /* FIXME: get the opaque_lock_name from a directive so we're portable
     * to non-process-inheriting operating systems, like Win32. */
        return;
    otn_counter = apr_rmm_malloc(client_rmm, sizeof(*otn_counter));
        return;
    return;
    initialize_tables(s, p);
    /* FIXME: get the client_lock_name from a directive so we're portable
     * to non-process-inheriting operating systems, like Win32. */
    /* FIXME: get the opaque_lock_name from a directive so we're portable
     * to non-process-inheriting operating systems, like Win32. */
            apr_rmm_free(client_rmm, (apr_rmm_off_t)entry);
    entry = (client_entry *)apr_rmm_malloc(client_rmm, sizeof(client_entry));
        entry = (client_entry *)apr_rmm_malloc(client_rmm, sizeof(client_entry));
    apr_global_mutex_lock(opaque_lock);
    apr_os_file_put(&tempsock, &sd, 0, r->pool);
    apr_os_file_put(&tempsock, &sd, 0, r->pool);
const char *ap_set_listenbacklog(cmd_parms *cmd, void *dummy, char *arg);
const char *ap_set_listener(cmd_parms *cmd, void *dummy, char *ips);
const char *ap_set_send_buffer_size(cmd_parms *cmd, void *dummy, char *arg);
{ "ListenBacklog", ap_set_listenbacklog, NULL, RSRC_CONF, TAKE1, \
  "Maximum length of the queue of pending connections, as used by listen(2)" }, \
{ "Listen", ap_set_listener, NULL, RSRC_CONF, TAKE1, \
  "A port number or a numeric IP address and a port number"}, \
{ "SendBufferSize", ap_set_send_buffer_size, NULL, RSRC_CONF, TAKE1, \
  "Send buffer size in bytes"},
API_EXPORT(char *) ap_resolve_env(ap_pool_t *p, const char * word); 
		    in = strchr(in, '}');
    if (!args || !args[0] || strchr(args, '=')) {
    if ((filename_only = strrchr(filename_full, '/')) == NULL) {
    if (strchr(msg,' ')) 
    if (!strchr(range, ',')) {
    if (strchr(new_file, '/') == NULL) {
const char *unixd_set_user(cmd_parms *cmd, void *dummy, char *arg)
const char *unixd_set_group(cmd_parms *cmd, void *dummy, char *arg)
const char *unixd_set_user(cmd_parms *cmd, void *dummy, char *arg);
const char *unixd_set_group(cmd_parms *cmd, void *dummy, char *arg);
{ "User", unixd_set_user, NULL, RSRC_CONF, TAKE1, \
  "Effective user id for this server"}, \
{ "Group", unixd_set_group, NULL, RSRC_CONF, TAKE1, \
  "Effective group id for this server"}, \
    char *starp;
	    if (strchr(handp->content_type, '*')) {
	    if ((starp = strchr(handp->content_type, '*'))) {
    char *p;
        if ((p = strchr(handler, ';')) != NULL) { /* MIME type arguments */
const char *ap_set_listener(cmd_parms *cmd, void *dummy, char *ips)
const char *ap_set_listenbacklog(cmd_parms *cmd, void *dummy, char *arg) 
const char *ap_set_send_buffer_size(cmd_parms *cmd, void *dummy, char *arg)
static char *ap_pid_fname=NULL;
API_VAR_EXPORT char *ap_scoreboard_fname=NULL;
static char *lock_fname;
static const char *set_pidfile(cmd_parms *cmd, void *dummy, char *arg) 
static const char *set_scoreboard(cmd_parms *cmd, void *dummy, char *arg) 
static const char *set_lockfile(cmd_parms *cmd, void *dummy, char *arg) 
static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy, char *arg) 
static const char *set_min_spare_threads(cmd_parms *cmd, void *dummy, char *arg)
static const char *set_max_spare_threads(cmd_parms *cmd, void *dummy, char *arg)
static const char *set_server_limit (cmd_parms *cmd, void *dummy, char *arg) 
static const char *set_threads_per_child (cmd_parms *cmd, void *dummy, char *arg) 
static const char *set_max_requests(cmd_parms *cmd, void *dummy, char *arg) 
static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, char *arg) 
{ "PidFile", set_pidfile, NULL, RSRC_CONF, TAKE1,
    "A file for logging the server process ID"},
{ "ScoreBoardFile", set_scoreboard, NULL, RSRC_CONF, TAKE1,
    "A file for Apache to maintain runtime process management information"},
{ "LockFile", set_lockfile, NULL, RSRC_CONF, TAKE1,
    "The lockfile used when Apache needs to lock the accept() call"},
{ "StartServers", set_daemons_to_start, NULL, RSRC_CONF, TAKE1,
  "Number of child processes launched at server startup" },
{ "MinSpareThreads", set_min_spare_threads, NULL, RSRC_CONF, TAKE1,
  "Minimum number of idle children, to handle request spikes" },
{ "MaxSpareThreads", set_max_spare_threads, NULL, RSRC_CONF, TAKE1,
  "Maximum number of idle children" },
{ "MaxClients", set_server_limit, NULL, RSRC_CONF, TAKE1,
  "Maximum number of children alive at the same time" },
{ "ThreadsPerChild", set_threads_per_child, NULL, RSRC_CONF, TAKE1,
  "Number of threads each child creates" },
{ "MaxRequestsPerChild", set_max_requests, NULL, RSRC_CONF, TAKE1,
  "Maximum number of requests a particular child serves before dying." },
{ "CoreDumpDirectory", set_coredumpdir, NULL, RSRC_CONF, TAKE1,
  "The location of the directory Apache changes to before dumping core" },
    semi = strchr(intype, ';');
    char *pos = strchr(*line, stop);
    char *pos = strchr(*line, stop);
API_EXPORT(char *) ap_resolve_env(ap_pool_t *p, const char * word)
       char * s, * e;
       if (!(s=strchr(word,'$')))
               return (char *)word;
               if ((s[1] == '{') && (e=strchr(s,'}'))) {
                       *e = '\0';
                           strcat(tmp,s);
       } while ((s=strchr(word,'$')));
	char *colon = strchr(path, ':');
	char *slash = strchr(path, '/');

#ifdef AP_DEBUG
# undef strrchr

char *ap_strrchr(char *s, int c)
{ return strrchr(s,c); }

const char *ap_strrchr_c(const char *s, int c)
{ return strrchr(s,c); }

#endif
	    s1 = strchr(s, '#');
    s = strchr(hostinfo, ':');
static const char *get_addresses(ap_pool_t *p, const char *w,
    if (*w == 0)
	if (t != NULL)
	    *t = ':';
	if (t != NULL)
	    *t = ':';
    if (t != NULL)
	*t = ':';
    path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path, 0, r->proxyreq);
#define MODULE_MAGIC_NUMBER_MINOR 0                     /* 0...n */
#ifdef AP_NEED_SET_MUTEX_PERMS
#include "unixd.h"
#endif

/**
 * The name of lockfile used when Apache needs to lock the accept() call.
 */
extern const char *ap_lock_fname;
const char *ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
                                const char *arg);

/**
 * The system mutex implementation to use for the accept mutex.
 */
extern apr_lockmech_e ap_accept_lock_mech;
const char *ap_mpm_set_accept_lock_mech(cmd_parms *cmd, void *dummy,
                                        const char *arg);

    char *lock_file;           /* filename for shm lock mutex */
static const char     *client_lock_name;
static const char     *opaque_lock_name;
    client_lock_name = apr_psprintf(ctx, "%s/authdigest_lock.%"APR_PID_T_FMT, tempdir, 
                                    getpid());
    /* FIXME: get the client_lock_name from a directive so we're portable
     * to non-process-inheriting operating systems, like Win32. */
    sts = apr_global_mutex_create(&client_lock, client_lock_name,
                                  APR_LOCK_DEFAULT, ctx);
    opaque_lock_name = apr_psprintf(ctx, "%s/authdigest_opaque_lock.%"APR_PID_T_FMT,
                                    tempdir, 
                                    getpid());
    sts = apr_global_mutex_create(&opaque_lock, opaque_lock_name,
                                  APR_LOCK_DEFAULT, ctx);
    sts = apr_global_mutex_child_init(&client_lock, client_lock_name, p);
    sts = apr_global_mutex_child_init(&opaque_lock, opaque_lock_name, p);

#ifdef AP_NEED_SET_MUTEX_PERMS
#include "unixd.h"
#endif
    const char           *mutex_path;
static char *wd_mutex_path = NULL;
        rc = apr_proc_mutex_child_init(&w->mutex, w->mutex_path, p);
static apr_status_t wd_create_mutex(ap_watchdog_t *w, apr_pool_t *p)
{
    apr_status_t rv;
    apr_lockmech_e mech = APR_LOCK_DEFAULT;
    const char *mb_path = wd_mutex_path ? wd_mutex_path : "logs";

    w->mutex_path = ap_server_root_relative(p,
                                        apr_pstrcat(p, mb_path,
                                        "/.wdc-", w->name, ".mutex", NULL));

    /* TODO: Check the mutex mechanisms */
#if APR_HAS_FCNTL_SERIALIZE
    mech = APR_LOCK_FCNTL;
#else
#if APR_HAS_FLOCK_SERIALIZE
    mech = APR_LOCK_FLOCK;
#endif
#endif
    rv = apr_proc_mutex_create(&w->mutex, w->mutex_path, mech, p);
#ifdef AP_NEED_SET_MUTEX_PERMS
    if (rv == APR_SUCCESS) {
        rv = ap_unixd_set_proc_mutex_perms(w->mutex);
        if (rv != APR_SUCCESS) {
            /* Destroy the mutex early */
            apr_proc_mutex_destroy(w->mutex);
            w->mutex = NULL;
        }
    }
#endif
    return rv;
}

                        rv = wd_create_mutex(w, wd_server_conf->pool);
                            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
                                    "Watchdog: Failed to create mutex.");
/*--------------------------------------------------------------------------*/
/*                                                                          */
/* WatchdogMutexPath directive                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/
static const char *wd_cmd_mutex_path(cmd_parms *cmd, void *dummy,
                                     const char *arg)
{
    const char *errs = ap_check_cmd_context(cmd, GLOBAL_ONLY);

    if (errs != NULL)
        return errs;

    if (wd_mutex_path != NULL)
       return "Duplicate WatchdogMutexPath directives are not allowed";

    wd_mutex_path = apr_pstrdup(cmd->pool, arg);
    if (wd_mutex_path == NULL)
        return "Invalid WatchdogMutexPath name";
    if (wd_mutex_path[strlen(wd_mutex_path) - 1] == '/')
        wd_mutex_path[strlen(wd_mutex_path) - 1] = '\0';
    return NULL;
}

    AP_INIT_TAKE1(
        "WatchdogMutexPath",                /* directive name               */
        wd_cmd_mutex_path,                  /* config action routine        */
        NULL,                               /* argument to include in call  */
        RSRC_CONF,                          /* where available              */
        "Path where the Watchdog mutexes will be created"
    ),
#ifdef AP_NEED_SET_MUTEX_PERMS
#include "unixd.h"
#endif

#if !defined(OS2) && !defined(WIN32) && !defined(NETWARE)
#include "unixd.h"
#define MOD_EXIPC_SET_MUTEX_PERMS /* XXX Apache should define something */
#endif

char *mutexfilename; /* Lock file name, used on some systems */
     * Both the shared memory and mutex allocation routines take a
     * file name. Depending on system-specific implementation of these
    /* 
     * Create another unique filename to lock upon. Note that
     * depending on OS and locking mechanism of choice, the file
     * may or may not be actually created. 
     */
    mutexfilename = apr_psprintf(pconf, "%s/httpd_mutex.%ld", tempdir,
                                 (long int) getpid());
  
    rs = apr_global_mutex_create(&exipc_mutex, (const char *) mutexfilename, 
                                 APR_LOCK_DEFAULT, pconf);
    if (APR_SUCCESS != rs) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rs, s, 
                     "Failed to create mutex on file %s", 
                     mutexfilename);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    /* 
     * After the mutex is created, its permissions need to be adjusted
     * on unix platforms so that the child processe can acquire
     * it. This call takes care of that. The preprocessor define was
     * set up early in this source file since Apache doesn't provide
     * it.
     */
#ifdef MOD_EXIPC_SET_MUTEX_PERMS
    rs = ap_unixd_set_global_mutex_perms(exipc_mutex);
        ap_log_error(APLOG_MARK, APLOG_CRIT, rs, s, 
                     "Parent could not set permissions on Example IPC "
                     "mutex: check User and Group directives");
#endif /* MOD_EXIPC_SET_MUTEX_PERMS */
                                     (const char *) mutexfilename, 
                     "Failed to reopen mutex on file %s", 
                     shmfilename);
#ifdef DEFAULT_LOCKFILE
    ap_rputs(" -D DEFAULT_LOCKFILE=\"" DEFAULT_LOCKFILE "\"\n", r);
#endif

#ifdef AP_NEED_SET_MUTEX_PERMS
#include "unixd.h"
#endif


#if APR_HAS_SHARED_MEMORY
        if (st->cache_file) {
            st->lock_file = apr_pstrcat(st->pool, st->cache_file, ".lck",
                                        NULL);
        }
#endif

        result = apr_global_mutex_create(&st->util_ldap_cache_lock,
                                         st->lock_file, APR_LOCK_DEFAULT,
                                         st->pool);
#ifdef AP_NEED_SET_MUTEX_PERMS
        result = ap_unixd_set_global_mutex_perms(st->util_ldap_cache_lock);
        if (result != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, result, s,
                         "LDAP cache: failed to set mutex permissions");
            return result;
        }
#endif

            st_vhost->lock_file = st->lock_file;
                                      st->lock_file, p);
                     st->lock_file, getpid());
#ifdef AP_NEED_SET_MUTEX_PERMS
#include "unixd.h"
#endif

static const char *lockname;
    int lock_warning_issued = 0;
        if (!lock_warning_issued && (!lockname || !*lockname)) {
            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
                         "mod_rewrite: Running external rewrite maps "
                         "without defining a RewriteLock is DANGEROUS!");
            ++lock_warning_issued;
        }

    /* only operate if a lockfile is used */
    if (lockname == NULL || *(lockname) == '\0') {
        return APR_SUCCESS;
    }

    rc = apr_global_mutex_create(&rewrite_mapr_lock_acquire, lockname,
                                 APR_LOCK_DEFAULT, p);
    if (rc != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, rc, s,
                     "mod_rewrite: Parent could not create RewriteLock "
                     "file %s", lockname);
        return rc;
    }

#ifdef AP_NEED_SET_MUTEX_PERMS
    rc = ap_unixd_set_global_mutex_perms(rewrite_mapr_lock_acquire);
        ap_log_error(APLOG_MARK, APLOG_CRIT, rc, s,
                     "mod_rewrite: Parent could not set permissions "
                     "on RewriteLock; check User and Group directives");
#endif
    /* only operate if a lockfile is used */
    if (lockname == NULL || *(lockname) == '\0') {
        return APR_SUCCESS;
    }

    apr_global_mutex_destroy (rewrite_mapr_lock_acquire);
    rewrite_mapr_lock_acquire = NULL;
    lockname = NULL;
static const char *cmd_rewritelock(cmd_parms *cmd, void *dconf, const char *a1)
{
    const char *error;

    if ((error = ap_check_cmd_context(cmd, GLOBAL_ONLY)) != NULL)
        return error;

    /* fixup the path, especially for rewritelock_remove() */
    lockname = ap_server_root_relative(cmd->pool, a1);

    if (!lockname) {
        return apr_pstrcat(cmd->pool, "Invalid RewriteLock path ", a1, NULL);
    }

    return NULL;
}

    if (lockname != NULL && *(lockname) != '\0') {
                                         lockname, p);
    AP_INIT_TAKE1(   "RewriteLock",     cmd_rewritelock,     NULL, RSRC_CONF,
                     "the filename of a lockfile used for inter-process "
                     "synchronization"),
    SSL_CMD_SRV(Mutex, TAKE1, AP_ALL_AVAILABLE_MUTEXES_STRING)
    SSL_CMD_SRV(StaplingMutex, TAKE1, AP_ALL_AVAILABLE_MUTEXES_STRING)
    mc->nMutexMode             = SSL_MUTEXMODE_UNSET;
    mc->nMutexMech             = APR_LOCK_DEFAULT;
    mc->szMutexFile            = NULL;
    mc->stapling_cache                  = NULL;
    mc->stapling_mutex_mode             = SSL_MUTEXMODE_UNSET;
    mc->stapling_mutex_mech             = APR_LOCK_DEFAULT;
    mc->stapling_mutex_file            = NULL;
    mc->stapling_mutex                 = NULL;
const char *ssl_cmd_SSLMutex(cmd_parms *cmd,
                             void *dcfg,
                             const char *arg_)
{
    apr_status_t rv;
    const char *err;
    SSLModConfigRec *mc = myModConfig(cmd->server);

    if ((err = ap_check_cmd_context(cmd, GLOBAL_ONLY))) {
        return err;
    }

    if (ssl_config_global_isfixed(mc)) {
        return NULL;
    }

    rv = ap_parse_mutex(arg_, cmd->server->process->pool,
                        &mc->nMutexMech, &mc->szMutexFile);

    if (rv == APR_ENOLOCK) {
        mc->nMutexMode  = SSL_MUTEXMODE_NONE;
        return NULL;
    } else if (rv == APR_ENOTIMPL) {
        return apr_pstrcat(cmd->pool, "Invalid SSLMutex argument ", arg_,
                           " (" AP_ALL_AVAILABLE_MUTEXES_STRING ")", NULL);
    } else if (rv == APR_BADARG) {
            return apr_pstrcat(cmd->pool, "Invalid SSLMutex filepath ",
                               arg_, NULL);
    }

    mc->nMutexMode  = SSL_MUTEXMODE_USED;

    return NULL;
}

const char *ssl_cmd_SSLStaplingMutex(cmd_parms *cmd,
                                     void *dcfg,
                                     const char *arg_)
{
    apr_status_t rv;
    const char *err;
    SSLModConfigRec *mc = myModConfig(cmd->server);

    if ((err = ap_check_cmd_context(cmd, GLOBAL_ONLY))) {
        return err;
    }

    if (ssl_config_global_isfixed(mc)) {
        return NULL;
    }

    rv = ap_parse_mutex(arg_, cmd->server->process->pool,
                        &mc->stapling_mutex_mech, &mc->stapling_mutex_file);

    if (rv == APR_ENOLOCK) {
        mc->stapling_mutex_mode  = SSL_MUTEXMODE_NONE;
        return NULL;
    } 
    else if (rv == APR_ENOTIMPL) {
        return apr_pstrcat(cmd->pool, "Invalid SSLStaplingMutex argument ",
                           arg_,
                           " (" AP_ALL_AVAILABLE_MUTEXES_STRING ")", NULL);
    } 
    else if (rv == APR_BADARG) {
        return apr_pstrcat(cmd->pool, "Invalid SSLStaplingMutex filepath ",
                           arg_, NULL);
    }

    mc->stapling_mutex_mode  = SSL_MUTEXMODE_USED;

    return NULL;
}

#ifdef AP_NEED_SET_MUTEX_PERMS
#include "unixd.h"
#endif

    else if (mc->nMutexMode == SSL_MUTEXMODE_NONE) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                     "An SSLMutex is required for the '%s' session cache",
                     mc->sesscache->name);
        return FALSE;
    }
    if ((rv = apr_global_mutex_create(&mc->pMutex, mc->szMutexFile,
                                      mc->nMutexMech, s->process->pool))
        if (mc->szMutexFile)
            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                         "Cannot create SSLMutex with file `%s'",
                         mc->szMutexFile);
        else
            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                         "Cannot create SSLMutex");
#ifdef AP_NEED_SET_MUTEX_PERMS
    rv = ap_unixd_set_global_mutex_perms(mc->pMutex);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                     "Could not set permissions on ssl_mutex; check User "
                     "and Group directives");
        return FALSE;
    }
#endif
    if (mc->nMutexMode == SSL_MUTEXMODE_NONE || !mc->sesscache
                                    mc->szMutexFile, p)) != APR_SUCCESS) {
        if (mc->szMutexFile)
                         "Cannot reinit SSLMutex with file `%s'",
                         mc->szMutexFile);
                         "Cannot reinit SSLMutex");
/**
 * Define the SSL mutex modes
 */
typedef enum {
    SSL_MUTEXMODE_UNSET  = UNSET,
    SSL_MUTEXMODE_NONE   = 0,
    SSL_MUTEXMODE_USED   = 1
} ssl_mutexmode_t;

    ssl_mutexmode_t nMutexMode;
    apr_lockmech_e  nMutexMech;
    const char     *szMutexFile;
    ssl_mutexmode_t stapling_mutex_mode;
    apr_lockmech_e  stapling_mutex_mech;
    const char     *stapling_mutex_file;
const char  *ssl_cmd_SSLMutex(cmd_parms *, void *, const char *);
const char *ssl_cmd_SSLStaplingMutex(cmd_parms *, void *, const char *);
#ifdef AP_NEED_SET_MUTEX_PERMS
#include "unixd.h"
#endif

    if (mc->stapling_mutex_mode == SSL_MUTEXMODE_NONE
        || mc->stapling_mutex_mode == SSL_MUTEXMODE_UNSET) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                     "An SSLStaplingMutex is required for OCSP Stapling");
        return FALSE;
    }
    if ((rv = apr_global_mutex_create(&mc->stapling_mutex,
                                      mc->stapling_mutex_file,
                                      mc->stapling_mutex_mech, s->process->pool))
            != APR_SUCCESS) {
        if (mc->stapling_mutex_file)
            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                         "Cannot create SSLStaplingMutex with file `%s'",
                         mc->stapling_mutex_file);
        else
            ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                         "Cannot create SSLStaplingMutex");
#ifdef AP_NEED_SET_MUTEX_PERMS
    rv = ap_unixd_set_global_mutex_perms(mc->stapling_mutex);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, s,
                     "Could not set permissions on ssl_mutex; check User "
                     "and Group directives");
        return FALSE;
    }
#endif
                                 mc->stapling_mutex_file, p)) != APR_SUCCESS) {
        if (mc->stapling_mutex_file) {
                         "Cannot reinit SSLMutex with file `%s'",
                         mc->szMutexFile);
                         "Cannot reinit SSLMutex");
AP_INIT_TAKE1("LockFile",  ap_mpm_set_lockfile, NULL, RSRC_CONF,
              "The lockfile used when Apache needs to lock the accept() call (deprecated)"),
AP_INIT_TAKE1("AcceptMutex", ap_mpm_set_accept_lock_mech, NULL, RSRC_CONF,
              AP_AVAILABLE_MUTEXES_STRING),
#ifdef DEFAULT_LOCKFILE
    printf(" -D DEFAULT_LOCKFILE=\"" DEFAULT_LOCKFILE "\"\n");
#endif

/* File used for accept locking, when we use a file */
#ifndef DEFAULT_LOCKFILE
#define DEFAULT_LOCKFILE DEFAULT_REL_RUNTIMEDIR "/accept.lock"
#endif

    status = apr_proc_mutex_child_init(&accept_mutex, ap_lock_fname, pchild);
                     "(%s) (%d)", ap_lock_fname, ap_accept_lock_mech);
    ap_lock_fname = apr_psprintf(_pconf, "%s.%" APR_PID_T_FMT,
                                 ap_server_root_relative(_pconf, ap_lock_fname),
                                 ap_my_pid);

    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname,
                               ap_accept_lock_mech, _pconf);
        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
                     "Couldn't create accept lock (%s) (%d)",
                     ap_lock_fname, ap_accept_lock_mech);
#if APR_USE_SYSVSEM_SERIALIZE
    if (ap_accept_lock_mech == APR_LOCK_DEFAULT ||
        ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
#else
    if (ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
#endif
        rv = ap_unixd_set_proc_mutex_perms(accept_mutex);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
                         "Couldn't set permissions on cross-process lock; "
                         "check User and Group directives");
            mpm_state = AP_MPMQ_STOPPING;
            return DONE;
        }
    }

                "AcceptMutex: %s (default: %s)",
    ap_lock_fname = DEFAULT_LOCKFILE;
/* File used for accept locking, when we use a file */
#ifndef DEFAULT_LOCKFILE
#define DEFAULT_LOCKFILE DEFAULT_REL_RUNTIMEDIR "/accept.lock"
#endif

    rv = SAFE_ACCEPT(apr_proc_mutex_child_init(&accept_mutex, ap_lock_fname,
    ap_lock_fname = apr_psprintf(_pconf, "%s.%" APR_PID_T_FMT,
                                 ap_server_root_relative(_pconf, ap_lock_fname),
                                 ap_my_pid);

    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname,
                               ap_accept_lock_mech, _pconf);
        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
                     "Couldn't create accept lock");
#if APR_USE_SYSVSEM_SERIALIZE
    if (ap_accept_lock_mech == APR_LOCK_DEFAULT ||
        ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
#else
    if (ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
#endif
        rv = ap_unixd_set_proc_mutex_perms(accept_mutex);
        if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
                         "Couldn't set permissions on cross-process lock; "
                         "check User and Group directives");
            mpm_state = AP_MPMQ_STOPPING;
            return DONE;
        }
    }

                "AcceptMutex: %s (default: %s)",
    ap_lock_fname = DEFAULT_LOCKFILE;
const char *ap_lock_fname = NULL;

const char *ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
                                const char *arg)
{
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    ap_lock_fname = arg;
    return NULL;
}

apr_lockmech_e ap_accept_lock_mech = APR_LOCK_DEFAULT;

const char *ap_mpm_set_accept_lock_mech(cmd_parms *cmd,
                                        void *dummy,
                                        const char *arg)
{
    apr_status_t rv;
    const char *lockfile;
    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
    if (err != NULL) {
        return err;
    }

    rv = ap_parse_mutex(arg, cmd->server->process->pool,
                        &ap_accept_lock_mech, &lockfile);

    if ((rv == APR_ENOTIMPL) || (rv == APR_ENOLOCK)) {
        return apr_pstrcat(cmd->pool, "Invalid AcceptMutex argument ", arg,
                           " (" AP_AVAILABLE_MUTEXES_STRING ")", NULL);
    } else if (rv == APR_BADARG) {
            return apr_pstrcat(cmd->pool, "Invalid AcceptMutex filepath ",
                               arg, NULL);
    }

    if (lockfile && !ap_lock_fname)
        ap_lock_fname = lockfile;
    return NULL;
}

    if (!strcasecmp(meth, "none") || !strcasecmp(meth, "no")) {
        return APR_ENOLOCK;
    }

#define MODULE_MAGIC_NUMBER_MAJOR 20111203
#define MODULE_MAGIC_NUMBER_MINOR 1                   /* 0...n */
typedef unsigned char overrides_t;
    if ((parms->override & cmd->req_override) == 0 && !override_list_ok)
        return apr_pstrcat(parms->pool, cmd->name, " not allowed here", NULL);
        return apr_pstrcat(parms->pool, "Invalid command '",
                           current->directive,
                           "', perhaps misspelled or defined by a module "
                           "not included in the server configuration",
                           NULL);
#define MODULE_MAGIC_NUMBER_MAJOR 20051115
static int read_request_line(request_rec *r, apr_bucket_brigade *bb)

#if 0
    conn_rec *conn = r->connection;
#endif
    int num_blank_lines = 0;
    int max_blank_lines = r->server->limit_req_fields;

    if (max_blank_lines <= 0) {
        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
    }

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    do {
        apr_status_t rv;

        /* insure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */
        r->the_request = NULL;
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                         &len, r, 0, bb);

        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }
            return 0;
        }
    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));

    /* we've probably got something to do, ignore graceful restart requests */
    ll = r->the_request;
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method",
                                r->method);
#endif

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

             && (minor < HTTP_VERSION(1, 0)) ) /* don't allow HTTP/0.1000 */
    else
    return 1;
    char *last_field = NULL;
    apr_size_t last_len = 0;
    apr_size_t alloc_len = 0;
    char *value;
    int fields_read = 0;
    char *tmp_field;
        int folded = 0;

        if (last_field != NULL) {
            if ((len > 0) && ((*field == '\t') || *field == ' ')) {
                /* This line is a continuation of the preceding line(s),
                 * so append it to the line that we've set aside.
                 * Note: this uses a power-of-two allocator to avoid
                 * doing O(n) allocs and using O(n^2) space for
                 * continuations that span many many lines.
                 */
                apr_size_t fold_len = last_len + len + 1; /* trailing null */

                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field "
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                if (fold_len > alloc_len) {
                    char *fold_buf;
                    alloc_len += alloc_len;
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
                    }
                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);
                    memcpy(fold_buf, last_field, last_len);
                    last_field = fold_buf;
                }
                memcpy(last_field + last_len, field, len +1); /* +1 for nul */
                last_len += len;
                folded = 1;
            }
            else /* not a continuation line */ {

                if (r->server->limit_req_fields
                    && (++fields_read > r->server->limit_req_fields)) {
                    r->status = HTTP_BAD_REQUEST;
                    apr_table_setn(r->notes, "error-notes",
                                   "The number of request header fields "
                                   "exceeds this server's limit.");
                    return;
                }

                if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                    r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Request header field is "
                                               "missing ':' separator.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool,
                                                              last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                tmp_field = value - 1; /* last character of field-name */

                *value++ = '\0'; /* NUL-terminate at colon */

                while (*value == ' ' || *value == '\t') {
                    ++value;            /* Skip to start of value   */
                }

                /* Strip LWS after field-name: */
                while (tmp_field > last_field
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                /* Strip LWS after field-value: */
                tmp_field = last_field + last_len - 1;
                while (tmp_field > value
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                apr_table_addn(r->headers_in, last_field, value);

                /* reset the alloc_len so that we'll allocate a new
                 * buffer if we have to do any more folding: we can't
                 * use the previous buffer because its contents are
                 * now part of r->headers_in
                 */
                alloc_len = 0;

            } /* end if current line is not a continuation starting with tab */
        }

        /* Found a blank line, stop. */
        if (len == 0) {
            break;

        /* Keep track of this line so that we can parse it on
         * the next loop iteration.  (In the folded case, last_field
         * has been updated already.)
         */
        if (!folded) {
            last_field = field;
            last_len = len;

    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
request_rec *ap_read_request(conn_rec *conn)
    const char *expect;
    int access_status;
    apr_bucket_brigade *tmp_bb;
    apr_socket_t *csd;
    apr_interval_time_t cur_timeout;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);

    /* Get the request... */
    if (!read_request_line(r, tmp_bb)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        apr_brigade_destroy(tmp_bb);
        return NULL;
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_get(csd, &cur_timeout);
    if (cur_timeout != conn->base_server->timeout) {
        apr_socket_timeout_set(csd, conn->base_server->timeout);
        cur_timeout = conn->base_server->timeout;
    }

    if (!r->assbackwards) {
        ap_get_mime_headers_core(r, tmp_bb);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        if (apr_table_get(r->headers_in, "Transfer-Encoding")
            && apr_table_get(r->headers_in, "Content-Length")) {
            /* 2616 section 4.4, point 3: "if both Transfer-Encoding
             * and Content-Length are received, the latter MUST be
             * ignored"; so unset it here to prevent any confusion
             * later. */
            apr_table_unset(r->headers_in, "Content-Length");
        }
    }
    else {
        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }
    }
    apr_brigade_destroy(tmp_bb);
    if (cur_timeout != r->server->timeout) {
        apr_socket_timeout_set(csd, r->server->timeout);
        cur_timeout = r->server->timeout;

    size_t recv_buffer_size;
        while (ap_get_brigade(data->input_filters, bb, AP_MODE_EXHAUSTIVE,
                              APR_BLOCK_READ, 0) == APR_SUCCESS) {
            if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
                ap_pass_brigade(r->output_filters, bb);
                break;
    ap_flush_conn(data);
    apr_socket_close(data_sock);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
                 "proxy: FTP: Closing Data connection.");
             * if we are overriding the errors, we cant put the content of the
             * page into the brigade
            /* read the body, pass it to the output filters */
                                      AP_IOBUFSIZE) == APR_SUCCESS) {
                        ap_pass_brigade(r->output_filters, bb);
                        break;
                    e = apr_bucket_flush_create();
                    APR_BRIGADE_INSERT_TAIL(bb, e);
                        break;
        apr_socket_close(p_conn->sock);
        backend->connection = NULL;
static char* process_tags(header_entry *hdr, request_rec *r)
            str = apr_pstrdup(r->pool, s);
            str = apr_pstrcat(r->pool, str, s, NULL);
            apr_table_addn(headers, hdr->header, process_tags(hdr, r));
            apr_table_mergen(headers, hdr->header, process_tags(hdr, r));
                apr_table_addn(headers, hdr->header, process_tags(hdr, r));
                char *new_val = process_tags(hdr, r);
                 ap_set_content_type(r, process_tags(hdr, r));
            apr_table_setn(headers, hdr->header, process_tags(hdr, r));
                ed.p = r->pool;
#define PROXY_WORKER_IS_INITIALIZED(f)   ( (f)->s->status & \
  PROXY_WORKER_INITIALIZED )
#define PROXY_WORKER_IS_STANDBY(f)   ( (f)->s->status & \
  PROXY_WORKER_HOT_STANDBY )
#define PROXY_WORKER_IS_USABLE(f)   ( !((f)->s->status & \
  (PROXY_WORKER_NOT_USABLE_BITMAP)) && PROXY_WORKER_IS_INITIALIZED(f) )
#include "http_conf_globals.h"	/* for user_id & group_id */

    tms = gmtime(&sec);

    register int x, y, badesc, badpath;
    for (x = 0, y = 0; url[y]; ++x, ++y) {
	if (url[y] != '%')
	    url[x] = url[y];
	    if (!ap_isxdigit(url[y + 1]) || !ap_isxdigit(url[y + 2])) {
		url[x] = '%';
		url[x] = x2c(&url[y + 1]);
		if (url[x] == '/' || url[x] == '\0')
    url[x] = '\0';
typedef struct {
    const char *name;                 /* matching module name */
    const char *info;                 /* additional info */
typedef struct {
static void *create_info_config(apr_pool_t *p, server_rec *s)
    info_svr_conf *conf = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t *p, void *basev, void *overridesv)
    info_svr_conf *new = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info = apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec * r, int nest, const char* thisfn, int linenum)
    const char *prevfn = ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL) thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n", thisfn);
    if (linenum > 0) sprintf(buf, "%d", linenum);
    else             buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i) ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i) ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec * r, const ap_directive_t * dir,
                                int nest)
        ap_escape_html(r->pool, dir->directive),
        ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec * r, const ap_directive_t * dir,
                                int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n", 
                  ap_escape_html(r->pool, dir->directive),
                  ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec * r, const ap_directive_t * dir,
            }
            else {
        ap_rprintf(r, "/%s</tt></dd>",
                   ap_escape_html(r->pool, dirname));
            }
    
static int mod_info_has_cmd(const command_rec * cmds, ap_directive_t * dir)
    const command_rec * cmd;
    if (cmds == NULL) return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0) return 1;
	}
static void mod_info_show_parents(request_rec * r, ap_directive_t * node, 
                                    int from, int to) {
    if (from < to) mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec * r, const command_rec * cmds,
    ap_directive_t * dir;
    if (level == 0) ap_set_module_config(r->request_config, &info_module, NULL);
                                                 shown, level + 1)) {
        } else if (mod_info_has_cmd(cmds, dir)) {
    }
typedef struct { /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc)(void); /* just to get the right size */
    const char * const *aszPredecessors;
    const char * const *aszSuccessors;
typedef apr_array_header_t * ( 
__stdcall 
* hook_get_t)(void);
typedef struct {
static int module_find_hook(module *modp,
                            hook_get_t hook_get)
    elts = (hook_struct_t *)hooks->elts;
    for (i=0; i< hooks->nelts; i++) {
                               hook_lookup_t *lookup,
                               int *comma)
    int i, comma=0;
    for (i=0; request_hooks[i].name; i++) {
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
	return DECLINED;
	     "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n", r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ", r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name, modp->name);
            ap_rprintf(r, "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                        ap_get_server_version());
            ap_rprintf(r, "<dt><strong>Server Built:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                        ap_get_server_built());
            ap_rprintf(r, "<dt><strong>API Version:</strong> "
                        "<tt>%d:%d</tt></dt>\n",
                        MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r, "<dt><strong>Hostname/port:</strong> "
                        "<tt>%s:%u</tt></dt>\n",
                        ap_get_server_name(r), ap_get_server_port(r));
            ap_rprintf(r, "<dt><strong>Timeouts:</strong> "
                        "<tt>connection: %d &nbsp;&nbsp; "
                        "keep-alive: %d</tt></dt>",
                        (int)(apr_time_sec(serv->timeout)), 
                        (int)(apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n", ap_show_mpm());
            ap_rprintf(r, "<dt><strong>MPM Information:</strong> "
		       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r, "<dt><strong>Server Root:</strong> "
                        "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r, "<dt><strong>Config File:</strong> "
		       "<tt>%s</tt></dt>\n", ap_conftree->filename);
        for (modp = ap_top_module; modp; modp = modp->next) {
            if (!r->args || !strcasecmp(modp->name, r->args)) {
                ap_rprintf(r, "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                            "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                            modp->name, modp->name);
                ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                hand = modp->handlers;
                if (hand) {
                    while (hand) {
                        if (hand->content_type) {
                            ap_rprintf(r, " <tt>%s</tt>\n", hand->content_type);
                        }
                        else {
                            break;
                        }
                        hand++;
                        if (hand && hand->content_type) {
                            ap_rputs(",", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                if (module_find_hook(modp, ap_hook_get_handler)) {
                    ap_rputs("<tt> <em>yes</em></tt>", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                ap_rputs("</dt>", r);
                ap_rputs("<dt><strong>Configuration Phase Participation:</strong>\n",
                      r);
                if (modp->create_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Directory Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Directory Configs</tt>", r);
                    comma = 1;
                }
                if (modp->create_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Server Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Server Configs</tt>", r);
                    comma = 1;
                }
                if (!comma)
                    ap_rputs("<tt> <em>none</em></tt>", r);
                comma = 0;
                ap_rputs("</dt>", r);

                module_request_hook_participate(r, modp);

                cmd = modp->cmds;
                if (cmd) {
                    ap_rputs("<dt><strong>Module Directives:</strong></dt>", r);
                    while (cmd) {
                        if (cmd->name) {
                            ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                ap_escape_html(r->pool, cmd->name),
                                cmd->name[0] == '<' ? "&gt;" : "");
                            if (cmd->errmsg) {
                                ap_rputs(cmd->errmsg, r);
                            ap_rputs("</i></tt></dd>\n", r);
                        }
                        else {
                            break;
                        cmd++;
                    ap_rputs("<dt><strong>Current Configuration:</strong></dt>\n", r);
                    mod_info_module_cmds(r, modp->cmds, ap_conftree, 0, 0);
                }
                else {
                    ap_rputs("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>", r);
                }
                more_info = find_more_info(serv, modp->name);
                if (more_info) {
                    ap_rputs("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                          r);
                    ap_rputs(more_info, r);
                    ap_rputs("</dd>", r);
                }
                ap_rputs("</dl><hr />\n", r);
                if (r->args) {
                    break;
        }
        if (!modp && r->args && strcasecmp(r->args, "server")) {
            ap_rputs("<p><b>No such module</b></p>\n", r);
        }
    ap_rputs(ap_psignature("",r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy, 
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
static const command_rec info_cmds[] =
{
static void register_hooks(apr_pool_t *p)
module AP_MODULE_DECLARE_DATA info_module =
{
        cl_val = atol(old_cl_val);
module AP_MODULE_DECLARE_DATA imap_module;
    icr = ap_get_module_config(r->per_dir_config, &imap_module);
module AP_MODULE_DECLARE_DATA imap_module =
#ifdef USE_TPF_ACCEPT
#define ap_accept(_fd, _sa, _ln)	tpf_accept(_fd, _sa, _ln)
#else
#define ap_accept(_fd, _sa, _ln)	accept(_fd, _sa, _ln)
#endif

    struct sockaddr_in local_addr;	/* local IP address and port */
/* TODO: replace the fd with APR stuff */
    int fd;
    int fds[2];
    FILE *write_f;
#define ap_piped_log_write_fd(pl)	(fileno((pl)->write_f))
API_EXPORT(long) ap_send_fd(APRFile fd, request_rec *r);
API_EXPORT(long) ap_send_fd_length(APRFile fd, request_rec *r, long length);
    FILE *error_log;
API_EXPORT(char *) ap_md5digest(ap_context_t *p, FILE *infile, int convert);
API_EXPORT(char *) ap_md5digest(ap_context_t *p, APRFile infile);
    FILE *f;
    f = ap_pfopen(r->pool, r->filename, "r");

    if (f == NULL) {
    ap_scan_script_header_err(r, f, NULL);
	ap_pfclose(r->pool, f);
	fseek(f, 0, SEEK_CUR);
	ap_send_fd(fileno(f), r);
    ap_pfclose(r->pool, f);
static void do_emit_plain(request_rec *r, FILE *f)
    while (!feof(f)) {
	    n = fread(buf, sizeof(char), IOBUFSIZE, f);
	while (n == -1 && ferror(f) && errno == EINTR);
    FILE *f;
		if ((f = ap_pfopen(r->pool, rr->filename, "r")) != 0) {
		    ap_pfclose(r->pool, f);
    FILE *f;
		if ((f = ap_pfopen(r->pool, rr->filename, "r")) != 0) {
		    ap_pfclose(r->pool, f);
    FILE *thefile = NULL;
        if (!(thefile = ap_pfopen(r->pool, r->filename, "r"))) {
	n = fread(titlebuf, sizeof(char), MAX_STRING_LEN - 1, thefile);
	    ap_pfclose(r->pool, thefile);
		    ap_pfclose(r->pool, thefile);
	ap_pfclose(r->pool, thefile);
    DIR *d;
    struct DIR_TYPE *dstruct;
    if (!(d = ap_popendir(r->pool, name))) {
	ap_pclosedir(r->pool, d);
    while ((dstruct = readdir(d))) {
	p = make_autoindex_entry(dstruct->d_name, autoindex_opts,
    ap_pclosedir(r->pool, d);
      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
    APRFile fd;         /*  Abstract out File descriptors. */
#if defined(OS2) || defined(WIN32)
    /* Need binary mode for OS/2 */
    fd = ap_popenf(r->pool, r->filename, O_RDONLY | O_BINARY, 0);
#else
    fd = ap_popenf(r->pool, r->filename, O_RDONLY, 0);
#endif

    if (fd == -1) {
        ap_pclosef(r->pool, fd);
		  fd, 0);
			  ap_md5digest(r->pool, fd, convert_flag));
			  ap_md5digest(r->pool, fd));
		ap_send_fd(fd, r);
		long offset, length;
		    /* ZZZ change to AP func */
		    if (lseek(fd, offset, SEEK_SET) == -1) {
			ap_pclosef(r->pool, fd);
		    ap_send_fd_length(fd, r, length);
    ap_pclosef(r->pool, fd);
API_EXPORT(long) ap_send_fd(APRFile fd, request_rec *r)
API_EXPORT(long) ap_send_fd_length(APRFile fd, request_rec *r, long length)
static int xfer_flags = (O_WRONLY | O_APPEND | O_CREAT);
static mode_t xfer_mode = (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 * well, use the CLF. log_fd is -1 before the log file is opened and
    int log_fd;
    if (cls->outcnt && cls->log_fd != -1) {
        write(cls->log_fd, cls->outbuf, cls->outcnt);
        write(cls->log_fd, str, len);
    write(cls->log_fd, str, len);
    cls->log_fd = -1;
    if (cls->log_fd > 0) {
        if ((cls->log_fd = ap_popenf(p, fname, xfer_flags, xfer_mode)) < 0) {
static enum header_state get_header_line(char *buffer, int len, FILE *map)
    int c;
        if (fgets(buffer, MAX_STRING_LEN, map) == NULL) {
    while ((c = getc(map)) != EOF) {
            while ((c = getc(map)) != EOF && c != '\n') {
                c = getc(map);
            ungetc(c, map);
            while (cp < buf_end - 2 && (c = getc(map)) != EOF && c != '\n') {
            ungetc(c, map);
    FILE *map;
    map = ap_pfopen(neg->pool, rr->filename, "r");
    if (map == NULL) {
    ap_pfclose(neg->pool, map);
    DIR *dirp;
    struct DIR_TYPE *dir_entry;
    dirp = ap_popendir(neg->pool, neg->dir_name);

    if (dirp == NULL) {
    while ((dir_entry = readdir(dirp))) {
        if (strncmp(dir_entry->d_name, filp, prefix_len)) {
        if (dir_entry->d_name[prefix_len] != '.') {
        sub_req = ap_sub_req_lookup_file(dir_entry->d_name, r);
            ap_pclosedir(neg->pool, dirp);
        mime_info.file_name = ap_pstrdup(neg->pool, dir_entry->d_name);
    ap_pclosedir(neg->pool, dirp);
    s->error_log = stderr;
static int make_sock(const struct sockaddr_in *server)
    int s;
    if (server->sin_addr.s_addr != htonl(INADDR_ANY))
	ap_snprintf(addr, sizeof(addr), "address %s port %d",
		inet_ntoa(server->sin_addr), ntohs(server->sin_port));
    else
	ap_snprintf(addr, sizeof(addr), "port %d", ntohs(server->sin_port));

#ifdef WIN32
    s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
    if (s == INVALID_SOCKET) {
	ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
                     "make_sock: failed to get a socket for %s", addr);
	return -1;
    }
#else
    if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
	ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
		    "make_sock: failed to get a socket for %s", addr);
	return -1;
    }
#endif

#ifdef SO_REUSEADDR
    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &one, sizeof(int)) < 0) {
	close(s);
	return -1;
#endif
    one = 1;
#ifdef SO_KEEPALIVE
    if (setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (char *) &one, sizeof(int)) < 0) {
	close(s);
	return -1;
#endif
#ifdef SO_SNDBUF
	if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
		(char *) &send_buffer_size, sizeof(int)) < 0) {
	    ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
#endif
    if (bind(s, (struct sockaddr *) server, sizeof(struct sockaddr_in)) == -1) {
	close(s);
	return -1;
    if (listen(s, ap_listenbacklog) == -1) {
	close(s);
	return -1;
    return s;
	close(lr->fd);
static void alloc_listener(struct sockaddr_in *local_addr)
	if (!memcmp(&(*walk)->local_addr, local_addr, sizeof(local_addr))) {
    new->local_addr = *local_addr;
    new->fd = -1;
    struct sockaddr_in local_addr;

	local_addr.sin_family = AF_INET;
	local_addr.sin_addr.s_addr = htonl(INADDR_ANY); /* XXX */
	local_addr.sin_port = htons(port ? port : DEFAULT_HTTP_PORT);
	alloc_listener(&local_addr);
	if (lr->fd < 0) {
	    lr->fd = make_sock(&lr->local_addr);
	}
	if (lr->fd >= 0) {
	close(lr->fd);
	free(lr);
    struct sockaddr_in local_addr;
    local_addr.sin_family = AF_INET;
    if (ports == ips) { /* no address */
	local_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    }
    else {
	local_addr.sin_addr.s_addr = ap_get_virthost_addr(ips, NULL);
    }
    local_addr.sin_port = htons(port);
    alloc_listener(&local_addr);
	s->error_log = dummy;
        if (!(s->error_log = ap_pfopen(p, fname, "a"))) {
	if (dup2(fileno(s_main->error_log), STDERR_FILENO) == -1) {
        && fileno(s->error_log) != STDERR_FILENO)
        dup2(fileno(s->error_log), STDERR_FILENO);
    FILE *logf;
	logf = stderr;
	fputs(errstr, logf);
	fputc('\n', logf);
	fflush(logf);
      ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
		   ap_psprintf(p,
			       "pid file %s overwritten -- Unclean shutdown of previous Apache run?",
			       fname)
		   );
    close(pl->fds[0]);
    close(pl->fds[1]);
    close(pl->fds[0]);
    close(pl->fds[1]);
    if (pipe(pl->fds) == -1) {
	close(pl->fds[0]);
	close(pl->fds[1]);
    pl->write_f = dummy;
    ap_pfclose(pl->p, pl->write_f);

    int csd = -1;
    int sd = -1;
    size_t len = sizeof(struct sockaddr);
                sd = ap_listeners->fd;
                        sd = listenfds[curr_pollfd].fd;
            csd = ap_accept(sd, &sa_client, &len);
        process_socket(ptrans, &sa_client, csd, process_slot, thread_slot);
        listenfds[i].fd = lr->fd;

static int sd;

    lock_fd = ap_popenf(p, ap_lock_fname, O_CREAT | O_WRONLY | O_EXCL, 0644);
static int csd;
    csd = -1;
		    if (FD_ISSET(lr->fd, &main_fds))
		sd = lr->fd;
		sd = ap_listeners->fd;
		csd = ap_accept(sd, &sa_client, &clen);
		if (csd >= 0 || errno != EINTR)
	    if (csd >= 0)
	if (getsockname(csd, &sa_server, &clen) < 0) {
	    close(csd);
	sock_disable_nagle(csd);
	iol = unix_attach_socket(csd);
		    "larger FD_SETSIZE", csd, FD_SETSIZE);
	    close(csd);
	FD_SET(lr->fd, &listenfds);
	if (lr->fd > listenmaxfd) {
	    listenmaxfd = lr->fd;

static int get_rfc1413(int sock, const struct sockaddr_in *our_sin,
		       const struct sockaddr_in *rmt_sin, 
    struct sockaddr_in rmt_query_sin, our_query_sin;
    our_query_sin = *our_sin;
    our_query_sin.sin_port = htons(ANY_PORT);
    rmt_query_sin = *rmt_sin;
    rmt_query_sin.sin_port = htons(RFC1413_PORT);
    if (bind(sock, (struct sockaddr *) &our_query_sin,
	     sizeof(struct sockaddr_in)) < 0) {
    if (connect(sock, (struct sockaddr *) &rmt_query_sin,
		sizeof(struct sockaddr_in)) < 0)
	            return -1;
    buflen = ap_snprintf(buffer, sizeof(buffer), "%u,%u\r\n", ntohs(rmt_sin->sin_port),
		ntohs(our_sin->sin_port));
        int j;
	j = write(sock, buffer+i, (strlen(buffer+i)));
	if (j < 0 && errno != EINTR) {
        int j;
	j = read(sock, buffer+i, (sizeof(buffer) - 1) - i);
	if (j < 0 && errno != EINTR) {
	       user) != 3 || ntohs(rmt_sin->sin_port) != rmt_port
	|| ntohs(our_sin->sin_port) != our_port)
    static int sock;
    sock = ap_psocket(conn->pool, AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock < 0) {
	if (get_rfc1413(sock, &conn->local_addr, &conn->remote_addr, user, srv) >= 0)
    ap_pclosesocket(conn->pool, sock);
/* Common structure that holds the file and ap_context_t for ap_pcfg_openfile */
typedef struct {
    ap_context_t *pool;
    FILE *file;
} poolfile_t;

static int cfg_close(void *param)
    poolfile_t *cfp = (poolfile_t *) param;
    return (ap_pfclose(cfp->pool, cfp->file));
    poolfile_t *cfp = (poolfile_t *) param;
    return (fgetc(cfp->file));
    poolfile_t *cfp = (poolfile_t *) param;
    return (fgets(buf, bufsiz, cfp->file));
    poolfile_t *new_pfile;
    FILE *file;
    struct stat stbuf;
    /* ZZZ bopenf and use AP defines for flags. */
    file = ap_pfopen(p, name, "r");
                name, (file == NULL) ? strerror(errno) : "successful");
    if (file == NULL)
    if (fstat(fileno(file), &stbuf) == 0 &&
        !S_ISREG(stbuf.st_mode) &&
        strcmp(name, "/dev/null") != 0) {
        ap_pfclose(p, file);
    new_pfile = ap_palloc(p, sizeof(*new_pfile));
    new_pfile->file = file;
    new_pfile->pool = p;
    new_cfg->param = new_pfile;
API_EXPORT(char *) ap_md5digest(ap_context_t *p, APRFile infile, int convert)
API_EXPORT(char *) ap_md5digest(ap_context_t *p, APRFile infile)
    r->server->error_log = stderr;
typedef struct {
    const char *name;                 /* matching module name */
    const char *info;                 /* additional info */
typedef struct {
static void *create_info_config(apr_pool_t *p, server_rec *s)
    info_svr_conf *conf = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t *p, void *basev, void *overridesv)
    info_svr_conf *new = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info = apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec * r, int nest, const char* thisfn, int linenum)
    const char *prevfn = ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL) thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n", thisfn);
    if (linenum > 0) sprintf(buf, "%d", linenum);
    else             buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i) ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i) ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec * r, const ap_directive_t * dir,
                                int nest)
        ap_escape_html(r->pool, dir->directive),
        ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec * r, const ap_directive_t * dir,
                                int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n", 
                  ap_escape_html(r->pool, dir->directive),
                  ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec * r, const ap_directive_t * dir,
            }
            else {
        ap_rprintf(r, "/%s</tt></dd>",
                   ap_escape_html(r->pool, dirname));
            }
    
static int mod_info_has_cmd(const command_rec * cmds, ap_directive_t * dir)
    const command_rec * cmd;
    if (cmds == NULL) return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0) return 1;
	}
static void mod_info_show_parents(request_rec * r, ap_directive_t * node, 
                                    int from, int to) {
    if (from < to) mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec * r, const command_rec * cmds,
    ap_directive_t * dir;
    if (level == 0) ap_set_module_config(r->request_config, &info_module, NULL);
                                                 shown, level + 1)) {
        } else if (mod_info_has_cmd(cmds, dir)) {
    }
typedef struct { /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc)(void); /* just to get the right size */
    const char * const *aszPredecessors;
    const char * const *aszSuccessors;
typedef apr_array_header_t * ( 
__stdcall 
* hook_get_t)(void);
typedef struct {
static int module_find_hook(module *modp,
                            hook_get_t hook_get)
    elts = (hook_struct_t *)hooks->elts;
    for (i=0; i< hooks->nelts; i++) {
                               hook_lookup_t *lookup,
                               int *comma)
    int i, comma=0;
    for (i=0; request_hooks[i].name; i++) {
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
	return DECLINED;
	     "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n", r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ", r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name, modp->name);
            ap_rprintf(r, "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                        ap_get_server_version());
            ap_rprintf(r, "<dt><strong>Server Built:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                        ap_get_server_built());
            ap_rprintf(r, "<dt><strong>API Version:</strong> "
                        "<tt>%d:%d</tt></dt>\n",
                        MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r, "<dt><strong>Hostname/port:</strong> "
                        "<tt>%s:%u</tt></dt>\n",
                        ap_get_server_name(r), ap_get_server_port(r));
            ap_rprintf(r, "<dt><strong>Timeouts:</strong> "
                        "<tt>connection: %d &nbsp;&nbsp; "
                        "keep-alive: %d</tt></dt>",
                        (int)(apr_time_sec(serv->timeout)), 
                        (int)(apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n", ap_show_mpm());
            ap_rprintf(r, "<dt><strong>MPM Information:</strong> "
		       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r, "<dt><strong>Server Root:</strong> "
                        "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r, "<dt><strong>Config File:</strong> "
		       "<tt>%s</tt></dt>\n", ap_conftree->filename);
        for (modp = ap_top_module; modp; modp = modp->next) {
            if (!r->args || !strcasecmp(modp->name, r->args)) {
                ap_rprintf(r, "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                            "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                            modp->name, modp->name);
                ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                hand = modp->handlers;
                if (hand) {
                    while (hand) {
                        if (hand->content_type) {
                            ap_rprintf(r, " <tt>%s</tt>\n", hand->content_type);
                        }
                        else {
                            break;
                        }
                        hand++;
                        if (hand && hand->content_type) {
                            ap_rputs(",", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                if (module_find_hook(modp, ap_hook_get_handler)) {
                    ap_rputs("<tt> <em>yes</em></tt>", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                ap_rputs("</dt>", r);
                ap_rputs("<dt><strong>Configuration Phase Participation:</strong>\n",
                      r);
                if (modp->create_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Directory Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Directory Configs</tt>", r);
                    comma = 1;
                }
                if (modp->create_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Server Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Server Configs</tt>", r);
                    comma = 1;
                }
                if (!comma)
                    ap_rputs("<tt> <em>none</em></tt>", r);
                comma = 0;
                ap_rputs("</dt>", r);

                module_request_hook_participate(r, modp);

                cmd = modp->cmds;
                if (cmd) {
                    ap_rputs("<dt><strong>Module Directives:</strong></dt>", r);
                    while (cmd) {
                        if (cmd->name) {
                            ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                ap_escape_html(r->pool, cmd->name),
                                cmd->name[0] == '<' ? "&gt;" : "");
                            if (cmd->errmsg) {
                                ap_rputs(cmd->errmsg, r);
                            ap_rputs("</i></tt></dd>\n", r);
                        }
                        else {
                            break;
                        cmd++;
                    ap_rputs("<dt><strong>Current Configuration:</strong></dt>\n", r);
                    mod_info_module_cmds(r, modp->cmds, ap_conftree, 0, 0);
                }
                else {
                    ap_rputs("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>", r);
                }
                more_info = find_more_info(serv, modp->name);
                if (more_info) {
                    ap_rputs("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                          r);
                    ap_rputs(more_info, r);
                    ap_rputs("</dd>", r);
                }
                ap_rputs("</dl><hr />\n", r);
                if (r->args) {
                    break;
        }
        if (!modp && r->args && strcasecmp(r->args, "server")) {
            ap_rputs("<p><b>No such module</b></p>\n", r);
        }
    ap_rputs(ap_psignature("",r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy, 
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
static const command_rec info_cmds[] =
{
static void register_hooks(apr_pool_t *p)
module AP_MODULE_DECLARE_DATA info_module =
{
        if (ap_proxy_isvalidenc(url, NULL) != APR_SUCCESS) {
            return HTTP_BAD_REQUEST;
        }
 * by Alexei Kosut <akosut@apache.org>
 * This module implements Microsoft's ISAPI, allowing Apache (when running
 * under Windows) to load Internet Server Applications (ISAPI extensions).
 * It implements all of the ISAPI 2.0 specification, except for the 
 * "Microsoft-only" extensions dealing with asynchronous I/O. All ISAPI
 * extensions that use only synchronous I/O and are compatible with the
 * ISAPI 2.0 specification should work (most ISAPI 1.0 extensions should
 * function as well).
 * To load, simply place the ISA in a location in the document tree.
 * Then add an "AddHandler isapi-isa dll" into your config file.
 * You should now be able to load ISAPI DLLs just be reffering to their
 * URLs. Make sure the ExecCGI option is active in the directory
 * the ISA is in.
#include "apr_strings.h"
#include "apr_portable.h"
#include "apr_buckets.h"
/* We use the exact same header file as the original */
#include <HttpExt.h>
#if !defined(HSE_REQ_MAP_URL_TO_PATH_EX) \
 || !defined(HSE_REQ_SEND_RESPONSE_HEADER_EX)
#pragma message("WARNING: This build of Apache is missing the recent changes")
#pragma message("in the Microsoft Win32 Platform SDK; some mod_isapi features")
#pragma message("will be disabled.  To obtain the latest Platform SDK files,")
#pragma message("please refer to:")
#pragma message("http://msdn.microsoft.com/downloads/sdks/platform/platform.asp")
#endif
/* Our isapi global config values */
static struct isapi_global_conf {
    apr_pool_t         *pool;
    apr_array_header_t *modules;
} loaded;

static apr_status_t isapi_load(apr_pool_t *p, request_rec *r, 
                               const char *fpath, isapi_loaded** isa);
    isapi_loaded *isa, **newisa;
    
	             "ISAPI: Invalid module path %s, skipping", filename);
	    "ISAPI: unable to stat(%s), skipping", fspec);
	    "ISAPI: %s isn't a regular file, skipping", fspec);
    /* Load the extention as cached (passing NULL for r) */
    rv = isapi_load(loaded.pool, NULL, fspec, &isa); 
                     "ISAPI: unable to cache %s, skipping", fspec);
    /* Add to cached list of loaded modules */
    newisa = apr_array_push(loaded.modules);
    *newisa = isa;
    
    const char *filename;
    apr_dso_handle_t *handle;
    HSE_VERSION_INFO *pVer;
    int   refcount;
    DWORD timeout;
    BOOL  fakeasync;
    DWORD report_version;
static apr_status_t isapi_unload(isapi_loaded* isa, int force)
     * If optionally cached, pass HSE_TERM_ADVISORY_UNLOAD,
     * and if it returns TRUE, unload, otherwise, cache it.
    if (((--isa->refcount > 0) && !force) || !isa->handle)
        if (force)
        else if (!(*isa->TerminateExtension)(HSE_TERM_ADVISORY_UNLOAD))
static apr_status_t cleanup_isapi(void *isa)
    return isapi_unload((isapi_loaded*) isa, TRUE);
static apr_status_t isapi_load(apr_pool_t *p, request_rec *r, 
                               const char *fpath, isapi_loaded** isa)
    isapi_loaded **found = (isapi_loaded **)loaded.modules->elts;
    int n;
    for (n = 0; n < loaded.modules->nelts; ++n) {
        if (strcasecmp(fpath, (*found)->filename) == 0) {
            break;
        }
        ++found;
    }
    
    if (n < loaded.modules->nelts) 
    {
        *isa = *found;
        if ((*isa)->handle) 
        {
            ++(*isa)->refcount;
            return APR_SUCCESS;
        }
        /* Otherwise we fall through and have to reload the resource
         * into this existing mod_isapi cache bucket.
         */
    }
    else
    {
        *isa = apr_pcalloc(p, sizeof(isapi_module));
        (*isa)->filename = fpath;
        (*isa)->pVer = apr_pcalloc(p, sizeof(HSE_VERSION_INFO));
    
        /* TODO: These need to become overrideable, so that we
         * assure a given isapi can be fooled into behaving well.
         */
        (*isa)->timeout = INFINITE; /* microsecs */
        (*isa)->fakeasync = TRUE;
        (*isa)->report_version = MAKELONG(0, 5); /* Revision 5.0 */
    }
    rv = apr_dso_load(&(*isa)->handle, fpath, p);
        ap_log_rerror(APLOG_MARK, APLOG_ALERT, rv, r,
                      "ISAPI: %s failed to load", fpath);
        (*isa)->handle = NULL;
    rv = apr_dso_sym((void**)&(*isa)->GetExtensionVersion, (*isa)->handle,
        ap_log_rerror(APLOG_MARK, APLOG_ALERT, rv, r,
                      "ISAPI: %s is missing GetExtensionVersion()",
                      fpath);
        apr_dso_unload((*isa)->handle);
        (*isa)->handle = NULL;
    rv = apr_dso_sym((void**)&(*isa)->HttpExtensionProc, (*isa)->handle,
        ap_log_rerror(APLOG_MARK, APLOG_ALERT, rv, r,
                      "ISAPI: %s is missing HttpExtensionProc()",
                      fpath);
        apr_dso_unload((*isa)->handle);
        (*isa)->handle = NULL;
    rv = apr_dso_sym((void**)&(*isa)->TerminateExtension, (*isa)->handle,
    if (!((*isa)->GetExtensionVersion)((*isa)->pVer)) {
        ap_log_rerror(APLOG_MARK, APLOG_ALERT, rv, r,
                      "ISAPI: %s call GetExtensionVersion() failed", 
                      fpath);
        apr_dso_unload((*isa)->handle);
        (*isa)->handle = NULL;
    ++(*isa)->refcount;

    apr_pool_cleanup_register(p, *isa, cleanup_isapi, 
                                   apr_pool_cleanup_null);
    LPEXTENSION_CONTROL_BLOCK ecb;
BOOL WINAPI GetServerVariable (HCONN hConn, LPSTR lpszVariableName,
                               LPVOID lpvBuffer, LPDWORD lpdwSizeofBuffer)
    request_rec *r = ((isapi_cid *)hConn)->r;
    DWORD len;
            return FALSE;
        return TRUE;
            return FALSE;
        return TRUE;
            return FALSE;
        return TRUE;
    return FALSE;
BOOL WINAPI WriteClient (HCONN ConnID, LPVOID Buffer, LPDWORD lpdwBytes,
                         DWORD dwReserved)
    return TRUE;
BOOL WINAPI ReadClient (HCONN ConnID, LPVOID lpvBuffer, LPDWORD lpdwSize)
    DWORD read = 0;
    return TRUE;
static apr_ssize_t send_response_header(isapi_cid *cid, const char *stat,
                                        const char *head, apr_size_t statlen,
    /* Parse them out, or die trying */
BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
                                  LPVOID lpvBuffer, LPDWORD lpdwSize,
                                  LPDWORD lpdwDataType)
    isapi_cid *cid = (isapi_cid *)hConn;
        return TRUE;
    case 2: /* HSE_REQ_SEND_URL */
        return TRUE;
    case 3: /* HSE_REQ_SEND_RESPONSE_HEADER */
            return FALSE;
        return TRUE;
    case 4: /* HSE_REQ_DONE_WITH_SESSION */
            SetEvent(cid->complete);            
        return TRUE;
    case 1001: /* HSE_REQ_MAP_URL_TO_PATH */
        DWORD len;
        return TRUE;
    case 1002: /* HSE_REQ_GET_SSPI_INFO */
        return FALSE;
    case 1003: /* HSE_APPEND_LOG_PARAMETER */
        return TRUE;
    case 1005: /* HSE_REQ_IO_COMPLETION */
        if (!cid->isa->fakeasync) {
            if (cid->dconf.log_unsupported)
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
                          "ISAPI: ServerSupportFunction HSE_REQ_IO_COMPLETION "
                          "is not supported: %s", r->filename);
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        cid->completion = (PFN_HSE_IO_COMPLETION) lpvBuffer;
        cid->completion_arg = (PVOID) lpdwDataType;
        return TRUE;
    case 1006: /* HSE_REQ_TRANSMIT_FILE */
        if (!cid->isa->fakeasync && (tf->dwFlags & HSE_IO_ASYNC)) {
            return FALSE;
            return FALSE;
                return FALSE;
        return TRUE;
    case 1007: /* HSE_REQ_REFRESH_ISAPI_ACL */
        return FALSE;
    case 1008: /* HSE_REQ_IS_KEEP_CONN */
        *((LPBOOL) lpvBuffer) = (r->connection->keepalive == 1);
        return TRUE;
    case 1010: /* XXX: Fake it : HSE_REQ_ASYNC_READ_CLIENT */
        return FALSE;
    case 1011: /* HSE_REQ_GET_IMPERSONATION_TOKEN  Added in ISAPI 4.0 */
        return FALSE;
#ifdef HSE_REQ_MAP_URL_TO_PATH_EX
    case 1012: /* HSE_REQ_MAP_URL_TO_PATH_EX */
        LPHSE_URL_MAPEX_INFO info = (LPHSE_URL_MAPEX_INFO) lpdwDataType;
                                            MAX_PATH) - info->lpszPath;
        return TRUE;
#endif
    case 1014: /* HSE_REQ_ABORTIVE_CLOSE */
        return FALSE;
    case 1015: /* HSE_REQ_GET_CERT_INFO_EX  Added in ISAPI 4.0 */
        return FALSE;
#ifdef HSE_REQ_SEND_RESPONSE_HEADER_EX
    case 1016: /* HSE_REQ_SEND_RESPONSE_HEADER_EX  Added in ISAPI 4.0 */
        LPHSE_SEND_HEADER_EX_INFO shi
                                  = (LPHSE_SEND_HEADER_EX_INFO) lpvBuffer;
        /* XXX: ignore shi->fKeepConn?  We shouldn't need the advise */
        /* r->connection->keepalive = shi->fKeepConn; */
            return FALSE;
        return TRUE;

#endif
    case 1017: /* HSE_REQ_CLOSE_CONNECTION  Added after ISAPI 4.0 */
        return FALSE;
    case 1018: /* HSE_REQ_IS_CONNECTED  Added after ISAPI 4.0 */
        *((LPBOOL) lpvBuffer) = (r->connection->aborted == 0);
        return TRUE;
    case 1020: /* HSE_REQ_EXTENSION_TRIGGER  Added after ISAPI 4.0 */
        return FALSE;
        return FALSE;
    DWORD read;
    if(strcmp(r->handler, "isapi-isa"))

    if (!(ap_allow_options(r) & OPT_EXECCGI))

    if (r->finfo.filetype == APR_NOFILE)

    if (r->finfo.filetype != APR_REG)

        r->path_info && *r->path_info)
    {
    /* Load the isapi extention without caching (pass r value) 
     * but note that we will recover an existing cached module.
     */
    if (isapi_load(loaded.pool, r, r->filename, &isa) != APR_SUCCESS)
        

    cid->ecb = apr_pcalloc(r->pool, sizeof(struct _EXTENSION_CONTROL_BLOCK));
    cid->ecb->ConnID = (HCONN)cid;
        isapi_unload(isa, FALSE);
         * TODO: add the httpd.conf option for read_ahead_buflen.
            if (cid->ecb->cbTotalBytes > (DWORD)cid->dconf.read_ahead_buflen)
            isapi_unload(isa, FALSE);
             * the ISA's "advice".
        case HSE_STATUS_PENDING:    
            
            if (!isa->fakeasync) {
                if (cid->dconf.log_unsupported)
                {
                     ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
                                   "ISAPI: %s asynch I/O request refused", 
                                   r->filename);
                     cid->r->status = HTTP_INTERNAL_SERVER_ERROR;
                }
            }
            else {
                cid->complete = CreateEvent(NULL, FALSE, FALSE, NULL);
    /* All done with the DLL... get rid of it... */
    isapi_unload(isa, FALSE);
    
    loaded.modules = apr_array_make(loaded.pool, 20, sizeof(isapi_loaded*));
    if (!loaded.modules) {
	ap_log_error(APLOG_MARK, APLOG_ERR, APR_EGENERAL, NULL,
                     "ISAPI: could not create the isapi cache");
    return OK;
}

static int compare_loaded(const void *av, const void *bv)
{
    const isapi_loaded **a = av;
    const isapi_loaded **b = bv;

    return strcmp((*a)->filename, (*b)->filename);
}

static int isapi_post_config(apr_pool_t *p, apr_pool_t *plog,
                             apr_pool_t *ptemp, server_rec *s)
{
    isapi_loaded **elts = (isapi_loaded **)loaded.modules->elts;
    int nelts = loaded.modules->nelts;

    /* sort the elements of the main_server, by filename */
    qsort(elts, nelts, sizeof(isapi_loaded*), compare_loaded);

    ap_hook_post_config(isapi_post_config, NULL, NULL, APR_HOOK_MIDDLE);
AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char *segment)
    char *copy = apr_palloc(p, 3 * strlen(segment) + 1);
module AP_MODULE_DECLARE_DATA imap_module;
    icr = ap_get_module_config(r->per_dir_config, &imap_module);
module AP_MODULE_DECLARE_DATA imap_module =
                mime_info.file_name = apr_filename_of_pathname(rr->filename);
    SSL_renegotiate(ssl);
            SSL_renegotiate(ssl);
    char *cp, *cp2;
        else if (is_absolute_uri(r->filename)) {
            /* skip 'scheme:' */
            for (cp = r->filename; *cp != ':' && *cp != '\0'; cp++)
                ;
            /* skip '://' */
            cp += 3;
            /* skip host part */
            for ( ; *cp != '/' && *cp != '\0'; cp++)
                ;
            if (*cp != '\0') {
                if (rulestatus != ACTION_NOESCAPE) {
                    rewritelog(r, 1, "escaping %s for redirect", r->filename);
                    cp2 = ap_escape_uri(r->pool, cp);
                }
                else {
                    cp2 = apr_pstrdup(r->pool, cp);
                }
                *cp = '\0';
                r->filename = apr_pstrcat(r->pool, r->filename, cp2, NULL);
            if (r->args != NULL) {
                char *args;
                if (rulestatus == ACTION_NOESCAPE) {
                    args = r->args;
                }
                else {
                    args = ap_escape_uri(r->pool, r->args);
                }
                                          args, NULL);
        else if (is_absolute_uri(r->filename)) {
                /* skip 'scheme:' */
                for (cp = r->filename; *cp != ':' && *cp != '\0'; cp++)
                    ;
                /* skip '://' */
                cp += 3;

            /* skip 'scheme:' */
            for (cp = r->filename; *cp != ':' && *cp != '\0'; cp++)
                ;
            /* skip '://' */
            cp += 3;
            /* skip host part */
            for ( ; *cp != '/' && *cp != '\0'; cp++)
                ;
            if (*cp != '\0') {
                if (rulestatus != ACTION_NOESCAPE) {
                    rewritelog(r, 1, "[per-dir %s] escaping %s for redirect",
                               dconf->directory, r->filename);
                    cp2 = ap_escape_uri(r->pool, cp);
                }
                else {
                    cp2 = apr_pstrdup(r->pool, cp);
                }
                *cp = '\0';
                r->filename = apr_pstrcat(r->pool, r->filename, cp2, NULL);
            if (r->args != NULL) {
                char *args;
                if (rulestatus == ACTION_NOESCAPE) {
                    args = r->args;
                }
                else {
                    args = ap_escape_uri(r->pool, r->args);
                }
                                          args, NULL);
/*
**
**  return non-zero if the URI is absolute (includes a scheme etc.)
**
*/
static int is_absolute_uri(char *uri)
    int i = strlen(uri);
    if (   (i > 7 && strncasecmp(uri, "http://",   7) == 0)
        || (i > 8 && strncasecmp(uri, "https://",  8) == 0)
        || (i > 9 && strncasecmp(uri, "gopher://", 9) == 0)
        || (i > 6 && strncasecmp(uri, "ftp://",    6) == 0)
        || (i > 5 && strncasecmp(uri, "ldap:",     5) == 0)
        || (i > 5 && strncasecmp(uri, "news:",     5) == 0)
        || (i > 7 && strncasecmp(uri, "mailto:",   7) == 0) ) {
        return 1;
    else {
        return 0;
static int   is_absolute_uri(char *uri);
#define PROXY_WORKER_IS_INITIALIZED(f)   ( (f)->s->status & \
  PROXY_WORKER_INITIALIZED )
#define PROXY_WORKER_IS_STANDBY(f)   ( (f)->s->status & \
  PROXY_WORKER_HOT_STANDBY )
#define PROXY_WORKER_IS_USABLE(f)   ( !((f)->s->status & \
  (PROXY_WORKER_NOT_USABLE_BITMAP)) && PROXY_WORKER_IS_INITIALIZED(f) )
                ++value;
                           r->parsed_uri.path, "?", NULL);
                           r->parsed_uri.path, "?", r->parsed_uri.query, NULL);
typedef struct {
    char* hdr;
    char* val;
} cache_header_tbl_t;

    apr_ssize_t num_header_out;
    apr_ssize_t num_req_hdrs;
    cache_header_tbl_t *header_out;
    cache_header_tbl_t *req_hdrs; /* for Vary negotiation */
    /* TODO:
     * We desperately need a more efficient way of allocating objects. We're
     * making way too many malloc calls to create a fully populated
     * cache object...
     */

    /* Cleanup the cache_object_t */
    if (obj->key) {
        free((void*)obj->key);
    }

    free(obj);

        if (mobj->header_out) {
            if (mobj->header_out[0].hdr)
                free(mobj->header_out[0].hdr);
            free(mobj->header_out);
        }
        if (mobj->req_hdrs) {
            if (mobj->req_hdrs[0].hdr)
                free(mobj->req_hdrs[0].hdr);
            free(mobj->req_hdrs);
        }
        free(mobj);
    apr_size_t key_len;
    /* Allocate and initialize cache_object_t */
    obj = calloc(1, sizeof(*obj));
    if (!obj) {
        return DECLINED;
    }
    key_len = strlen(key) + 1;
    obj->key = malloc(key_len);
    if (!obj->key) {
        cleanup_cache_object(obj);
    memcpy((void*)obj->key, key, key_len);
    mobj = calloc(1, sizeof(*mobj));
    if (!mobj) {
        cleanup_cache_object(obj);
        return DECLINED;
    }
static apr_status_t serialize_table(cache_header_tbl_t **obj,
                                    apr_ssize_t *nelts,
                                    apr_table_t *table)
{
    const apr_array_header_t *elts_arr = apr_table_elts(table);
    apr_table_entry_t *elts = (apr_table_entry_t *) elts_arr->elts;
    apr_ssize_t i;
    apr_size_t len = 0;
    apr_size_t idx = 0;
    char *buf;

    *nelts = elts_arr->nelts;
    if (*nelts == 0 ) {
        *obj=NULL;
        return APR_SUCCESS;
    }
    *obj = malloc(sizeof(cache_header_tbl_t) * elts_arr->nelts);
    if (NULL == *obj) {
        return APR_ENOMEM;
    }
    for (i = 0; i < elts_arr->nelts; ++i) {
        len += strlen(elts[i].key);
        len += strlen(elts[i].val);
        len += 2;  /* Extra space for NULL string terminator for key and val */
    }

    /* Transfer the headers into a contiguous memory block */
    buf = malloc(len);
    if (!buf) {
        free(*obj);
        *obj = NULL;
        return APR_ENOMEM;
    }

    for (i = 0; i < *nelts; ++i) {
        (*obj)[i].hdr = &buf[idx];
        len = strlen(elts[i].key) + 1;              /* Include NULL terminator */
        memcpy(&buf[idx], elts[i].key, len);
        idx+=len;

        (*obj)[i].val = &buf[idx];
        len = strlen(elts[i].val) + 1;
        memcpy(&buf[idx], elts[i].val, len);
        idx+=len;
    }
    return APR_SUCCESS;
}
static int unserialize_table( cache_header_tbl_t *ctbl,
                              int num_headers,
                              apr_table_t *t )
{
    int i;

    for (i = 0; i < num_headers; ++i) {
        apr_table_addn(t, ctbl[i].hdr, ctbl[i].val);
    }
    return APR_SUCCESS;
}
    int rc;
    h->req_hdrs = apr_table_make(r->pool, mobj->num_req_hdrs);
    h->resp_hdrs = apr_table_make(r->pool, mobj->num_header_out);
    rc = unserialize_table(mobj->req_hdrs, mobj->num_req_hdrs, h->req_hdrs);
    rc = unserialize_table(mobj->header_out, mobj->num_header_out,
                           h->resp_hdrs);

    return rc;
    int rc;
    rc = serialize_table(&mobj->req_hdrs,
                         &mobj->num_req_hdrs,
                         r->headers_in);
    if (rc != APR_SUCCESS) {
        return rc;
    }

    rc = serialize_table(&mobj->header_out, &mobj->num_header_out,
                         headers_out);
    if (rc != APR_SUCCESS) {
        return rc;
    }
                char *buf = malloc(obj->count);
                if (!buf) {
                memcpy(buf, mobj->m, obj->count);
                free(mobj->m);
                mobj->m = buf;
#define MODULE_MAGIC_NUMBER_MAJOR 20111203
#define MODULE_MAGIC_NUMBER_MINOR 1                   /* 0...n */
typedef unsigned char overrides_t;
    if ((parms->override & cmd->req_override) == 0 && !override_list_ok)
        return apr_pstrcat(parms->pool, cmd->name, " not allowed here", NULL);
        return apr_pstrcat(parms->pool, "Invalid command '",
                           current->directive,
                           "', perhaps misspelled or defined by a module "
                           "not included in the server configuration",
                           NULL);
#define MODULE_MAGIC_NUMBER_MAJOR 20051115
static int read_request_line(request_rec *r, apr_bucket_brigade *bb)

#if 0
    conn_rec *conn = r->connection;
#endif
    int num_blank_lines = 0;
    int max_blank_lines = r->server->limit_req_fields;

    if (max_blank_lines <= 0) {
        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
    }

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    do {
        apr_status_t rv;

        /* insure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */
        r->the_request = NULL;
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                         &len, r, 0, bb);

        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }
            return 0;
        }
    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));

    /* we've probably got something to do, ignore graceful restart requests */
    ll = r->the_request;
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method",
                                r->method);
#endif

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

             && (minor < HTTP_VERSION(1, 0)) ) /* don't allow HTTP/0.1000 */
    else
    return 1;
    char *last_field = NULL;
    apr_size_t last_len = 0;
    apr_size_t alloc_len = 0;
    char *value;
    int fields_read = 0;
    char *tmp_field;
        int folded = 0;

        if (last_field != NULL) {
            if ((len > 0) && ((*field == '\t') || *field == ' ')) {
                /* This line is a continuation of the preceding line(s),
                 * so append it to the line that we've set aside.
                 * Note: this uses a power-of-two allocator to avoid
                 * doing O(n) allocs and using O(n^2) space for
                 * continuations that span many many lines.
                 */
                apr_size_t fold_len = last_len + len + 1; /* trailing null */

                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field "
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                if (fold_len > alloc_len) {
                    char *fold_buf;
                    alloc_len += alloc_len;
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
                    }
                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);
                    memcpy(fold_buf, last_field, last_len);
                    last_field = fold_buf;
                }
                memcpy(last_field + last_len, field, len +1); /* +1 for nul */
                last_len += len;
                folded = 1;
            }
            else /* not a continuation line */ {

                if (r->server->limit_req_fields
                    && (++fields_read > r->server->limit_req_fields)) {
                    r->status = HTTP_BAD_REQUEST;
                    apr_table_setn(r->notes, "error-notes",
                                   "The number of request header fields "
                                   "exceeds this server's limit.");
                    return;
                }

                if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                    r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Request header field is "
                                               "missing ':' separator.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool,
                                                              last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                tmp_field = value - 1; /* last character of field-name */

                *value++ = '\0'; /* NUL-terminate at colon */

                while (*value == ' ' || *value == '\t') {
                    ++value;            /* Skip to start of value   */
                }

                /* Strip LWS after field-name: */
                while (tmp_field > last_field
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                /* Strip LWS after field-value: */
                tmp_field = last_field + last_len - 1;
                while (tmp_field > value
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                apr_table_addn(r->headers_in, last_field, value);

                /* reset the alloc_len so that we'll allocate a new
                 * buffer if we have to do any more folding: we can't
                 * use the previous buffer because its contents are
                 * now part of r->headers_in
                 */
                alloc_len = 0;

            } /* end if current line is not a continuation starting with tab */
        }

        /* Found a blank line, stop. */
        if (len == 0) {
            break;

        /* Keep track of this line so that we can parse it on
         * the next loop iteration.  (In the folded case, last_field
         * has been updated already.)
         */
        if (!folded) {
            last_field = field;
            last_len = len;

    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
request_rec *ap_read_request(conn_rec *conn)
    const char *expect;
    int access_status;
    apr_bucket_brigade *tmp_bb;
    apr_socket_t *csd;
    apr_interval_time_t cur_timeout;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);

    /* Get the request... */
    if (!read_request_line(r, tmp_bb)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        apr_brigade_destroy(tmp_bb);
        return NULL;
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_get(csd, &cur_timeout);
    if (cur_timeout != conn->base_server->timeout) {
        apr_socket_timeout_set(csd, conn->base_server->timeout);
        cur_timeout = conn->base_server->timeout;
    }

    if (!r->assbackwards) {
        ap_get_mime_headers_core(r, tmp_bb);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        if (apr_table_get(r->headers_in, "Transfer-Encoding")
            && apr_table_get(r->headers_in, "Content-Length")) {
            /* 2616 section 4.4, point 3: "if both Transfer-Encoding
             * and Content-Length are received, the latter MUST be
             * ignored"; so unset it here to prevent any confusion
             * later. */
            apr_table_unset(r->headers_in, "Content-Length");
        }
    }
    else {
        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }
    }
    apr_brigade_destroy(tmp_bb);
    if (cur_timeout != r->server->timeout) {
        apr_socket_timeout_set(csd, r->server->timeout);
        cur_timeout = r->server->timeout;

  (PROXY_WORKER_NOT_USABLE_BITMAP | PROXY_WORKER_HOT_STANDBY )) && \
  PROXY_WORKER_IS_INITIALIZED(f) )

#define PROXY_WORKER_IS_USABLE_STANDBY(f)   ( !((f)->s->status & \
  PROXY_WORKER_NOT_USABLE_BITMAP) && PROXY_WORKER_IS_STANDBY(f) && \
  PROXY_WORKER_IS_INITIALIZED(f) )

#define PROXY_WORKER_IS_USABLE_DC(f)   ( !((f)->s->status & \
    proxy_worker *worker = (proxy_worker *)balancer->workers->elts;
    for (i = 0; i < balancer->workers->nelts; i++) {
        if (*(worker->s->route) && strcmp(worker->s->route, route) == 0) {
            if (worker && PROXY_WORKER_IS_USABLE(worker)) {
                return worker;
            } else {
                /*
                 * If the worker is in error state run
                 * retry on that worker. It will be marked as
                 * operational if the retry timeout is elapsed.
                 * The worker might still be unusable, but we try
                 * anyway.
                 */
                ap_proxy_retry_worker("BALANCER", worker, r->server);
                if (PROXY_WORKER_IS_USABLE(worker)) {
                        return worker;
                     * We have a worker that is unusable.
                     * It can be in error or disabled, but in case
                     * it has a redirection set use that redirection worker.
                     * This enables to safely remove the member from the
                     * balancer. Of course you will need some kind of
                     * session replication between those two remote.
                    if (*worker->s->redirect) {
                        proxy_worker *rworker = NULL;
                        rworker = find_route_worker(balancer, worker->s->redirect, r);
                        /* Check if the redirect worker is usable */
                        if (rworker && !PROXY_WORKER_IS_USABLE(rworker)) {
                            /*
                             * If the worker is in error state run
                             * retry on that worker. It will be marked as
                             * operational if the retry timeout is elapsed.
                             * The worker might still be unusable, but we try
                             * anyway.
                             */
                            ap_proxy_retry_worker("BALANCER", rworker, r->server);
                        }
                        if (rworker && PROXY_WORKER_IS_USABLE(rworker))
                            return rworker;
                    }
                }
            }
        }
        worker++;
    }
    /*
     * Check for any hot-standbys, since we have no usable workers
     */
    worker = (proxy_worker *)balancer->workers->elts;
    for (i = 0; i < balancer->workers->nelts; i++) {
        if (*(worker->s->route) && (strcmp(worker->s->route, route) == 0) &&
            PROXY_WORKER_IS_STANDBY(worker)) {
            if (worker && PROXY_WORKER_IS_USABLE_STANDBY(worker)) {
                return worker;
            } else {
                ap_proxy_retry_worker("BALANCER", worker, r->server);
                if (PROXY_WORKER_IS_USABLE_STANDBY(worker)) {
                        return worker;
                } else {
                    if (*worker->s->redirect) {
                        proxy_worker *rworker = NULL;
                        rworker = find_route_worker(balancer, worker->s->redirect, r);
                        if (rworker && !PROXY_WORKER_IS_USABLE_STANDBY(rworker)) {
                            ap_proxy_retry_worker("BALANCER", rworker, r->server);
                        if (rworker && PROXY_WORKER_IS_USABLE_STANDBY(rworker))
                            return rworker;
        worker++;
                else {
                    if (worker->s->status & PROXY_WORKER_DISABLED)
                       ap_rputs("Dis ", r);
                    if (worker->s->status & PROXY_WORKER_IN_ERROR)
                       ap_rputs("Err ", r);
                    if (worker->s->status & PROXY_WORKER_STOPPED)
                       ap_rputs("Stop ", r);
                    if (worker->s->status & PROXY_WORKER_HOT_STANDBY)
                       ap_rputs("Stby ", r);
                    if (!PROXY_WORKER_IS_INITIALIZED(worker))
                        ap_rputs("-", r);
                }
    proxy_worker *worker = (proxy_worker *)balancer->workers->elts;


    for (i = 0; i < balancer->workers->nelts; i++) {
        /* If the worker is in error state run
         * retry on that worker. It will be marked as
         * operational if the retry timeout is elapsed.
         * The worker might still be unusable, but we try
         * anyway.
         */
        if (!PROXY_WORKER_IS_USABLE(worker))
            ap_proxy_retry_worker("BALANCER", worker, r->server);
        /* Take into calculation only the workers that are
         * not in error state or not disabled.
         */
        if (PROXY_WORKER_IS_USABLE(worker)) {
            worker->s->lbstatus += worker->s->lbfactor;
            total_factor += worker->s->lbfactor;
            if (!mycandidate || worker->s->lbstatus > mycandidate->s->lbstatus)
                mycandidate = worker;
        }
        worker++;
    }

    if (!mycandidate) {
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (PROXY_WORKER_IS_STANDBY(worker)) {
                if (!PROXY_WORKER_IS_USABLE_STANDBY(worker))
                    ap_proxy_retry_worker("BALANCER", worker, r->server);
                if (PROXY_WORKER_IS_USABLE_STANDBY(worker)) {
                    worker->s->lbstatus += worker->s->lbfactor;
                    total_factor += worker->s->lbfactor;
                    if (!mycandidate || worker->s->lbstatus > mycandidate->s->lbstatus)
                        mycandidate = worker;
                }
            worker++;
    proxy_worker *worker = (proxy_worker *)balancer->workers->elts;
    for (i = 0; i < balancer->workers->nelts; i++) {
        /* If the worker is in error state run
         * retry on that worker. It will be marked as
         * operational if the retry timeout is elapsed.
         * The worker might still be unusable, but we try
         * anyway.
         */
        if (!PROXY_WORKER_IS_USABLE(worker))
            ap_proxy_retry_worker("BALANCER", worker, r->server);
        /* Take into calculation only the workers that are
         * not in error state or not disabled.
         */
        if (PROXY_WORKER_IS_USABLE(worker)) {
            mytraffic = (worker->s->transferred/worker->s->lbfactor) +
                        (worker->s->read/worker->s->lbfactor);
            if (!mycandidate || mytraffic < curmin) {
                mycandidate = worker;
                curmin = mytraffic;
            }
        }
        worker++;
    }

    if (!mycandidate) {
        for (i = 0; i < balancer->workers->nelts; i++) {
            if (PROXY_WORKER_IS_STANDBY(worker)) {
                if (!PROXY_WORKER_IS_USABLE_STANDBY(worker))
                    ap_proxy_retry_worker("BALANCER", worker, r->server);
                if (PROXY_WORKER_IS_USABLE_STANDBY(worker)) {
                    mytraffic = (worker->s->transferred/worker->s->lbfactor) +
                        (worker->s->read/worker->s->lbfactor);
                    if (!mycandidate || mytraffic < curmin) {
                        mycandidate = worker;
                        curmin = mytraffic;
                    }
            worker++;
    if (!PROXY_WORKER_IS_USABLE_DC(worker)) {
        if (!PROXY_WORKER_IS_USABLE_DC(worker)) {
    if (!connected && PROXY_WORKER_IS_USABLE_DC(worker) &&
#include "h2_private.h"

#include "h2_request.h"
    stream->req = h2_request_create(1, stream->pool, 0);
    h2_request_make(stream->req, stream->pool, r->method, scheme,
                    authority, path, r->headers_in);
                req = h2_request_createn(0, ctx->pool, method, ctx->req->scheme,
                                         ctx->req->authority, path, headers,
                                         ctx->req->serialize);
h2_request *h2_request_create(int id, apr_pool_t *pool, int serialize)
{
    return h2_request_createn(id, pool, NULL, NULL, NULL, NULL, NULL,
                              serialize);
}

h2_request *h2_request_createn(int id, apr_pool_t *pool,
                               const char *method, const char *scheme,
                               const char *authority, const char *path,
                               apr_table_t *header, int serialize)
{
    h2_request *req = apr_pcalloc(pool, sizeof(h2_request));
    
    req->id             = id;
    req->method         = method;
    req->scheme         = scheme;
    req->authority      = authority;
    req->path           = path;
    req->headers        = header? header : apr_table_make(pool, 10);
    req->request_time   = apr_time_now();
    req->serialize      = serialize;
    
    return req;
}

static apr_status_t add_h1_header(h2_request *req, apr_pool_t *pool, 
                                  const char *name, size_t nlen,
                                  const char *value, size_t vlen)
{
    char *hname, *hvalue;
    
    if (h2_req_ignore_header(name, nlen)) {
        return APR_SUCCESS;
    }
    else if (H2_HD_MATCH_LIT("cookie", name, nlen)) {
        const char *existing = apr_table_get(req->headers, "cookie");
        if (existing) {
            char *nval;
            
            /* Cookie header come separately in HTTP/2, but need
             * to be merged by "; " (instead of default ", ")
             */
            hvalue = apr_pstrndup(pool, value, vlen);
            nval = apr_psprintf(pool, "%s; %s", existing, hvalue);
            apr_table_setn(req->headers, "Cookie", nval);
            return APR_SUCCESS;
        }
    }
    else if (H2_HD_MATCH_LIT("host", name, nlen)) {
        if (apr_table_get(req->headers, "Host")) {
            return APR_SUCCESS; /* ignore duplicate */
        }
    }
    
    hname = apr_pstrndup(pool, name, nlen);
    hvalue = apr_pstrndup(pool, value, vlen);
    h2_util_camel_case_header(hname, nlen);
    apr_table_mergen(req->headers, hname, hvalue);
    
    return APR_SUCCESS;
}

typedef struct {
    h2_request *req;
    apr_pool_t *pool;
} h1_ctx;

static int set_h1_header(void *ctx, const char *key, const char *value)
{
    h1_ctx *x = ctx;
    size_t klen = strlen(key);
    if (!h2_req_ignore_header(key, klen)) {
        add_h1_header(x->req, x->pool, key, klen, value, strlen(value));
    }
    return 1;
}

static apr_status_t add_all_h1_header(h2_request *req, apr_pool_t *pool, 
                                      apr_table_t *header)
{
    h1_ctx x;
    x.req = req;
    x.pool = pool;
    apr_table_do(set_h1_header, &x, header, NULL);
    return APR_SUCCESS;
}


apr_status_t h2_request_make(h2_request *req, apr_pool_t *pool,
                             const char *method, const char *scheme, 
                             const char *authority, const char *path, 
                             apr_table_t *headers)
{
    req->method    = method;
    req->scheme    = scheme;
    req->authority = authority;
    req->path      = path;

    AP_DEBUG_ASSERT(req->scheme);
    AP_DEBUG_ASSERT(req->authority);
    AP_DEBUG_ASSERT(req->path);
    AP_DEBUG_ASSERT(req->method);

    return add_all_h1_header(req, pool, headers);
}

    status = h2_request_make(req, r->pool,  r->method, scheme, authority,
                             apr_uri_unparse(r->pool, &r->parsed_uri, 
                                             APR_URI_UNP_OMITSITEPART),
                             r->headers_in);
    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(03058)
                  "h2_request(%d): rwrite %s host=%s://%s%s",
                  req->id, req->method, req->scheme, req->authority, req->path);
        status = add_h1_header(req, pool, name, nlen, value, vlen);
h2_request *h2_request_create(int id, apr_pool_t *pool, int serialize);

h2_request *h2_request_createn(int id, apr_pool_t *pool,
                               const char *method, const char *scheme,
                               const char *authority, const char *path,
                               apr_table_t *headers, int serialize);

apr_status_t h2_request_make(h2_request *req, apr_pool_t *pool,
                             const char *method, const char *scheme, 
                             const char *authority, const char *path, 
                             apr_table_t *headers);

#define H2_STREAM_OUT_LOG(lvl,s,msg) \
    do { \
        if (APLOG_C_IS_LEVEL((s)->session->c,lvl)) \
        h2_util_bb_log((s)->session->c,(s)->session->id,lvl,msg,(s)->buffer); \
    } while(0)
    
        req = h2_request_create(id, pool, 
#include "h2_private.h"
#include "h2_request.h"
void h2_util_bb_log(conn_rec *c, int stream_id, int level, 
                    const char *tag, apr_bucket_brigade *bb)
{
    char buffer[4 * 1024];
    const char *line = "(null)";
    apr_size_t len, bmax = sizeof(buffer)/sizeof(buffer[0]);
    
    len = h2_util_bb_print(buffer, bmax, tag, "", bb);
    /* Intentional no APLOGNO */
    ap_log_cerror(APLOG_MARK, level, 0, c, "bb_dump(%ld-%d): %s", 
                  c->id, stream_id, len? buffer : line);
}

void h2_util_bb_log(conn_rec *c, int stream_id, int level, 
                    const char *tag, apr_bucket_brigade *bb);
#include "h2_request.h"
        else if (!strcasecmp(w, "Options")) {
        else if (!strcasecmp(w, "execCGI")) {
        /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        if (action == '-') {
                                                   apr_bucket_brigade * bb);
static int ftp_getrc_msg(conn_rec *c, apr_bucket_brigade * bb, char *msgbuf, int msglen)
    if (APR_SUCCESS != (rv = ap_proxy_string_read(c, bb, response, sizeof(response), &eos))) {
            if (APR_SUCCESS != (rv = ap_proxy_string_read(c, bb, response, sizeof(response), &eos))) {
apr_status_t ap_proxy_send_dir_filter(ap_filter_t * f, apr_bucket_brigade * in)
                           "\n\n<HTML>\n<HEAD>\n<TITLE>%s%s</TITLE>\n"
                           "<BASE HREF=\"%s%s\">\n</HEAD>\n\n"
                           "<BODY>\n\n<H2>Directory of "
                           "<A HREF=\"/\">%s</A>/",
                           site, path, site, path, site);
            str = apr_psprintf(p, "<A HREF=\"/%s/\">%s</A>/", path + 1, reldir);
            str = apr_psprintf(p, "</H2>\n\n<HR></HR>\n\n<PRE>");
            str = apr_psprintf(p, "</H2>\n\n(%s)\n\n<HR></HR>\n\n<PRE>", pwd);
            str = apr_psprintf(p, "%s\n</PRE>\n\n<HR></HR>\n\n<PRE>\n",
                               readme);

            } while (filename[0] != ' ');
            *(filename++) = '\0';
            str = apr_psprintf(p, "%s <A HREF=\"%s\">%s %s</A>\n", ctx->buffer, filename, filename, link_ptr);
                str = apr_psprintf(p, "%s <A HREF=\"%s/\">%s</A>\n",
                                   ctx->buffer, filename, filename);
                str = apr_psprintf(p, "%s <A HREF=\"%s\">%s</A>\n",
                                   ctx->buffer, filename, filename);
            str = apr_pstrdup(p, ctx->buffer);
        str = apr_psprintf(p, "</PRE>\n\n<HR></HR>\n\n%s\n\n</BODY>\n</HTML>\n", ap_psignature("", r));
    apr_socket_t *sock, *local_sock, *remote_sock = NULL;
    conn_rec *origin, *remote;
     * 
     * 
     * 
     * 
         * 
     * 
        apr_sockaddr_t *remote_addr;
        char *remote_ip;
        apr_port_t remote_port;
                remote_port = atoi(pstr + 3);
                             remote_port);
                if ((rv = apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
                apr_socket_addr_get(&remote_addr, APR_REMOTE, sock);
                apr_sockaddr_ip_get(&remote_ip, remote_addr);
                apr_sockaddr_info_get(&epsv_addr, remote_ip, APR_INET, remote_port, 0, p);
                rv = apr_connect(remote_sock, epsv_addr);
                apr_socket_close(remote_sock);
                if ((rv = apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
                rv = apr_connect(remote_sock, pasv_addr);
                apr_socket_close(remote_sock);
     * 
            rv = apr_accept(&remote_sock, local_sock, r->pool);
    remote = ap_new_connection(p, r->server, remote_sock, r->connection->id, r->connection->sbh);
    if (!remote) {
    ap_proxy_pre_http_connection(remote);
     * 
        while (ap_get_brigade(remote->input_filters, bb, AP_MODE_EXHAUSTIVE,
    ap_flush_conn(remote);
    apr_socket_close(remote_sock);
     * 
static void ap_proxy_ftp_register_hook(apr_pool_t * p)
    time_left = ccfg->timeout_at - now;
    if (time_left <= 0) {
        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c,
                      "Request %s read timeout", ccfg->type);
        return APR_TIMEUP;
    }
    if (time_left < apr_time_from_sec(1)) {
        time_left = apr_time_from_sec(1);
    }

    if (saved_sock_timeout >= time_left) {
        rv = apr_socket_timeout_set(ccfg->socket, time_left);
        AP_DEBUG_ASSERT(rv == APR_SUCCESS);
    }
    else {
        saved_sock_timeout = -1;
    }
    rv = ap_get_brigade(f->next, bb, mode, block, readbytes);
    if (saved_sock_timeout != -1) {
        apr_socket_timeout_set(ccfg->socket, saved_sock_timeout);
    }
    if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {
        extend_timeout(ccfg, bb);
module AP_MODULE_DECLARE_DATA imap_module;
    icr = ap_get_module_config(r->per_dir_config, &imap_module);
module AP_MODULE_DECLARE_DATA imap_module =
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type("text/xml", r);
    ap_rset_content_type(apr_pstrdup(r->pool, info->content_type), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html;charset=utf-8", r);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html", r);
                    ap_rset_content_type("text/plain", r);
    ap_rset_content_type("message/http", r);
AP_DECLARE(void) ap_rset_content_type(const char *ct, request_rec *r)
        ap_rset_content_type("text/html; charset=iso-8859-1", r);
            ap_rset_content_type(apr_pstrcat(r->pool, "multipart",
                                             use_range_x(r) ? "/x-" : "/",
                                             "byteranges; boundary=",
                                             r->boundary, NULL), r);
    ap_rset_content_type(rr->content_type, r);
        ap_rset_content_type(r->content_type, new);
        ap_rset_content_type(DIR_MAGIC_TYPE, r);
                ap_rset_content_type((char*) type, r);
                ap_rset_content_type(exinfo->forced_type, r);
	    ap_rset_content_type(apr_pstrcat(r->pool, ctp->type, "/",
                                             ctp->subtype, NULL), r);
			ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                         "; charset=", charset,
                                                         NULL), r);
		    ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                     "; ", pp->attr,
                                                     "=", pp->val,
                                                     NULL), r);
		ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                 "; charset=", charset,
                                                 NULL), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type(CGI_MAGIC_TYPE, sub_req);
        ap_rset_content_type(t, r);
                ap_rset_content_type(p->forced_mimetype, r);
	    ap_rset_content_type(tmp, r);
	ap_rset_content_type(tmp, r);
	ap_rset_content_type(apr_pstrdup(r->pool, sub->content_type), r);
        ap_rset_content_type("text/html", r);
            ap_rset_content_type(ap_default_type(r), r);
                    ap_rset_content_type(apr_pstrdup(p, buf), r);
static int disk_serve(request_rec *r)
    apr_bucket *e;
    apr_bucket_brigade *bb = apr_brigade_create(r->pool); 
    const char *filename;
    ap_filter_t *f;
    char str[256];
    apr_off_t offset = 0;

    /* XXX Very expensive!!! */
    filename = ap_server_root_relative(r->pool, 
                        apr_pstrcat(r->pool, "proxy", r->uri, NULL));
    if ((rv = apr_file_open(&fd, filename, APR_READ, 
                 APR_UREAD, r->connection->pool)) != APR_SUCCESS) {
        return DECLINED;
    }

    /* skip the cached headers. */
    do {
        apr_file_gets(str, 256, fd);
        offset += strlen(str);
    } while (strcmp(str, CRLF));

    /* If we are serving from the cache, we don't want to try to cache it
     * again.
    for ((f = r->output_filters); (f = f->next);) {
        if (!strcasecmp(f->frec->name, "CACHE")) {
            ap_remove_output_filter(f);
        }
    e = apr_bucket_file_create(fd, offset, r->finfo.size, r->pool);
    ap_pass_brigade(r->output_filters, bb);
typedef struct cache_struct {
    const char *filename;
    apr_file_t *fd;
    int state;
} cache_struct;

static int disk_cache(request_rec *r, apr_bucket_brigade *bb, void **cf)
    cache_struct *ctx = *cf;
    apr_bucket *e;
    if (ctx == NULL) {
        *cf = ctx = apr_pcalloc(r->pool, sizeof(*ctx));
    }
    if (ctx->filename == NULL) {
        apr_status_t rv;
        /* XXX Very expensive!!! */
        apr_dir_make(ap_server_root_relative(r->pool, "proxy"), APR_UREAD | APR_UWRITE | APR_UEXECUTE | APR_GREAD | APR_GWRITE, r->pool);

        /* currently, we are using the uri as the cache key.  This is
         * probably wrong, but it is much better than a hard-coded filename.
         */
        /* XXX Very expensive!!! */
        ctx->filename = ap_server_root_relative(r->pool, 
                            apr_pstrcat(r->pool, "proxy", r->uri, NULL));
        if ((rv = apr_file_open(&ctx->fd, ctx->filename, 
                     APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BUFFERED,
                     APR_UREAD | APR_UWRITE, r->pool)) != APR_SUCCESS) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                         "Could not create cache file");
            *cf = NULL;
    } 
    APR_BRIGADE_FOREACH(e, bb) {

        apr_file_write(ctx->fd, str, &length);
    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
        apr_file_close(ctx->fd);
    ap_hook_store_cache(disk_cache, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_serve_cache(disk_serve, NULL, NULL, APR_HOOK_MIDDLE);
    NULL,			/* create per-directory config structure */
    NULL,        		/* merge per-directory config structures */
    NULL,			/* create per-server config structure */
    NULL,			/* merge per-server config structures */
    NULL,			/* command apr_table_t */
    proxy_server_conf *ps = ap_pcalloc(p, sizeof(proxy_server_conf));

    ps->sec_proxy = ap_make_array(p, 10, sizeof(ap_conf_vector_t *));
    ps->proxies = ap_make_array(p, 10, sizeof(struct proxy_remote));
    ps->aliases = ap_make_array(p, 10, sizeof(struct proxy_alias));
    ps->raliases = ap_make_array(p, 10, sizeof(struct proxy_alias));
    ps->noproxies = ap_make_array(p, 10, sizeof(struct noproxy_entry));
    ps->dirconn = ap_make_array(p, 10, sizeof(struct dirconn_entry));
    ps->allowed_connect_ports = ap_make_array(p, 10, sizeof(int));
    proxy_server_conf *ps = ap_pcalloc(p, sizeof(proxy_server_conf));
#include "apr_compat.h"
        if (ch == '%' && ap_isxdigit(x[i + 1]) && ap_isxdigit(x[i + 2])) {
        if (ch == '%' && ap_isxdigit(x[i + 1]) && ap_isxdigit(x[i + 2])) {
        ap_cpystrn(message, cmd, sizeof message);
        *pmessage = ap_pstrdup(r->pool, message);
    char dates[AP_RFC822_DATE_LEN];
        backend = ap_pcalloc(c->pool, sizeof(proxy_conn_rec));
        && ap_isalpha(type_suffix[5])) {
        if ( ! (dirlisting = (ap_tolower(type_suffix[5]) == 'd')))
            xfer_type = ap_toupper(type_suffix[5]);
            ap_table_add(r->headers_out, "Retry-After",
                         apr_psprintf(p, "%lu", (unsigned long)(60 * secs)));
                ap_table_mergen(r->headers_out, "Via",
                                (conf->viaopt == via_full)
                                ? apr_psprintf(p, "%d.%d %s%s (%s)",
                                               HTTP_VERSION_MAJOR(r->proto_num),
                                               HTTP_VERSION_MINOR(r->proto_num),
                                               ap_get_server_name(r),
                                               server_portstr,
                                               AP_SERVER_BASEVERSION)
                                : apr_psprintf(p, "%d.%d %s%s",
                                               HTTP_VERSION_MAJOR(r->proto_num),
                                               HTTP_VERSION_MINOR(r->proto_num),
                                               ap_get_server_name(r),
                                               server_portstr)
        backend = ap_pcalloc(c->pool, sizeof(proxy_conn_rec));
	    if (!ap_isxdigit(x[i + 1]) || !ap_isxdigit(x[i + 2]))
	    if (strcmp(week, ap_day_snames[wk]) == 0)
	if (strcmp(month, ap_month_snames[mon]) == 0)
    apr_snprintf(q, 30, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", ap_day_snames[wk],
       mday, ap_month_snames[mon], year, hour, min, sec);
    headers_out = ap_make_table(r->pool, 20);
typedef struct {
    char* hdr;
    char* val;
} cache_header_tbl_t;

    apr_ssize_t num_header_out;
    apr_ssize_t num_req_hdrs;
    cache_header_tbl_t *header_out;
    cache_header_tbl_t *req_hdrs; /* for Vary negotiation */
    /* TODO:
     * We desperately need a more efficient way of allocating objects. We're
     * making way too many malloc calls to create a fully populated
     * cache object...
     */

    /* Cleanup the cache_object_t */
    if (obj->key) {
        free((void*)obj->key);
    }

    free(obj);

        if (mobj->header_out) {
            if (mobj->header_out[0].hdr)
                free(mobj->header_out[0].hdr);
            free(mobj->header_out);
        }
        if (mobj->req_hdrs) {
            if (mobj->req_hdrs[0].hdr)
                free(mobj->req_hdrs[0].hdr);
            free(mobj->req_hdrs);
        }
        free(mobj);
    apr_size_t key_len;
    /* Allocate and initialize cache_object_t */
    obj = calloc(1, sizeof(*obj));
    if (!obj) {
        return DECLINED;
    }
    key_len = strlen(key) + 1;
    obj->key = malloc(key_len);
    if (!obj->key) {
        cleanup_cache_object(obj);
    memcpy((void*)obj->key, key, key_len);
    mobj = calloc(1, sizeof(*mobj));
    if (!mobj) {
        cleanup_cache_object(obj);
        return DECLINED;
    }
static apr_status_t serialize_table(cache_header_tbl_t **obj,
                                    apr_ssize_t *nelts,
                                    apr_table_t *table)
{
    const apr_array_header_t *elts_arr = apr_table_elts(table);
    apr_table_entry_t *elts = (apr_table_entry_t *) elts_arr->elts;
    apr_ssize_t i;
    apr_size_t len = 0;
    apr_size_t idx = 0;
    char *buf;

    *nelts = elts_arr->nelts;
    if (*nelts == 0 ) {
        *obj=NULL;
        return APR_SUCCESS;
    }
    *obj = malloc(sizeof(cache_header_tbl_t) * elts_arr->nelts);
    if (NULL == *obj) {
        return APR_ENOMEM;
    }
    for (i = 0; i < elts_arr->nelts; ++i) {
        len += strlen(elts[i].key);
        len += strlen(elts[i].val);
        len += 2;  /* Extra space for NULL string terminator for key and val */
    }

    /* Transfer the headers into a contiguous memory block */
    buf = malloc(len);
    if (!buf) {
        free(*obj);
        *obj = NULL;
        return APR_ENOMEM;
    }

    for (i = 0; i < *nelts; ++i) {
        (*obj)[i].hdr = &buf[idx];
        len = strlen(elts[i].key) + 1;              /* Include NULL terminator */
        memcpy(&buf[idx], elts[i].key, len);
        idx+=len;

        (*obj)[i].val = &buf[idx];
        len = strlen(elts[i].val) + 1;
        memcpy(&buf[idx], elts[i].val, len);
        idx+=len;
    }
    return APR_SUCCESS;
}
static int unserialize_table( cache_header_tbl_t *ctbl,
                              int num_headers,
                              apr_table_t *t )
{
    int i;

    for (i = 0; i < num_headers; ++i) {
        apr_table_addn(t, ctbl[i].hdr, ctbl[i].val);
    }
    return APR_SUCCESS;
}
    int rc;
    h->req_hdrs = apr_table_make(r->pool, mobj->num_req_hdrs);
    h->resp_hdrs = apr_table_make(r->pool, mobj->num_header_out);
    rc = unserialize_table(mobj->req_hdrs, mobj->num_req_hdrs, h->req_hdrs);
    rc = unserialize_table(mobj->header_out, mobj->num_header_out,
                           h->resp_hdrs);

    return rc;
    int rc;
    rc = serialize_table(&mobj->req_hdrs,
                         &mobj->num_req_hdrs,
                         r->headers_in);
    if (rc != APR_SUCCESS) {
        return rc;
    }

    rc = serialize_table(&mobj->header_out, &mobj->num_header_out,
                         headers_out);
    if (rc != APR_SUCCESS) {
        return rc;
    }
                char *buf = malloc(obj->count);
                if (!buf) {
                memcpy(buf, mobj->m, obj->count);
                free(mobj->m);
                mobj->m = buf;
typedef struct {
    const char *name;                 /* matching module name */
    const char *info;                 /* additional info */
typedef struct {
static void *create_info_config(apr_pool_t *p, server_rec *s)
    info_svr_conf *conf = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t *p, void *basev, void *overridesv)
    info_svr_conf *new = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info = apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec * r, int nest, const char* thisfn, int linenum)
    const char *prevfn = ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL) thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n", thisfn);
    if (linenum > 0) sprintf(buf, "%d", linenum);
    else             buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i) ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i) ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec * r, const ap_directive_t * dir,
                                int nest)
        ap_escape_html(r->pool, dir->directive),
        ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec * r, const ap_directive_t * dir,
                                int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n", 
                  ap_escape_html(r->pool, dir->directive),
                  ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec * r, const ap_directive_t * dir,
            }
            else {
        ap_rprintf(r, "/%s</tt></dd>",
                   ap_escape_html(r->pool, dirname));
            }
    
static int mod_info_has_cmd(const command_rec * cmds, ap_directive_t * dir)
    const command_rec * cmd;
    if (cmds == NULL) return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0) return 1;
	}
static void mod_info_show_parents(request_rec * r, ap_directive_t * node, 
                                    int from, int to) {
    if (from < to) mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec * r, const command_rec * cmds,
    ap_directive_t * dir;
    if (level == 0) ap_set_module_config(r->request_config, &info_module, NULL);
                                                 shown, level + 1)) {
        } else if (mod_info_has_cmd(cmds, dir)) {
    }
typedef struct { /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc)(void); /* just to get the right size */
    const char * const *aszPredecessors;
    const char * const *aszSuccessors;
typedef apr_array_header_t * ( 
__stdcall 
* hook_get_t)(void);
typedef struct {
static int module_find_hook(module *modp,
                            hook_get_t hook_get)
    elts = (hook_struct_t *)hooks->elts;
    for (i=0; i< hooks->nelts; i++) {
                               hook_lookup_t *lookup,
                               int *comma)
    int i, comma=0;
    for (i=0; request_hooks[i].name; i++) {
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
	return DECLINED;
	     "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n", r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ", r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name, modp->name);
            ap_rprintf(r, "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                        ap_get_server_version());
            ap_rprintf(r, "<dt><strong>Server Built:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                        ap_get_server_built());
            ap_rprintf(r, "<dt><strong>API Version:</strong> "
                        "<tt>%d:%d</tt></dt>\n",
                        MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r, "<dt><strong>Hostname/port:</strong> "
                        "<tt>%s:%u</tt></dt>\n",
                        ap_get_server_name(r), ap_get_server_port(r));
            ap_rprintf(r, "<dt><strong>Timeouts:</strong> "
                        "<tt>connection: %d &nbsp;&nbsp; "
                        "keep-alive: %d</tt></dt>",
                        (int)(apr_time_sec(serv->timeout)), 
                        (int)(apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n", ap_show_mpm());
            ap_rprintf(r, "<dt><strong>MPM Information:</strong> "
		       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r, "<dt><strong>Server Root:</strong> "
                        "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r, "<dt><strong>Config File:</strong> "
		       "<tt>%s</tt></dt>\n", ap_conftree->filename);
        for (modp = ap_top_module; modp; modp = modp->next) {
            if (!r->args || !strcasecmp(modp->name, r->args)) {
                ap_rprintf(r, "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                            "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                            modp->name, modp->name);
                ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                hand = modp->handlers;
                if (hand) {
                    while (hand) {
                        if (hand->content_type) {
                            ap_rprintf(r, " <tt>%s</tt>\n", hand->content_type);
                        }
                        else {
                            break;
                        }
                        hand++;
                        if (hand && hand->content_type) {
                            ap_rputs(",", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                if (module_find_hook(modp, ap_hook_get_handler)) {
                    ap_rputs("<tt> <em>yes</em></tt>", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                ap_rputs("</dt>", r);
                ap_rputs("<dt><strong>Configuration Phase Participation:</strong>\n",
                      r);
                if (modp->create_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Directory Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Directory Configs</tt>", r);
                    comma = 1;
                }
                if (modp->create_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Server Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Server Configs</tt>", r);
                    comma = 1;
                }
                if (!comma)
                    ap_rputs("<tt> <em>none</em></tt>", r);
                comma = 0;
                ap_rputs("</dt>", r);

                module_request_hook_participate(r, modp);

                cmd = modp->cmds;
                if (cmd) {
                    ap_rputs("<dt><strong>Module Directives:</strong></dt>", r);
                    while (cmd) {
                        if (cmd->name) {
                            ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                ap_escape_html(r->pool, cmd->name),
                                cmd->name[0] == '<' ? "&gt;" : "");
                            if (cmd->errmsg) {
                                ap_rputs(cmd->errmsg, r);
                            ap_rputs("</i></tt></dd>\n", r);
                        }
                        else {
                            break;
                        cmd++;
                    ap_rputs("<dt><strong>Current Configuration:</strong></dt>\n", r);
                    mod_info_module_cmds(r, modp->cmds, ap_conftree, 0, 0);
                }
                else {
                    ap_rputs("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>", r);
                }
                more_info = find_more_info(serv, modp->name);
                if (more_info) {
                    ap_rputs("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                          r);
                    ap_rputs(more_info, r);
                    ap_rputs("</dd>", r);
                }
                ap_rputs("</dl><hr />\n", r);
                if (r->args) {
                    break;
        }
        if (!modp && r->args && strcasecmp(r->args, "server")) {
            ap_rputs("<p><b>No such module</b></p>\n", r);
        }
    ap_rputs(ap_psignature("",r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy, 
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
static const command_rec info_cmds[] =
{
static void register_hooks(apr_pool_t *p)
module AP_MODULE_DECLARE_DATA info_module =
{
    int received_continue = 1; /* flag to indicate if we should
                                * loop over response parsing logic
                                * in the case that the origin told us
                                * to HTTP_CONTINUE
                                */
    while (received_continue) {
        if ( r->status != HTTP_CONTINUE ) {
            received_continue = 0;
        } else {
                         "proxy: HTTP: received 100 CONTINUE");
            (!ap_is_HTTP_INFO(r->status)) &&       /* not any 1xx response */
    }
            if ((status > 199) && /* not any 1xx response */
                (status != HTTP_NO_CONTENT) && /* not 204 */
    if (flag && !client_shm) {
        ap_log_error(APLOG_MARK, APLOG_WARNING, 0,
                     cmd->server, "Digest: WARNING: nonce-count checking "
                     "support - disabling check");
        flag = 0;
        if (!client_shm) {
            ap_log_error(APLOG_MARK, APLOG_WARNING, 0,
                         cmd->server, "Digest: WARNING: algorithm `MD5-sess' "
                         "is not supported on platforms without shared-memory "
                         "support - reverting to MD5");
            alg = "MD5";
        }
#include "apr_lib.h"
#include "http_log.h"
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;
 
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;
 
    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */
 
    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
            /* this is a hack to make sure that request time is set,
             * it's not perfect, but it's better than nothing
             */
            r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */
 
    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk
 
#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */
 
    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);
 
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method);
#endif
    uri = ap_getword_white(r->pool, &ll);
 
    /* Provide quick information about the request method as soon as known */
 
    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }
 
    ap_parse_uri(r, uri);
 
    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }
 
    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);
 
    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */
 
    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))    /* don't allow HTTP/0.1000 */
        r->proto_num = HTTP_VERSION(major, minor);
    else
        r->proto_num = HTTP_VERSION(1,0);
 
    return 1;
}

static int http_create_request(request_rec *r)
{
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
    int keptalive;

    hconn = apr_pcalloc(r->pool, sizeof(*hconn));
    ap_set_module_config(r->connection->conn_config, &http_module, hconn);

    if (!r->main && !r->prev && !r->next) {
        keptalive = r->connection->keepalive == 1;
        r->connection->keepalive    = 0;
 
        /* XXX can we optimize these timeouts at all? gstein */
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(keptalive
                         ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                         : r->server->timeout * APR_USEC_PER_SEC));
 
        /* Get the request... */
        if (!read_request_line(r)) {
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                              "request failed: URI too long");
                ap_send_error_response(r, 0);
                ap_run_log_transaction(r);
                return OK;
            }
            return DONE;
        }
        if (keptalive) {
            apr_setsocketopt(r->connection->client_socket,
                             APR_SO_TIMEOUT,
                             (int)(r->server->timeout * APR_USEC_PER_SEC));
        }
    }
    return OK;
}

    ap_hook_create_request(http_create_request, NULL, NULL, APR_HOOK_MIDDLE);
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
	    || (r->server->keep_alive_max > hconn->keepalives))
        int left = r->server->keep_alive_max - hconn->keepalives;
        hconn->keepalives++;
typedef struct ap_http_conn_rec ap_http_conn_rec;

struct ap_http_conn_rec {
    /** How many times have we used it? */
    int keepalives;
};

AP_DECLARE_DATA extern module http_module;

#include "mod_core.h"
    if (ap_run_create_request(r) != OK) {
        return NULL;
    }
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type("text/xml", r);
    ap_rset_content_type(apr_pstrdup(r->pool, info->content_type), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html;charset=utf-8", r);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html", r);
                    ap_rset_content_type("text/plain", r);
    ap_rset_content_type("message/http", r);
AP_DECLARE(void) ap_rset_content_type(const char *ct, request_rec *r)
        ap_rset_content_type("text/html; charset=iso-8859-1", r);
            ap_rset_content_type(apr_pstrcat(r->pool, "multipart",
                                             use_range_x(r) ? "/x-" : "/",
                                             "byteranges; boundary=",
                                             r->boundary, NULL), r);
    ap_rset_content_type(rr->content_type, r);
        ap_rset_content_type(r->content_type, new);
        ap_rset_content_type(DIR_MAGIC_TYPE, r);
                ap_rset_content_type((char*) type, r);
                ap_rset_content_type(exinfo->forced_type, r);
	    ap_rset_content_type(apr_pstrcat(r->pool, ctp->type, "/",
                                             ctp->subtype, NULL), r);
			ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                         "; charset=", charset,
                                                         NULL), r);
		    ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                     "; ", pp->attr,
                                                     "=", pp->val,
                                                     NULL), r);
		ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                 "; charset=", charset,
                                                 NULL), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type(CGI_MAGIC_TYPE, sub_req);
        ap_rset_content_type(t, r);
                ap_rset_content_type(p->forced_mimetype, r);
	    ap_rset_content_type(tmp, r);
	ap_rset_content_type(tmp, r);
	ap_rset_content_type(apr_pstrdup(r->pool, sub->content_type), r);
        ap_rset_content_type("text/html", r);
            ap_rset_content_type(ap_default_type(r), r);
                    ap_rset_content_type(apr_pstrdup(p, buf), r);
        cache_server_conf *conf =
          (cache_server_conf *)ap_get_module_config(r->server->module_config,
                                                    &cache_module);
                     "Incoming request may be asking for a uncached version of "
    if (cc_req && ap_cache_liststr(r->pool, cc_req, "max-age", &val)) {
    if (cc_req && ap_cache_liststr(r->pool, cc_req, "min-fresh", &val)) {
                site, basedir, ap_escape_html(p, path),
                site, str);
    int pasvmode = 0;
		 "proxy: FTP connecting %s to %s:%d", url, connectname, connectport);
                      "proxy: error creating socket");
		     "proxy: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
		 "proxy: socket has been created");
			     "proxy: attempt to connect to %pI (%s) failed", connect_addr, connectname);
		     "proxy: an error occurred creating a new connection to %pI (%s)", connect_addr, connectname);
		 "proxy: connection complete");
    apr_table_set(r->notes, "Directory-README", buffer);
     * Try PASV, if that fails try normally.
/* this temporarily switches off PASV */
    /* try to set up PASV data connection first */
/* IPV6 FIXME:
 * The EPSV command replaces PASV where both IPV4 and IPV6 is supported. Only
 * the port is returned, the IP address is always the same as that on the
 * control connection. Example:
 *   Entering Extended Passive Mode (|||6446|)
 */
    buf = apr_pstrcat(p, "PASV", CRLF, NULL);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                 "proxy: FTP: PASV");
    /* possible results: 227, 421, 500, 501, 502, 530 */
    /*   227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
    /*   421 Service not available, closing control connection. */
    /*   500 Syntax error, command unrecognized. */
    /*   501 Syntax error in parameters or arguments. */
    /*   502 Command not implemented. */
    /*   530 Not logged in. */
    i = ftp_getrc_msg(origin, cbb, buffer, sizeof(buffer));
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: FTP: %d %s", i, buffer);
    if (i == -1) {
	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
			     "Error reading from remote server");
    }
    if (i != 227 && i != 502) {
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
    }
    else if (i == 227) {
	unsigned int h0, h1, h2, h3, p0, p1;
	char *pstr;
/* FIXME: Check PASV against RFC1123 */
	pstr = apr_pstrdup(p, buffer);
	pstr = strtok(pstr, " ");	/* separate result code */
	if (pstr != NULL) {
	    if (*(pstr + strlen(pstr) + 1) == '=') {
	        pstr += strlen(pstr) + 2;
	        pstr = strtok(NULL, "(");  /* separate address & port params */
		if (pstr != NULL)
		    pstr = strtok(NULL, ")");
	if (pstr != NULL && (sscanf(pstr,
		 "%d,%d,%d,%d,%d,%d", &h3, &h2, &h1, &h0, &p1, &p0) == 6)) {
	    apr_sockaddr_t *pasv_addr;
	    int pasvport = (p1 << 8) + p0;
            ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                         "proxy: FTP: PASV contacting host %d.%d.%d.%d:%d",
                         h3, h2, h1, h0, pasvport);
	    if ((rv = apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
		ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
			     "proxy: error creating PASV socket");
		return HTTP_INTERNAL_SERVER_ERROR;
	    }
	    if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
		conf->recv_buffer_size))) {
				 "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
	    }
	    /* make the connection */
	    apr_sockaddr_info_get(&pasv_addr, apr_psprintf(p, "%d.%d.%d.%d", h3, h2, h1, h0), APR_INET, pasvport, 0, p);
	    rv = apr_connect(remote_sock, pasv_addr);
            if (rv != APR_SUCCESS) {
		ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
			     "proxy: FTP: PASV error creating socket");
		return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_psprintf(r->pool,
				     "PASV attempt to connect to %pI failed - firewall/NAT?", pasv_addr));
            }
		pasvmode = 1;
	else
	    /* and try the regular way */
	    apr_socket_close(remote_sock);
    /* set up data connection */
    if (!pasvmode) {
	    return ap_proxyerror(r, HTTP_NOT_IMPLEMENTED, "Connect to IPV6 ftp server not supported");
    if (!pasvmode) {
    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                  "proxy: FTP: ready to suck data");

     * - white space around the '='
                value += strspn(value, " \t");  /* Move past WS */
    note = apr_pstrcat(r->pool, MOD_SESSION_COOKIE, name, NULL);
    zz = (session_rec *) apr_pcalloc(r->pool, sizeof(session_rec));
    zz->pool = r->pool;
    zz->entries = apr_table_make(r->pool, 10);
    zz->uuid = (apr_uuid_t *) apr_pcalloc(r->pool, sizeof(apr_uuid_t));
    imap_conf_rec *new = (imap_conf_rec *) apr_pcalloc(p, sizeof(imap_conf_rec));
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted") && *comment) {
    if (!strcasecmp(menu, "unformatted") && *comment) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
        if (ap_proxy_isvalidenc(url, NULL) != APR_SUCCESS) {
            return HTTP_BAD_REQUEST;
        }
                    ((cert = SSL_get_peer_certificate(ssl)) != NULL))
                    X509_free(cert);
            if (do_verify &&
                ((cert = SSL_get_peer_certificate(ssl)) == NULL)) {
                ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                             "Re-negotiation handshake failed: "
                             "Client certificate missing");
                return HTTP_FORBIDDEN;
#include "apr_lib.h"
#include "http_log.h"
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;
 
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;
 
    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */
 
    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
            /* this is a hack to make sure that request time is set,
             * it's not perfect, but it's better than nothing
             */
            r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */
 
    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk
 
#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */
 
    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);
 
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method);
#endif
    uri = ap_getword_white(r->pool, &ll);
 
    /* Provide quick information about the request method as soon as known */
 
    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }
 
    ap_parse_uri(r, uri);
 
    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }
 
    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);
 
    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */
 
    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))    /* don't allow HTTP/0.1000 */
        r->proto_num = HTTP_VERSION(major, minor);
    else
        r->proto_num = HTTP_VERSION(1,0);
 
    return 1;
}

static int http_create_request(request_rec *r)
{
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
    int keptalive;

    hconn = apr_pcalloc(r->pool, sizeof(*hconn));
    ap_set_module_config(r->connection->conn_config, &http_module, hconn);

    if (!r->main && !r->prev && !r->next) {
        keptalive = r->connection->keepalive == 1;
        r->connection->keepalive    = 0;
 
        /* XXX can we optimize these timeouts at all? gstein */
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(keptalive
                         ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                         : r->server->timeout * APR_USEC_PER_SEC));
 
        /* Get the request... */
        if (!read_request_line(r)) {
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                              "request failed: URI too long");
                ap_send_error_response(r, 0);
                ap_run_log_transaction(r);
                return OK;
            }
            return DONE;
        }
        if (keptalive) {
            apr_setsocketopt(r->connection->client_socket,
                             APR_SO_TIMEOUT,
                             (int)(r->server->timeout * APR_USEC_PER_SEC));
        }
    }
    return OK;
}

    ap_hook_create_request(http_create_request, NULL, NULL, APR_HOOK_MIDDLE);
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
	    || (r->server->keep_alive_max > hconn->keepalives))
        int left = r->server->keep_alive_max - hconn->keepalives;
        hconn->keepalives++;
typedef struct ap_http_conn_rec ap_http_conn_rec;

struct ap_http_conn_rec {
    /** How many times have we used it? */
    int keepalives;
};

AP_DECLARE_DATA extern module http_module;

#include "mod_core.h"
    if (ap_run_create_request(r) != OK) {
        return NULL;
    }
AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char *segment)
    char *copy = apr_palloc(p, 3 * strlen(segment) + 1);
            if (r->status == HTTP_BAD_REQUEST) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                              "request failed: invalid characters in URI");
            }
            else {
                                    (REG_EXTENDED | REG_NOSUB
                                     | (icase ? REG_ICASE : 0)));
            (!b->pattern && !ap_regexec(b->preg, val, 0, NULL, 0))) {
                    apr_table_setn(r->subprocess_env, elts[j].key, elts[j].val);
    bio_filter_out_ctx_t *b = (bio_filter_out_ctx_t *)(bio->ptr);
    if (!b->length && (inl + b->blen < sizeof(b->buffer))) {
        memcpy(&b->buffer[b->blen], in, inl);
        b->blen += inl;
                                                         b->bb->bucket_alloc);
        b->length += inl;
        APR_BRIGADE_INSERT_TAIL(b->bb, bucket);
    bio_filter_out_ctx_t *b = (bio_filter_out_ctx_t *)(bio->ptr);
        b->blen = b->length = 0;
        ret = (long)((b->blen + b->length) == 0);
        b->blen = b->length = (apr_size_t)num;
        ret = (long)(b->blen + b->length);
            *pptr = (char *)&(b->buffer[0]);
        ret = (long)(b->blen + b->length);
    bio_filter_in_ctx_t *ctx = (bio_filter_in_ctx_t *)(bio->ptr);
    apr_read_type_e block = ctx->block;
    SSLConnRec *sslconn = myConnConfig(ctx->f->c);
    ctx->rc = APR_SUCCESS;
    if ((SSL_version(ctx->ssl) == SSL2_VERSION) || sslconn->is_proxy) {
        bio_filter_out_flush(ctx->wbio);
    if (!ctx->bb) {
        ctx->rc = APR_EOF;
    if (APR_BRIGADE_EMPTY(ctx->bb)) {
        ctx->rc = ap_get_brigade(ctx->f->next, ctx->bb,
        if (APR_STATUS_IS_EAGAIN(ctx->rc) || APR_STATUS_IS_EINTR(ctx->rc)
               || (ctx->rc == APR_SUCCESS && APR_BRIGADE_EMPTY(ctx->bb))) {
        if (ctx->rc != APR_SUCCESS) {
            apr_brigade_cleanup(ctx->bb);
            ctx->bb = NULL;
    ctx->rc = brigade_consume(ctx->bb, block, in, &inl);
    if (ctx->rc == APR_SUCCESS) {
    if (APR_STATUS_IS_EAGAIN(ctx->rc) 
            || APR_STATUS_IS_EINTR(ctx->rc)) {
    apr_brigade_cleanup(ctx->bb);
    ctx->bb = NULL;
    if (APR_STATUS_IS_EOF(ctx->rc) && inl) {
    SSLFilterRec *ctx = f->ctx;
    n = ssl_io_hook_write(ctx->pssl, (unsigned char *)data, len);
        if (SSL_total_renegotiations(ctx->pssl)) {
    SSLFilterRec *ctx = f->ctx;
    if (!ctx->pssl) {
    if ((status = ssl_hook_process_connection(ctx)) != APR_SUCCESS) {
            if ((status = bio_filter_out_flush(ctx->pbioWrite)) != APR_SUCCESS) {
static apr_status_t ssl_io_input_read(bio_filter_in_ctx_t *ctx,
    if ((bytes = char_buffer_read(&ctx->cbuf, buf, wanted))) {
        if (ctx->mode == AP_MODE_SPECULATIVE) {
            ctx->cbuf.value -= bytes;
            ctx->cbuf.length += bytes;
        if ((*len >= wanted) || ctx->mode == AP_MODE_GETLINE) {
        rc = SSL_read(ctx->frec->pssl, buf + bytes, wanted - bytes);
            if (ctx->mode == AP_MODE_SPECULATIVE) {
                char_buffer_write(&ctx->cbuf, buf, rc);
            return ctx->rc;
            if (APR_STATUS_IS_EAGAIN(ctx->rc)
                    || APR_STATUS_IS_EINTR(ctx->rc)) {
                if (ctx->block == APR_NONBLOCK_READ) {
                ctx->rc = APR_EOF;
            int ssl_err = SSL_get_error(ctx->frec->pssl, rc);
                if (ctx->block == APR_NONBLOCK_READ) {
                    ctx->rc = APR_EAGAIN;
                conn_rec *c = (conn_rec *)SSL_get_app_data(ctx->frec->pssl);
                ap_log_error(APLOG_MARK, APLOG_ERR, ctx->rc, c->base_server,
                conn_rec *c = (conn_rec *)SSL_get_app_data(ctx->frec->pssl);
                ap_log_error(APLOG_MARK, APLOG_ERR, ctx->rc, c->base_server,
                if (ctx->rc == APR_SUCCESS) {
                    ctx->rc = APR_EGENERAL;
    return ctx->rc;
static apr_status_t ssl_io_input_getline(bio_filter_in_ctx_t *ctx,
        status = ssl_io_input_read(ctx, buf + offset, &tmplen);
        char_buffer_write(&ctx->cbuf, value, length);
    bio_filter_in_ctx_t *ctx = f->ctx;
    ctx->ssl = NULL;
    ctx->frec->pssl = NULL;
    bio_filter_in_ctx_t *ctx = f->ctx;
    apr_size_t len = sizeof(ctx->buffer);
    if (!ctx->ssl) {
    ctx->mode = mode;
    ctx->block = block;
    status = ssl_hook_process_connection(ctx->frec);
    if (ctx->mode == AP_MODE_READBYTES || 
        ctx->mode == AP_MODE_SPECULATIVE) {
        status = ssl_io_input_read(ctx, ctx->buffer, &len);
    else if (ctx->mode == AP_MODE_GETLINE) {
        status = ssl_io_input_getline(ctx, ctx->buffer, &len);
            apr_bucket_transient_create(ctx->buffer, len, f->c->bucket_alloc);
    bio_filter_in_ctx_t *ctx;
    ctx = apr_palloc(c->pool, sizeof(*ctx));
    frec->pInputFilter = ap_add_input_filter(ssl_io_filter, ctx, NULL, c);
    frec->pbioRead->ptr = (void *)ctx;
    ctx->frec = frec;
    ctx->ssl = ssl;
    ctx->wbio = frec->pbioWrite;
    ctx->f = frec->pInputFilter;
    ctx->bb = apr_brigade_create(c->pool, c->bucket_alloc);
    ctx->cbuf.length = 0;
    ctx->pool = c->pool;
    dav_dir_conf *conf = ap_get_module_config(r->per_dir_config, &dav_module);

    /* if DAV is not enabled, then we've got nothing to do */
    if (conf->provider == NULL) {
    }

    if (r->method_number == M_GET) {
        /*
         * ### need some work to pull Content-Type and Content-Language
         * ### from the property database.
         */

        /*
         * If the repository hasn't indicated that it will handle the
         * GET method, then just punt.
         *
         * ### this isn't quite right... taking over the response can break
         * ### things like mod_negotiation. need to look into this some more.
         */
        if (!conf->provider->repos->handle_get) {
            return DECLINED;
        }
    }
    /* quickly ignore any HTTP/0.9 requests which aren't subreqs. */
    if (r->assbackwards && !r->main) {
        return DECLINED;
    }

    char         *re_string;
    regmatch_t   (*re_result)[10];
        if (!ctx->intern->re_result || !ctx->intern->re_string) {
            int idx = atoi(var);
            apr_size_t len = (*ctx->intern->re_result)[idx].rm_eo
                           - (*ctx->intern->re_result)[idx].rm_so;
            if (    (*ctx->intern->re_result)[idx].rm_so < 0
                 || (*ctx->intern->re_result)[idx].rm_eo < 0) {
            val = apr_pstrmemdup(ctx->dpool, ctx->intern->re_string
                                 + (*ctx->intern->re_result)[idx].rm_so, len);
        val = apr_table_get(ctx->intern->r->subprocess_env, var);
        if (val == LAZY_VALUE)
            val = add_include_vars_lazy(ctx->intern->r, var);
static int re_check(request_rec *r, include_ctx_t *ctx, 
                    char *string, char *rexp)
    const apr_size_t nres = sizeof(*ctx->intern->re_result) / sizeof(regmatch_t);
    int regex_error;
    compiled = ap_pregcomp(r->pool, rexp, REG_EXTENDED | REG_NOSUB);
    if (compiled == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "unable to compile pattern \"%s\"", rexp);
    if (!ctx->intern->re_result) {
        ctx->intern->re_result = apr_pcalloc(r->pool, sizeof(*ctx->intern->re_result));
    ctx->intern->re_string = string;
    regex_error = ap_regexec(compiled, string, nres, *ctx->intern->re_result, 0);
    ap_pregfree(r->pool, compiled);
    return (!regex_error);
                    re_check(r, ctx, current->left->token.value,
        intern->re_string = NULL;
#define MODULE_MAGIC_NUMBER_MAJOR 20111203
#define MODULE_MAGIC_NUMBER_MINOR 1                   /* 0...n */
typedef unsigned char overrides_t;
    if ((parms->override & cmd->req_override) == 0 && !override_list_ok)
        return apr_pstrcat(parms->pool, cmd->name, " not allowed here", NULL);
        return apr_pstrcat(parms->pool, "Invalid command '",
                           current->directive,
                           "', perhaps misspelled or defined by a module "
                           "not included in the server configuration",
                           NULL);
    if (apr_table_get(r->subprocess_env, "force-proxy-request-1.0")
         || ((r->proto_num < HTTP_VERSION(1,1)) 
             && !apr_table_get(r->subprocess_env, "force-proxy-request-1.1"))) {
        p_conn->close++;
    r->content_type = "text/html";
    r->content_type = DAV_XML_CONTENT_TYPE;
    r->content_type = DAV_XML_CONTENT_TYPE;
    r->content_type = DAV_XML_CONTENT_TYPE;
    r->content_type = DAV_XML_CONTENT_TYPE;
    r->content_type = DAV_XML_CONTENT_TYPE;
    r->content_type = "text/xml";
    r->content_type = apr_pstrdup(r->pool, info->content_type);
    r->content_type = "text/html";
            r->content_type = "text/html";
    r->content_type = "text/html;charset=utf-8";
    r->content_type = "text/html";
    rr->content_type = CGI_MAGIC_TYPE;

    rr->content_type = CGI_MAGIC_TYPE;
    r->content_type = "text/html";
    r->content_type = "text/html";
                    r->content_type = "text/plain";
    r->content_type = "message/http";
        r->content_type = "text/html; charset=iso-8859-1";
            r->content_type = apr_pstrcat(r->pool, "multipart",
                                          use_range_x(r) ? "/x-" : "/",
                                          "byteranges; boundary=",
                                          r->boundary, NULL);
    r->content_type = rr->content_type;
        new->content_type = r->content_type;

        r->content_type = DIR_MAGIC_TYPE;
                r->content_type = type;
                r->content_type = exinfo->forced_type;
	    r->content_type = apr_pstrcat(r->pool, ctp->type, "/",
					 ctp->subtype, NULL);
			r->content_type = apr_pstrcat(r->pool, r->content_type,
						     "; charset=", charset,
						     NULL);
		    r->content_type = apr_pstrcat(r->pool, r->content_type,
						 "; ", pp->attr,
						 "=", pp->val,
						 NULL);
		r->content_type = apr_pstrcat(r->pool, r->content_type,
					     "; charset=", charset,
					     NULL);
    r->content_type = "text/html";
            sub_req->content_type = CGI_MAGIC_TYPE;
        r->content_type = t;
                r->content_type = p->forced_mimetype;
	    r->content_type = tmp;
	r->content_type = tmp;
	r->content_type = apr_pstrdup(r->pool, sub->content_type);
        r->content_type = "text/html";
            r->content_type = ap_default_type(r);
                    r->content_type = apr_pstrdup(p, buf);
static const char * const lwday[7] =
{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

 * is converted to the RFC 1123 format, otherwise it is not modified.
 * This routine is not very fast at doing conversions, as it uses
 * sscanf and sprintf. However, if the date is already correctly
 * formatted, then it exits very quickly.
     ap_proxy_date_canon(apr_pool_t *p, const char *x1)
    char *x = apr_pstrdup(p, x1);
    int wk, mday, year, hour, min, sec, mon;
    char *q, month[4], zone[4], week[4];

    q = strchr(x, ',');
    /* check for RFC 850 date */
    if (q != NULL && q - x > 3 && q[1] == ' ') {
        *q = '\0';
        for (wk = 0; wk < 7; wk++) {
            if (strcmp(x, lwday[wk]) == 0) {
                break;
            }
        }
        *q = ',';
        if (wk == 7) {
            return x;       /* not a valid date */
        }
        if (q[4] != '-' || q[8] != '-' || q[11] != ' ' || q[14] != ':' ||
            q[17] != ':' || strcmp(&q[20], " GMT") != 0) {
            return x;
        }
        if (sscanf(q + 2, "%u-%3s-%u %u:%u:%u %3s", &mday, month, &year,
               &hour, &min, &sec, zone) != 7) {
            return x;
        }
        if (year < 70) {
            year += 2000;
        }
        else {
            year += 1900;
        }
    }
    else {
/* check for acstime() date */
        if (x[3] != ' ' || x[7] != ' ' || x[10] != ' ' || x[13] != ':' ||
            x[16] != ':' || x[19] != ' ' || x[24] != '\0') {
            return x;
        }
        if (sscanf(x, "%3s %3s %u %u:%u:%u %u", week, month, &mday, &hour,
                   &min, &sec, &year) != 7) {
            return x;
        }
        for (wk = 0; wk < 7; wk++) {
            if (strcmp(week, apr_day_snames[wk]) == 0) {
                break;
            }
        }
        if (wk == 7) {
            return x;
        }
/* check date */
    for (mon = 0; mon < 12; mon++) {
        if (strcmp(month, apr_month_snames[mon]) == 0) {
            break;
        }
    if (mon == 12) {
        return x;
    q = apr_palloc(p, 30);
    apr_snprintf(q, 30, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", apr_day_snames[wk],
                 mday, apr_month_snames[mon], year, hour, min, sec);
    return q;
    rnew->headers_in      = r->headers_in;
 * created at config time in the parent are valid across children.  For
 * example, the vhostrec pointer in the scoreboard below is valid in all
 * children of the same generation.
 *
 * The safe way to access the vhost pointer is like this:
 *
 * worker_score *ss = pointer to whichver slot is interesting;
 * process_score *ps = pointer to whichver slot is interesting;
 * server_rec *vh = ss->vhostrec;
 *
 * if (ps->generation != ap_my_generation) {
 *     vh = NULL;
 * }
 *
 * then if vh is not NULL it's valid in this child.
 *
 * This avoids various race conditions around restarts.
    SB_SHARED = 1,
    SB_NOT_SHARED = 2
    server_rec *vhostrec;	/* What virtual host is being accessed? */
                                /* SEE ABOVE FOR SAFE USAGE! */
    worker_score *next;
    global_score global;
#define KEY_LENGTH 16
#define VALUE_LENGTH 64
typedef struct {
    char key[KEY_LENGTH];
    char value[VALUE_LENGTH];
} status_table_entry;
AP_DECLARE_NONSTD(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e t);
AP_DECLARE(void) ap_increment_counts(void *sbh, request_rec *r);
void ap_init_scoreboard(void);

AP_DECLARE(void) reopen_scoreboard(apr_pool_t *p);

AP_DECLARE(void) ap_create_sb_handle(void **new_handle, apr_pool_t *p,
AP_DECLARE(int) ap_update_child_status(void *sbh, int status, request_rec *r);
AP_DECLARE(worker_score *) ap_get_servers_scoreboard(int x, int y);
AP_DECLARE(process_score *) ap_get_parent_scoreboard(int x);
AP_DECLARE(global_score *) ap_get_global_scoreboard(void);
/* Disable shmem until pools/init gets sorted out - remove next line when fixed */
#define APR_HAS_SHARED_MEMORY 0

#if APR_HAS_SHARED_MEMORY
#include "apr_shmem.h"
#else
/* just provide dummies - the code does run-time checks anyway */
typedef   void apr_shmem_t;
typedef   void apr_shm_name_t;

/*
static apr_status_t apr_shm_init(apr_shmem_t **m, apr_size_t reqsize, const char *file, apr_pool_t *cont) {
    return APR_ENOTIMPL;
}
*/
static apr_status_t apr_shm_destroy(apr_shmem_t *m) {
    return APR_ENOTIMPL;
}
static void *apr_shm_malloc(apr_shmem_t *c, apr_size_t reqsize) {
    return NULL;
}
/*
static void *apr_shm_calloc(apr_shmem_t *shared, apr_size_t size) {
    return NULL;
}
*/
static apr_status_t apr_shm_free(apr_shmem_t *shared, void *free) {
    return APR_ENOTIMPL;
}
/*
static apr_status_t apr_shm_name_get(apr_shmem_t *c, apr_shm_name_t **name) {
    return APR_ENOTIMPL;
}
static apr_status_t apr_shm_name_set(apr_shmem_t *c, apr_shm_name_t *name) {
    return APR_ENOTIMPL;
}
static apr_status_t apr_shm_open(apr_shmem_t *c) {
    return APR_ENOTIMPL;
}
static apr_status_t apr_shm_avail(apr_shmem_t *c, apr_size_t *avail) {
    return APR_ENOTIMPL;
}
*/
#endif /* ndef APR_HAS_SHARED_MEMORY */

static apr_shmem_t    *client_shm = NULL;
static unsigned long *opaque_cntr;
    ap_log_rerror(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
    sts = apr_shm_init(&client_shm, shmem_size, tmpnam(NULL), ctx);
    client_list = apr_shm_malloc(client_shm, sizeof(*client_list) +
    opaque_cntr = apr_shm_malloc(client_shm, sizeof(*opaque_cntr));
    otn_counter = apr_shm_malloc(client_shm, sizeof(*otn_counter));
            apr_shm_free(client_shm, entry);
    entry = apr_shm_malloc(client_shm, sizeof(client_entry));
        entry = apr_shm_malloc(client_shm, sizeof(client_entry));
    server_rec *vhost;
	    vhost = ws_record.vhostrec;
	    if (ps_record.generation != ap_my_generation) {
		vhost = NULL;
	    }

			    vhost ? ap_escape_html(r->pool, 
				vhost->server_hostname) : "(unavailable)");
			     vhost ? ap_escape_html(r->pool, 
				vhost->server_hostname) : "(unavailable)",
                    n = ssl_rand_choosenum(0, sizeof(scoreboard)-1024-1);
#ifndef lint
static char const 
ssl_expr_yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
#endif
#include <stdlib.h>
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYLEX ssl_expr_yylex()
#define YYEMPTY -1
#define ssl_expr_yyclearin (ssl_expr_yychar=(YYEMPTY))
#define ssl_expr_yyerrok (ssl_expr_yyerrflag=0)
#define YYRECOVERING() (ssl_expr_yyerrflag!=0)
static int ssl_expr_yygrowstack();
#define YYPREFIX "ssl_expr_yy"
#line 69 "ssl_expr_parse.y"
#line 24 "y.tab.c"
#define YYERRCODE 256
#define T_TRUE 257
#define T_FALSE 258
#define T_DIGIT 259
#define T_ID 260
#define T_STRING 261
#define T_REGEX 262
#define T_REGEX_I 263
#define T_FUNC_FILE 264
#define T_OP_EQ 265
#define T_OP_NE 266
#define T_OP_LT 267
#define T_OP_LE 268
#define T_OP_GT 269
#define T_OP_GE 270
#define T_OP_REG 271
#define T_OP_NRE 272
#define T_OP_IN 273
#define T_OP_OR 274
#define T_OP_AND 275
#define T_OP_NOT 276
const short ssl_expr_yylhs[] = {                                        -1,
    0,    1,    1,    1,    1,    1,    1,    1,    2,    2,
    2,    2,    2,    2,    2,    2,    2,    5,    5,    6,
    6,    6,    6,    4,    4,    3,
const short ssl_expr_yylen[] = {                                         2,
    1,    1,    1,    2,    3,    3,    1,    3,    3,    3,
    3,    3,    3,    3,    5,    3,    3,    1,    3,    1,
    1,    4,    1,    1,    1,    4,
const short ssl_expr_yydefred[] = {                                      0,
    2,    3,   20,   21,    0,    0,    0,    0,    0,    0,
    7,   23,    0,    0,    4,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    8,
    0,    0,    6,    9,   10,   11,   12,   13,   14,   24,
   25,   16,   17,    0,   26,   22,    0,   18,   15,    0,
   19,
const short ssl_expr_yydgoto[] = {                                       9,
   10,   11,   12,   42,   47,   13,
const short ssl_expr_yysindex[] = {                                    -37,
    0,    0,    0,    0,  -35,  -37,  -37,  -99,    0, -247,
    0,    0, -250, -229,    0,  -39, -227,  -37,  -37,  -33,
  -33,  -33,  -33,  -33,  -33, -233, -233,  -89,   -6,    0,
  -87, -239,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  -33,    0,    0,  -38,    0,    0,  -33,
    0,
const short ssl_expr_yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   39,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    1,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,
const short ssl_expr_yygindex[] = {                                      0,
    7,    0,    0,   13,    0,  -13,
#define YYTABLESIZE 275
const short ssl_expr_yytable[] = {                                       8,
    5,   30,    7,    8,   14,   50,   34,   35,   36,   37,
   38,   39,   15,   16,   20,   21,   22,   23,   24,   25,
   26,   27,   28,   17,   32,   33,   18,   19,   40,   41,
   48,   29,   31,   44,   45,   19,   51,   46,    1,   43,
    0,    5,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   49,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
    2,    3,    0,    4,    0,    3,    5,    4,    0,    0,
    5,    0,    0,    0,   18,   19,    0,    0,    6,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    5,
const short ssl_expr_yycheck[] = {                                      37,
    0,   41,   40,   37,   40,   44,   20,   21,   22,   23,
   24,   25,    6,    7,  265,  266,  267,  268,  269,  270,
  271,  272,  273,  123,   18,   19,  274,  275,  262,  263,
   44,  261,  260,  123,   41,  275,   50,  125,    0,   27,
   -1,   41,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  125,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
  258,  259,   -1,  261,   -1,  259,  264,  261,   -1,   -1,
  264,   -1,   -1,   -1,  274,  275,   -1,   -1,  276,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  274,
#define YYFINAL 9
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 276
#if YYDEBUG
const char * const ssl_expr_yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,"'%'",0,0,"'('","')'",0,0,"','",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"T_TRUE",
"T_FALSE","T_DIGIT","T_ID","T_STRING","T_REGEX","T_REGEX_I","T_FUNC_FILE",
"T_OP_EQ","T_OP_NE","T_OP_LT","T_OP_LE","T_OP_GT","T_OP_GE","T_OP_REG",
"T_OP_NRE","T_OP_IN","T_OP_OR","T_OP_AND","T_OP_NOT",
const char * const ssl_expr_yyrule[] = {
"$accept : root",
"root : expr",
"expr : T_TRUE",
"expr : T_FALSE",
"expr : T_OP_NOT expr",
"expr : expr T_OP_OR expr",
"expr : expr T_OP_AND expr",
"expr : comparison",
"expr : '(' expr ')'",
"comparison : word T_OP_EQ word",
"comparison : word T_OP_NE word",
"comparison : word T_OP_LT word",
"comparison : word T_OP_LE word",
"comparison : word T_OP_GT word",
"comparison : word T_OP_GE word",
"comparison : word T_OP_IN '{' words '}'",
"comparison : word T_OP_REG regex",
"comparison : word T_OP_NRE regex",
"words : word",
"words : words ',' word",
"word : T_DIGIT",
"word : T_STRING",
"word : '%' '{' T_ID '}'",
"word : funccall",
"regex : T_REGEX",
"regex : T_REGEX_I",
"funccall : T_FUNC_FILE '(' T_STRING ')'",
#if YYDEBUG
#include <stdio.h>
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#define YYSTACKSIZE 10000
#define YYMAXDEPTH 10000
#define YYINITSTACKSIZE 200
int ssl_expr_yydebug;
int ssl_expr_yynerrs;
int ssl_expr_yyerrflag;
int ssl_expr_yychar;
short *ssl_expr_yyssp;
YYSTYPE *ssl_expr_yyvsp;
YYSTYPE ssl_expr_yyval;
YYSTYPE ssl_expr_yylval;
short *ssl_expr_yyss;
short *ssl_expr_yysslim;
YYSTYPE *ssl_expr_yyvs;
int ssl_expr_yystacksize;
#line 177 "ssl_expr_parse.y"
int ssl_expr_yyerror(char *s)
    ssl_expr_error = s;
    return 2;
#line 230 "y.tab.c"
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int ssl_expr_yygrowstack()
    int newsize, i;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = ssl_expr_yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;
    i = ssl_expr_yyssp - ssl_expr_yyss;
    newss = ssl_expr_yyss ? (short *)realloc(ssl_expr_yyss, newsize * sizeof *newss) :
      (short *)malloc(newsize * sizeof *newss);
    if (newss == NULL)
        return -1;
    ssl_expr_yyss = newss;
    ssl_expr_yyssp = newss + i;
    newvs = ssl_expr_yyvs ? (YYSTYPE *)realloc(ssl_expr_yyvs, newsize * sizeof *newvs) :
      (YYSTYPE *)malloc(newsize * sizeof *newvs);
    if (newvs == NULL)
        return -1;
    ssl_expr_yyvs = newvs;
    ssl_expr_yyvsp = newvs + i;
    ssl_expr_yystacksize = newsize;
    ssl_expr_yysslim = ssl_expr_yyss + newsize - 1;
    return 0;
#define YYABORT goto ssl_expr_yyabort
#define YYREJECT goto ssl_expr_yyabort
#define YYACCEPT goto ssl_expr_yyaccept
#define YYERROR goto ssl_expr_yyerrlab
#ifndef YYPARSE_PARAM
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG void
#else	/* ! ANSI-C/C++ */
#endif	/* ANSI-C/C++ */
#else	/* YYPARSE_PARAM */
#ifndef YYPARSE_PARAM_TYPE
#define YYPARSE_PARAM_TYPE void *
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
#endif	/* ANSI-C/C++ */
#endif	/* ! YYPARSE_PARAM */
ssl_expr_yyparse (YYPARSE_PARAM_ARG)
    YYPARSE_PARAM_DECL
    register int ssl_expr_yym, ssl_expr_yyn, ssl_expr_yystate;
#if YYDEBUG
    register const char *ssl_expr_yys;
    if ((ssl_expr_yys = getenv("YYDEBUG")))
        ssl_expr_yyn = *ssl_expr_yys;
        if (ssl_expr_yyn >= '0' && ssl_expr_yyn <= '9')
            ssl_expr_yydebug = ssl_expr_yyn - '0';
    ssl_expr_yynerrs = 0;
    ssl_expr_yyerrflag = 0;
    ssl_expr_yychar = (-1);
    if (ssl_expr_yyss == NULL && ssl_expr_yygrowstack()) goto ssl_expr_yyoverflow;
    ssl_expr_yyssp = ssl_expr_yyss;
    ssl_expr_yyvsp = ssl_expr_yyvs;
    *ssl_expr_yyssp = ssl_expr_yystate = 0;
ssl_expr_yyloop:
    if ((ssl_expr_yyn = ssl_expr_yydefred[ssl_expr_yystate])) goto ssl_expr_yyreduce;
    if (ssl_expr_yychar < 0)
        if ((ssl_expr_yychar = ssl_expr_yylex()) < 0) ssl_expr_yychar = 0;
#if YYDEBUG
        if (ssl_expr_yydebug)
        {
            ssl_expr_yys = 0;
            if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
            if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, ssl_expr_yystate, ssl_expr_yychar, ssl_expr_yys);
        }
    if ((ssl_expr_yyn = ssl_expr_yysindex[ssl_expr_yystate]) && (ssl_expr_yyn += ssl_expr_yychar) >= 0 &&
            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yychar)
#if YYDEBUG
        if (ssl_expr_yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, ssl_expr_yystate, ssl_expr_yytable[ssl_expr_yyn]);
#endif
        if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
        {
            goto ssl_expr_yyoverflow;
        }
        *++ssl_expr_yyssp = ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
        *++ssl_expr_yyvsp = ssl_expr_yylval;
        ssl_expr_yychar = (-1);
        if (ssl_expr_yyerrflag > 0)  --ssl_expr_yyerrflag;
        goto ssl_expr_yyloop;
    if ((ssl_expr_yyn = ssl_expr_yyrindex[ssl_expr_yystate]) && (ssl_expr_yyn += ssl_expr_yychar) >= 0 &&
            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yychar)
        ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];
        goto ssl_expr_yyreduce;
    }
    if (ssl_expr_yyerrflag) goto ssl_expr_yyinrecovery;
#if defined(lint) || defined(__GNUC__)
    goto ssl_expr_yynewerror;
ssl_expr_yynewerror:
    ssl_expr_yyerror("syntax error");
#if defined(lint) || defined(__GNUC__)
    goto ssl_expr_yyerrlab;
ssl_expr_yyerrlab:
    ++ssl_expr_yynerrs;
ssl_expr_yyinrecovery:
    if (ssl_expr_yyerrflag < 3)
    {
        ssl_expr_yyerrflag = 3;
        for (;;)
        {
            if ((ssl_expr_yyn = ssl_expr_yysindex[*ssl_expr_yyssp]) && (ssl_expr_yyn += YYERRCODE) >= 0 &&
                    ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (ssl_expr_yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *ssl_expr_yyssp, ssl_expr_yytable[ssl_expr_yyn]);
#endif
                if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
                {
                    goto ssl_expr_yyoverflow;
                }
                *++ssl_expr_yyssp = ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
                *++ssl_expr_yyvsp = ssl_expr_yylval;
                goto ssl_expr_yyloop;
            }
            else
            {
#if YYDEBUG
                if (ssl_expr_yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *ssl_expr_yyssp);
#endif
                if (ssl_expr_yyssp <= ssl_expr_yyss) goto ssl_expr_yyabort;
                --ssl_expr_yyssp;
                --ssl_expr_yyvsp;
            }
        }
    else
        if (ssl_expr_yychar == 0) goto ssl_expr_yyabort;
#if YYDEBUG
        if (ssl_expr_yydebug)
        {
            ssl_expr_yys = 0;
            if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
            if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, ssl_expr_yystate, ssl_expr_yychar, ssl_expr_yys);
        }
#endif
        ssl_expr_yychar = (-1);
        goto ssl_expr_yyloop;
#if YYDEBUG
    if (ssl_expr_yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, ssl_expr_yystate, ssl_expr_yyn, ssl_expr_yyrule[ssl_expr_yyn]);
#endif
    ssl_expr_yym = ssl_expr_yylen[ssl_expr_yyn];
    ssl_expr_yyval = ssl_expr_yyvsp[1-ssl_expr_yym];
    switch (ssl_expr_yyn)
{ ssl_expr_info.expr = ssl_expr_yyvsp[0].exVal; }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_True,  NULL, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_False, NULL, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Not,   ssl_expr_yyvsp[0].exVal,   NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Or,    ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_And,   ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Comp,  ssl_expr_yyvsp[0].exVal,   NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[-1].exVal; }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_EQ,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_IN,  ssl_expr_yyvsp[-4].exVal, ssl_expr_yyvsp[-1].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_REG, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NRE, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, ssl_expr_yyvsp[-2].exVal);   }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Digit,  ssl_expr_yyvsp[0].cpVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_String, ssl_expr_yyvsp[0].cpVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Var,    ssl_expr_yyvsp[-1].cpVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[0].exVal; }
break;
            }
break;
            }
break;
            }
break;
#line 550 "y.tab.c"
    ssl_expr_yyssp -= ssl_expr_yym;
    ssl_expr_yystate = *ssl_expr_yyssp;
    ssl_expr_yyvsp -= ssl_expr_yym;
    ssl_expr_yym = ssl_expr_yylhs[ssl_expr_yyn];
    if (ssl_expr_yystate == 0 && ssl_expr_yym == 0)
#if YYDEBUG
        if (ssl_expr_yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        ssl_expr_yystate = YYFINAL;
        *++ssl_expr_yyssp = YYFINAL;
        *++ssl_expr_yyvsp = ssl_expr_yyval;
        if (ssl_expr_yychar < 0)
        {
            if ((ssl_expr_yychar = ssl_expr_yylex()) < 0) ssl_expr_yychar = 0;
#if YYDEBUG
            if (ssl_expr_yydebug)
            {
                ssl_expr_yys = 0;
                if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
                if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, ssl_expr_yychar, ssl_expr_yys);
            }
#endif
        }
        if (ssl_expr_yychar == 0) goto ssl_expr_yyaccept;
        goto ssl_expr_yyloop;
    if ((ssl_expr_yyn = ssl_expr_yygindex[ssl_expr_yym]) && (ssl_expr_yyn += ssl_expr_yystate) >= 0 &&
            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yystate)
        ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
    else
        ssl_expr_yystate = ssl_expr_yydgoto[ssl_expr_yym];
#if YYDEBUG
    if (ssl_expr_yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *ssl_expr_yyssp, ssl_expr_yystate);
#endif
    if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
        goto ssl_expr_yyoverflow;
    *++ssl_expr_yyssp = ssl_expr_yystate;
    *++ssl_expr_yyvsp = ssl_expr_yyval;
    goto ssl_expr_yyloop;
ssl_expr_yyoverflow:
    ssl_expr_yyerror("yacc stack overflow");
ssl_expr_yyabort:
    return (1);
ssl_expr_yyaccept:
    return (0);
#ifndef YYERRCODE
#define YYERRCODE 256
#endif

#define T_TRUE 257
#define T_FALSE 258
#define T_DIGIT 259
#define T_ID 260
#define T_STRING 261
#define T_REGEX 262
#define T_REGEX_I 263
#define T_FUNC_FILE 264
#define T_OP_EQ 265
#define T_OP_NE 266
#define T_OP_LT 267
#define T_OP_LE 268
#define T_OP_GT 269
#define T_OP_GE 270
#define T_OP_REG 271
#define T_OP_NRE 272
#define T_OP_IN 273
#define T_OP_OR 274
#define T_OP_AND 275
#define T_OP_NOT 276
    void *sbh;
    void *sbh;
        ap_scoreboard_image->global.running_generation = ap_my_generation;
        rc = DosAllocSharedMem((PPVOID)&ap_scoreboard_image, ap_scoreboard_fname,
        ap_init_scoreboard();
    } while (!shutdown_pending && ap_my_generation == ap_scoreboard_image->global.running_generation);
    void *sbh;
    void *sbh;
        ap_scoreboard_image->global.running_generation = ap_my_generation;
    void *sbh;
    void *sbh;
    reopen_scoreboard(pchild);
    ap_scoreboard_image->global.running_generation = ap_my_generation;
	ap_scoreboard_image->global.running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
	ap_scoreboard_image->global.running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
    void *sbh;
    thread_control[THREAD_GLOBAL(thread_num)].generation = ap_scoreboard_image->global.running_generation;
    ++ap_scoreboard_image->global.running_generation;
    void *sbh;
        /* Set up the scoreboard. */
        ap_run_pre_mpm(pconf, SB_NOT_SHARED);
        /* Humm... Should we put the parent pid here? Does it matter 
         * since the scoreboard is not shared?
         */
        ap_scoreboard_image->parent[0].pid = parent_pid;
        ap_scoreboard_image->parent[0].quiescing = 0;
    void *sbh;
    reopen_scoreboard(pchild);
    ap_scoreboard_image->global.running_generation = ap_my_generation;
AP_DECLARE(const char *) ap_mpm_set_scoreboard(cmd_parms *cmd, void *dummy,
					       const char *arg)

AP_DECLARE(const char *) ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
					     const char *arg)
#include "apr_shmem.h"
static apr_shmem_t *scoreboard_shm = NULL;
typedef struct sb_handle {
} sb_handle;
    apr_shm_free(scoreboard_shm, ap_scoreboard_image);
    scoreboard_size = sizeof(scoreboard);
    scoreboard_size += sizeof(worker_score * ) * server_limit;
void ap_init_scoreboard(void)
    memset(ap_scoreboard_image, 0, scoreboard_size);
    more_storage = (char *)(ap_scoreboard_image + 1);
    ap_scoreboard_image->servers = (worker_score **)more_storage;
    more_storage += server_limit * sizeof(worker_score *);

    ap_assert(more_storage == (char *)ap_scoreboard_image + scoreboard_size);
static apr_status_t setup_shared(apr_pool_t *p)
    const char *fname;
    fname = ap_server_root_relative(p, ap_scoreboard_fname);
    rv = apr_shm_init(&scoreboard_shm, scoreboard_size, fname, p);
    ap_scoreboard_image = apr_shm_malloc(scoreboard_shm, scoreboard_size);
    if (ap_scoreboard_image == NULL) {
        ap_log_error(APLOG_MARK, APLOG_CRIT | APLOG_NOERRNO, 0, NULL,
                     "Fatal error: cannot allocate scoreboard");
        apr_shm_destroy(scoreboard_shm);
        return APR_EGENERAL;
    }
AP_DECLARE(void) reopen_scoreboard(apr_pool_t *p)
/* ap_cleanup_scoreboard
 * 
 */
    if (ap_scoreboard_image->global.sb_type == SB_SHARED) {
/* ap_create_scoreboard(apr_pool_t*, ap_scoreboard_e t)
 *
 * Create or reinit an existing scoreboard. The MPM can control whether
 *
 * ###: Is there any reason to export this symbol in the first place?
AP_DECLARE_NONSTD(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
	running_gen = ap_scoreboard_image->global.running_generation;
            rv = setup_shared(p);
            if (rv) {
            ap_scoreboard_image = (scoreboard *) malloc(scoreboard_size);
            if (ap_scoreboard_image == NULL) {
    ap_init_scoreboard(); /* can't just memset() */
    ap_scoreboard_image->global.sb_type = sb_type;
    ap_scoreboard_image->global.running_generation = running_gen;
    ap_restart_time = apr_time_now();
    apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
				       worker_score *new_score_rec)
    lseek(scoreboard_fd, (long) child_num * sizeof(worker_score), 0);
    lseek(scoreboard_fd,
	  (char *) &ap_scoreboard_image->global -(char *) ap_scoreboard_image, 0);
AP_DECLARE(void) ap_increment_counts(void *sbh, request_rec *r)
    sb_handle *sb = sbh;
AP_DECLARE(void) ap_create_sb_handle(void **new_handle, apr_pool_t *p,
    sb_handle *sbh;

    sbh = (sb_handle *)apr_palloc(p, sizeof *sbh);
    *new_handle = sbh;
    sbh->child_num = child_num;
    sbh->thread_num = thread_num;
    int old_status, i;
        if (ps->generation != ap_my_generation) {
            for (i = 0; i < thread_limit; i++) {
                ap_scoreboard_image->servers[child_num][i].vhostrec = NULL;
            }
            ps->generation = ap_my_generation;
        }
	    ws->vhostrec =  r->server;
AP_DECLARE(int)ap_update_child_status(void *sbh, int status, request_rec *r)
    sb_handle *sb = sbh;
    
    return ap_update_child_status_from_indexes(sb->child_num, sb->thread_num,
AP_DECLARE(worker_score *) ap_get_servers_scoreboard(int x, int y)
AP_DECLARE(process_score *) ap_get_parent_scoreboard(int x)
AP_DECLARE(global_score *) ap_get_global_scoreboard()
    return(&ap_scoreboard_image->global);
    ap_listen_rec **walk;
        new->next = ap_listeners;
        ap_listeners = new;
    for (lr = ap_listeners; lr; lr = lr->next) {
    apr_os_file_put(&tempsock, &sd, 0, r->pool);
    apr_os_file_put(&tempsock, &sd, 0, r->pool);
        return cache->provider->store_body(cache->handle, f, in);
    return cache->provider->store_body(cache->handle, f, in);
    apr_status_t (*store_body)(cache_handle_t *h, ap_filter_t *f, apr_bucket_brigade *b);
 * Always first in the header file:
 *   disk_cache_format_t format;
 *
 * VARY_FORMAT_VERSION:
 * DISK_FORMAT_VERSION:
 *   disk_cache_info_t
static apr_status_t store_body(cache_handle_t *h, ap_filter_t *f, apr_bucket_brigade *b);
/*
 * Modified file bucket implementation to be able to deliver files
 * while caching.
 */

/* Derived from apr_buckets_file.c */

#define BUCKET_IS_DISKCACHE(e)        ((e)->type == &bucket_type_diskcache)
APU_DECLARE_DATA const apr_bucket_type_t bucket_type_diskcache;

static void diskcache_bucket_destroy(void *data)
{
    diskcache_bucket_data *f = data;

    if (apr_bucket_shared_destroy(f)) {
        /* no need to close files here; it will get
         * done automatically when the pool gets cleaned up */
        apr_bucket_free(f);
    }
}


/* The idea here is to convert diskcache buckets to regular file buckets
   as data becomes available */
/* FIXME: Maybe we should care about the block argument, right now we're
          always blocking */
static apr_status_t diskcache_bucket_read(apr_bucket *e, const char **str,
                                          apr_size_t *len, 
                                          apr_read_type_e block)
{
    diskcache_bucket_data *a = e->data;
    apr_file_t *f = a->fd;
    apr_bucket *b = NULL;
    char *buf;
    apr_status_t rv;
    apr_finfo_t finfo;
    apr_size_t filelength = e->length; /* bytes remaining in file past offset */
    apr_off_t fileoffset = e->start;
    apr_off_t fileend;
    apr_size_t available;
#if APR_HAS_THREADS && !APR_HAS_XTHREAD_FILES
    apr_int32_t flags;
#endif

#if APR_HAS_THREADS && !APR_HAS_XTHREAD_FILES
    if ((flags = apr_file_flags_get(f)) & APR_XTHREAD) {
        /* this file descriptor is shared across multiple threads and
         * this OS doesn't support that natively, so as a workaround
         * we must reopen the file into a->readpool */
        const char *fname;
        apr_file_name_get(&fname, f);

        rv = apr_file_open(&f, fname, (flags & ~APR_XTHREAD), 0, a->readpool);
        if (rv != APR_SUCCESS)
            return rv;

        a->fd = f;
    }
#endif

    /* in case we die prematurely */
    *str = NULL;
    *len = 0;

    while(1) {
        /* Figure out how big the file is right now, sit here until
           it's grown enough or we get bored */
        fileend = 0;
        rv = apr_file_seek(f, APR_END, &fileend);
        if(rv != APR_SUCCESS) {
            return rv;
        }

        if(fileend >= fileoffset + MIN(filelength, CACHE_BUF_SIZE)) {
            break;
        }

        rv = apr_file_info_get(&finfo, APR_FINFO_MTIME, f);
        if(rv != APR_SUCCESS ||
                finfo.mtime < (apr_time_now() - a->updtimeout) ) 
        {
            return APR_EGENERAL;
        }
        apr_sleep(CACHE_LOOP_SLEEP);
    }

    /* Convert this bucket to a zero-length heap bucket so we won't be called
       again */
    buf = apr_bucket_alloc(0, e->list);
    apr_bucket_heap_make(e, buf, 0, apr_bucket_free);

    /* Wrap as much as possible into a regular file bucket */
    available = MIN(filelength, fileend-fileoffset);
    b = apr_bucket_file_create(f, fileoffset, available, a->readpool, e->list);
    APR_BUCKET_INSERT_AFTER(e, b);

    /* Put any remains in yet another bucket */
    if(available < filelength) {
        e=b;
        /* for efficiency, we can just build a new apr_bucket struct
         * to wrap around the existing bucket */
        b = apr_bucket_alloc(sizeof(*b), e->list);
        b->start  = fileoffset + available;
        b->length = filelength - available;
        b->data   = a;
        b->type   = &bucket_type_diskcache;
        b->free   = apr_bucket_free;
        b->list   = e->list;
        APR_BUCKET_INSERT_AFTER(e, b);
    }
    else {
        diskcache_bucket_destroy(a);
    }

    *str = buf;
    return APR_SUCCESS;
}

static apr_bucket * diskcache_bucket_make(apr_bucket *b,
                                                apr_file_t *fd,
                                                apr_off_t offset,
                                                apr_size_t len, 
                                                apr_interval_time_t timeout,
                                                apr_pool_t *p)
{
    diskcache_bucket_data *f;

    f = apr_bucket_alloc(sizeof(*f), b->list);
    f->fd = fd;
    f->readpool = p;
    f->updtimeout = timeout;

    b = apr_bucket_shared_make(b, f, offset, len);
    b->type = &bucket_type_diskcache;

    return b;
}

static apr_bucket * diskcache_bucket_create(apr_file_t *fd,
                                                  apr_off_t offset,
                                                  apr_size_t len, 
                                                  apr_interval_time_t timeout,
                                                  apr_pool_t *p,
                                                  apr_bucket_alloc_t *list)
{
    apr_bucket *b = apr_bucket_alloc(sizeof(*b), list);

    APR_BUCKET_INIT(b);
    b->free = apr_bucket_free;
    b->list = list;
    return diskcache_bucket_make(b, fd, offset, len, timeout, p);
}


/* FIXME: This is probably only correct for the first case, that seems
   to be the one that occurs all the time... */
static apr_status_t diskcache_bucket_setaside(apr_bucket *data, 
                                              apr_pool_t *reqpool)
{
    diskcache_bucket_data *a = data->data;
    apr_file_t *fd = NULL;
    apr_file_t *f = a->fd;
    apr_pool_t *curpool = apr_file_pool_get(f);

    if (apr_pool_is_ancestor(curpool, reqpool)) {
        return APR_SUCCESS;
    }

    if (!apr_pool_is_ancestor(a->readpool, reqpool)) {
        /* FIXME: Figure out what needs to be done here */
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                "disk_cache: diskcache_bucket_setaside: FIXME1");
        a->readpool = reqpool;
    }

    /* FIXME: Figure out what needs to be done here */
    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
            "disk_cache: diskcache_bucket_setaside: FIXME2");

    apr_file_setaside(&fd, f, reqpool);
    a->fd = fd;
    return APR_SUCCESS;
}

APU_DECLARE_DATA const apr_bucket_type_t bucket_type_diskcache = {
    "DISKCACHE", 5, APR_BUCKET_DATA,
    diskcache_bucket_destroy,
    diskcache_bucket_read,
    diskcache_bucket_setaside,
    apr_bucket_shared_split,
    apr_bucket_shared_copy
};

/* From apr_brigade.c */

/* A "safe" maximum bucket size, 1Gb */
#define MAX_BUCKET_SIZE (0x40000000)

static apr_bucket * diskcache_brigade_insert(apr_bucket_brigade *bb,
                                                   apr_file_t *f, apr_off_t
                                                   start, apr_off_t length,
                                                   apr_interval_time_t timeout,
                                                   apr_pool_t *p)
{
    apr_bucket *e;

    if (length < MAX_BUCKET_SIZE) {
        e = diskcache_bucket_create(f, start, (apr_size_t)length, timeout, p, 
                bb->bucket_alloc);
    }
    else {
        /* Several buckets are needed. */        
        e = diskcache_bucket_create(f, start, MAX_BUCKET_SIZE, timeout, p, 
                bb->bucket_alloc);

        while (length > MAX_BUCKET_SIZE) {
            apr_bucket *ce;
            apr_bucket_copy(e, &ce);
            APR_BRIGADE_INSERT_TAIL(bb, ce);
            e->start += MAX_BUCKET_SIZE;
            length -= MAX_BUCKET_SIZE;
        }
        e->length = (apr_size_t)length; /* Resize just the last bucket */
    }

    APR_BRIGADE_INSERT_TAIL(bb, e);
    return e;
}

/* --------------------------------------------------------------- */

static apr_status_t mkdir_structure(disk_cache_conf *conf, const char *file, apr_pool_t *pool)
    apr_status_t rv = APR_SUCCESS;
        *p = '/';
            break;
    if (rv != APR_SUCCESS && !APR_STATUS_IS_EEXIST(rv)) {
        return rv;
    }

    return APR_SUCCESS;
    dobj->initial_size = len;
    dobj->file_size = -1;
    dobj->updtimeout = conf->updtimeout;
    dobj->frv = APR_SUCCESS;

static apr_status_t file_read_timeout(apr_file_t *file, char * buf,
                                      apr_size_t len, apr_time_t timeout)
    apr_size_t left, done;
    apr_finfo_t finfo;
    done = 0;
    left = len;

    while(1) {
        rc = apr_file_read_full(file, buf+done, left, &len);
        if (rc == APR_SUCCESS) {
           break;
        }
        done += len;
        left -= len;
        if(!APR_STATUS_IS_EOF(rc)) {
            return rc;
        }
        rc = apr_file_info_get(&finfo, APR_FINFO_MTIME, file);
        if(rc != APR_SUCCESS) {
           return rc;
        }
        if(finfo.mtime < (apr_time_now() - timeout) ) {
            return APR_ETIMEDOUT;
        apr_sleep(CACHE_LOOP_SLEEP);
    return APR_SUCCESS;
}
static apr_status_t open_header(cache_handle_t *h, request_rec *r, 
                                const char *key, disk_cache_conf *conf)
{
    int flags;
    disk_cache_format_t format;
    apr_status_t rc;
    const char *nkey = key;
    disk_cache_info_t disk_info;
    cache_object_t *obj = h->cache_obj;
    disk_cache_object_t *dobj = obj->vobj;
    flags = APR_READ|APR_BINARY|APR_BUFFERED;
        return CACHE_EDECLINED;
    rc = apr_file_read_full(dobj->hfd, &format, sizeof(format), NULL);
    if(APR_STATUS_IS_EOF(rc)) {
        return CACHE_ENODATA;
    }
    else if(rc != APR_SUCCESS) {
        return rc;
    }
    /* Vary-files are being written to tmpfile and moved in place, so
       the should always be complete */
        rc = apr_file_read_full(dobj->hfd, &expire, sizeof(expire), NULL);
        if(rc != APR_SUCCESS) {
            return rc;
        }
            return CACHE_EDECLINED;
            return CACHE_EDECLINED;
        dobj->hdrsfile = data_file(r->pool, conf, dobj, nkey);
            dobj->hfd = NULL;
            return CACHE_EDECLINED;
        }
        rc = apr_file_read_full(dobj->hfd, &format, sizeof(format), NULL);
        if(APR_STATUS_IS_EOF(rc)) {
            return CACHE_ENODATA;
        }
        else if(rc != APR_SUCCESS) {
            return rc;

    if(format != DISK_FORMAT_VERSION) {
        ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                     "disk_cache: File '%s' had a version mismatch. File had "
                     "version: %d (current is %d). Deleted.", dobj->hdrsfile,
                     format, DISK_FORMAT_VERSION);
        file_cache_errorcleanup(dobj, r);
        return CACHE_EDECLINED;
    /* read the data from the header file */
    rc = apr_file_read_full(dobj->hfd, &disk_info, sizeof(disk_info), NULL);
    if(APR_STATUS_IS_EOF(rc)) {
        return CACHE_ENODATA;
    else if(rc != APR_SUCCESS) {
        return rc;
    /* Store it away so we can get it later. */
    dobj->disk_info = disk_info;
    return APR_SUCCESS;

static apr_status_t open_header_timeout(cache_handle_t *h, request_rec *r, 
                                const char *key, disk_cache_conf *conf,
                                disk_cache_object_t *dobj)
    apr_status_t rc;
    apr_finfo_t finfo;

    while(1) {
        if(dobj->hfd) {
            apr_file_close(dobj->hfd);
            dobj->hfd = NULL;
        }
        rc = open_header(h, r, key, conf);
        if(rc != APR_SUCCESS && rc != CACHE_ENODATA) {
            if(rc != CACHE_EDECLINED) {
                ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server,
                             "disk_cache: Cannot load header file: %s",
                             dobj->hdrsfile);
            }
            return rc;
        }

        /* Objects with unknown body size will have file_size == -1 until the
           entire body is written and the header updated with the actual size.
           And since we depend on knowing the body size we wait until the size
           is written */
        if(rc == APR_SUCCESS && dobj->disk_info.file_size >= 0) {
            break;
        }
        rc = apr_file_info_get(&finfo, APR_FINFO_MTIME, dobj->hfd);
        if(rc != APR_SUCCESS) {
            return rc;
        }
        if(finfo.mtime < (apr_time_now() - dobj->updtimeout)) {
            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, r->server,
                         "disk_cache: Timed out waiting for header for URL %s"
                         " - caching the body failed?", key);
            return CACHE_EDECLINED;
        }
        apr_sleep(CACHE_LOOP_SLEEP);
    }

    return APR_SUCCESS;

static apr_status_t open_body_timeout(request_rec *r, const char *key, 
                                      disk_cache_object_t *dobj)
    apr_off_t off;
    apr_time_t starttime = apr_time_now();
    int flags;
#if APR_HAS_SENDFILE
    core_dir_config *pdconf = ap_get_module_config(r->per_dir_config,
                                                   &core_module);
#endif  
    flags = APR_READ|APR_BINARY|APR_BUFFERED;
#if APR_HAS_SENDFILE
    flags |= ((pdconf->enable_sendfile == ENABLE_SENDFILE_OFF)
             ? 0 : APR_SENDFILE_ENABLED);
#endif  

    /* Wait here until we get a body cachefile, data in it, and do quick sanity
     * check */

    while(1) {
        if(dobj->fd == NULL) {
            rc = apr_file_open(&dobj->fd, dobj->datafile, flags, 0, r->pool);
            if(rc != APR_SUCCESS) {
                if(starttime < (apr_time_now() - dobj->updtimeout) ) {
                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, r->server,
                                 "disk_cache: Timed out waiting for body for "
                                 "URL %s - caching failed?", key);
                    return CACHE_EDECLINED;
                }
                apr_sleep(CACHE_LOOP_SLEEP);
                continue;
            }
        }
        dobj->file_size = 0;
        rc = apr_file_seek(dobj->fd, APR_END, &dobj->file_size);
        if(rc != APR_SUCCESS) {
            return rc;
        }
        if(dobj->initial_size < dobj->file_size) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: Bad cached body for URL %s, size %"
                         APR_OFF_T_FMT " != %" APR_OFF_T_FMT,  dobj->name,
                         dobj->initial_size, dobj->file_size);
            file_cache_errorcleanup(dobj, r);
            return CACHE_EDECLINED;
        }
        else if(dobj->initial_size > dobj->file_size) {
            /* Still caching or failed? */
            apr_finfo_t finfo;

            rc = apr_file_info_get(&finfo, APR_FINFO_MTIME, dobj->fd);
            if(rc != APR_SUCCESS ||
                    finfo.mtime < (apr_time_now() - dobj->updtimeout) ) 
            {
                ap_log_error(APLOG_MARK, APLOG_WARNING, rc, r->server,
                             "disk_cache: Body for URL %s is too small - "
                             "caching the body failed?", dobj->name);
                return CACHE_EDECLINED;
            }
        }
        if(dobj->file_size > 0) {
            break;
        apr_sleep(CACHE_LOOP_SLEEP);
    }

    /* Go back to the beginning */
    off = 0;
    rc = apr_file_seek(dobj->fd, APR_SET, &off);
    if(rc != APR_SUCCESS) {
        return rc;
    return APR_SUCCESS;
}


static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
{
    apr_status_t rc;
    disk_cache_object_t *dobj;
    cache_info *info;
    apr_size_t len;
    static int error_logged = 0;
    disk_cache_conf *conf = ap_get_module_config(r->server->module_config,
                                                 &disk_cache_module);
    char urlbuff[MAX_STRING_LEN];

    h->cache_obj = NULL;

    /* Look up entity keyed to 'url' */
    if (conf->cache_root == NULL) {
        if (!error_logged) {
            error_logged = 1;
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: Cannot cache files to disk without a "
                         "CacheRoot specified.");
        }
        return DECLINED;
    }

    /* Create and init the cache object */
    h->cache_obj = apr_pcalloc(r->pool, sizeof(cache_object_t));
    h->cache_obj->vobj = dobj = apr_pcalloc(r->pool, sizeof(disk_cache_object_t));
    info = &(h->cache_obj->info);

    /* Save the cache root */
    dobj->root = apr_pstrndup(r->pool, conf->cache_root, conf->cache_root_len);
    dobj->root_len = conf->cache_root_len;

    dobj->hdrsfile = header_file(r->pool, conf, dobj, key);

    dobj->updtimeout = conf->updtimeout;

    /* Open header and read basic info, wait until header contains
       valid size information for the body */
    rc = open_header_timeout(h, r, key, conf, dobj);
    if(rc != APR_SUCCESS) {
        return DECLINED;
    }

    /* TODO: We have the ability to serve partially cached requests,
     * however in order to avoid some sticky what if conditions
     * should the content turn out to be too large to be cached,
     * we must only allow partial cache serving if the cached
     * entry has a content length known in advance.
     */

    info->status = dobj->disk_info.status;
    info->date = dobj->disk_info.date;
    info->expire = dobj->disk_info.expire;
    info->request_time = dobj->disk_info.request_time;
    info->response_time = dobj->disk_info.response_time;

    dobj->initial_size = (apr_off_t) dobj->disk_info.file_size;
    dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);

    len = dobj->disk_info.name_len;

    if(len > 0) {
        rc = file_read_timeout(dobj->hfd, urlbuff, len, dobj->updtimeout);
        if (rc == APR_ETIMEDOUT) {
            ap_log_error(APLOG_MARK, APLOG_WARNING, rc, r->server,
                         "disk_cache: Timed out waiting for urlbuff for "
                         "URL %s - caching failed?",  key);
            return DECLINED;
        }
        else if(rc != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_WARNING, rc, r->server,
                         "disk_cache: Error reading urlbuff for URL %s",
                         key);
            return DECLINED;
        }
    }
    urlbuff[len] = '\0';

    /* check that we have the same URL */
    if (strcmp(urlbuff, dobj->name) != 0) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "disk_cache: Cached URL %s didn't match requested "
                     "URL %s", urlbuff, dobj->name);
        return DECLINED;
    }

    dobj->datafile = data_file(r->pool, conf, dobj, h->cache_obj->key);
    dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);

    /* Only need body cachefile if we have a body */
    if(dobj->initial_size > 0) {
        rc = open_body_timeout(r, key, dobj);
        if(rc != APR_SUCCESS) {
            return DECLINED;
        }
    }
    else {
        dobj->file_size = 0;
    }

    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "disk_cache: Recalled status for cached URL %s",  dobj->name);
    return OK;
}


static int remove_entity(cache_handle_t *h)
{
    /* Null out the cache object pointer so next time we start from scratch  */
    h->cache_obj = NULL;
    return OK;
}

static int remove_url(cache_handle_t *h, apr_pool_t *p)
{
    apr_status_t rc;
    disk_cache_object_t *dobj;

    /* Get disk cache object from cache handle */
    dobj = (disk_cache_object_t *) h->cache_obj->vobj;
    if (!dobj) {
        return DECLINED;
    }

    /* Delete headers file */
    if (dobj->hdrsfile) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                     "disk_cache: Deleting %s from cache.", dobj->hdrsfile);

        rc = apr_file_remove(dobj->hdrsfile, p);
        if ((rc != APR_SUCCESS) && !APR_STATUS_IS_ENOENT(rc)) {
            /* Will only result in an output if httpd is started with -e debug.
             * For reason see log_error_core for the case s == NULL.
             */
            ap_log_error(APLOG_MARK, APLOG_DEBUG, rc, NULL,
                   "disk_cache: Failed to delete headers file %s from cache.",
                         dobj->hdrsfile);
            return DECLINED;
        }
    }

     /* Delete data file */
    if (dobj->datafile) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                     "disk_cache: Deleting %s from cache.", dobj->datafile);
static apr_status_t read_table(request_rec *r,
                             "disk_cache: CGI Interface Error: Script headers apparently ASCII: (CGI = %s)",

static apr_status_t read_table_timeout(cache_handle_t *handle, request_rec *r,
                               apr_table_t **table, apr_file_t *file,
                               apr_time_t timeout)
{
    apr_off_t off;
    apr_finfo_t finfo;
    apr_status_t rv;

    off = 0;
    rv = apr_file_seek(file, APR_CUR, &off);
    if(rv != APR_SUCCESS) {
        return rv;
    }

    while(1) {
        *table = apr_table_make(r->pool, 20);
        rv = read_table(r, *table, file);
        if(rv == APR_SUCCESS) {
            break;
        }
        apr_table_clear(*table);

        rv = apr_file_seek(file, APR_SET, &off);
        if(rv != APR_SUCCESS) {
            return rv;
        }

        rv = apr_file_info_get(&finfo, APR_FINFO_MTIME, file);
        if(rv != APR_SUCCESS ||
                finfo.mtime < (apr_time_now() - timeout) ) 
        {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "disk_cache: Timed out waiting for cache headers "
                          "URL %s", handle->cache_obj->key);
            return APR_EGENERAL;
        }
        apr_sleep(CACHE_LOOP_SLEEP);
    }

    return APR_SUCCESS;
}


    apr_status_t rv;
    rv = read_table_timeout(h, r, &(h->resp_hdrs), dobj->hfd, dobj->updtimeout);
    if(rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                     "disk_cache: Timed out waiting for response headers "
                     "for URL %s - caching failed?",  dobj->name);
        return rv;
    }
    rv = read_table_timeout(h, r, &(h->req_hdrs), dobj->hfd, dobj->updtimeout);
    if(rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                     "disk_cache: Timed out waiting for request headers "
                     "for URL %s - caching failed?",  dobj->name);
        return rv;
    }
    dobj->hfd = NULL;
    /* Insert as much as possible as regular file (ie. sendfile():able) */
    if(dobj->file_size > 0) {
        if(apr_brigade_insert_file(bb, dobj->fd, 0, 
                                   dobj->file_size, p) == NULL) 
        {
            return APR_ENOMEM;
        }
    }

    /* Insert any remainder as read-while-caching bucket */
    if(dobj->file_size < dobj->initial_size) {
        if(diskcache_brigade_insert(bb, dobj->fd, dobj->file_size, 
                                    dobj->initial_size - dobj->file_size,
                                    dobj->updtimeout, p
                    ) == NULL) 
        {
            return APR_ENOMEM;
        }
    }

static apr_status_t open_new_file(request_rec *r, const char *filename,
                                  apr_file_t **fd, disk_cache_conf *conf)
    int flags;
#if APR_HAS_SENDFILE
    core_dir_config *pdconf = ap_get_module_config(r->per_dir_config,
                                                   &core_module);
#endif  

    flags = APR_CREATE | APR_WRITE | APR_READ | APR_BINARY | APR_BUFFERED | APR_EXCL | APR_TRUNCATE;
#if APR_HAS_SENDFILE
    flags |= ((pdconf->enable_sendfile == ENABLE_SENDFILE_OFF)
             ? 0 : APR_SENDFILE_ENABLED);
#endif  

    while(1) {
        rv = apr_file_open(fd, filename, flags, 
                APR_FPROT_UREAD | APR_FPROT_UWRITE, r->pool);

        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, r->server,
                     "disk_cache: open_new_file: Opening %s", filename);

        if(APR_STATUS_IS_EEXIST(rv)) {
            apr_finfo_t finfo;

            rv = apr_stat(&finfo, filename, APR_FINFO_MTIME, r->pool);
            if(APR_STATUS_IS_ENOENT(rv)) {
                /* Someone else has already removed it, try again */
                continue;
            }
            else if(rv != APR_SUCCESS) {
                return rv;
            }
            if(finfo.mtime < (apr_time_now() - conf->updtimeout) ) {
                /* Something stale that's left around */

                rv = apr_file_remove(filename, r->pool);
                if(rv != APR_SUCCESS && !APR_STATUS_IS_ENOENT(rv)) {
                    ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                                 "disk_cache: open_new_file: Failed to "
                                 "remove old %s", filename);
                    return rv;
                }
                continue;
            }
            else {
                /* Someone else has just created the file, return identifiable
                   status so calling function can do the right thing */
                return CACHE_EEXIST;
            }
        }
        else if(APR_STATUS_IS_ENOENT(rv)) {
            /* The directory for the file didn't exist */

            rv = mkdir_structure(conf, filename, r->pool);
            if(rv != APR_SUCCESS) {
                ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                             "disk_cache: open_new_file: Failed to make "
                             "directory for %s", filename);
                return rv;
            }
            continue;
        }
        else if(rv == APR_SUCCESS) {
            return APR_SUCCESS;
        }
        else {
            ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                         "disk_cache: open_new_file: Failed to open %s",
                         filename);
            return rv;
        }
    }
    /* We should never get here, so */
    return APR_EGENERAL;
}
static apr_status_t store_vary_header(cache_handle_t *h, disk_cache_conf *conf,
                                       request_rec *r, cache_info *info,
                                       const char *varyhdr)
{
    disk_cache_object_t *dobj = (disk_cache_object_t*) h->cache_obj->vobj;
    apr_array_header_t* varray;
    const char *vfile;
    apr_status_t rv;
    int flags;
    disk_cache_format_t format = VARY_FORMAT_VERSION;
    struct iovec iov[2];
    apr_size_t amt;
    if(dobj->prefix != NULL) {
        vfile = dobj->prefix;
    }
    else {
        vfile = dobj->hdrsfile;
    }
    flags = APR_CREATE | APR_WRITE | APR_BINARY | APR_EXCL | APR_BUFFERED;
    rv = apr_file_mktemp(&dobj->tfd, dobj->tempfile, flags, r->pool);
    if (rv != APR_SUCCESS) {
        return rv;
    }
    iov[0].iov_base = (void*)&format;
    iov[0].iov_len = sizeof(format);
    iov[1].iov_base = (void*)&info->expire;
    iov[1].iov_len = sizeof(info->expire);
    rv = apr_file_writev(dobj->tfd, (const struct iovec *) &iov, 2, &amt);
    if (rv != APR_SUCCESS) {
        file_cache_errorcleanup(dobj, r);
        return rv;
    }
    varray = apr_array_make(r->pool, 6, sizeof(char*));
    tokens_to_array(r->pool, varyhdr, varray);
    rv = store_array(dobj->tfd, varray);
    if (rv != APR_SUCCESS) {
        file_cache_errorcleanup(dobj, r);
        return rv;
    }

    rv = apr_file_close(dobj->tfd);
    dobj->tfd = NULL;
    if (rv != APR_SUCCESS) {
        file_cache_errorcleanup(dobj, r);
        return rv;
    }
    rv = safe_file_rename(conf, dobj->tempfile, vfile, r->pool);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                     "disk_cache: rename tempfile to varyfile failed: "
                     "%s -> %s", dobj->tempfile, vfile);
        file_cache_errorcleanup(dobj, r);
        return rv;
    }
    dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);
    if(dobj->prefix == NULL) {
        const char *tmp = regen_key(r->pool, r->headers_in, varray, dobj->name);
        dobj->prefix = dobj->hdrsfile;
        dobj->hdrsfile = header_file(r->pool, conf, dobj, tmp);
    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "disk_cache: Stored vary header for URL %s", dobj->name);
    return APR_SUCCESS;
}
static apr_status_t store_disk_header(disk_cache_object_t *dobj,
                                       request_rec *r, cache_info *info)
{
    disk_cache_format_t format = DISK_FORMAT_VERSION;
    struct iovec iov[3];
    int niov;
    disk_cache_info_t disk_info;
    apr_size_t amt;
    apr_status_t rv;
    disk_info.file_size = dobj->initial_size;

    niov = 0;
    iov[niov].iov_base = (void*)&format;
    iov[niov++].iov_len = sizeof(format);
    iov[niov].iov_base = (void*)&disk_info;
    iov[niov++].iov_len = sizeof(disk_cache_info_t);
    iov[niov].iov_base = (void*)dobj->name;
    iov[niov++].iov_len = disk_info.name_len;
    rv = apr_file_writev(dobj->hfd, (const struct iovec *) &iov, niov, &amt);
        file_cache_errorcleanup(dobj, r);
            file_cache_errorcleanup(dobj, r);
            file_cache_errorcleanup(dobj, r);
    return APR_SUCCESS;
}

static apr_status_t store_headers(cache_handle_t *h, request_rec *r, 
                                  cache_info *info)
{
    disk_cache_conf *conf = ap_get_module_config(r->server->module_config,
                                                 &disk_cache_module);
    apr_status_t rv;
    int flags=0, rewriting;
    disk_cache_object_t *dobj = (disk_cache_object_t*) h->cache_obj->vobj;


    /* This is flaky... we need to manage the cache_info differently */
    h->cache_obj->info = *info;

    if(dobj->hfd) {
        ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                     "disk_cache: Rewriting headers for URL %s", dobj->name);

        rewriting = TRUE;
    }
    else {
        ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                     "disk_cache: Storing new headers for URL %s", dobj->name);

        rewriting = FALSE;
    }

    if (r->headers_out) {
        const char *tmp;

        tmp = apr_table_get(r->headers_out, "Vary");

        if (tmp) {
            rv = store_vary_header(h, conf, r, info, tmp);
            if(rv != APR_SUCCESS) {
                return rv;
            }
        }
    } 

    if(rewriting) {
        /* Assume we are just rewriting the header if we have an fd. The
           fd might be readonly though, in that case reopen it for writes.
           Something equivalent to fdopen would have been handy. */

        flags = apr_file_flags_get(dobj->hfd);

        if(!(flags & APR_WRITE)) {
            apr_file_close(dobj->hfd);
            rv = apr_file_open(&dobj->hfd, dobj->hdrsfile, 
                    APR_WRITE | APR_BINARY | APR_BUFFERED, 0, r->pool);
            if (rv != APR_SUCCESS) {
                dobj->hfd = NULL;
                return rv;
            }
        }
        else {
            /* We can write here, so let's just move to the right place */
            apr_off_t off=0;
            rv = apr_file_seek(dobj->hfd, APR_SET, &off);
            if (rv != APR_SUCCESS) {
                return rv;
            }
        }
    }
    else {
        rv = open_new_file(r, dobj->hdrsfile, &(dobj->hfd), conf);
        if(rv == CACHE_EEXIST) {
            dobj->skipstore = TRUE;
        }
        else if(rv != APR_SUCCESS) {
            return rv;
        }
    }

    if(dobj->skipstore) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "disk_cache: Skipping store for URL %s: Someone else "
                     "beat us to it",  dobj->name);
        return APR_SUCCESS;
    rv = store_disk_header(dobj, r, info);
    if(rv != APR_SUCCESS) {
    /* If the body size is unknown, the header file will be rewritten later
       so we can't close it */
    if(dobj->initial_size < 0) {
        rv = apr_file_flush(dobj->hfd);
    }
    else {
        rv = apr_file_close(dobj->hfd);
        dobj->hfd = NULL;
    }
    if(rv != APR_SUCCESS) {
        return rv;
    }
/**
 * Store the body of the response in the disk cache.
 * 
 * As the data is written to the cache, it is also written to
 * the filter provided. On network write failure, the full body
 * will still be cached.
 */
static apr_status_t store_body(cache_handle_t *h, ap_filter_t *f, apr_bucket_brigade *bb)
    apr_bucket *e, *b;
    request_rec *r = f->r;
    dobj->store_body_called++;
    
    if(r->no_cache) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "disk_cache: store_body called for URL %s even though"
                     "no_cache is set", dobj->name);
        file_cache_errorcleanup(dobj, r);
        ap_remove_output_filter(f);
        return ap_pass_brigade(f->next, bb);
    }

    if(dobj->initial_size == 0) {
        /* Don't waste a body cachefile on a 0 length body */
        return ap_pass_brigade(f->next, bb);
    }

    if(!dobj->skipstore && dobj->fd == NULL) {
        rv = open_new_file(r, dobj->datafile, &(dobj->fd), conf);
        if (rv == CACHE_EEXIST) {
            /* Someone else beat us to storing this */
            dobj->skipstore = TRUE;
        }
        else if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: store_body tried to open cached file "
                         "for URL %s and this failed", dobj->name);
            ap_remove_output_filter(f);
            return ap_pass_brigade(f->next, bb);
        }
        else {
            dobj->file_size = 0;
    if(dobj->skipstore) {
        /* Someone else beat us to storing this object.
         * We are too late to take advantage of this storage :( */
        ap_remove_output_filter(f);
        return ap_pass_brigade(f->next, bb);
    }

    /* set up our temporary brigade */
    if (!dobj->tmpbb) {
        dobj->tmpbb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    }
    else {
        apr_brigade_cleanup(dobj->tmpbb);
    }

    /* start caching the brigade */
    ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                 "disk_cache: Caching body for URL %s", dobj->name);

    e = APR_BRIGADE_FIRST(bb);
    while (e != APR_BRIGADE_SENTINEL(bb)) {

        apr_off_t offset = 0;

        /* try write all data buckets to the cache, except for metadata buckets */
        if(!APR_BUCKET_IS_METADATA(e)) {

            /* read in a bucket fragment */
            rv = apr_bucket_read(e, &str, &length, APR_BLOCK_READ);
            if (rv != APR_SUCCESS) {
                ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                             "disk_cache: Error when reading bucket for URL %s, aborting request",
                             dobj->name);
                file_cache_errorcleanup(dobj, r);
                /* not being able to read the bucket is fatal,
                 * return this up the filter stack
                 */
                return rv;
            }

            /* try write the bucket fragment to the cache */
            apr_file_seek(dobj->fd, APR_END, &offset);
            rv = apr_file_write_full(dobj->fd, str, length, &written);
            offset = - (apr_off_t)written;
            apr_file_seek(dobj->fd, APR_END, &offset);

            /* if the cache write was successful, swap the original bucket
             * with a file bucket pointing to the same data in the cache.
             * 
             * This is done because:
             * 
             * - The ap_core_output_filter can take advantage of its ability
             * to do non blocking writes on file buckets.
             * 
             * - We are prevented from the need to read the original bucket
             * a second time inside ap_core_output_filter, which could be
             * expensive or memory consuming.
             * 
             * - The cache, in theory, should be faster than the backend,
             * otherwise there would be little point in caching in the first
             * place.
             */
            if (APR_SUCCESS == rv) {

                /* remove and destroy the original bucket from the brigade */
                b = e;
                e = APR_BUCKET_NEXT(e);
                APR_BUCKET_REMOVE(b);
                apr_bucket_destroy(b);

                /* Is our network connection still alive?
                 * If not, we must continue caching the file, so keep looping.
                 * We will return the error at the end when caching is done.
                 */
                if (APR_SUCCESS == dobj->frv) {

                    /* insert a file bucket pointing to the cache into out temporary brigade */
                    if (diskcache_brigade_insert(dobj->tmpbb, dobj->fd, dobj->file_size, 
                                                 written,
                                                 dobj->updtimeout, r->pool) == NULL) {
                       return APR_ENOMEM;
                    }

                    /* TODO: If we are not able to guarantee that
                     * apr_core_output_filter() will not block on our
                     * file buckets, then the check for whether the
                     * socket will block must go here.
                     */
    
                    /* send our new brigade to the network */
                    dobj->frv = ap_pass_brigade(f->next, dobj->tmpbb);
    
                }

                /* update the write counter, and sanity check the size */
                dobj->file_size += written;
                if (dobj->file_size > conf->maxfs) {
                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                                 "disk_cache: URL %s failed the size check "
                                 "(%" APR_OFF_T_FMT " > %" APR_OFF_T_FMT ")",
                                 dobj->name, dobj->file_size, conf->maxfs);
                    file_cache_errorcleanup(dobj, r);
                    ap_remove_output_filter(f);
                    return ap_pass_brigade(f->next, bb);
                }

            }

            /*
             * If the cache write failed, continue to loop and pass data to
             * the network. Remove the cache filter from the output filters
             * so we don't inadvertently try to cache write again, leaving
             * a hole in the cached data.
             */
            else {

                /* mark the write as having failed */
                ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                             "disk_cache: Error when writing cache file for "
                             "URL %s", dobj->name);
                             
                /* step away gracefully */
                file_cache_errorcleanup(dobj, r);
                ap_remove_output_filter(f);

                /* write the rest of the brigade to the network, and leave */
                return ap_pass_brigade(f->next, bb);

            }



        /* write metadata buckets direct to the output filter */
        else {

            /* move the metadata bucket to our temporary brigade */
            b = e;
            e = APR_BUCKET_NEXT(e);
            APR_BUCKET_REMOVE(b);
            APR_BRIGADE_INSERT_HEAD(dobj->tmpbb, b);

            /* Is our network connection still alive?
             * If not, we must continue looping, but stop writing to the network.
             */
            if (APR_SUCCESS == dobj->frv) {
    
                /* TODO: If we are not able to guarantee that
                 * apr_core_output_filter() will not block on our
                 * file buckets, then the check for whether the
                 * socket will block must go here.
                 */
    
                /* send our new brigade to the network */
                dobj->frv = ap_pass_brigade(f->next, dobj->tmpbb);
    
            }


        apr_brigade_cleanup(dobj->tmpbb);

    }

    
    /* Drop out here if this wasn't the end */
    if (!APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
        return APR_SUCCESS;
    }

    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "disk_cache: Done caching URL %s, len %" APR_OFF_T_FMT,
                 dobj->name, dobj->file_size);

    if (APR_SUCCESS != dobj->frv) {
        ap_log_error(APLOG_MARK, APLOG_ERR, dobj->frv, r->server,
                     "disk_cache: An error occurred while writing to the "
                     "network for URL %s.",
                     h->cache_obj->key);
    if (dobj->file_size < conf->minfs) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "disk_cache: URL %s failed the size check "
                     "(%" APR_OFF_T_FMT "<%" APR_OFF_T_FMT ")",
                     h->cache_obj->key, dobj->file_size, conf->minfs);
        /* Remove the intermediate cache file and return filter status */
        file_cache_errorcleanup(dobj, r);
        return dobj->frv;
    }
    if (dobj->initial_size < 0) {
        /* Update header information now that we know the size */
        dobj->initial_size = dobj->file_size;
        rv = store_headers(h, r, &(h->cache_obj->info));
        if (rv != APR_SUCCESS) {
            return dobj->frv;
    }
    else if (dobj->initial_size != dobj->file_size) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "disk_cache: URL %s - body size mismatch: suggested %"
                     APR_OFF_T_FMT "  bodysize %" APR_OFF_T_FMT ")",
                     dobj->name, dobj->initial_size, dobj->file_size);
        file_cache_errorcleanup(dobj, r);
        return dobj->frv;
    }
    /* All checks were fine, close output file */
    rv = apr_file_close(dobj->fd);
    dobj->fd = NULL;
    if (rv != APR_SUCCESS) {
                     "disk_cache: While trying to close the cache file for "
                     "URL %s, the close failed", dobj->name);
        file_cache_errorcleanup(dobj, r);
        return dobj->frv;
    return dobj->frv;

    conf->updtimeout = DEFAULT_UPDATE_TIMEOUT;

static const char
*set_cache_updtimeout(cmd_parms *parms, void *in_struct_ptr, const char *arg)
{
    apr_int64_t val;
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config,
                                                 &disk_cache_module);

    if (apr_strtoff(&val, arg, NULL, 0) != APR_SUCCESS || val < 0) 
    {
        return "CacheUpdateTimeout argument must be a non-negative integer representing the timeout in milliseconds for cache update operations";
    }

    conf->updtimeout = val * 1000;

    return NULL;
}


    AP_INIT_TAKE1("CacheUpdateTimeout", set_cache_updtimeout, NULL, RSRC_CONF,
                  "Timeout in ms for cache updates"),
#define DISK_FORMAT_VERSION_OLD 4
#define DISK_FORMAT_VERSION 5
#define CACHE_BUF_SIZE 65536

/* How long to sleep before retrying while looping */
#define CACHE_LOOP_SLEEP 200000


/* Indicates the format of the header struct stored on-disk. */
typedef apr_uint32_t disk_cache_format_t;

    /* The body size forced to 64bit to not break when people go from non-LFS
     * to LFS builds */
    apr_int64_t file_size;
    apr_off_t initial_size;  /*  Initial file size reported by caller */

    apr_interval_time_t updtimeout; /* Cache update timeout */

    int skipstore;              /* Set if we should skip storing stuff */
    int store_body_called;      /* Number of times store_body() has executed */
    apr_bucket_brigade *tmpbb;  /* Temporary bucket brigade. */
    apr_status_t frv;           /* Last known status of network write */
#define DEFAULT_UPDATE_TIMEOUT apr_time_from_sec(10)
    apr_interval_time_t updtimeout;   /* Cache update timeout */
#define CACHE_ENODATA (APR_OS_START_USERERR+1)
#define CACHE_EDECLINED (APR_OS_START_USERERR+2)
#define CACHE_EEXIST (APR_OS_START_USERERR+3)


typedef struct diskcache_bucket_data diskcache_bucket_data;
struct diskcache_bucket_data {
    /* Number of buckets using this memory */
    apr_bucket_refcount  refcount;
    apr_file_t  *fd;
    /* The pool into which any needed structures should
     *  be created while reading from this file bucket */
    apr_pool_t *readpool;
    /* Cache update timeout */
    apr_interval_time_t updtimeout;

};


    apr_status_t frv;   /* last known status of writing to the output filter */
static apr_status_t store_body(cache_handle_t *h, ap_filter_t *f, apr_bucket_brigade *b);
static apr_status_t store_body(cache_handle_t *h, ap_filter_t *f, apr_bucket_brigade *b)
    request_rec *r = f->r;
                ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                         "mem_cache: Failed to open file '%s' while attempting to cache the file descriptor.", name);
                return ap_pass_brigade(f->next, b);
            return ap_pass_brigade(f->next, b);
            /* we didn't have space to cache it, fall back gracefully */
            cleanup_cache_object(obj);
            ap_remove_output_filter(f);
            ap_log_error(APLOG_MARK, APLOG_ERR, APR_ENOMEM, r->server,
                         "mem_cache: Could not store body - not enough memory.");
            return ap_pass_brigade(f->next, b);
                    /* we didn't have space to cache it, fall back gracefully */
                    cleanup_cache_object(obj);
                    ap_remove_output_filter(f);
                    ap_log_error(APLOG_MARK, APLOG_ERR, APR_ENOMEM, r->server,
                                 "mem_cache: Could not store next bit of body - not enough memory.");
                    return ap_pass_brigade(f->next, b);
            cleanup_cache_object(obj);
            /* not being able to read the bucket is fatal,
             * return this up the filter stack
             */
            if ((obj->count + len) > mobj->m_len) {
                /* we didn't have space to cache it, fall back gracefully */
                cleanup_cache_object(obj);
                ap_remove_output_filter(f);
                ap_log_error(APLOG_MARK, APLOG_ERR, APR_ENOMEM, r->server,
                             "mem_cache: Could not store body - buffer overflow.");
                return ap_pass_brigade(f->next, b);
            }
            else {
            }
    return ap_pass_brigade(f->next, b);

            if (r->status == HTTP_BAD_REQUEST) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                              "request failed: invalid characters in URI");
            }
            else {
    BIO *bio;
            char *cp;
            char *cp2;
            bio = BIO_new(BIO_s_mem());
            BIO_printf(bio, "lastUpdate: ");
            n = BIO_pending(bio);
            cp = malloc(n+1);
            n = BIO_read(bio, cp, n);
            cp[n] = NUL;
            BIO_free(bio);

            cp2 = X509_NAME_oneline(subject, NULL, 0);
            ssl_log(s, SSL_LOG_TRACE, "CA CRL: Issuer: %s, %s", cp2, cp);
            free(cp2);
            free(cp);
#include "http_main.h"
#include "apr_strings.h"
static void skiplf(BUFF *foo)
{
	char c;
	do
	{
		c = ap_bgetc(foo);
	} while(c != '\n');
}
/*
 * Returns the ftp status code;
 *  or -1 on I/O error, 0 on data error
 */
static int ftp_getrc(BUFF *f)
{
    int len, status;
    char linebuff[100], buff[5];

    len = ap_bgets(linebuff, sizeof linebuff, f);
    if (len == -1)
	return -1;
/* check format */
    if (len < 5 || !apr_isdigit(linebuff[0]) || !apr_isdigit(linebuff[1]) ||
	!apr_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
	status = 0;
    else
	status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';

    if (linebuff[len - 1] != '\n') {
		skiplf(f);
    }

/* skip continuation lines */
    if (linebuff[3] == '-') {
	memcpy(buff, linebuff, 3);
	buff[3] = ' ';
	do {
	    len = ap_bgets(linebuff, sizeof linebuff, f);
	    if (len == -1)
		return -1;
	    if (linebuff[len - 1] != '\n') {
			skiplf(f);
	    }
	} while (memcmp(linebuff, buff, 4) != 0);
    }

    return status;
}
static int ftp_getrc_msg(BUFF *f, char *msgbuf, int msglen)
    char linebuff[100], buff[5];
    len = ap_bgets(linebuff, sizeof linebuff, f);
    if (len == -1)
    if (len < 5 || !apr_isdigit(linebuff[0]) || !apr_isdigit(linebuff[1]) ||
	!apr_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
	status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';
    mb = apr_cpystrn(mb, linebuff+4, me - mb);
    if (linebuff[len - 1] != '\n')
		skiplf(f);
    if (linebuff[3] == '-') {
	memcpy(buff, linebuff, 3);
	    len = ap_bgets(linebuff, sizeof linebuff, f);
	    if (linebuff[len - 1] != '\n') {
			skiplf(f);
	    }
	    mb = apr_cpystrn(mb, linebuff+4, me - mb);
	} while (memcmp(linebuff, buff, 4) != 0);
int ap_proxy_ftp_handler(request_rec *r, ap_cache_el *c, char *url)
    char *host, *path, *strp, *parms;
    apr_socket_t *sock, *dsock, *inc;
    int port, i, j, len, rc, nocache = 0;
    apr_socket_t *csd;
    struct in_addr destaddr;
    apr_table_t *resp_hdrs;
    BUFF *f;
    BUFF *data = NULL;
    apr_file_t *cachefp = NULL;
    apr_pool_t *p = r->pool;
    const long int zero = 0L;
    struct noproxy_entry *npent = (struct noproxy_entry *) conf->noproxies->elts;
    struct nocache_entry *ncent = (struct nocache_entry *) conf->nocaches->elts;
    apr_sockaddr_t *localsa;

/* stuff for PASV mode */
    unsigned int presult, h0, h1, h2, h3, p0, p1;
    unsigned short pport;
    int pasvmode = 0;
    char pasv[64];
    char *pstr, dates[AP_RFC822_DATE_LEN];
    char *npaddr;
    apr_port_t npport;
	
/* stuff for responses */
    char resp[MAX_STRING_LEN];
    char *size = NULL;
/* we only support GET and HEAD */
/* We break the URL into host, port, path-search */

    host = r->parsed_uri.hostname;
    port = (r->parsed_uri.port != 0)
	    ? r->parsed_uri.port
	    : ap_default_port_for_request(r);
	nocache = 1;	/* This resource only accessible with username/password */
	nocache = 1;	/* This resource only accessible with username/password */
/* check if ProxyBlock directive on this host */
    destaddr.s_addr = ap_inet_addr(host);
    for (i = 0; i < conf->noproxies->nelts; i++) {
	if ((npent[i].name != NULL && ap_strstr_c(host, npent[i].name) != NULL)
	    || destaddr.s_addr == npent[i].addr.s_addr || npent[i].name[0] == '*')
	    return ap_proxyerror(r, HTTP_FORBIDDEN,
				 "Connect to remote machine blocked");
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                 "FTP: connect to %s:%d", host, port);
    parms = strchr(path, ';');
    if (parms != NULL)
	*(parms++) = '\0';
    if (ap_proxy_doconnect(sock, host, port, r) != APR_SUCCESS) {
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_pstrcat(r->pool,
				"Could not connect to remote machine: ",
				host, NULL));
    f = ap_bcreate(p, B_RDWR);
    ap_bpush_socket(f, sock);
/* shouldn't we implement telnet control options here? */
#if APR_CHARSET_EBCDIC
    ap_bsetflag(f, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 1);
#endif /*APR_CHARSET_EBCDIC*/
/* possible results: */
    /* 120 Service ready in nnn minutes. */
    /* 220 Service ready for new user. */
    /* 421 Service not available, closing control connection. */
    i = ftp_getrc_msg(f, resp, sizeof resp);
				 "FTP: returned status %d", i);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, resp);
    ap_bvputs(f, "USER ", user, CRLF, NULL);
    ap_bflush(f);			/* capture any errors */
/* possible results; 230, 331, 332, 421, 500, 501, 530 */
/* states: 1 - error, 2 - success; 3 - send password, 4,5 fail */
    /* 230 User logged in, proceed. */
    /* 331 User name okay, need password. */
    /* 332 Need account for login. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /*     (This may include errors such as command line too long.) */
    /* 501 Syntax error in parameters or arguments. */
    /* 530 Not logged in. */
    i = ftp_getrc(f);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
			     "Error reading from remote server");
	ap_bvputs(f, "PASS ", password, CRLF, NULL);
	ap_bflush(f);
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
/* possible results 202, 230, 332, 421, 500, 501, 503, 530 */
    /* 230 User logged in, proceed. */
    /* 332 Need account for login. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 503 Bad sequence of commands. */
    /* 530 Not logged in. */
	i = ftp_getrc(f);
				 "Need account for login");
/* set the directory (walk directory component by component):
 * this is what we must do if we don't know the OS type of the remote
 * machine
 */
	ap_bvputs(f, "CWD ", path, CRLF, NULL);
	ap_bflush(f);
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
/* responses: 250, 421, 500, 501, 502, 530, 550 */
    /* 250 Requested file action okay, completed. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 530 Not logged in. */
    /* 550 Requested action not taken. */
	i = ftp_getrc(f);
	    return HTTP_NOT_FOUND;
	    return HTTP_BAD_GATEWAY;
	/* TM - Added CRLF to the end of TYPE I, otherwise it hangs the
	   connection */
	ap_bputs("TYPE I" CRLF, f);
	ap_bflush(f);
/* responses: 200, 421, 500, 501, 504, 530 */
    /* 200 Command okay. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 504 Command not implemented for that parameter. */
    /* 530 Not logged in. */
	i = ftp_getrc(f);
	    return HTTP_BAD_GATEWAY;
/* Allow not implemented */
/* try to set up PASV data connection first */
    if ((apr_socket_create(&dsock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
	ap_bclose(f);
    if (conf->recv_buffer_size > 0 && apr_setsocketopt(dsock, APR_SO_RCVBUF,
    ap_bputs("PASV" CRLF, f);
    ap_bflush(f);
/* possible results: 227, 421, 500, 501, 502, 530 */
    /* 227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 530 Not logged in. */
    i = ap_bgets(pasv, sizeof(pasv), f);
    if (i == -1) {
	apr_socket_close(dsock);
	ap_bclose(f);
	return HTTP_INTERNAL_SERVER_ERROR;
	pasv[i - 1] = '\0';
                     "FTP: returned status %d", presult);
	    /* pardon the parens, but it makes gcc happy */
	    destaddr.s_addr = htonl((((((h3 << 8) + h2) << 8) + h1) << 8) + h0);
	    pport = (p1 << 8) + p0;
                         "FTP: contacting host %d.%d.%d.%d:%d",
                         h3, h2, h1, h0, pport);
/* scary */
            if (ap_proxy_doconnect(dsock, inet_ntoa(destaddr), pport, r) == APR_SUCCESS) {
		return ap_proxyerror(r, HTTP_BAD_GATEWAY,
		    apr_pstrcat(r->pool,
		    "Could not connect to remote machine: ",
		    inet_ntoa(destaddr), NULL));
	    }
	    apr_socket_close(dsock);	/* and try the regular way */
    if (!pasvmode) {		/* set up data connection */
	if ((apr_socket_create(&dsock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
	    ap_bclose(f);
        apr_socket_addr_get(&localsa, APR_LOCAL, sock);
        apr_sockaddr_port_get(&npport, localsa);
        apr_sockaddr_ip_get(&npaddr, localsa);
	if (apr_setsocketopt(dsock, APR_SO_REUSEADDR, one) != APR_SUCCESS) {
	    apr_socket_close(dsock);
	    ap_bclose(f);
        if (apr_sockaddr_info_get(&localsa, npaddr, APR_INET, npport, 0, r->pool) 
            != APR_SUCCESS) {
            ap_bclose(f);
	if (apr_bind(dsock, localsa) != APR_SUCCESS) {
	    apr_snprintf(buff, sizeof(buff), "%s:%d", npaddr, npport);
	    ap_bclose(f);
	    apr_socket_close(dsock);
	apr_listen(dsock, 2);	/* only need a short queue */
/* set request; "path" holds last path component */
	ap_bvputs(f, "SIZE ", path, CRLF, NULL);
	ap_bflush(f);
	i = ftp_getrc_msg(f, resp, sizeof resp);
                     "FTP: returned status %d with response %s", i, resp);
		ap_bvputs(f, "CWD ", path, CRLF, NULL);
		ap_bflush(f);
		i = ftp_getrc(f);
		    return HTTP_NOT_FOUND;
		    return HTTP_BAD_GATEWAY;
		for (j = 0; j < sizeof resp && apr_isdigit(resp[j]); j++)
			;
		resp[j] = '\0';
		if (resp[0] != '\0')
		    size = apr_pstrdup(p, resp);
    ap_bvputs(f, "PWD", CRLF, NULL);
    ap_bflush(f);
/* responses: 257, 500, 501, 502, 421, 550 */
    /* 257 "<directory-name>" <commentary> */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 550 Requested action not taken. */
    i = ftp_getrc_msg(f, resp, sizeof resp);
	return HTTP_NOT_FOUND;
	const char *dirp = resp;
			ap_bvputs(f, "LIST ", path, CRLF, NULL);
			ap_bputs("LIST -lag" CRLF, f);
					 "FTP: LIST %s", (len == 0 ? "" : path));
		ap_bvputs(f, "RETR ", path, CRLF, NULL);
    ap_bflush(f);
/* RETR: 110, 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 530, 550
   NLST: 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 502, 530 */
    /* 110 Restart marker reply. */
    /* 125 Data connection already open; transfer starting. */
    /* 150 File status okay; about to open data connection. */
    /* 226 Closing data connection. */
    /* 250 Requested file action okay, completed. */
    /* 421 Service not available, closing control connection. */
    /* 425 Can't open data connection. */
    /* 426 Connection closed; transfer aborted. */
    /* 450 Requested file action not taken. */
    /* 451 Requested action aborted. Local error in processing. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 530 Not logged in. */
    /* 550 Requested action not taken. */
    rc = ftp_getrc(f);
	ap_bvputs(f, "CWD ", path, CRLF, NULL);
	ap_bflush(f);
	rc = ftp_getrc(f);
	    return HTTP_NOT_FOUND;
	    return HTTP_BAD_GATEWAY;
	ap_bvputs(f, "PWD", CRLF, NULL);
	ap_bflush(f);
	i = ftp_getrc_msg(f, resp, sizeof resp);
	    return HTTP_NOT_FOUND;
	    const char *dirp = resp;
	ap_bputs("LIST -lag" CRLF, f);
	ap_bflush(f);
	rc = ftp_getrc(f);
    if (rc != 125 && rc != 150 && rc != 226 && rc != 250)
	return HTTP_BAD_GATEWAY;
    resp_hdrs = ap_make_table(p, 2);
	
    apr_table_setn(resp_hdrs, "Date", dates);
    apr_table_setn(resp_hdrs, "Server", ap_get_server_version());
		apr_table_setn(resp_hdrs, "Content-Type", "text/html");
	    apr_table_setn(resp_hdrs, "Content-Type", r->content_type);
		ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
		 "FTP: Content-Type set to %s", r->content_type);
	    apr_table_setn(resp_hdrs, "Content-Type", ap_default_type(r));
	    apr_table_setn(resp_hdrs, "Content-Length", size);
	apr_table_setn(resp_hdrs, "Content-Encoding", r->content_encoding);
    }
	ap_cache_el_header_merge(c, resp_hdrs);
	
/* check if NoCache directive on this host */
    for (i = 0; i < conf->nocaches->nelts; i++) {
	if ((ncent[i].name != NULL && ap_strstr_c(host, ncent[i].name) != NULL)
	    || destaddr.s_addr == ncent[i].addr.s_addr || ncent[i].name[0] == '*')
	    nocache = 1;
    }

#if 0
    i = ap_proxy_cache_update(c, resp_hdrs, 0, nocache);

    if (i != DECLINED) {
	ap_pclosesocket(p, dsock);
	ap_bclose(f);
	return i;
#endif

    if(nocache || !ap_proxy_cache_should_cache(r, resp_hdrs, 0))
        ap_proxy_cache_error(&c);
    else
        ap_cache_el_data(c, &cachefp);
    if (!pasvmode) {		/* wait for connection */
            switch(apr_accept(&inc, dsock, r->pool))
                apr_socket_close(dsock);
                ap_bclose(f);
                if (c != NULL) ap_proxy_cache_error(&c);
        data = ap_bcreate(p, B_RDWR);
        ap_bpush_socket(f, csd);
    }
    else {
	data = ap_bcreate(p, B_RDWR);
	ap_bpush_socket(data, dsock);
/* send response */
/* write status line */
    if (!r->assbackwards)
	ap_rvputs(r, "HTTP/1.0 ", r->status_line, CRLF, NULL);
        if (cachefp && apr_file_puts(apr_pstrcat(r->pool, "HTTP/1.0 ",
          r->status_line, CRLF, NULL), cachefp) != APR_SUCCESS) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
		"proxy: error writing CRLF to cache");
	    ap_proxy_cache_error(&c);
            cachefp = NULL;
/* send headers */
    ap_cache_el_header_walk(c, ap_proxy_send_hdr_line, r, NULL);
    if (!r->assbackwards)
	ap_rputs(CRLF, r);
    if (cachefp && apr_file_puts(CRLF, cachefp) == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
	    "proxy: error writing CRLF to cache");
	ap_proxy_cache_error(&c);
        cachefp = NULL;
    }
/* This is done by a filter now, so this can probably be removed cleanly.
    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
*/
/* send body */
	if (parms[0] != 'd') {
	    ap_proxy_send_fb(NULL, data, r, c);
	} else
	    send_dir(data, r, c, cwd);

	if (rc == 125 || rc == 150)
	    rc = ftp_getrc(f);

	/* XXX: we checked for 125||150||226||250 above. This is redundant. */
	if (rc != 226 && rc != 250)
            /* XXX: we no longer log an "error writing to c->tempfile" - should we? */
	    ap_proxy_cache_error(&c);
/* abort the transfer */
	ap_bputs("ABOR" CRLF, f);
	ap_bflush(f);
	if (!pasvmode)
	    ap_bclose(data);
/* responses: 225, 226, 421, 500, 501, 502 */
    /* 225 Data connection open; no transfer in progress. */
    /* 226 Closing data connection. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    i = ftp_getrc(f);
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                 "FTP: returned status %d", i);
/* finish */
    ap_bputs("QUIT" CRLF, f);
    ap_bflush(f);
/* responses: 221, 500 */
    /* 221 Service closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    i = ftp_getrc(f);
    if (pasvmode)
	ap_bclose(data);
    ap_bclose(f);

    ap_rflush(r);	/* flush before garbage collection */

    if(c) ap_proxy_cache_update(c);
    size_t recv_buffer_size;
        while (ap_get_brigade(data->input_filters, bb, AP_MODE_EXHAUSTIVE,
                              APR_BLOCK_READ, 0) == APR_SUCCESS) {
            if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
                ap_pass_brigade(r->output_filters, bb);
                break;
    ap_flush_conn(data);
    apr_socket_close(data_sock);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
                 "proxy: FTP: Closing Data connection.");
             * if we are overriding the errors, we cant put the content of the
             * page into the brigade
            /* read the body, pass it to the output filters */
                                      AP_IOBUFSIZE) == APR_SUCCESS) {
                        ap_pass_brigade(r->output_filters, bb);
                        break;
                    e = apr_bucket_flush_create();
                    APR_BRIGADE_INSERT_TAIL(bb, e);
                        break;
        apr_socket_close(p_conn->sock);
        backend->connection = NULL;
        return cache->provider->store_body(cache->handle, f, in);
    return cache->provider->store_body(cache->handle, f, in);
    apr_status_t (*store_body)(cache_handle_t *h, ap_filter_t *f, apr_bucket_brigade *b);
 * Always first in the header file:
 *   disk_cache_format_t format;
 *
 * VARY_FORMAT_VERSION:
 * DISK_FORMAT_VERSION:
 *   disk_cache_info_t
static apr_status_t store_body(cache_handle_t *h, ap_filter_t *f, apr_bucket_brigade *b);
/*
 * Modified file bucket implementation to be able to deliver files
 * while caching.
 */

/* Derived from apr_buckets_file.c */

#define BUCKET_IS_DISKCACHE(e)        ((e)->type == &bucket_type_diskcache)
APU_DECLARE_DATA const apr_bucket_type_t bucket_type_diskcache;

static void diskcache_bucket_destroy(void *data)
{
    diskcache_bucket_data *f = data;

    if (apr_bucket_shared_destroy(f)) {
        /* no need to close files here; it will get
         * done automatically when the pool gets cleaned up */
        apr_bucket_free(f);
    }
}


/* The idea here is to convert diskcache buckets to regular file buckets
   as data becomes available */
/* FIXME: Maybe we should care about the block argument, right now we're
          always blocking */
static apr_status_t diskcache_bucket_read(apr_bucket *e, const char **str,
                                          apr_size_t *len, 
                                          apr_read_type_e block)
{
    diskcache_bucket_data *a = e->data;
    apr_file_t *f = a->fd;
    apr_bucket *b = NULL;
    char *buf;
    apr_status_t rv;
    apr_finfo_t finfo;
    apr_size_t filelength = e->length; /* bytes remaining in file past offset */
    apr_off_t fileoffset = e->start;
    apr_off_t fileend;
    apr_size_t available;
#if APR_HAS_THREADS && !APR_HAS_XTHREAD_FILES
    apr_int32_t flags;
#endif

#if APR_HAS_THREADS && !APR_HAS_XTHREAD_FILES
    if ((flags = apr_file_flags_get(f)) & APR_XTHREAD) {
        /* this file descriptor is shared across multiple threads and
         * this OS doesn't support that natively, so as a workaround
         * we must reopen the file into a->readpool */
        const char *fname;
        apr_file_name_get(&fname, f);

        rv = apr_file_open(&f, fname, (flags & ~APR_XTHREAD), 0, a->readpool);
        if (rv != APR_SUCCESS)
            return rv;

        a->fd = f;
    }
#endif

    /* in case we die prematurely */
    *str = NULL;
    *len = 0;

    while(1) {
        /* Figure out how big the file is right now, sit here until
           it's grown enough or we get bored */
        fileend = 0;
        rv = apr_file_seek(f, APR_END, &fileend);
        if(rv != APR_SUCCESS) {
            return rv;
        }

        if(fileend >= fileoffset + MIN(filelength, CACHE_BUF_SIZE)) {
            break;
        }

        rv = apr_file_info_get(&finfo, APR_FINFO_MTIME, f);
        if(rv != APR_SUCCESS ||
                finfo.mtime < (apr_time_now() - a->updtimeout) ) 
        {
            return APR_EGENERAL;
        }
        apr_sleep(CACHE_LOOP_SLEEP);
    }

    /* Convert this bucket to a zero-length heap bucket so we won't be called
       again */
    buf = apr_bucket_alloc(0, e->list);
    apr_bucket_heap_make(e, buf, 0, apr_bucket_free);

    /* Wrap as much as possible into a regular file bucket */
    available = MIN(filelength, fileend-fileoffset);
    b = apr_bucket_file_create(f, fileoffset, available, a->readpool, e->list);
    APR_BUCKET_INSERT_AFTER(e, b);

    /* Put any remains in yet another bucket */
    if(available < filelength) {
        e=b;
        /* for efficiency, we can just build a new apr_bucket struct
         * to wrap around the existing bucket */
        b = apr_bucket_alloc(sizeof(*b), e->list);
        b->start  = fileoffset + available;
        b->length = filelength - available;
        b->data   = a;
        b->type   = &bucket_type_diskcache;
        b->free   = apr_bucket_free;
        b->list   = e->list;
        APR_BUCKET_INSERT_AFTER(e, b);
    }
    else {
        diskcache_bucket_destroy(a);
    }

    *str = buf;
    return APR_SUCCESS;
}

static apr_bucket * diskcache_bucket_make(apr_bucket *b,
                                                apr_file_t *fd,
                                                apr_off_t offset,
                                                apr_size_t len, 
                                                apr_interval_time_t timeout,
                                                apr_pool_t *p)
{
    diskcache_bucket_data *f;

    f = apr_bucket_alloc(sizeof(*f), b->list);
    f->fd = fd;
    f->readpool = p;
    f->updtimeout = timeout;

    b = apr_bucket_shared_make(b, f, offset, len);
    b->type = &bucket_type_diskcache;

    return b;
}

static apr_bucket * diskcache_bucket_create(apr_file_t *fd,
                                                  apr_off_t offset,
                                                  apr_size_t len, 
                                                  apr_interval_time_t timeout,
                                                  apr_pool_t *p,
                                                  apr_bucket_alloc_t *list)
{
    apr_bucket *b = apr_bucket_alloc(sizeof(*b), list);

    APR_BUCKET_INIT(b);
    b->free = apr_bucket_free;
    b->list = list;
    return diskcache_bucket_make(b, fd, offset, len, timeout, p);
}


/* FIXME: This is probably only correct for the first case, that seems
   to be the one that occurs all the time... */
static apr_status_t diskcache_bucket_setaside(apr_bucket *data, 
                                              apr_pool_t *reqpool)
{
    diskcache_bucket_data *a = data->data;
    apr_file_t *fd = NULL;
    apr_file_t *f = a->fd;
    apr_pool_t *curpool = apr_file_pool_get(f);

    if (apr_pool_is_ancestor(curpool, reqpool)) {
        return APR_SUCCESS;
    }

    if (!apr_pool_is_ancestor(a->readpool, reqpool)) {
        /* FIXME: Figure out what needs to be done here */
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                "disk_cache: diskcache_bucket_setaside: FIXME1");
        a->readpool = reqpool;
    }

    /* FIXME: Figure out what needs to be done here */
    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
            "disk_cache: diskcache_bucket_setaside: FIXME2");

    apr_file_setaside(&fd, f, reqpool);
    a->fd = fd;
    return APR_SUCCESS;
}

APU_DECLARE_DATA const apr_bucket_type_t bucket_type_diskcache = {
    "DISKCACHE", 5, APR_BUCKET_DATA,
    diskcache_bucket_destroy,
    diskcache_bucket_read,
    diskcache_bucket_setaside,
    apr_bucket_shared_split,
    apr_bucket_shared_copy
};

/* From apr_brigade.c */

/* A "safe" maximum bucket size, 1Gb */
#define MAX_BUCKET_SIZE (0x40000000)

static apr_bucket * diskcache_brigade_insert(apr_bucket_brigade *bb,
                                                   apr_file_t *f, apr_off_t
                                                   start, apr_off_t length,
                                                   apr_interval_time_t timeout,
                                                   apr_pool_t *p)
{
    apr_bucket *e;

    if (length < MAX_BUCKET_SIZE) {
        e = diskcache_bucket_create(f, start, (apr_size_t)length, timeout, p, 
                bb->bucket_alloc);
    }
    else {
        /* Several buckets are needed. */        
        e = diskcache_bucket_create(f, start, MAX_BUCKET_SIZE, timeout, p, 
                bb->bucket_alloc);

        while (length > MAX_BUCKET_SIZE) {
            apr_bucket *ce;
            apr_bucket_copy(e, &ce);
            APR_BRIGADE_INSERT_TAIL(bb, ce);
            e->start += MAX_BUCKET_SIZE;
            length -= MAX_BUCKET_SIZE;
        }
        e->length = (apr_size_t)length; /* Resize just the last bucket */
    }

    APR_BRIGADE_INSERT_TAIL(bb, e);
    return e;
}

/* --------------------------------------------------------------- */

static apr_status_t mkdir_structure(disk_cache_conf *conf, const char *file, apr_pool_t *pool)
    apr_status_t rv = APR_SUCCESS;
        *p = '/';
            break;
    if (rv != APR_SUCCESS && !APR_STATUS_IS_EEXIST(rv)) {
        return rv;
    }

    return APR_SUCCESS;
    dobj->initial_size = len;
    dobj->file_size = -1;
    dobj->updtimeout = conf->updtimeout;
    dobj->frv = APR_SUCCESS;

static apr_status_t file_read_timeout(apr_file_t *file, char * buf,
                                      apr_size_t len, apr_time_t timeout)
    apr_size_t left, done;
    apr_finfo_t finfo;
    done = 0;
    left = len;

    while(1) {
        rc = apr_file_read_full(file, buf+done, left, &len);
        if (rc == APR_SUCCESS) {
           break;
        }
        done += len;
        left -= len;
        if(!APR_STATUS_IS_EOF(rc)) {
            return rc;
        }
        rc = apr_file_info_get(&finfo, APR_FINFO_MTIME, file);
        if(rc != APR_SUCCESS) {
           return rc;
        }
        if(finfo.mtime < (apr_time_now() - timeout) ) {
            return APR_ETIMEDOUT;
        apr_sleep(CACHE_LOOP_SLEEP);
    return APR_SUCCESS;
}
static apr_status_t open_header(cache_handle_t *h, request_rec *r, 
                                const char *key, disk_cache_conf *conf)
{
    int flags;
    disk_cache_format_t format;
    apr_status_t rc;
    const char *nkey = key;
    disk_cache_info_t disk_info;
    cache_object_t *obj = h->cache_obj;
    disk_cache_object_t *dobj = obj->vobj;
    flags = APR_READ|APR_BINARY|APR_BUFFERED;
        return CACHE_EDECLINED;
    rc = apr_file_read_full(dobj->hfd, &format, sizeof(format), NULL);
    if(APR_STATUS_IS_EOF(rc)) {
        return CACHE_ENODATA;
    }
    else if(rc != APR_SUCCESS) {
        return rc;
    }
    /* Vary-files are being written to tmpfile and moved in place, so
       the should always be complete */
        rc = apr_file_read_full(dobj->hfd, &expire, sizeof(expire), NULL);
        if(rc != APR_SUCCESS) {
            return rc;
        }
            return CACHE_EDECLINED;
            return CACHE_EDECLINED;
        dobj->hdrsfile = data_file(r->pool, conf, dobj, nkey);
            dobj->hfd = NULL;
            return CACHE_EDECLINED;
        }
        rc = apr_file_read_full(dobj->hfd, &format, sizeof(format), NULL);
        if(APR_STATUS_IS_EOF(rc)) {
            return CACHE_ENODATA;
        }
        else if(rc != APR_SUCCESS) {
            return rc;

    if(format != DISK_FORMAT_VERSION) {
        ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                     "disk_cache: File '%s' had a version mismatch. File had "
                     "version: %d (current is %d). Deleted.", dobj->hdrsfile,
                     format, DISK_FORMAT_VERSION);
        file_cache_errorcleanup(dobj, r);
        return CACHE_EDECLINED;
    /* read the data from the header file */
    rc = apr_file_read_full(dobj->hfd, &disk_info, sizeof(disk_info), NULL);
    if(APR_STATUS_IS_EOF(rc)) {
        return CACHE_ENODATA;
    else if(rc != APR_SUCCESS) {
        return rc;
    /* Store it away so we can get it later. */
    dobj->disk_info = disk_info;
    return APR_SUCCESS;

static apr_status_t open_header_timeout(cache_handle_t *h, request_rec *r, 
                                const char *key, disk_cache_conf *conf,
                                disk_cache_object_t *dobj)
    apr_status_t rc;
    apr_finfo_t finfo;

    while(1) {
        if(dobj->hfd) {
            apr_file_close(dobj->hfd);
            dobj->hfd = NULL;
        }
        rc = open_header(h, r, key, conf);
        if(rc != APR_SUCCESS && rc != CACHE_ENODATA) {
            if(rc != CACHE_EDECLINED) {
                ap_log_error(APLOG_MARK, APLOG_ERR, rc, r->server,
                             "disk_cache: Cannot load header file: %s",
                             dobj->hdrsfile);
            }
            return rc;
        }

        /* Objects with unknown body size will have file_size == -1 until the
           entire body is written and the header updated with the actual size.
           And since we depend on knowing the body size we wait until the size
           is written */
        if(rc == APR_SUCCESS && dobj->disk_info.file_size >= 0) {
            break;
        }
        rc = apr_file_info_get(&finfo, APR_FINFO_MTIME, dobj->hfd);
        if(rc != APR_SUCCESS) {
            return rc;
        }
        if(finfo.mtime < (apr_time_now() - dobj->updtimeout)) {
            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, r->server,
                         "disk_cache: Timed out waiting for header for URL %s"
                         " - caching the body failed?", key);
            return CACHE_EDECLINED;
        }
        apr_sleep(CACHE_LOOP_SLEEP);
    }

    return APR_SUCCESS;

static apr_status_t open_body_timeout(request_rec *r, const char *key, 
                                      disk_cache_object_t *dobj)
    apr_off_t off;
    apr_time_t starttime = apr_time_now();
    int flags;
#if APR_HAS_SENDFILE
    core_dir_config *pdconf = ap_get_module_config(r->per_dir_config,
                                                   &core_module);
#endif  
    flags = APR_READ|APR_BINARY|APR_BUFFERED;
#if APR_HAS_SENDFILE
    flags |= ((pdconf->enable_sendfile == ENABLE_SENDFILE_OFF)
             ? 0 : APR_SENDFILE_ENABLED);
#endif  

    /* Wait here until we get a body cachefile, data in it, and do quick sanity
     * check */

    while(1) {
        if(dobj->fd == NULL) {
            rc = apr_file_open(&dobj->fd, dobj->datafile, flags, 0, r->pool);
            if(rc != APR_SUCCESS) {
                if(starttime < (apr_time_now() - dobj->updtimeout) ) {
                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, r->server,
                                 "disk_cache: Timed out waiting for body for "
                                 "URL %s - caching failed?", key);
                    return CACHE_EDECLINED;
                }
                apr_sleep(CACHE_LOOP_SLEEP);
                continue;
            }
        }
        dobj->file_size = 0;
        rc = apr_file_seek(dobj->fd, APR_END, &dobj->file_size);
        if(rc != APR_SUCCESS) {
            return rc;
        }
        if(dobj->initial_size < dobj->file_size) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: Bad cached body for URL %s, size %"
                         APR_OFF_T_FMT " != %" APR_OFF_T_FMT,  dobj->name,
                         dobj->initial_size, dobj->file_size);
            file_cache_errorcleanup(dobj, r);
            return CACHE_EDECLINED;
        }
        else if(dobj->initial_size > dobj->file_size) {
            /* Still caching or failed? */
            apr_finfo_t finfo;

            rc = apr_file_info_get(&finfo, APR_FINFO_MTIME, dobj->fd);
            if(rc != APR_SUCCESS ||
                    finfo.mtime < (apr_time_now() - dobj->updtimeout) ) 
            {
                ap_log_error(APLOG_MARK, APLOG_WARNING, rc, r->server,
                             "disk_cache: Body for URL %s is too small - "
                             "caching the body failed?", dobj->name);
                return CACHE_EDECLINED;
            }
        }
        if(dobj->file_size > 0) {
            break;
        apr_sleep(CACHE_LOOP_SLEEP);
    }

    /* Go back to the beginning */
    off = 0;
    rc = apr_file_seek(dobj->fd, APR_SET, &off);
    if(rc != APR_SUCCESS) {
        return rc;
    return APR_SUCCESS;
}


static int open_entity(cache_handle_t *h, request_rec *r, const char *key)
{
    apr_status_t rc;
    disk_cache_object_t *dobj;
    cache_info *info;
    apr_size_t len;
    static int error_logged = 0;
    disk_cache_conf *conf = ap_get_module_config(r->server->module_config,
                                                 &disk_cache_module);
    char urlbuff[MAX_STRING_LEN];

    h->cache_obj = NULL;

    /* Look up entity keyed to 'url' */
    if (conf->cache_root == NULL) {
        if (!error_logged) {
            error_logged = 1;
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: Cannot cache files to disk without a "
                         "CacheRoot specified.");
        }
        return DECLINED;
    }

    /* Create and init the cache object */
    h->cache_obj = apr_pcalloc(r->pool, sizeof(cache_object_t));
    h->cache_obj->vobj = dobj = apr_pcalloc(r->pool, sizeof(disk_cache_object_t));
    info = &(h->cache_obj->info);

    /* Save the cache root */
    dobj->root = apr_pstrndup(r->pool, conf->cache_root, conf->cache_root_len);
    dobj->root_len = conf->cache_root_len;

    dobj->hdrsfile = header_file(r->pool, conf, dobj, key);

    dobj->updtimeout = conf->updtimeout;

    /* Open header and read basic info, wait until header contains
       valid size information for the body */
    rc = open_header_timeout(h, r, key, conf, dobj);
    if(rc != APR_SUCCESS) {
        return DECLINED;
    }

    /* TODO: We have the ability to serve partially cached requests,
     * however in order to avoid some sticky what if conditions
     * should the content turn out to be too large to be cached,
     * we must only allow partial cache serving if the cached
     * entry has a content length known in advance.
     */

    info->status = dobj->disk_info.status;
    info->date = dobj->disk_info.date;
    info->expire = dobj->disk_info.expire;
    info->request_time = dobj->disk_info.request_time;
    info->response_time = dobj->disk_info.response_time;

    dobj->initial_size = (apr_off_t) dobj->disk_info.file_size;
    dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);

    len = dobj->disk_info.name_len;

    if(len > 0) {
        rc = file_read_timeout(dobj->hfd, urlbuff, len, dobj->updtimeout);
        if (rc == APR_ETIMEDOUT) {
            ap_log_error(APLOG_MARK, APLOG_WARNING, rc, r->server,
                         "disk_cache: Timed out waiting for urlbuff for "
                         "URL %s - caching failed?",  key);
            return DECLINED;
        }
        else if(rc != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_WARNING, rc, r->server,
                         "disk_cache: Error reading urlbuff for URL %s",
                         key);
            return DECLINED;
        }
    }
    urlbuff[len] = '\0';

    /* check that we have the same URL */
    if (strcmp(urlbuff, dobj->name) != 0) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "disk_cache: Cached URL %s didn't match requested "
                     "URL %s", urlbuff, dobj->name);
        return DECLINED;
    }

    dobj->datafile = data_file(r->pool, conf, dobj, h->cache_obj->key);
    dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);

    /* Only need body cachefile if we have a body */
    if(dobj->initial_size > 0) {
        rc = open_body_timeout(r, key, dobj);
        if(rc != APR_SUCCESS) {
            return DECLINED;
        }
    }
    else {
        dobj->file_size = 0;
    }

    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "disk_cache: Recalled status for cached URL %s",  dobj->name);
    return OK;
}


static int remove_entity(cache_handle_t *h)
{
    /* Null out the cache object pointer so next time we start from scratch  */
    h->cache_obj = NULL;
    return OK;
}

static int remove_url(cache_handle_t *h, apr_pool_t *p)
{
    apr_status_t rc;
    disk_cache_object_t *dobj;

    /* Get disk cache object from cache handle */
    dobj = (disk_cache_object_t *) h->cache_obj->vobj;
    if (!dobj) {
        return DECLINED;
    }

    /* Delete headers file */
    if (dobj->hdrsfile) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                     "disk_cache: Deleting %s from cache.", dobj->hdrsfile);

        rc = apr_file_remove(dobj->hdrsfile, p);
        if ((rc != APR_SUCCESS) && !APR_STATUS_IS_ENOENT(rc)) {
            /* Will only result in an output if httpd is started with -e debug.
             * For reason see log_error_core for the case s == NULL.
             */
            ap_log_error(APLOG_MARK, APLOG_DEBUG, rc, NULL,
                   "disk_cache: Failed to delete headers file %s from cache.",
                         dobj->hdrsfile);
            return DECLINED;
        }
    }

     /* Delete data file */
    if (dobj->datafile) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                     "disk_cache: Deleting %s from cache.", dobj->datafile);
static apr_status_t read_table(request_rec *r,
                             "disk_cache: CGI Interface Error: Script headers apparently ASCII: (CGI = %s)",

static apr_status_t read_table_timeout(cache_handle_t *handle, request_rec *r,
                               apr_table_t **table, apr_file_t *file,
                               apr_time_t timeout)
{
    apr_off_t off;
    apr_finfo_t finfo;
    apr_status_t rv;

    off = 0;
    rv = apr_file_seek(file, APR_CUR, &off);
    if(rv != APR_SUCCESS) {
        return rv;
    }

    while(1) {
        *table = apr_table_make(r->pool, 20);
        rv = read_table(r, *table, file);
        if(rv == APR_SUCCESS) {
            break;
        }
        apr_table_clear(*table);

        rv = apr_file_seek(file, APR_SET, &off);
        if(rv != APR_SUCCESS) {
            return rv;
        }

        rv = apr_file_info_get(&finfo, APR_FINFO_MTIME, file);
        if(rv != APR_SUCCESS ||
                finfo.mtime < (apr_time_now() - timeout) ) 
        {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "disk_cache: Timed out waiting for cache headers "
                          "URL %s", handle->cache_obj->key);
            return APR_EGENERAL;
        }
        apr_sleep(CACHE_LOOP_SLEEP);
    }

    return APR_SUCCESS;
}


    apr_status_t rv;
    rv = read_table_timeout(h, r, &(h->resp_hdrs), dobj->hfd, dobj->updtimeout);
    if(rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                     "disk_cache: Timed out waiting for response headers "
                     "for URL %s - caching failed?",  dobj->name);
        return rv;
    }
    rv = read_table_timeout(h, r, &(h->req_hdrs), dobj->hfd, dobj->updtimeout);
    if(rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                     "disk_cache: Timed out waiting for request headers "
                     "for URL %s - caching failed?",  dobj->name);
        return rv;
    }
    dobj->hfd = NULL;
    /* Insert as much as possible as regular file (ie. sendfile():able) */
    if(dobj->file_size > 0) {
        if(apr_brigade_insert_file(bb, dobj->fd, 0, 
                                   dobj->file_size, p) == NULL) 
        {
            return APR_ENOMEM;
        }
    }

    /* Insert any remainder as read-while-caching bucket */
    if(dobj->file_size < dobj->initial_size) {
        if(diskcache_brigade_insert(bb, dobj->fd, dobj->file_size, 
                                    dobj->initial_size - dobj->file_size,
                                    dobj->updtimeout, p
                    ) == NULL) 
        {
            return APR_ENOMEM;
        }
    }

static apr_status_t open_new_file(request_rec *r, const char *filename,
                                  apr_file_t **fd, disk_cache_conf *conf)
    int flags;
#if APR_HAS_SENDFILE
    core_dir_config *pdconf = ap_get_module_config(r->per_dir_config,
                                                   &core_module);
#endif  

    flags = APR_CREATE | APR_WRITE | APR_READ | APR_BINARY | APR_BUFFERED | APR_EXCL | APR_TRUNCATE;
#if APR_HAS_SENDFILE
    flags |= ((pdconf->enable_sendfile == ENABLE_SENDFILE_OFF)
             ? 0 : APR_SENDFILE_ENABLED);
#endif  

    while(1) {
        rv = apr_file_open(fd, filename, flags, 
                APR_FPROT_UREAD | APR_FPROT_UWRITE, r->pool);

        ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, r->server,
                     "disk_cache: open_new_file: Opening %s", filename);

        if(APR_STATUS_IS_EEXIST(rv)) {
            apr_finfo_t finfo;

            rv = apr_stat(&finfo, filename, APR_FINFO_MTIME, r->pool);
            if(APR_STATUS_IS_ENOENT(rv)) {
                /* Someone else has already removed it, try again */
                continue;
            }
            else if(rv != APR_SUCCESS) {
                return rv;
            }
            if(finfo.mtime < (apr_time_now() - conf->updtimeout) ) {
                /* Something stale that's left around */

                rv = apr_file_remove(filename, r->pool);
                if(rv != APR_SUCCESS && !APR_STATUS_IS_ENOENT(rv)) {
                    ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                                 "disk_cache: open_new_file: Failed to "
                                 "remove old %s", filename);
                    return rv;
                }
                continue;
            }
            else {
                /* Someone else has just created the file, return identifiable
                   status so calling function can do the right thing */
                return CACHE_EEXIST;
            }
        }
        else if(APR_STATUS_IS_ENOENT(rv)) {
            /* The directory for the file didn't exist */

            rv = mkdir_structure(conf, filename, r->pool);
            if(rv != APR_SUCCESS) {
                ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                             "disk_cache: open_new_file: Failed to make "
                             "directory for %s", filename);
                return rv;
            }
            continue;
        }
        else if(rv == APR_SUCCESS) {
            return APR_SUCCESS;
        }
        else {
            ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                         "disk_cache: open_new_file: Failed to open %s",
                         filename);
            return rv;
        }
    }
    /* We should never get here, so */
    return APR_EGENERAL;
}
static apr_status_t store_vary_header(cache_handle_t *h, disk_cache_conf *conf,
                                       request_rec *r, cache_info *info,
                                       const char *varyhdr)
{
    disk_cache_object_t *dobj = (disk_cache_object_t*) h->cache_obj->vobj;
    apr_array_header_t* varray;
    const char *vfile;
    apr_status_t rv;
    int flags;
    disk_cache_format_t format = VARY_FORMAT_VERSION;
    struct iovec iov[2];
    apr_size_t amt;
    if(dobj->prefix != NULL) {
        vfile = dobj->prefix;
    }
    else {
        vfile = dobj->hdrsfile;
    }
    flags = APR_CREATE | APR_WRITE | APR_BINARY | APR_EXCL | APR_BUFFERED;
    rv = apr_file_mktemp(&dobj->tfd, dobj->tempfile, flags, r->pool);
    if (rv != APR_SUCCESS) {
        return rv;
    }
    iov[0].iov_base = (void*)&format;
    iov[0].iov_len = sizeof(format);
    iov[1].iov_base = (void*)&info->expire;
    iov[1].iov_len = sizeof(info->expire);
    rv = apr_file_writev(dobj->tfd, (const struct iovec *) &iov, 2, &amt);
    if (rv != APR_SUCCESS) {
        file_cache_errorcleanup(dobj, r);
        return rv;
    }
    varray = apr_array_make(r->pool, 6, sizeof(char*));
    tokens_to_array(r->pool, varyhdr, varray);
    rv = store_array(dobj->tfd, varray);
    if (rv != APR_SUCCESS) {
        file_cache_errorcleanup(dobj, r);
        return rv;
    }

    rv = apr_file_close(dobj->tfd);
    dobj->tfd = NULL;
    if (rv != APR_SUCCESS) {
        file_cache_errorcleanup(dobj, r);
        return rv;
    }
    rv = safe_file_rename(conf, dobj->tempfile, vfile, r->pool);
    if (rv != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                     "disk_cache: rename tempfile to varyfile failed: "
                     "%s -> %s", dobj->tempfile, vfile);
        file_cache_errorcleanup(dobj, r);
        return rv;
    }
    dobj->tempfile = apr_pstrcat(r->pool, conf->cache_root, AP_TEMPFILE, NULL);
    if(dobj->prefix == NULL) {
        const char *tmp = regen_key(r->pool, r->headers_in, varray, dobj->name);
        dobj->prefix = dobj->hdrsfile;
        dobj->hdrsfile = header_file(r->pool, conf, dobj, tmp);
    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "disk_cache: Stored vary header for URL %s", dobj->name);
    return APR_SUCCESS;
}
static apr_status_t store_disk_header(disk_cache_object_t *dobj,
                                       request_rec *r, cache_info *info)
{
    disk_cache_format_t format = DISK_FORMAT_VERSION;
    struct iovec iov[3];
    int niov;
    disk_cache_info_t disk_info;
    apr_size_t amt;
    apr_status_t rv;
    disk_info.file_size = dobj->initial_size;

    niov = 0;
    iov[niov].iov_base = (void*)&format;
    iov[niov++].iov_len = sizeof(format);
    iov[niov].iov_base = (void*)&disk_info;
    iov[niov++].iov_len = sizeof(disk_cache_info_t);
    iov[niov].iov_base = (void*)dobj->name;
    iov[niov++].iov_len = disk_info.name_len;
    rv = apr_file_writev(dobj->hfd, (const struct iovec *) &iov, niov, &amt);
        file_cache_errorcleanup(dobj, r);
            file_cache_errorcleanup(dobj, r);
            file_cache_errorcleanup(dobj, r);
    return APR_SUCCESS;
}

static apr_status_t store_headers(cache_handle_t *h, request_rec *r, 
                                  cache_info *info)
{
    disk_cache_conf *conf = ap_get_module_config(r->server->module_config,
                                                 &disk_cache_module);
    apr_status_t rv;
    int flags=0, rewriting;
    disk_cache_object_t *dobj = (disk_cache_object_t*) h->cache_obj->vobj;


    /* This is flaky... we need to manage the cache_info differently */
    h->cache_obj->info = *info;

    if(dobj->hfd) {
        ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                     "disk_cache: Rewriting headers for URL %s", dobj->name);

        rewriting = TRUE;
    }
    else {
        ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                     "disk_cache: Storing new headers for URL %s", dobj->name);

        rewriting = FALSE;
    }

    if (r->headers_out) {
        const char *tmp;

        tmp = apr_table_get(r->headers_out, "Vary");

        if (tmp) {
            rv = store_vary_header(h, conf, r, info, tmp);
            if(rv != APR_SUCCESS) {
                return rv;
            }
        }
    } 

    if(rewriting) {
        /* Assume we are just rewriting the header if we have an fd. The
           fd might be readonly though, in that case reopen it for writes.
           Something equivalent to fdopen would have been handy. */

        flags = apr_file_flags_get(dobj->hfd);

        if(!(flags & APR_WRITE)) {
            apr_file_close(dobj->hfd);
            rv = apr_file_open(&dobj->hfd, dobj->hdrsfile, 
                    APR_WRITE | APR_BINARY | APR_BUFFERED, 0, r->pool);
            if (rv != APR_SUCCESS) {
                dobj->hfd = NULL;
                return rv;
            }
        }
        else {
            /* We can write here, so let's just move to the right place */
            apr_off_t off=0;
            rv = apr_file_seek(dobj->hfd, APR_SET, &off);
            if (rv != APR_SUCCESS) {
                return rv;
            }
        }
    }
    else {
        rv = open_new_file(r, dobj->hdrsfile, &(dobj->hfd), conf);
        if(rv == CACHE_EEXIST) {
            dobj->skipstore = TRUE;
        }
        else if(rv != APR_SUCCESS) {
            return rv;
        }
    }

    if(dobj->skipstore) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "disk_cache: Skipping store for URL %s: Someone else "
                     "beat us to it",  dobj->name);
        return APR_SUCCESS;
    rv = store_disk_header(dobj, r, info);
    if(rv != APR_SUCCESS) {
    /* If the body size is unknown, the header file will be rewritten later
       so we can't close it */
    if(dobj->initial_size < 0) {
        rv = apr_file_flush(dobj->hfd);
    }
    else {
        rv = apr_file_close(dobj->hfd);
        dobj->hfd = NULL;
    }
    if(rv != APR_SUCCESS) {
        return rv;
    }
/**
 * Store the body of the response in the disk cache.
 * 
 * As the data is written to the cache, it is also written to
 * the filter provided. On network write failure, the full body
 * will still be cached.
 */
static apr_status_t store_body(cache_handle_t *h, ap_filter_t *f, apr_bucket_brigade *bb)
    apr_bucket *e, *b;
    request_rec *r = f->r;
    dobj->store_body_called++;
    
    if(r->no_cache) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "disk_cache: store_body called for URL %s even though"
                     "no_cache is set", dobj->name);
        file_cache_errorcleanup(dobj, r);
        ap_remove_output_filter(f);
        return ap_pass_brigade(f->next, bb);
    }

    if(dobj->initial_size == 0) {
        /* Don't waste a body cachefile on a 0 length body */
        return ap_pass_brigade(f->next, bb);
    }

    if(!dobj->skipstore && dobj->fd == NULL) {
        rv = open_new_file(r, dobj->datafile, &(dobj->fd), conf);
        if (rv == CACHE_EEXIST) {
            /* Someone else beat us to storing this */
            dobj->skipstore = TRUE;
        }
        else if (rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                         "disk_cache: store_body tried to open cached file "
                         "for URL %s and this failed", dobj->name);
            ap_remove_output_filter(f);
            return ap_pass_brigade(f->next, bb);
        }
        else {
            dobj->file_size = 0;
    if(dobj->skipstore) {
        /* Someone else beat us to storing this object.
         * We are too late to take advantage of this storage :( */
        ap_remove_output_filter(f);
        return ap_pass_brigade(f->next, bb);
    }

    /* set up our temporary brigade */
    if (!dobj->tmpbb) {
        dobj->tmpbb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    }
    else {
        apr_brigade_cleanup(dobj->tmpbb);
    }

    /* start caching the brigade */
    ap_log_error(APLOG_MARK, APLOG_INFO, 0, r->server,
                 "disk_cache: Caching body for URL %s", dobj->name);

    e = APR_BRIGADE_FIRST(bb);
    while (e != APR_BRIGADE_SENTINEL(bb)) {

        apr_off_t offset = 0;

        /* try write all data buckets to the cache, except for metadata buckets */
        if(!APR_BUCKET_IS_METADATA(e)) {

            /* read in a bucket fragment */
            rv = apr_bucket_read(e, &str, &length, APR_BLOCK_READ);
            if (rv != APR_SUCCESS) {
                ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                             "disk_cache: Error when reading bucket for URL %s, aborting request",
                             dobj->name);
                file_cache_errorcleanup(dobj, r);
                /* not being able to read the bucket is fatal,
                 * return this up the filter stack
                 */
                return rv;
            }

            /* try write the bucket fragment to the cache */
            apr_file_seek(dobj->fd, APR_END, &offset);
            rv = apr_file_write_full(dobj->fd, str, length, &written);
            offset = - (apr_off_t)written;
            apr_file_seek(dobj->fd, APR_END, &offset);

            /* if the cache write was successful, swap the original bucket
             * with a file bucket pointing to the same data in the cache.
             * 
             * This is done because:
             * 
             * - The ap_core_output_filter can take advantage of its ability
             * to do non blocking writes on file buckets.
             * 
             * - We are prevented from the need to read the original bucket
             * a second time inside ap_core_output_filter, which could be
             * expensive or memory consuming.
             * 
             * - The cache, in theory, should be faster than the backend,
             * otherwise there would be little point in caching in the first
             * place.
             */
            if (APR_SUCCESS == rv) {

                /* remove and destroy the original bucket from the brigade */
                b = e;
                e = APR_BUCKET_NEXT(e);
                APR_BUCKET_REMOVE(b);
                apr_bucket_destroy(b);

                /* Is our network connection still alive?
                 * If not, we must continue caching the file, so keep looping.
                 * We will return the error at the end when caching is done.
                 */
                if (APR_SUCCESS == dobj->frv) {

                    /* insert a file bucket pointing to the cache into out temporary brigade */
                    if (diskcache_brigade_insert(dobj->tmpbb, dobj->fd, dobj->file_size, 
                                                 written,
                                                 dobj->updtimeout, r->pool) == NULL) {
                       return APR_ENOMEM;
                    }

                    /* TODO: If we are not able to guarantee that
                     * apr_core_output_filter() will not block on our
                     * file buckets, then the check for whether the
                     * socket will block must go here.
                     */
    
                    /* send our new brigade to the network */
                    dobj->frv = ap_pass_brigade(f->next, dobj->tmpbb);
    
                }

                /* update the write counter, and sanity check the size */
                dobj->file_size += written;
                if (dobj->file_size > conf->maxfs) {
                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                                 "disk_cache: URL %s failed the size check "
                                 "(%" APR_OFF_T_FMT " > %" APR_OFF_T_FMT ")",
                                 dobj->name, dobj->file_size, conf->maxfs);
                    file_cache_errorcleanup(dobj, r);
                    ap_remove_output_filter(f);
                    return ap_pass_brigade(f->next, bb);
                }

            }

            /*
             * If the cache write failed, continue to loop and pass data to
             * the network. Remove the cache filter from the output filters
             * so we don't inadvertently try to cache write again, leaving
             * a hole in the cached data.
             */
            else {

                /* mark the write as having failed */
                ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                             "disk_cache: Error when writing cache file for "
                             "URL %s", dobj->name);
                             
                /* step away gracefully */
                file_cache_errorcleanup(dobj, r);
                ap_remove_output_filter(f);

                /* write the rest of the brigade to the network, and leave */
                return ap_pass_brigade(f->next, bb);

            }



        /* write metadata buckets direct to the output filter */
        else {

            /* move the metadata bucket to our temporary brigade */
            b = e;
            e = APR_BUCKET_NEXT(e);
            APR_BUCKET_REMOVE(b);
            APR_BRIGADE_INSERT_HEAD(dobj->tmpbb, b);

            /* Is our network connection still alive?
             * If not, we must continue looping, but stop writing to the network.
             */
            if (APR_SUCCESS == dobj->frv) {
    
                /* TODO: If we are not able to guarantee that
                 * apr_core_output_filter() will not block on our
                 * file buckets, then the check for whether the
                 * socket will block must go here.
                 */
    
                /* send our new brigade to the network */
                dobj->frv = ap_pass_brigade(f->next, dobj->tmpbb);
    
            }


        apr_brigade_cleanup(dobj->tmpbb);

    }

    
    /* Drop out here if this wasn't the end */
    if (!APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {
        return APR_SUCCESS;
    }

    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "disk_cache: Done caching URL %s, len %" APR_OFF_T_FMT,
                 dobj->name, dobj->file_size);

    if (APR_SUCCESS != dobj->frv) {
        ap_log_error(APLOG_MARK, APLOG_ERR, dobj->frv, r->server,
                     "disk_cache: An error occurred while writing to the "
                     "network for URL %s.",
                     h->cache_obj->key);
    if (dobj->file_size < conf->minfs) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "disk_cache: URL %s failed the size check "
                     "(%" APR_OFF_T_FMT "<%" APR_OFF_T_FMT ")",
                     h->cache_obj->key, dobj->file_size, conf->minfs);
        /* Remove the intermediate cache file and return filter status */
        file_cache_errorcleanup(dobj, r);
        return dobj->frv;
    }
    if (dobj->initial_size < 0) {
        /* Update header information now that we know the size */
        dobj->initial_size = dobj->file_size;
        rv = store_headers(h, r, &(h->cache_obj->info));
        if (rv != APR_SUCCESS) {
            return dobj->frv;
    }
    else if (dobj->initial_size != dobj->file_size) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "disk_cache: URL %s - body size mismatch: suggested %"
                     APR_OFF_T_FMT "  bodysize %" APR_OFF_T_FMT ")",
                     dobj->name, dobj->initial_size, dobj->file_size);
        file_cache_errorcleanup(dobj, r);
        return dobj->frv;
    }
    /* All checks were fine, close output file */
    rv = apr_file_close(dobj->fd);
    dobj->fd = NULL;
    if (rv != APR_SUCCESS) {
                     "disk_cache: While trying to close the cache file for "
                     "URL %s, the close failed", dobj->name);
        file_cache_errorcleanup(dobj, r);
        return dobj->frv;
    return dobj->frv;

    conf->updtimeout = DEFAULT_UPDATE_TIMEOUT;

static const char
*set_cache_updtimeout(cmd_parms *parms, void *in_struct_ptr, const char *arg)
{
    apr_int64_t val;
    disk_cache_conf *conf = ap_get_module_config(parms->server->module_config,
                                                 &disk_cache_module);

    if (apr_strtoff(&val, arg, NULL, 0) != APR_SUCCESS || val < 0) 
    {
        return "CacheUpdateTimeout argument must be a non-negative integer representing the timeout in milliseconds for cache update operations";
    }

    conf->updtimeout = val * 1000;

    return NULL;
}


    AP_INIT_TAKE1("CacheUpdateTimeout", set_cache_updtimeout, NULL, RSRC_CONF,
                  "Timeout in ms for cache updates"),
#define DISK_FORMAT_VERSION_OLD 4
#define DISK_FORMAT_VERSION 5
#define CACHE_BUF_SIZE 65536

/* How long to sleep before retrying while looping */
#define CACHE_LOOP_SLEEP 200000


/* Indicates the format of the header struct stored on-disk. */
typedef apr_uint32_t disk_cache_format_t;

    /* The body size forced to 64bit to not break when people go from non-LFS
     * to LFS builds */
    apr_int64_t file_size;
    apr_off_t initial_size;  /*  Initial file size reported by caller */

    apr_interval_time_t updtimeout; /* Cache update timeout */

    int skipstore;              /* Set if we should skip storing stuff */
    int store_body_called;      /* Number of times store_body() has executed */
    apr_bucket_brigade *tmpbb;  /* Temporary bucket brigade. */
    apr_status_t frv;           /* Last known status of network write */
#define DEFAULT_UPDATE_TIMEOUT apr_time_from_sec(10)
    apr_interval_time_t updtimeout;   /* Cache update timeout */
#define CACHE_ENODATA (APR_OS_START_USERERR+1)
#define CACHE_EDECLINED (APR_OS_START_USERERR+2)
#define CACHE_EEXIST (APR_OS_START_USERERR+3)


typedef struct diskcache_bucket_data diskcache_bucket_data;
struct diskcache_bucket_data {
    /* Number of buckets using this memory */
    apr_bucket_refcount  refcount;
    apr_file_t  *fd;
    /* The pool into which any needed structures should
     *  be created while reading from this file bucket */
    apr_pool_t *readpool;
    /* Cache update timeout */
    apr_interval_time_t updtimeout;

};


    apr_status_t frv;   /* last known status of writing to the output filter */
static apr_status_t store_body(cache_handle_t *h, ap_filter_t *f, apr_bucket_brigade *b);
static apr_status_t store_body(cache_handle_t *h, ap_filter_t *f, apr_bucket_brigade *b)
    request_rec *r = f->r;
                ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                         "mem_cache: Failed to open file '%s' while attempting to cache the file descriptor.", name);
                return ap_pass_brigade(f->next, b);
            return ap_pass_brigade(f->next, b);
            /* we didn't have space to cache it, fall back gracefully */
            cleanup_cache_object(obj);
            ap_remove_output_filter(f);
            ap_log_error(APLOG_MARK, APLOG_ERR, APR_ENOMEM, r->server,
                         "mem_cache: Could not store body - not enough memory.");
            return ap_pass_brigade(f->next, b);
                    /* we didn't have space to cache it, fall back gracefully */
                    cleanup_cache_object(obj);
                    ap_remove_output_filter(f);
                    ap_log_error(APLOG_MARK, APLOG_ERR, APR_ENOMEM, r->server,
                                 "mem_cache: Could not store next bit of body - not enough memory.");
                    return ap_pass_brigade(f->next, b);
            cleanup_cache_object(obj);
            /* not being able to read the bucket is fatal,
             * return this up the filter stack
             */
            if ((obj->count + len) > mobj->m_len) {
                /* we didn't have space to cache it, fall back gracefully */
                cleanup_cache_object(obj);
                ap_remove_output_filter(f);
                ap_log_error(APLOG_MARK, APLOG_ERR, APR_ENOMEM, r->server,
                             "mem_cache: Could not store body - buffer overflow.");
                return ap_pass_brigade(f->next, b);
            }
            else {
            }
    return ap_pass_brigade(f->next, b);

                                                   apr_bucket_brigade * bb);
static int ftp_getrc_msg(conn_rec *c, apr_bucket_brigade * bb, char *msgbuf, int msglen)
    if (APR_SUCCESS != (rv = ap_proxy_string_read(c, bb, response, sizeof(response), &eos))) {
            if (APR_SUCCESS != (rv = ap_proxy_string_read(c, bb, response, sizeof(response), &eos))) {
apr_status_t ap_proxy_send_dir_filter(ap_filter_t * f, apr_bucket_brigade * in)
                           "\n\n<HTML>\n<HEAD>\n<TITLE>%s%s</TITLE>\n"
                           "<BASE HREF=\"%s%s\">\n</HEAD>\n\n"
                           "<BODY>\n\n<H2>Directory of "
                           "<A HREF=\"/\">%s</A>/",
                           site, path, site, path, site);
            str = apr_psprintf(p, "<A HREF=\"/%s/\">%s</A>/", path + 1, reldir);
            str = apr_psprintf(p, "</H2>\n\n<HR></HR>\n\n<PRE>");
            str = apr_psprintf(p, "</H2>\n\n(%s)\n\n<HR></HR>\n\n<PRE>", pwd);
            str = apr_psprintf(p, "%s\n</PRE>\n\n<HR></HR>\n\n<PRE>\n",
                               readme);

            } while (filename[0] != ' ');
            *(filename++) = '\0';
            str = apr_psprintf(p, "%s <A HREF=\"%s\">%s %s</A>\n", ctx->buffer, filename, filename, link_ptr);
                str = apr_psprintf(p, "%s <A HREF=\"%s/\">%s</A>\n",
                                   ctx->buffer, filename, filename);
                str = apr_psprintf(p, "%s <A HREF=\"%s\">%s</A>\n",
                                   ctx->buffer, filename, filename);
            str = apr_pstrdup(p, ctx->buffer);
        str = apr_psprintf(p, "</PRE>\n\n<HR></HR>\n\n%s\n\n</BODY>\n</HTML>\n", ap_psignature("", r));
    apr_socket_t *sock, *local_sock, *remote_sock = NULL;
    conn_rec *origin, *remote;
     * 
     * 
     * 
     * 
         * 
     * 
        apr_sockaddr_t *remote_addr;
        char *remote_ip;
        apr_port_t remote_port;
                remote_port = atoi(pstr + 3);
                             remote_port);
                if ((rv = apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
                apr_socket_addr_get(&remote_addr, APR_REMOTE, sock);
                apr_sockaddr_ip_get(&remote_ip, remote_addr);
                apr_sockaddr_info_get(&epsv_addr, remote_ip, APR_INET, remote_port, 0, p);
                rv = apr_connect(remote_sock, epsv_addr);
                apr_socket_close(remote_sock);
                if ((rv = apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
                rv = apr_connect(remote_sock, pasv_addr);
                apr_socket_close(remote_sock);
     * 
            rv = apr_accept(&remote_sock, local_sock, r->pool);
    remote = ap_new_connection(p, r->server, remote_sock, r->connection->id, r->connection->sbh);
    if (!remote) {
    ap_proxy_pre_http_connection(remote);
     * 
        while (ap_get_brigade(remote->input_filters, bb, AP_MODE_EXHAUSTIVE,
    ap_flush_conn(remote);
    apr_socket_close(remote_sock);
     * 
static void ap_proxy_ftp_register_hook(apr_pool_t * p)
#include "apr_lib.h"
#include "http_log.h"
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;
 
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;
 
    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */
 
    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
            /* this is a hack to make sure that request time is set,
             * it's not perfect, but it's better than nothing
             */
            r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */
 
    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk
 
#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */
 
    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);
 
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method);
#endif
    uri = ap_getword_white(r->pool, &ll);
 
    /* Provide quick information about the request method as soon as known */
 
    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }
 
    ap_parse_uri(r, uri);
 
    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }
 
    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);
 
    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */
 
    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))    /* don't allow HTTP/0.1000 */
        r->proto_num = HTTP_VERSION(major, minor);
    else
        r->proto_num = HTTP_VERSION(1,0);
 
    return 1;
}

static int http_create_request(request_rec *r)
{
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
    int keptalive;

    hconn = apr_pcalloc(r->pool, sizeof(*hconn));
    ap_set_module_config(r->connection->conn_config, &http_module, hconn);

    if (!r->main && !r->prev && !r->next) {
        keptalive = r->connection->keepalive == 1;
        r->connection->keepalive    = 0;
 
        /* XXX can we optimize these timeouts at all? gstein */
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(keptalive
                         ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                         : r->server->timeout * APR_USEC_PER_SEC));
 
        /* Get the request... */
        if (!read_request_line(r)) {
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                              "request failed: URI too long");
                ap_send_error_response(r, 0);
                ap_run_log_transaction(r);
                return OK;
            }
            return DONE;
        }
        if (keptalive) {
            apr_setsocketopt(r->connection->client_socket,
                             APR_SO_TIMEOUT,
                             (int)(r->server->timeout * APR_USEC_PER_SEC));
        }
    }
    return OK;
}

    ap_hook_create_request(http_create_request, NULL, NULL, APR_HOOK_MIDDLE);
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
	    || (r->server->keep_alive_max > hconn->keepalives))
        int left = r->server->keep_alive_max - hconn->keepalives;
        hconn->keepalives++;
typedef struct ap_http_conn_rec ap_http_conn_rec;

struct ap_http_conn_rec {
    /** How many times have we used it? */
    int keepalives;
};

AP_DECLARE_DATA extern module http_module;

#include "mod_core.h"
    if (ap_run_create_request(r) != OK) {
        return NULL;
    }
    imap_conf_rec *new = (imap_conf_rec *) apr_pcalloc(p, sizeof(imap_conf_rec));
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted") && *comment) {
    if (!strcasecmp(menu, "unformatted") && *comment) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    /* If we have a saved brigade from a previous run, concat the passed
     * brigade with our saved brigade.  Otherwise just continue.
     */
    if (!APR_BRIGADE_EMPTY(ctx->bb)) {
        APR_BRIGADE_CONCAT(ctx->bb, bb);
        bb = ctx->bb;
    }
    apr_brigade_destroy(ctx->bb);
 * 20051231.0 (2.3.0-dev)  Added num_blank_lines, pending_header_line, and
 *                         pending_header_size to request_rec
    /** Number of leading blank lines encountered before request header */
    int num_blank_lines;

    /** A buffered header line, used to support header folding while
     *  reading the request */
    char *pending_header_line;

    /** If nonzero, the number of bytes allocated to hold pending_header_line */
    apr_size_t pending_header_size;

static void set_the_request(request_rec *r, char *line)
    apr_socket_t *csd;
    ll = r->the_request = line;
             && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */
    }
    else {
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(r->connection->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->connection->base_server->timeout);

    return;
}

static apr_status_t set_mime_header(request_rec *r, char *line)
{
    char *value, *tmp_field;

    if (r->server->limit_req_fields) {
        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);
        if (mime_headers->nelts >= r->server->limit_req_fields) {
            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields "
                           "exceeds this server's limit.");
            r->status = HTTP_BAD_REQUEST;
            return APR_ENOSPC;
        }
    }
    
    if (!(value = strchr(line, ':'))) { /* Find ':' or    */
        r->status = HTTP_BAD_REQUEST;      /* abort bad request */
        apr_table_setn(r->notes, "error-notes",
                       apr_pstrcat(r->pool,
                                   "Request header field is "
                                   "missing ':' separator.<br />\n"
                                   "<pre>\n",
                                   ap_escape_html(r->pool, line),
                                   "</pre>\n", NULL));
        return APR_EGENERAL;
    }

    tmp_field = value - 1; /* last character of field-name */

    *value++ = '\0'; /* NUL-terminate at colon */

    while (*value == ' ' || *value == '\t') {
        ++value;            /* Skip to start of value   */
    }

    /* Strip LWS after field-name: */
    while (tmp_field > line
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }

    /* Strip LWS after field-value: */
    tmp_field = strchr(value, '\0') - 1;
    while (tmp_field > value
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }
    apr_table_addn(r->headers_in, line, value);
    return APR_SUCCESS;
}

static apr_status_t process_request_line(request_rec *r, char *line,
                                         int skip_first)
{
    if (!skip_first && (r->the_request == NULL)) {
        /* This is the first line of the request */
        if ((line == NULL) || (*line == '\0')) {
            /* We skip empty lines because browsers have to tack a CRLF on to the end
             * of POSTs to support old CERN webservers.
             */
            int max_blank_lines = r->server->limit_req_fields;
            if (max_blank_lines <= 0) {
                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
            }
            r->num_blank_lines++;
            if (r->num_blank_lines < max_blank_lines) {
                return APR_SUCCESS;
            }
        }
        set_the_request(r, line);
    }
    else {
        /* We've already read the first line of the request.  This is either
         * a header field or the blank line terminating the header
         */
        if ((line == NULL) || (*line == '\0')) {
            if (r->pending_header_line != NULL) {
                apr_status_t rv = set_mime_header(r, r->pending_header_line);
                if (rv != APR_SUCCESS) {
                    return rv;
                }
                r->pending_header_line = NULL;
            }
            if (r->status == HTTP_REQUEST_TIME_OUT) {
                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
                r->status = HTTP_OK;
            }
        }
        else {
            if ((*line == ' ') || (*line == '\t')) {
                /* This line is a continuation of the previous one */
                if (r->pending_header_line == NULL) {
                    r->pending_header_line = line;
                    r->pending_header_size = 0;
                }
                else {
                    apr_size_t pending_len = strlen(r->pending_header_line);
                    apr_size_t fold_len = strlen(line);
                    if ((r->server->limit_req_fieldsize > 0)
						&& (pending_len + fold_len >
                               (apr_size_t) r->server->limit_req_fieldsize)) {
                        /* CVE-2004-0942 */
                        r->status = HTTP_BAD_REQUEST;
                        return APR_ENOSPC;
                    }
                    if (pending_len + fold_len + 1 > r->pending_header_size) {
                        /* Allocate a new buffer big enough to hold the
                         * concatenated lines
                         */
                        apr_size_t new_size = r->pending_header_size;
                        char *new_buf;
                        if (new_size == 0) {
                            new_size = pending_len + fold_len + 1;
                        }
                        else {
                            do {
                                new_size *= 2;
                            } while (new_size < pending_len + fold_len + 1);
                        }
                        new_buf = (char *)apr_palloc(r->pool, new_size);
                        memcpy(new_buf, r->pending_header_line, pending_len);
                        r->pending_header_line = new_buf;
                        r->pending_header_size = new_size;
                    }
                    memcpy(r->pending_header_line + pending_len, line,
                           fold_len + 1);
                }
            }
            else {
                /* Set aside this line in case the next line is a continuation
                 */
                if (r->pending_header_line != NULL) {
                    apr_status_t rv = set_mime_header(r, r->pending_header_line);
                    if (rv != APR_SUCCESS) {
                        return rv;
                    }
                }
                r->pending_header_line = line;
                r->pending_header_size = 0;
            }
        }
    }
    return APR_SUCCESS;
        rv = process_request_line(r, field, 1);
        if (rv != APR_SUCCESS) {
            return;
        if ((field == NULL) || (*field == '\0')) {
            return;
static request_rec *init_request(conn_rec *conn)
    
    return r;
}
static request_rec *request_post_read(request_rec *r, conn_rec *conn)
{
    apr_socket_t *csd;
    const char *expect;
    int access_status;
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->server->timeout);

    if (apr_table_get(r->headers_in, "Transfer-Encoding") &&
        apr_table_get(r->headers_in, "Content-Length")) {
        /* 2616 section 4.4, point 3: "if both Transfer-Encoding
         * and Content-Length are received, the latter MUST be
         * ignored"; so unset it here to prevent any confusion
         * later.
         */
        apr_table_unset(r->headers_in, "Content-Length");
static apr_status_t read_partial_request(request_rec *r) {
    apr_bucket_brigade *tmp_bb;
    apr_status_t rv = APR_SUCCESS;

    /* Read and process lines of the request until we
     * encounter a complete request header, an error, or EAGAIN
     */
    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    while (r->status == HTTP_REQUEST_TIME_OUT) {
        char *line = NULL;
        apr_size_t line_length;
        apr_size_t length_limit;
        int first_line = (r->the_request == NULL);
        if (first_line) {
            length_limit = r->server->limit_req_line;
        }
        else {
            if (r->assbackwards) {
                r->status = HTTP_OK;
                break;
            }
            length_limit = r->server->limit_req_fieldsize;
        }
        /* TODO: use a nonblocking call in place of ap_rgetline */
        rv = ap_rgetline(&line, length_limit + 2,
                         &line_length, r, 0, tmp_bb);
        if (rv == APR_SUCCESS) {
            rv = process_request_line(r, line, 0);
        }
        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();
            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                if (first_line) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: URI too long (longer than %d)",
                                  r->server->limit_req_line);
                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                    r->proto_num = HTTP_VERSION(1,0);
                    r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
                }
                else {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: header line too long "
                                  "(longer than %d)",
                                  r->server->limit_req_fieldsize);
                    r->status = HTTP_BAD_REQUEST;
                }
            }
            break;
        }
    }
    apr_brigade_destroy(tmp_bb);
    return rv;
}

request_rec *ap_read_request(conn_rec *conn)
{
    request_rec *r;
    apr_status_t rv;

    r = init_request(conn);

    rv = read_partial_request(r);
    /* TODO poll if EAGAIN */
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return NULL;
    }

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers! Have to dink things just to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "client sent invalid HTTP/0.9 request: HEAD %s",
                      r->uri);
        r->header_only = 0;
        r->status = HTTP_BAD_REQUEST;
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return r;
    }

    return request_post_read(r, conn);
}

    sc->enabled                = FALSE;
    cfgMergeBool(enabled);
        sc->enabled = TRUE;
        sc->enabled = FALSE;
        sc->enabled = UNSET;
#if 0
        if (sc->enabled == UNSET) {
            sc->enabled = FALSE;
#endif
    /* A bit of a hack, but initialize the server if SSL is optional or
     * not.
    if (sc->enabled) {
        if ((sc->enabled == TRUE) && (s->port == DEFAULT_HTTP_PORT)) {
        if (!sc->enabled && (s->port == DEFAULT_HTTPS_PORT)) {
        if (!(sc->enabled && s->addrs)) {
        if (sc->enabled == UNSET) {
    if (!(sc->enabled || ssl)) {
    if (!(sc->enabled && sslconn->ssl && sslconn->client_cert) ||
    if (sc->enabled == UNSET) {
    if (!(sc->enabled && sslconn && (ssl = sslconn->ssl))) {
    BOOL             enabled;
    time_left = ccfg->timeout_at - now;
    if (time_left <= 0) {
        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c,
                      "Request %s read timeout", ccfg->type);
        return APR_TIMEUP;
    }
    if (time_left < apr_time_from_sec(1)) {
        time_left = apr_time_from_sec(1);
    }

    if (saved_sock_timeout >= time_left) {
        rv = apr_socket_timeout_set(ccfg->socket, time_left);
        AP_DEBUG_ASSERT(rv == APR_SUCCESS);
    }
    else {
        saved_sock_timeout = -1;
    }
    rv = ap_get_brigade(f->next, bb, mode, block, readbytes);
    if (saved_sock_timeout != -1) {
        apr_socket_timeout_set(ccfg->socket, saved_sock_timeout);
    }
    if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {
        extend_timeout(ccfg, bb);
    path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path, 0, r->proxyreq);
    r->content_type = "text/html";
        len = ap_getline(buffer, sizeof(buffer), rp, 0);
            len = ap_getline(buffer, sizeof(buffer), rp, 0);
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
             * not do a retry.
            if (r->proxyreq == PROXYREQ_REVERSE && c->keepalives) {
    SSLFilterRec *frec;
static bio_filter_out_ctx_t *bio_filter_out_ctx_new(SSLFilterRec *frec, conn_rec *c)
    outctx->frec = frec;
        return APR_SUCCESS;
    return ap_pass_brigade(outctx->frec->pOutputFilter->next, outctx->bb);
static int bio_filter_new(BIO *bio)
static int bio_filter_free(BIO *bio)
        bio_filter_out_flush(bio);
        ret = (bio_filter_out_flush(bio) == APR_SUCCESS);
    bio_filter_new,
    bio_filter_free,
    BIO *wbio;
    SSLFilterRec *frec;
        bio_filter_out_flush(inctx->wbio);
    bio_filter_new,
    bio_filter_free,
static int ssl_io_hook_write(SSL *ssl, unsigned char *buf, int len)
    int rc;
    if (ssl == NULL) {
        return -1;
    rc = SSL_write(ssl, buf, len);
    if (rc < 0) {
        int ssl_err = SSL_get_error(ssl, rc);
             * Simulate an EINTR in case OpenSSL wants to write more.
            errno = EINTR;
        else if (ssl_err == SSL_ERROR_SSL) {
            conn_rec *c = (conn_rec *)SSL_get_app_data(ssl);
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server,
                    "SSL error on writing data");
        /*
         * XXX - Just trying to reflect the behaviour in 
         * openssl_state_machine.c [mod_tls]. TBD
         */
        rc = 0;
    return rc;
}

static apr_status_t ssl_filter_write(ap_filter_t *f,
                                     const char *data,
                                     apr_size_t len)
{
    SSLFilterRec *frec = f->ctx;
    apr_size_t n;

    /* write SSL */
    n = ssl_io_hook_write(frec->pssl, (unsigned char *)data, len);

    if (n != len) {
        if (SSL_total_renegotiations(frec->pssl)) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server,
                "failed to write %d of %d bytes (%s)",
                n > 0 ? len - n : len, len, reason);
        return APR_EINVAL;

    return APR_SUCCESS;
    SSLFilterRec *frec = f->ctx;
    if (!frec->pssl) {
    if ((status = ssl_hook_process_connection(frec)) != APR_SUCCESS) {
            if ((status = bio_filter_out_flush(frec->pbioWrite)) != APR_SUCCESS) {
                return status;
                /* By definition, nothing can come after EOS.
        /* Down to a nonblock pattern as we have some data already
         */
        inctx->block = APR_NONBLOCK_READ;
        rc = SSL_read(inctx->frec->pssl, buf + bytes, wanted - bytes);
                inctx->rc = APR_EOF;
            int ssl_err = SSL_get_error(inctx->frec->pssl, rc);
                conn_rec *c = (conn_rec *)SSL_get_app_data(inctx->frec->pssl);
                            "SSL filter error reading data");
                break;
                conn_rec *c = (conn_rec *)SSL_get_app_data(inctx->frec->pssl);
                            "SSL library error reading data");
                if (inctx->rc == APR_SUCCESS) {
                    inctx->rc = APR_EGENERAL;
                }
                break;
    inctx->frec->pssl = NULL;
    status = ssl_hook_process_connection(inctx->frec);
static void ssl_io_input_add_filter(SSLFilterRec *frec, conn_rec *c,
    frec->pInputFilter = ap_add_input_filter(ssl_io_filter, inctx, NULL, c);
    frec->pbioRead = BIO_new(&bio_filter_in_method);
    frec->pbioRead->ptr = (void *)inctx;
    inctx->frec = frec;
    inctx->wbio = frec->pbioWrite;
    inctx->f = frec->pInputFilter;
    SSLFilterRec *pRec = (SSLFilterRec *)data;
    if (!pRec->pssl) {
    if ((ret = ssl_hook_CloseConnection(pRec)) != APR_SUCCESS) {
    SSLFilterRec *filter;
    filter = apr_palloc(c->pool, sizeof(SSLFilterRec));
    filter->pOutputFilter   = ap_add_output_filter(ssl_io_filter,
                                                   filter, NULL, c);
    filter->pbioWrite       = BIO_new(&bio_filter_out_method);
    filter->pbioWrite->ptr  = (void *)bio_filter_out_ctx_new(filter, c);
    ssl_io_input_add_filter(filter, c, ssl);
    SSL_set_bio(ssl, filter->pbioRead, filter->pbioWrite);
    filter->pssl            = ssl;
    apr_pool_cleanup_register(c->pool, (void*)filter,
    int limited;
    int method_mask;
#define METHODS     16
    int method_mask;
    /* The array used for extension methods */
    int allowed;
    int limited;
    int mmask = (1 << method);
    int mask;
     * If it's one of our known methods, use the shortcut and use the
     * bitmask.
    int i;
    char **xmethod;
     * The simple case: a method hard-coded into Apache.
	return (methnum & cmd->limited);
    }
    /*
     * Some extension method we don't know implicitly.
     */
    if ((cmd->limited_xmethods == NULL)
	|| (cmd->limited_xmethods->nelts == 0)) {
	return 0;
    xmethod = (char **) cmd->limited_xmethods->elts;
    for (i = 0; i < cmd->limited_xmethods->nelts; ++i) {
	if (strcmp(method, xmethod[i]) == 0) {
	    return 1;
	}
    }
    return 0;
    int limited = 0;
        int  methnum = ap_method_number_of(method);
	    char **xmethod;
	    register int i, j, k;

	    /*
	     * Deal with <Limit> by adding the method to the list.
	     */
	    if (!tog) {
		if (cmd->limited_xmethods == NULL) {
		    cmd->limited_xmethods = apr_array_make(cmd->pool, 2,
							   sizeof(char *));
		}
		xmethod = (char **) apr_array_push(cmd->limited_xmethods);
		*xmethod = apr_pstrdup(cmd->pool, method);
	    }
	    /*
	     * <LimitExcept>, so remove any/all occurrences of the method
	     * in the extension array.
	     */
	    else if ((cmd->limited_xmethods != NULL)
		     && (cmd->limited_xmethods->nelts != 0)) {
		xmethod = (char **) cmd->limited_xmethods->elts;
		for (i = 0; i < cmd->limited_xmethods->nelts; i++) {
		    if (strcmp(xmethod[i], method) == 0) {
			for (j = i, k = i + 1;
			     k < cmd->limited_xmethods->nelts;
			     ++j, ++k) {
			    xmethod[j] = xmethod[k];
			}
			cmd->limited_xmethods->nelts--;
		    }
		}
	    }
	limited |= (1 << methnum);
    char buf[4096];
    /* ### fix this mechanism to allow more than 4K of output */
    written = apr_vsnprintf(buf, sizeof(buf), fmt, va);
 * @deffunc unsigned long ap_get_limit_req_body(const request_rec *r)
AP_DECLARE(unsigned long) ap_get_limit_req_body(const request_rec *r);
    unsigned long limit_req_body;  /* limit on bytes in request msg body */
    apr_off_t max_body;
    max_body = ap_get_limit_req_body(r);
    if (max_body && (r->remaining > max_body)) {
        /* XXX shouldn't we enforce this for chunked encoding too? */
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                      "Request content-length of %s is larger than "
                      "the configured limit of %" APR_OFF_T_FMT, lenp,
                      max_body);
        return HTTP_REQUEST_ENTITY_TOO_LARGE;
    }

AP_DECLARE(unsigned long) ap_get_limit_req_body(const request_rec *r)
    conf->limit_req_body = (unsigned long)strtol(arg, (char **)NULL, 10);
        else if (!strcasecmp(w, "Options")) {
        else if (!strcasecmp(w, "execCGI")) {
        /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        if (action == '-') {
            if (r->status == HTTP_BAD_REQUEST) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                              "request failed: invalid characters in URI");
            }
            else {
        ap_rvputs(r, ap_get_server_name(r), " (", r->connection->local_ip,
apr_inline void ap_sync_scoreboard_image(void);
    ap_sync_scoreboard_image();
static int ap_threads_per_child = 0;
extern int ap_threads_per_child;
extern int ap_extended_status;



static void setup_shared_mem(apr_pool_t *p)
    apr_register_cleanup(p, NULL, ap_cleanup_shared_mem, apr_null_cleanup);
void reopen_scoreboard(apr_pool_t *p)
#endif   /* APR_SHARED_MEM */
/* Called by parent process */
void reinit_scoreboard(apr_pool_t *p)
        setup_shared_mem(p);
apr_inline void ap_sync_scoreboard_image(void)
    int save_errno = errno;
    err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, errcode, errstr);
    err->save_errno = save_errno;
                                 DAV_ERR_PROP_BAD_MAJOR,
                                 DAV_ERR_PROP_BAD_MAJOR,
                             HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN,
        return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN,
                             DAV_ERR_LOCK_NO_DB,
                             HTTP_INTERNAL_SERVER_ERROR, 0,
                                 DAV_ERR_LOCK_CORRUPT_DB,
                         DAV_ERR_LOCK_CORRUPT_DB,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
    if (apr_file_read(file, pbuf->buf, &amt) != APR_SUCCESS
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        if (apr_file_remove(pathname, p) != 0) {
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
    if (apr_file_open(&file, pathname,
                APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BINARY,
                APR_OS_DEFAULT, p) != APR_SUCCESS) {
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
    if (apr_file_write(file, pbuf->buf, &amt) != APR_SUCCESS
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
                             HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(ctx->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
            if (apr_file_perms_set(dst, perms)) {
                return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
    if ((apr_file_open(&inf, src, APR_READ | APR_BINARY, APR_OS_DEFAULT, p))
            != APR_SUCCESS) {
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(p, MAP_IO2HTTP(status), 0,
            if (apr_file_remove(dst, p) != APR_SUCCESS) {
                return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            if (apr_file_remove(dst, p) != APR_SUCCESS) {
            return dav_new_error(p, MAP_IO2HTTP(status), 0,
        int save_errno = errno;   /* save the errno that got us here */
             err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            err->save_errno = save_errno;
        else if (apr_file_remove(dst, p) != APR_SUCCESS) {
            /* Note that we use the latest errno */
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        err->save_errno = save_errno;
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
                return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
        return dav_new_error(p, MAP_IO2HTTP(rv), 0,
            if (apr_file_remove(stream->pathname, stream->p) != APR_SUCCESS) {
            return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, rv,
        return dav_new_error(stream->p, HTTP_INSUFFICIENT_STORAGE, 0,
        return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0,
    if (apr_file_seek(stream->f, APR_SET, &abs_pos) != APR_SUCCESS) {
        return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(pool, HTTP_CONFLICT, 0,
        return dav_new_error(pool, HTTP_CONFLICT, 0,
        return dav_new_error(pool, HTTP_FORBIDDEN, 0,
        return dav_new_error(pool, HTTP_FORBIDDEN, 0,
        return dav_new_error(ctx->pool, HTTP_INSUFFICIENT_STORAGE, 0,
        return dav_new_error(ctx->pool, HTTP_CONFLICT, 0,
        return dav_new_error(ctx->pool, HTTP_FORBIDDEN, 0,
            if (apr_dir_make(dstinfo->pathname, APR_OS_DEFAULT,
                             ctx->pool) != APR_SUCCESS) {
                err = dav_new_error(ctx->pool, HTTP_FORBIDDEN, 0, NULL);
            return dav_new_error(src->info->pool, HTTP_MULTI_STATUS, 0,
        return dav_new_error(src->info->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(src->info->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(srcinfo->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(info->pool, HTTP_MULTI_STATUS, 0,
    if (apr_file_remove(info->pathname, info->pool) != APR_SUCCESS) {
        return dav_new_error(info->pool, HTTP_FORBIDDEN, 0, NULL);
    if ((apr_dir_open(&dirp, fsctx->path1.buf, pool)) != APR_SUCCESS) {
        return dav_new_error(pool, HTTP_NOT_FOUND, 0, NULL);
        apr_status_t status;
            err = dav_new_error(pool, HTTP_NOT_FOUND, 0, NULL);
        return dav_new_error(params->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0,
            return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0,
        return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0,
    return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0,
    if (apr_file_perms_set(resource->info->pathname, perms) != APR_SUCCESS) {
                             HTTP_INTERNAL_SERVER_ERROR, 0,
    if (apr_file_perms_set(resource->info->pathname, perms) != APR_SUCCESS) {
                             HTTP_INTERNAL_SERVER_ERROR, 0,
    int save_errno = errno;
    err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, errcode, errstr);
    err->save_errno = save_errno;
                             HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN,
        return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN,
                             DAV_ERR_LOCK_NO_DB,
                             HTTP_INTERNAL_SERVER_ERROR, 0,
                                 DAV_ERR_LOCK_CORRUPT_DB,
                         DAV_ERR_LOCK_CORRUPT_DB,
                             HTTP_INTERNAL_SERVER_ERROR, 0,
        if (errscan->save_errno != 0) {
            errno = errscan->save_errno;
            ap_log_rerror(APLOG_MARK, level, errno, r, "%s  [%d, #%d]",
                          errscan->desc, errscan->status, errscan->error_id);
        }
        else {
            ap_log_rerror(APLOG_MARK, level, 0, r,
                          "%s  [%d, #%d]",
                          errscan->desc, errscan->status, errscan->error_id);
        }
        return dav_new_error(r->pool, HTTP_NOT_FOUND, 0,
                err = dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
                    err = dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
                    return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
                    err = dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
                            return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
                    err424_set = dav_new_error(p, HTTP_FAILED_DEPENDENCY, 0,
                    err424_delete = dav_new_error(p, HTTP_FAILED_DEPENDENCY, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
        err = dav_new_error(ctx->w.pool, HTTP_CONFLICT, 0,
        err = dav_new_error(ctx->w.pool, HTTP_CONFLICT, 0,
            err = dav_new_error(r->pool, multi_status->status, 0, multi_status->desc);
            err = dav_new_error(r->pool, HTTP_MULTI_STATUS, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
      err = dav_new_error(r->pool, HTTP_FORBIDDEN, 0,
    int save_errno;             /* copy of errno causing the error */
                                      int error_id, const char *desc);
** namespace may be NULL, which means "DAV:". save_errno will be
** filled with the current errno value.
                                          int error_id, const char *desc,
        return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
                                 DAV_ERR_PROP_READONLY,
                                 DAV_ERR_PROP_NO_DATABASE,
DAV_DECLARE(dav_error*) dav_new_error(apr_pool_t *p, int status,
                                      int error_id, const char *desc)
    int save_errno = errno;
    err->save_errno = save_errno;
                                          int error_id, const char *desc,
    dav_error *err = dav_new_error(p, status, error_id, desc);
                                     DAV_ERR_IF_TAGGED,
            if (apr_uri_parse(r->pool, uri, &parsed_uri) != APR_SUCCESS) {
                                     DAV_ERR_IF_TAGGED,
                                     DAV_ERR_IF_UNCLOSED_PAREN,
                                     DAV_ERR_IF_PARSE,
                                             DAV_ERR_IF_PARSE, NULL);
                                             DAV_ERR_IF_PARSE, NULL);
                                                 DAV_ERR_IF_MULTIPLE_NOT,
                                         DAV_ERR_IF_UNK_CHAR,
                                 DAV_ERR_IF_UNK_CHAR,
            return dav_new_error(p, HTTP_LOCKED, 0,
                return dav_new_error(p, HTTP_LOCKED, 0,
        return dav_new_error(p, HTTP_LOCKED, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0,
                        return dav_new_error(p, HTTP_FORBIDDEN, 0, errmsg);
            return dav_new_error(p, HTTP_LOCKED, 0 /* error_id */,
            return dav_new_error(p, HTTP_BAD_REQUEST, 0,
            return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0,
        return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0,
    return dav_new_error(p, HTTP_LOCKED, 1 /* error_id */,
        return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(r->pool, result, 0, NULL);
            err = dav_new_error(r->pool, HTTP_FORBIDDEN, 0,
            return dav_new_error(r->pool, HTTP_FAILED_DEPENDENCY, 0,
        return dav_new_error(r->pool, HTTP_MULTI_STATUS, 0,
        return dav_new_error(r->pool, HTTP_BAD_REQUEST, DAV_ERR_IF_ABSENT,
                return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
                err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0,
        return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0,
            return dav_new_error(r->pool, HTTP_MULTI_STATUS, 0,
            return dav_new_error(p, HTTP_BAD_REQUEST, 0,
    return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
 * created at config time in the parent are valid across children.  For
 * example, the vhostrec pointer in the scoreboard below is valid in all
 * children of the same generation.
 *
 * The safe way to access the vhost pointer is like this:
 *
 * worker_score *ss = pointer to whichver slot is interesting;
 * process_score *ps = pointer to whichver slot is interesting;
 * server_rec *vh = ss->vhostrec;
 *
 * if (ps->generation != ap_my_generation) {
 *     vh = NULL;
 * }
 *
 * then if vh is not NULL it's valid in this child.
 *
 * This avoids various race conditions around restarts.
    SB_SHARED = 1,
    SB_NOT_SHARED = 2
    server_rec *vhostrec;	/* What virtual host is being accessed? */
                                /* SEE ABOVE FOR SAFE USAGE! */
    worker_score *next;
    global_score global;
#define KEY_LENGTH 16
#define VALUE_LENGTH 64
typedef struct {
    char key[KEY_LENGTH];
    char value[VALUE_LENGTH];
} status_table_entry;
AP_DECLARE_NONSTD(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e t);
AP_DECLARE(void) ap_increment_counts(void *sbh, request_rec *r);
void ap_init_scoreboard(void);

AP_DECLARE(void) reopen_scoreboard(apr_pool_t *p);

AP_DECLARE(void) ap_create_sb_handle(void **new_handle, apr_pool_t *p,
AP_DECLARE(int) ap_update_child_status(void *sbh, int status, request_rec *r);
AP_DECLARE(worker_score *) ap_get_servers_scoreboard(int x, int y);
AP_DECLARE(process_score *) ap_get_parent_scoreboard(int x);
AP_DECLARE(global_score *) ap_get_global_scoreboard(void);
/* Disable shmem until pools/init gets sorted out - remove next line when fixed */
#define APR_HAS_SHARED_MEMORY 0

#if APR_HAS_SHARED_MEMORY
#include "apr_shmem.h"
#else
/* just provide dummies - the code does run-time checks anyway */
typedef   void apr_shmem_t;
typedef   void apr_shm_name_t;

/*
static apr_status_t apr_shm_init(apr_shmem_t **m, apr_size_t reqsize, const char *file, apr_pool_t *cont) {
    return APR_ENOTIMPL;
}
*/
static apr_status_t apr_shm_destroy(apr_shmem_t *m) {
    return APR_ENOTIMPL;
}
static void *apr_shm_malloc(apr_shmem_t *c, apr_size_t reqsize) {
    return NULL;
}
/*
static void *apr_shm_calloc(apr_shmem_t *shared, apr_size_t size) {
    return NULL;
}
*/
static apr_status_t apr_shm_free(apr_shmem_t *shared, void *free) {
    return APR_ENOTIMPL;
}
/*
static apr_status_t apr_shm_name_get(apr_shmem_t *c, apr_shm_name_t **name) {
    return APR_ENOTIMPL;
}
static apr_status_t apr_shm_name_set(apr_shmem_t *c, apr_shm_name_t *name) {
    return APR_ENOTIMPL;
}
static apr_status_t apr_shm_open(apr_shmem_t *c) {
    return APR_ENOTIMPL;
}
static apr_status_t apr_shm_avail(apr_shmem_t *c, apr_size_t *avail) {
    return APR_ENOTIMPL;
}
*/
#endif /* ndef APR_HAS_SHARED_MEMORY */

static apr_shmem_t    *client_shm = NULL;
static unsigned long *opaque_cntr;
    ap_log_rerror(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
    sts = apr_shm_init(&client_shm, shmem_size, tmpnam(NULL), ctx);
    client_list = apr_shm_malloc(client_shm, sizeof(*client_list) +
    opaque_cntr = apr_shm_malloc(client_shm, sizeof(*opaque_cntr));
    otn_counter = apr_shm_malloc(client_shm, sizeof(*otn_counter));
            apr_shm_free(client_shm, entry);
    entry = apr_shm_malloc(client_shm, sizeof(client_entry));
        entry = apr_shm_malloc(client_shm, sizeof(client_entry));
    server_rec *vhost;
	    vhost = ws_record.vhostrec;
	    if (ps_record.generation != ap_my_generation) {
		vhost = NULL;
	    }

			    vhost ? ap_escape_html(r->pool, 
				vhost->server_hostname) : "(unavailable)");
			     vhost ? ap_escape_html(r->pool, 
				vhost->server_hostname) : "(unavailable)",
                    n = ssl_rand_choosenum(0, sizeof(scoreboard)-1024-1);
#ifndef lint
static char const 
ssl_expr_yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
#endif
#include <stdlib.h>
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYLEX ssl_expr_yylex()
#define YYEMPTY -1
#define ssl_expr_yyclearin (ssl_expr_yychar=(YYEMPTY))
#define ssl_expr_yyerrok (ssl_expr_yyerrflag=0)
#define YYRECOVERING() (ssl_expr_yyerrflag!=0)
static int ssl_expr_yygrowstack();
#define YYPREFIX "ssl_expr_yy"
#line 69 "ssl_expr_parse.y"
#line 24 "y.tab.c"
#define YYERRCODE 256
#define T_TRUE 257
#define T_FALSE 258
#define T_DIGIT 259
#define T_ID 260
#define T_STRING 261
#define T_REGEX 262
#define T_REGEX_I 263
#define T_FUNC_FILE 264
#define T_OP_EQ 265
#define T_OP_NE 266
#define T_OP_LT 267
#define T_OP_LE 268
#define T_OP_GT 269
#define T_OP_GE 270
#define T_OP_REG 271
#define T_OP_NRE 272
#define T_OP_IN 273
#define T_OP_OR 274
#define T_OP_AND 275
#define T_OP_NOT 276
const short ssl_expr_yylhs[] = {                                        -1,
    0,    1,    1,    1,    1,    1,    1,    1,    2,    2,
    2,    2,    2,    2,    2,    2,    2,    5,    5,    6,
    6,    6,    6,    4,    4,    3,
const short ssl_expr_yylen[] = {                                         2,
    1,    1,    1,    2,    3,    3,    1,    3,    3,    3,
    3,    3,    3,    3,    5,    3,    3,    1,    3,    1,
    1,    4,    1,    1,    1,    4,
const short ssl_expr_yydefred[] = {                                      0,
    2,    3,   20,   21,    0,    0,    0,    0,    0,    0,
    7,   23,    0,    0,    4,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    8,
    0,    0,    6,    9,   10,   11,   12,   13,   14,   24,
   25,   16,   17,    0,   26,   22,    0,   18,   15,    0,
   19,
const short ssl_expr_yydgoto[] = {                                       9,
   10,   11,   12,   42,   47,   13,
const short ssl_expr_yysindex[] = {                                    -37,
    0,    0,    0,    0,  -35,  -37,  -37,  -99,    0, -247,
    0,    0, -250, -229,    0,  -39, -227,  -37,  -37,  -33,
  -33,  -33,  -33,  -33,  -33, -233, -233,  -89,   -6,    0,
  -87, -239,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  -33,    0,    0,  -38,    0,    0,  -33,
    0,
const short ssl_expr_yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   39,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    1,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,
const short ssl_expr_yygindex[] = {                                      0,
    7,    0,    0,   13,    0,  -13,
#define YYTABLESIZE 275
const short ssl_expr_yytable[] = {                                       8,
    5,   30,    7,    8,   14,   50,   34,   35,   36,   37,
   38,   39,   15,   16,   20,   21,   22,   23,   24,   25,
   26,   27,   28,   17,   32,   33,   18,   19,   40,   41,
   48,   29,   31,   44,   45,   19,   51,   46,    1,   43,
    0,    5,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   49,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
    2,    3,    0,    4,    0,    3,    5,    4,    0,    0,
    5,    0,    0,    0,   18,   19,    0,    0,    6,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    5,
const short ssl_expr_yycheck[] = {                                      37,
    0,   41,   40,   37,   40,   44,   20,   21,   22,   23,
   24,   25,    6,    7,  265,  266,  267,  268,  269,  270,
  271,  272,  273,  123,   18,   19,  274,  275,  262,  263,
   44,  261,  260,  123,   41,  275,   50,  125,    0,   27,
   -1,   41,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  125,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
  258,  259,   -1,  261,   -1,  259,  264,  261,   -1,   -1,
  264,   -1,   -1,   -1,  274,  275,   -1,   -1,  276,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  274,
#define YYFINAL 9
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 276
#if YYDEBUG
const char * const ssl_expr_yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,"'%'",0,0,"'('","')'",0,0,"','",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"T_TRUE",
"T_FALSE","T_DIGIT","T_ID","T_STRING","T_REGEX","T_REGEX_I","T_FUNC_FILE",
"T_OP_EQ","T_OP_NE","T_OP_LT","T_OP_LE","T_OP_GT","T_OP_GE","T_OP_REG",
"T_OP_NRE","T_OP_IN","T_OP_OR","T_OP_AND","T_OP_NOT",
const char * const ssl_expr_yyrule[] = {
"$accept : root",
"root : expr",
"expr : T_TRUE",
"expr : T_FALSE",
"expr : T_OP_NOT expr",
"expr : expr T_OP_OR expr",
"expr : expr T_OP_AND expr",
"expr : comparison",
"expr : '(' expr ')'",
"comparison : word T_OP_EQ word",
"comparison : word T_OP_NE word",
"comparison : word T_OP_LT word",
"comparison : word T_OP_LE word",
"comparison : word T_OP_GT word",
"comparison : word T_OP_GE word",
"comparison : word T_OP_IN '{' words '}'",
"comparison : word T_OP_REG regex",
"comparison : word T_OP_NRE regex",
"words : word",
"words : words ',' word",
"word : T_DIGIT",
"word : T_STRING",
"word : '%' '{' T_ID '}'",
"word : funccall",
"regex : T_REGEX",
"regex : T_REGEX_I",
"funccall : T_FUNC_FILE '(' T_STRING ')'",
#if YYDEBUG
#include <stdio.h>
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#define YYSTACKSIZE 10000
#define YYMAXDEPTH 10000
#define YYINITSTACKSIZE 200
int ssl_expr_yydebug;
int ssl_expr_yynerrs;
int ssl_expr_yyerrflag;
int ssl_expr_yychar;
short *ssl_expr_yyssp;
YYSTYPE *ssl_expr_yyvsp;
YYSTYPE ssl_expr_yyval;
YYSTYPE ssl_expr_yylval;
short *ssl_expr_yyss;
short *ssl_expr_yysslim;
YYSTYPE *ssl_expr_yyvs;
int ssl_expr_yystacksize;
#line 177 "ssl_expr_parse.y"
int ssl_expr_yyerror(char *s)
    ssl_expr_error = s;
    return 2;
#line 230 "y.tab.c"
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int ssl_expr_yygrowstack()
    int newsize, i;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = ssl_expr_yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;
    i = ssl_expr_yyssp - ssl_expr_yyss;
    newss = ssl_expr_yyss ? (short *)realloc(ssl_expr_yyss, newsize * sizeof *newss) :
      (short *)malloc(newsize * sizeof *newss);
    if (newss == NULL)
        return -1;
    ssl_expr_yyss = newss;
    ssl_expr_yyssp = newss + i;
    newvs = ssl_expr_yyvs ? (YYSTYPE *)realloc(ssl_expr_yyvs, newsize * sizeof *newvs) :
      (YYSTYPE *)malloc(newsize * sizeof *newvs);
    if (newvs == NULL)
        return -1;
    ssl_expr_yyvs = newvs;
    ssl_expr_yyvsp = newvs + i;
    ssl_expr_yystacksize = newsize;
    ssl_expr_yysslim = ssl_expr_yyss + newsize - 1;
    return 0;
#define YYABORT goto ssl_expr_yyabort
#define YYREJECT goto ssl_expr_yyabort
#define YYACCEPT goto ssl_expr_yyaccept
#define YYERROR goto ssl_expr_yyerrlab
#ifndef YYPARSE_PARAM
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG void
#else	/* ! ANSI-C/C++ */
#endif	/* ANSI-C/C++ */
#else	/* YYPARSE_PARAM */
#ifndef YYPARSE_PARAM_TYPE
#define YYPARSE_PARAM_TYPE void *
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
#endif	/* ANSI-C/C++ */
#endif	/* ! YYPARSE_PARAM */
ssl_expr_yyparse (YYPARSE_PARAM_ARG)
    YYPARSE_PARAM_DECL
    register int ssl_expr_yym, ssl_expr_yyn, ssl_expr_yystate;
#if YYDEBUG
    register const char *ssl_expr_yys;
    if ((ssl_expr_yys = getenv("YYDEBUG")))
        ssl_expr_yyn = *ssl_expr_yys;
        if (ssl_expr_yyn >= '0' && ssl_expr_yyn <= '9')
            ssl_expr_yydebug = ssl_expr_yyn - '0';
    ssl_expr_yynerrs = 0;
    ssl_expr_yyerrflag = 0;
    ssl_expr_yychar = (-1);
    if (ssl_expr_yyss == NULL && ssl_expr_yygrowstack()) goto ssl_expr_yyoverflow;
    ssl_expr_yyssp = ssl_expr_yyss;
    ssl_expr_yyvsp = ssl_expr_yyvs;
    *ssl_expr_yyssp = ssl_expr_yystate = 0;
ssl_expr_yyloop:
    if ((ssl_expr_yyn = ssl_expr_yydefred[ssl_expr_yystate])) goto ssl_expr_yyreduce;
    if (ssl_expr_yychar < 0)
        if ((ssl_expr_yychar = ssl_expr_yylex()) < 0) ssl_expr_yychar = 0;
#if YYDEBUG
        if (ssl_expr_yydebug)
        {
            ssl_expr_yys = 0;
            if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
            if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, ssl_expr_yystate, ssl_expr_yychar, ssl_expr_yys);
        }
    if ((ssl_expr_yyn = ssl_expr_yysindex[ssl_expr_yystate]) && (ssl_expr_yyn += ssl_expr_yychar) >= 0 &&
            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yychar)
#if YYDEBUG
        if (ssl_expr_yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, ssl_expr_yystate, ssl_expr_yytable[ssl_expr_yyn]);
#endif
        if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
        {
            goto ssl_expr_yyoverflow;
        }
        *++ssl_expr_yyssp = ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
        *++ssl_expr_yyvsp = ssl_expr_yylval;
        ssl_expr_yychar = (-1);
        if (ssl_expr_yyerrflag > 0)  --ssl_expr_yyerrflag;
        goto ssl_expr_yyloop;
    if ((ssl_expr_yyn = ssl_expr_yyrindex[ssl_expr_yystate]) && (ssl_expr_yyn += ssl_expr_yychar) >= 0 &&
            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yychar)
        ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];
        goto ssl_expr_yyreduce;
    }
    if (ssl_expr_yyerrflag) goto ssl_expr_yyinrecovery;
#if defined(lint) || defined(__GNUC__)
    goto ssl_expr_yynewerror;
ssl_expr_yynewerror:
    ssl_expr_yyerror("syntax error");
#if defined(lint) || defined(__GNUC__)
    goto ssl_expr_yyerrlab;
ssl_expr_yyerrlab:
    ++ssl_expr_yynerrs;
ssl_expr_yyinrecovery:
    if (ssl_expr_yyerrflag < 3)
    {
        ssl_expr_yyerrflag = 3;
        for (;;)
        {
            if ((ssl_expr_yyn = ssl_expr_yysindex[*ssl_expr_yyssp]) && (ssl_expr_yyn += YYERRCODE) >= 0 &&
                    ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (ssl_expr_yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *ssl_expr_yyssp, ssl_expr_yytable[ssl_expr_yyn]);
#endif
                if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
                {
                    goto ssl_expr_yyoverflow;
                }
                *++ssl_expr_yyssp = ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
                *++ssl_expr_yyvsp = ssl_expr_yylval;
                goto ssl_expr_yyloop;
            }
            else
            {
#if YYDEBUG
                if (ssl_expr_yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *ssl_expr_yyssp);
#endif
                if (ssl_expr_yyssp <= ssl_expr_yyss) goto ssl_expr_yyabort;
                --ssl_expr_yyssp;
                --ssl_expr_yyvsp;
            }
        }
    else
        if (ssl_expr_yychar == 0) goto ssl_expr_yyabort;
#if YYDEBUG
        if (ssl_expr_yydebug)
        {
            ssl_expr_yys = 0;
            if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
            if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, ssl_expr_yystate, ssl_expr_yychar, ssl_expr_yys);
        }
#endif
        ssl_expr_yychar = (-1);
        goto ssl_expr_yyloop;
#if YYDEBUG
    if (ssl_expr_yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, ssl_expr_yystate, ssl_expr_yyn, ssl_expr_yyrule[ssl_expr_yyn]);
#endif
    ssl_expr_yym = ssl_expr_yylen[ssl_expr_yyn];
    ssl_expr_yyval = ssl_expr_yyvsp[1-ssl_expr_yym];
    switch (ssl_expr_yyn)
{ ssl_expr_info.expr = ssl_expr_yyvsp[0].exVal; }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_True,  NULL, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_False, NULL, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Not,   ssl_expr_yyvsp[0].exVal,   NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Or,    ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_And,   ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Comp,  ssl_expr_yyvsp[0].exVal,   NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[-1].exVal; }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_EQ,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_IN,  ssl_expr_yyvsp[-4].exVal, ssl_expr_yyvsp[-1].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_REG, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NRE, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, ssl_expr_yyvsp[-2].exVal);   }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Digit,  ssl_expr_yyvsp[0].cpVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_String, ssl_expr_yyvsp[0].cpVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Var,    ssl_expr_yyvsp[-1].cpVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[0].exVal; }
break;
            }
break;
            }
break;
            }
break;
#line 550 "y.tab.c"
    ssl_expr_yyssp -= ssl_expr_yym;
    ssl_expr_yystate = *ssl_expr_yyssp;
    ssl_expr_yyvsp -= ssl_expr_yym;
    ssl_expr_yym = ssl_expr_yylhs[ssl_expr_yyn];
    if (ssl_expr_yystate == 0 && ssl_expr_yym == 0)
#if YYDEBUG
        if (ssl_expr_yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        ssl_expr_yystate = YYFINAL;
        *++ssl_expr_yyssp = YYFINAL;
        *++ssl_expr_yyvsp = ssl_expr_yyval;
        if (ssl_expr_yychar < 0)
        {
            if ((ssl_expr_yychar = ssl_expr_yylex()) < 0) ssl_expr_yychar = 0;
#if YYDEBUG
            if (ssl_expr_yydebug)
            {
                ssl_expr_yys = 0;
                if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
                if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, ssl_expr_yychar, ssl_expr_yys);
            }
#endif
        }
        if (ssl_expr_yychar == 0) goto ssl_expr_yyaccept;
        goto ssl_expr_yyloop;
    if ((ssl_expr_yyn = ssl_expr_yygindex[ssl_expr_yym]) && (ssl_expr_yyn += ssl_expr_yystate) >= 0 &&
            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yystate)
        ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
    else
        ssl_expr_yystate = ssl_expr_yydgoto[ssl_expr_yym];
#if YYDEBUG
    if (ssl_expr_yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *ssl_expr_yyssp, ssl_expr_yystate);
#endif
    if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
        goto ssl_expr_yyoverflow;
    *++ssl_expr_yyssp = ssl_expr_yystate;
    *++ssl_expr_yyvsp = ssl_expr_yyval;
    goto ssl_expr_yyloop;
ssl_expr_yyoverflow:
    ssl_expr_yyerror("yacc stack overflow");
ssl_expr_yyabort:
    return (1);
ssl_expr_yyaccept:
    return (0);
#ifndef YYERRCODE
#define YYERRCODE 256
#endif

#define T_TRUE 257
#define T_FALSE 258
#define T_DIGIT 259
#define T_ID 260
#define T_STRING 261
#define T_REGEX 262
#define T_REGEX_I 263
#define T_FUNC_FILE 264
#define T_OP_EQ 265
#define T_OP_NE 266
#define T_OP_LT 267
#define T_OP_LE 268
#define T_OP_GT 269
#define T_OP_GE 270
#define T_OP_REG 271
#define T_OP_NRE 272
#define T_OP_IN 273
#define T_OP_OR 274
#define T_OP_AND 275
#define T_OP_NOT 276
    void *sbh;
    void *sbh;
        ap_scoreboard_image->global.running_generation = ap_my_generation;
        rc = DosAllocSharedMem((PPVOID)&ap_scoreboard_image, ap_scoreboard_fname,
        ap_init_scoreboard();
    } while (!shutdown_pending && ap_my_generation == ap_scoreboard_image->global.running_generation);
    void *sbh;
    void *sbh;
        ap_scoreboard_image->global.running_generation = ap_my_generation;
    void *sbh;
    void *sbh;
    reopen_scoreboard(pchild);
    ap_scoreboard_image->global.running_generation = ap_my_generation;
	ap_scoreboard_image->global.running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
	ap_scoreboard_image->global.running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
    void *sbh;
    thread_control[THREAD_GLOBAL(thread_num)].generation = ap_scoreboard_image->global.running_generation;
    ++ap_scoreboard_image->global.running_generation;
    void *sbh;
        /* Set up the scoreboard. */
        ap_run_pre_mpm(pconf, SB_NOT_SHARED);
        /* Humm... Should we put the parent pid here? Does it matter 
         * since the scoreboard is not shared?
         */
        ap_scoreboard_image->parent[0].pid = parent_pid;
        ap_scoreboard_image->parent[0].quiescing = 0;
    void *sbh;
    reopen_scoreboard(pchild);
    ap_scoreboard_image->global.running_generation = ap_my_generation;
AP_DECLARE(const char *) ap_mpm_set_scoreboard(cmd_parms *cmd, void *dummy,
					       const char *arg)

AP_DECLARE(const char *) ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
					     const char *arg)
#include "apr_shmem.h"
static apr_shmem_t *scoreboard_shm = NULL;
typedef struct sb_handle {
} sb_handle;
    apr_shm_free(scoreboard_shm, ap_scoreboard_image);
    scoreboard_size = sizeof(scoreboard);
    scoreboard_size += sizeof(worker_score * ) * server_limit;
void ap_init_scoreboard(void)
    memset(ap_scoreboard_image, 0, scoreboard_size);
    more_storage = (char *)(ap_scoreboard_image + 1);
    ap_scoreboard_image->servers = (worker_score **)more_storage;
    more_storage += server_limit * sizeof(worker_score *);

    ap_assert(more_storage == (char *)ap_scoreboard_image + scoreboard_size);
static apr_status_t setup_shared(apr_pool_t *p)
    const char *fname;
    fname = ap_server_root_relative(p, ap_scoreboard_fname);
    rv = apr_shm_init(&scoreboard_shm, scoreboard_size, fname, p);
    ap_scoreboard_image = apr_shm_malloc(scoreboard_shm, scoreboard_size);
    if (ap_scoreboard_image == NULL) {
        ap_log_error(APLOG_MARK, APLOG_CRIT | APLOG_NOERRNO, 0, NULL,
                     "Fatal error: cannot allocate scoreboard");
        apr_shm_destroy(scoreboard_shm);
        return APR_EGENERAL;
    }
AP_DECLARE(void) reopen_scoreboard(apr_pool_t *p)
/* ap_cleanup_scoreboard
 * 
 */
    if (ap_scoreboard_image->global.sb_type == SB_SHARED) {
/* ap_create_scoreboard(apr_pool_t*, ap_scoreboard_e t)
 *
 * Create or reinit an existing scoreboard. The MPM can control whether
 *
 * ###: Is there any reason to export this symbol in the first place?
AP_DECLARE_NONSTD(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
	running_gen = ap_scoreboard_image->global.running_generation;
            rv = setup_shared(p);
            if (rv) {
            ap_scoreboard_image = (scoreboard *) malloc(scoreboard_size);
            if (ap_scoreboard_image == NULL) {
    ap_init_scoreboard(); /* can't just memset() */
    ap_scoreboard_image->global.sb_type = sb_type;
    ap_scoreboard_image->global.running_generation = running_gen;
    ap_restart_time = apr_time_now();
    apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
				       worker_score *new_score_rec)
    lseek(scoreboard_fd, (long) child_num * sizeof(worker_score), 0);
    lseek(scoreboard_fd,
	  (char *) &ap_scoreboard_image->global -(char *) ap_scoreboard_image, 0);
AP_DECLARE(void) ap_increment_counts(void *sbh, request_rec *r)
    sb_handle *sb = sbh;
AP_DECLARE(void) ap_create_sb_handle(void **new_handle, apr_pool_t *p,
    sb_handle *sbh;

    sbh = (sb_handle *)apr_palloc(p, sizeof *sbh);
    *new_handle = sbh;
    sbh->child_num = child_num;
    sbh->thread_num = thread_num;
    int old_status, i;
        if (ps->generation != ap_my_generation) {
            for (i = 0; i < thread_limit; i++) {
                ap_scoreboard_image->servers[child_num][i].vhostrec = NULL;
            }
            ps->generation = ap_my_generation;
        }
	    ws->vhostrec =  r->server;
AP_DECLARE(int)ap_update_child_status(void *sbh, int status, request_rec *r)
    sb_handle *sb = sbh;
    
    return ap_update_child_status_from_indexes(sb->child_num, sb->thread_num,
AP_DECLARE(worker_score *) ap_get_servers_scoreboard(int x, int y)
AP_DECLARE(process_score *) ap_get_parent_scoreboard(int x)
AP_DECLARE(global_score *) ap_get_global_scoreboard()
    return(&ap_scoreboard_image->global);
                site, basedir, ap_escape_html(p, path),
                site, str);
#define MODULE_MAGIC_NUMBER_MINOR 22                   /* 0...n */
static int clear_conn_headers(void *data, const char *key, const char *val)
{
    apr_table_t *headers = ((header_dptr*)data)->table;
    apr_pool_t *pool = ((header_dptr*)data)->pool;
    const char *name;
    char *next = apr_pstrdup(pool, val);
    while (*next) {
        name = next;
        while (*next && !apr_isspace(*next) && (*next != ',')) {
            ++next;
        }
        while (*next && (apr_isspace(*next) || (*next == ','))) {
            *next++ = '\0';
        }
        apr_table_unset(headers, name);
    }
    return 1;
}
static void ap_proxy_clear_connection(apr_pool_t *p, apr_table_t *headers)
{
    header_dptr x;
    x.pool = p;
    x.table = headers;
    apr_table_unset(headers, "Proxy-Connection");
    apr_table_do(clear_conn_headers, &x, headers, "Connection", NULL);
    apr_table_unset(headers, "Connection");
}
            if (ap_find_token(p, apr_table_get(r->headers_out, "Connection"),
                              "close"))
                backend->close = 1;
            ap_proxy_clear_connection(p, r->headers_out);
void proxy_util_register_hooks(apr_pool_t *p)
{
    APR_REGISTER_OPTIONAL_FN(ap_proxy_retry_worker);
}

/* Clear all connection-based headers from the incoming headers table */
typedef struct header_dptr {
    apr_table_t *table;
    apr_time_t time;
} header_dptr;
static int clear_conn_headers(void *data, const char *key, const char *val)
    apr_table_t *headers = ((header_dptr*)data)->table;
    apr_pool_t *pool = ((header_dptr*)data)->pool;
    char *next = apr_pstrdup(pool, val);
    while (*next) {
        name = next;
        while (*next && !apr_isspace(*next) && (*next != ',')) {
            ++next;
        while (*next && (apr_isspace(*next) || (*next == ','))) {
            *next++ = '\0';
        apr_table_unset(headers, name);
    }
static void proxy_clear_connection(apr_pool_t *p, apr_table_t *headers)
    header_dptr x;
    x.pool = p;
    x.table = headers;
    apr_table_do(clear_conn_headers, &x, headers, "Connection", NULL);
    apr_table_unset(headers, "Connection");
    proxy_clear_connection(p, headers_in_copy);
 * 20051231.0 (2.3.0-dev)  Added num_blank_lines, pending_header_line, and
 *                         pending_header_size to request_rec
    /** Number of leading blank lines encountered before request header */
    int num_blank_lines;

    /** A buffered header line, used to support header folding while
     *  reading the request */
    char *pending_header_line;

    /** If nonzero, the number of bytes allocated to hold pending_header_line */
    apr_size_t pending_header_size;

static void set_the_request(request_rec *r, char *line)
    apr_socket_t *csd;
    ll = r->the_request = line;
             && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */
    }
    else {
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(r->connection->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->connection->base_server->timeout);

    return;
}

static apr_status_t set_mime_header(request_rec *r, char *line)
{
    char *value, *tmp_field;

    if (r->server->limit_req_fields) {
        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);
        if (mime_headers->nelts >= r->server->limit_req_fields) {
            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields "
                           "exceeds this server's limit.");
            r->status = HTTP_BAD_REQUEST;
            return APR_ENOSPC;
        }
    }
    
    if (!(value = strchr(line, ':'))) { /* Find ':' or    */
        r->status = HTTP_BAD_REQUEST;      /* abort bad request */
        apr_table_setn(r->notes, "error-notes",
                       apr_pstrcat(r->pool,
                                   "Request header field is "
                                   "missing ':' separator.<br />\n"
                                   "<pre>\n",
                                   ap_escape_html(r->pool, line),
                                   "</pre>\n", NULL));
        return APR_EGENERAL;
    }

    tmp_field = value - 1; /* last character of field-name */

    *value++ = '\0'; /* NUL-terminate at colon */

    while (*value == ' ' || *value == '\t') {
        ++value;            /* Skip to start of value   */
    }

    /* Strip LWS after field-name: */
    while (tmp_field > line
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }

    /* Strip LWS after field-value: */
    tmp_field = strchr(value, '\0') - 1;
    while (tmp_field > value
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }
    apr_table_addn(r->headers_in, line, value);
    return APR_SUCCESS;
}

static apr_status_t process_request_line(request_rec *r, char *line,
                                         int skip_first)
{
    if (!skip_first && (r->the_request == NULL)) {
        /* This is the first line of the request */
        if ((line == NULL) || (*line == '\0')) {
            /* We skip empty lines because browsers have to tack a CRLF on to the end
             * of POSTs to support old CERN webservers.
             */
            int max_blank_lines = r->server->limit_req_fields;
            if (max_blank_lines <= 0) {
                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
            }
            r->num_blank_lines++;
            if (r->num_blank_lines < max_blank_lines) {
                return APR_SUCCESS;
            }
        }
        set_the_request(r, line);
    }
    else {
        /* We've already read the first line of the request.  This is either
         * a header field or the blank line terminating the header
         */
        if ((line == NULL) || (*line == '\0')) {
            if (r->pending_header_line != NULL) {
                apr_status_t rv = set_mime_header(r, r->pending_header_line);
                if (rv != APR_SUCCESS) {
                    return rv;
                }
                r->pending_header_line = NULL;
            }
            if (r->status == HTTP_REQUEST_TIME_OUT) {
                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
                r->status = HTTP_OK;
            }
        }
        else {
            if ((*line == ' ') || (*line == '\t')) {
                /* This line is a continuation of the previous one */
                if (r->pending_header_line == NULL) {
                    r->pending_header_line = line;
                    r->pending_header_size = 0;
                }
                else {
                    apr_size_t pending_len = strlen(r->pending_header_line);
                    apr_size_t fold_len = strlen(line);
                    if ((r->server->limit_req_fieldsize > 0)
						&& (pending_len + fold_len >
                               (apr_size_t) r->server->limit_req_fieldsize)) {
                        /* CVE-2004-0942 */
                        r->status = HTTP_BAD_REQUEST;
                        return APR_ENOSPC;
                    }
                    if (pending_len + fold_len + 1 > r->pending_header_size) {
                        /* Allocate a new buffer big enough to hold the
                         * concatenated lines
                         */
                        apr_size_t new_size = r->pending_header_size;
                        char *new_buf;
                        if (new_size == 0) {
                            new_size = pending_len + fold_len + 1;
                        }
                        else {
                            do {
                                new_size *= 2;
                            } while (new_size < pending_len + fold_len + 1);
                        }
                        new_buf = (char *)apr_palloc(r->pool, new_size);
                        memcpy(new_buf, r->pending_header_line, pending_len);
                        r->pending_header_line = new_buf;
                        r->pending_header_size = new_size;
                    }
                    memcpy(r->pending_header_line + pending_len, line,
                           fold_len + 1);
                }
            }
            else {
                /* Set aside this line in case the next line is a continuation
                 */
                if (r->pending_header_line != NULL) {
                    apr_status_t rv = set_mime_header(r, r->pending_header_line);
                    if (rv != APR_SUCCESS) {
                        return rv;
                    }
                }
                r->pending_header_line = line;
                r->pending_header_size = 0;
            }
        }
    }
    return APR_SUCCESS;
        rv = process_request_line(r, field, 1);
        if (rv != APR_SUCCESS) {
            return;
        if ((field == NULL) || (*field == '\0')) {
            return;
static request_rec *init_request(conn_rec *conn)
    
    return r;
}
static request_rec *request_post_read(request_rec *r, conn_rec *conn)
{
    apr_socket_t *csd;
    const char *expect;
    int access_status;
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->server->timeout);

    if (apr_table_get(r->headers_in, "Transfer-Encoding") &&
        apr_table_get(r->headers_in, "Content-Length")) {
        /* 2616 section 4.4, point 3: "if both Transfer-Encoding
         * and Content-Length are received, the latter MUST be
         * ignored"; so unset it here to prevent any confusion
         * later.
         */
        apr_table_unset(r->headers_in, "Content-Length");
static apr_status_t read_partial_request(request_rec *r) {
    apr_bucket_brigade *tmp_bb;
    apr_status_t rv = APR_SUCCESS;

    /* Read and process lines of the request until we
     * encounter a complete request header, an error, or EAGAIN
     */
    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    while (r->status == HTTP_REQUEST_TIME_OUT) {
        char *line = NULL;
        apr_size_t line_length;
        apr_size_t length_limit;
        int first_line = (r->the_request == NULL);
        if (first_line) {
            length_limit = r->server->limit_req_line;
        }
        else {
            if (r->assbackwards) {
                r->status = HTTP_OK;
                break;
            }
            length_limit = r->server->limit_req_fieldsize;
        }
        /* TODO: use a nonblocking call in place of ap_rgetline */
        rv = ap_rgetline(&line, length_limit + 2,
                         &line_length, r, 0, tmp_bb);
        if (rv == APR_SUCCESS) {
            rv = process_request_line(r, line, 0);
        }
        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();
            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                if (first_line) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: URI too long (longer than %d)",
                                  r->server->limit_req_line);
                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                    r->proto_num = HTTP_VERSION(1,0);
                    r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
                }
                else {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: header line too long "
                                  "(longer than %d)",
                                  r->server->limit_req_fieldsize);
                    r->status = HTTP_BAD_REQUEST;
                }
            }
            break;
        }
    }
    apr_brigade_destroy(tmp_bb);
    return rv;
}

request_rec *ap_read_request(conn_rec *conn)
{
    request_rec *r;
    apr_status_t rv;

    r = init_request(conn);

    rv = read_partial_request(r);
    /* TODO poll if EAGAIN */
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return NULL;
    }

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers! Have to dink things just to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "client sent invalid HTTP/0.9 request: HEAD %s",
                      r->uri);
        r->header_only = 0;
        r->status = HTTP_BAD_REQUEST;
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return r;
    }

    return request_post_read(r, conn);
}

    path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path, 0, r->proxyreq);
    imap_conf_rec *new = (imap_conf_rec *) apr_pcalloc(p, sizeof(imap_conf_rec));
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted") && *comment) {
    if (!strcasecmp(menu, "unformatted") && *comment) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
        cl_val = atol(old_cl_val);
 * @return The length of the line, if successful
 *         n, if the line is too big to fit in the buffer
 *         -1 for miscellaneous errors
 * @deffunc int ap_method_number_of(const char *method)
AP_DECLARE(int) ap_rgetline(char **s, int n, request_rec *r, int fold);
 * Returns: 
 *     the length of s (normal case),
 *     n               (buffer full),
 *    -1               (other errors)
AP_DECLARE(int) ap_rgetline(char **s, int n, request_rec *r, int fold)
    char *pos;
    char *last_char;
    const char *temp;
    int retval;
    apr_size_t total = 0;
    int looking_ahead = 0;
    apr_size_t length;
    core_request_config *req_cfg;
    int do_alloc = (*s == NULL);
    apr_size_t alloc_size = 0;

    req_cfg = (core_request_config *)
                ap_get_module_config(r->request_config, &core_module);
    b = req_cfg->bb;
    /* make sure it's empty unless we're folding */ 
    AP_DEBUG_ASSERT(fold || APR_BRIGADE_EMPTY(b));

    while (1) {
        if (APR_BRIGADE_EMPTY(b)) {
            apr_off_t zero = 0;
            if ((retval = ap_get_brigade(r->input_filters, b,
                                         AP_MODE_GETLINE,
                                         APR_BLOCK_READ,
                                         &zero)) != APR_SUCCESS ||
                APR_BRIGADE_EMPTY(b)) {
                apr_brigade_destroy(b);
                return -1;
            }
        }
        e = APR_BRIGADE_FIRST(b); 
            return -1;
        if (e->length == 0) {
            apr_bucket_delete(e);
            continue;
        retval = apr_bucket_read(e, &temp, &length, APR_BLOCK_READ);
        if (retval != APR_SUCCESS) {
            apr_brigade_destroy(b);
            ap_log_rerror(APLOG_MARK, APLOG_ERR, retval, r, "apr_bucket_read() failed");
            if (total) {
                break; /* report previously-read data to caller, do ap_xlate_proto_to_ascii() */
            else {
                return -1;
        if ((looking_ahead) && (*temp != APR_ASCII_BLANK) && (*temp != APR_ASCII_TAB)) { 
            /* can't fold because next line isn't indented, 
             * so return what we have.  lookahead brigade is 
             * stashed on req_cfg->bb
             */
            AP_DEBUG_ASSERT(!APR_BRIGADE_EMPTY(req_cfg->bb));
            break;
        }
        if (total + length - 1 < (apr_size_t)n) {
                if (!*s) {
                    alloc_size = length;
                    *s = apr_palloc(r->pool, length + 2); /* +2 for LF, null */
                }
                else if (total + length > alloc_size) {
                    apr_size_t new_size = alloc_size;
                    char *new_buffer;
                    do {
                        new_size *= 2;
                    } while (total + length > new_size);
                    new_buffer = apr_palloc(r->pool, new_size + 2);
                    memcpy(new_buffer, *s, total);
                    alloc_size = new_size;
                    *s = new_buffer;
                }
            pos = *s + total;
            last_char = pos + length - 1;
            memcpy(pos, temp, length);
            apr_bucket_delete(e);
            /* input line was larger than the caller's buffer */
            apr_brigade_destroy(b); 
            /* don't need to worry about req_cfg->bb being bogus.
             * the request is about to die, and ErrorDocument
             * redirects get a new req_cfg->bb
             */
            return n;
        
        pos = last_char;        /* Point at the last character           */
        if (*pos == APR_ASCII_LF) { /* Did we get a full line of input?      */
                
            if (pos > *s && *(pos - 1) == APR_ASCII_CR) {
                --pos;          /* zap optional CR before LF             */
            }
                
            /*
             * Trim any extra trailing spaces or tabs except for the first
             * space or tab at the beginning of a blank string.  This makes
             * it much easier to check field values for exact matches, and
             * saves memory as well.  Terminate string at end of line.
             */
            while (pos > ((*s) + 1) && 
                   (*(pos - 1) == APR_ASCII_BLANK || *(pos - 1) == APR_ASCII_TAB)) {
                --pos;          /* trim extra trailing spaces or tabs    */
            }
            *pos = '\0';        /* zap end of string                     */
            total = pos - *s;   /* update total string length            */

            /* look ahead another line if line folding is desired 
             * and this line isn't empty
             */
            if (fold && total) {
                looking_ahead = 1;
                AP_DEBUG_ASSERT(APR_BRIGADE_EMPTY(req_cfg->bb));
                break;
        else {
            /* no LF yet...character mode client (telnet)...keep going
             * bump past last character read,   
             * and set total in case we bail before finding a LF   
             */
            total = ++pos - *s;
            looking_ahead = 0;  /* only appropriate right after LF       */ 
        }
    ap_xlate_proto_from_ascii(*s, total);
    return total;
    return ap_rgetline(&tmp_s, n, r, fold);
    int len;
    while ((len = ap_rgetline(&(r->the_request),
                              DEFAULT_LIMIT_REQUEST_LINE + 2, r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
	    /* this is a hack to make sure that request time is set,
	     * it's not perfect, but it's better than nothing 
	     */
	    r->request_time = apr_time_now();
    }
    int len;
    field = NULL;
    while ((len = ap_rgetline(&field, DEFAULT_LIMIT_REQUEST_FIELDSIZE + 2,
                              r, 1)) > 0) {
        if (r->server->limit_req_fields &&
            (++fields_read > r->server->limit_req_fields)) {
			   "The number of request header fields exceeds "
			   "this server's limit.");
        /* ap_getline returns (size of max buffer - 1) if it fills up the
         * buffer before finding the end-of-line.  This is only going to
         * happen if it exceeds the configured limit for a field size.
         */
        if (len > r->server->limit_req_fieldsize) {
			   apr_pstrcat(r->pool,
				       "Size of a request header field "
				       "exceeds server limit.<br />\n"
				       "<pre>\n",
				       ap_escape_html(r->pool, field),
				       "</pre>\n", NULL));
	}
	apr_table_addn(tmp_headers, field, value);
        field = NULL; /* to cause ap_rgetline to allocate a new one */
    apr_pool_t *pPool;
                          s->process->pool);
    pPool = s->process->pool;
    mc = (SSLModConfigRec *)apr_palloc(pPool, sizeof(*mc));
    mc->pPool = pPool;
    mc->aRandSeed              = apr_array_make(pPool, 4,
    mc->tVHostKeys             = apr_hash_make(pPool);
    mc->tPrivateKey            = apr_hash_make(pPool);
    mc->tPublicCert            = apr_hash_make(pPool);
    mc->tTmpKeys               = apr_hash_make(pPool);
                          s->process->pool);
    ssl_randseed_t *pRS;
    pRS = apr_array_push(mc->aRandSeed);
        pRS->nCtx = SSL_RSCTX_STARTUP;
        pRS->nCtx = SSL_RSCTX_CONNECT;
        pRS->nSrc   = SSL_RSSRC_FILE;
        pRS->cpPath = ap_server_root_relative(mc->pPool, arg2+5);
        pRS->nSrc   = SSL_RSSRC_EXEC;
        pRS->cpPath = ap_server_root_relative(mc->pPool, arg2+5);
        pRS->nSrc   = SSL_RSSRC_EGD;
        pRS->cpPath = ap_server_root_relative(mc->pPool, arg2+4);
        pRS->nSrc   = SSL_RSSRC_BUILTIN;
        pRS->cpPath = NULL;
        pRS->nSrc   = SSL_RSSRC_FILE;
        pRS->cpPath = ap_server_root_relative(mc->pPool, arg2);
    if (pRS->nSrc != SSL_RSSRC_BUILTIN) {
        if (!ssl_util_path_check(SSL_PCM_EXISTS, pRS->cpPath, cmd->pool)) {
                               pRS->cpPath, "' does not exist", NULL);
        pRS->nBytes = 0; /* read whole file */
        if (pRS->nSrc == SSL_RSSRC_BUILTIN) {
        pRS->nBytes = atoi(arg3);
        if (pRS->nBytes < 0) {
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
            sc->szPublicCertFile[i] = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
            sc->szPrivateKeyFile[i] = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
    sc->szCertificateChain = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, cpPath, cmd->pool)) {
                           cpPath, "' does not exist", NULL);
        sc->szCACertificatePath = cpPath;
        dc->szCACertificatePath = cpPath;
    sc->szCACertificatePath = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
        sc->szCACertificateFile = cpPath;
        dc->szCACertificateFile = cpPath;
    sc->szCACertificateFile = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, cpPath, cmd->pool)) {
                           cpPath, "' does not exist", NULL);
    sc->szCARevocationPath = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
    sc->szCARevocationFile = cpPath;
                               const char *cpLine)
    while (*cpLine) {
        w = ap_getword_conf(cmd->pool, &cpLine);
                               const char *cpExpr)
    ssl_expr *mpExpr;
    ssl_require_t *pReqRec;
    if (!(mpExpr = ssl_expr_comp(cmd->pool, (char *)cpExpr))) {
    pReqRec = apr_array_push(dc->aRequirement);
    pReqRec->cpExpr = apr_pstrdup(cmd->pool, cpExpr);
    pReqRec->mpExpr = mpExpr;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
    sc->szProxyCACertificateFile = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, cpPath, cmd->pool)) {
                           cpPath, "' does not exist", NULL);
    sc->szProxyCACertificatePath = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
    sc->szProxyClientCertificateFile = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, cpPath, cmd->pool)) {
                           cpPath, "' does not exist", NULL);
    sc->szProxyClientCertificatePath = cpPath;
    unsigned char *ucp;
        ucp = ssl_asn1_table_set(mc->tTmpKeys, "RSA:512", length);
        (void)i2d_RSAPrivateKey(rsa, &ucp); /* 2nd arg increments */
        ucp = ssl_asn1_table_set(mc->tTmpKeys, "RSA:1024", length);
        (void)i2d_RSAPrivateKey(rsa, &ucp); /* 2nd arg increments */
        ucp = ssl_asn1_table_set(mc->tTmpKeys, "DH:512", length);
        (void)i2d_DHparams(dh, &ucp); /* 2nd arg increments */
        ucp = ssl_asn1_table_set(mc->tTmpKeys, "DH:1024", length);
        (void)i2d_DHparams(dh, &ucp); /* 2nd arg increments */
            ucp = asn1->cpData;
                  d2i_RSAPrivateKey(NULL, &ucp, asn1->nData)))
            ucp = asn1->cpData;
                  d2i_RSAPrivateKey(NULL, &ucp, asn1->nData)))
            ucp = asn1->cpData;
                  d2i_DHparams(NULL, &ucp, asn1->nData)))
            ucp = asn1->cpData;
                  d2i_DHparams(NULL, &ucp, asn1->nData)))
    int nVerify = SSL_VERIFY_NONE;
    char *cp, *cpVHostID;
    EVP_PKEY *pKey;
    STACK_OF(X509_NAME) *skCAList;
    unsigned char *ucp;
    int isca, pathlen;
    sc->szVHostID = cpVHostID = ssl_util_vhostid(p, s);
                cpVHostID);
                "(theoretically shouldn't happen!)", cpVHostID);
                cpVHostID);
            cpVHostID, cp);
        nVerify |= SSL_VERIFY_PEER_STRICT;
        nVerify |= SSL_VERIFY_PEER;
    SSL_CTX_set_verify(ctx, nVerify,  ssl_callback_SSLVerify);
                cpVHostID, sc->szCipherSuite);
                    cpVHostID);
                "Init: (%s) Configuring client authentication", cpVHostID);
                    "for client authentication", cpVHostID);
        skCAList = ssl_init_FindCAList(s, p,
                                       sc->szCACertificateFile,
                                       sc->szCACertificatePath);
        if (!skCAList) {
                    cpVHostID);
        SSL_CTX_set_client_CA_list(sc->pSSLCtx, (STACK *)skCAList);
                cpVHostID);
                    cpVHostID);
        skCAList = (STACK_OF(X509_NAME) *)SSL_CTX_get_client_CA_list(ctx);
        if (sk_X509_NAME_num(skCAList) == 0) {
    cp = apr_psprintf(p, "%s:RSA", cpVHostID);
                cpVHostID);
        ucp = asn1->cpData;
              d2i_X509(NULL, &ucp, asn1->nData)))
                    cpVHostID);
                    cpVHostID);
    cp = apr_psprintf(p, "%s:DSA", cpVHostID);
                cpVHostID);
        ucp = asn1->cpData;
              d2i_X509(NULL, &ucp, asn1->nData)))
                    cpVHostID);
                    cpVHostID);
                cpVHostID);
                cpVHostID);
                        cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
            if (SSL_X509_getBC(sc->pPublicCert[i], &isca, &pathlen)) {
                if (isca) {
                            cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
                            cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
                            cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
                            cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
    cp = apr_psprintf(p, "%s:RSA", cpVHostID);
                cpVHostID);
        ucp = asn1->cpData;
              d2i_PrivateKey(EVP_PKEY_RSA, NULL, &ucp, asn1->nData)))
                    cpVHostID);
                    cpVHostID);
    cp = apr_psprintf(p, "%s:DSA", cpVHostID);
                cpVHostID);
        ucp = asn1->cpData;
              d2i_PrivateKey(EVP_PKEY_DSA, NULL, &ucp, asn1->nData)))
                    cpVHostID);
                    cpVHostID);
                cpVHostID);
        pKey = X509_get_pubkey(sc->pPublicCert[SSL_AIDX_DSA]);
        if (pKey && (EVP_PKEY_key_type(pKey) == EVP_PKEY_DSA) &&
            EVP_PKEY_missing_parameters(pKey))
            EVP_PKEY_copy_parameters(pKey,
        BOOL bSkipFirst = FALSE;
                bSkipFirst = TRUE;
                                          bSkipFirst, NULL);
                    cpVHostID);
                cpVHostID, n, n == 1 ? "" : "s");
    server_rec *s;
    server_rec **ps;
    ssl_ds_table *t;
    apr_pool_t *sp;
    BOOL bConflict = FALSE;
    apr_pool_create(&sp, p);
    t = ssl_ds_table_make(sp, sizeof(server_rec *));
        key = apr_psprintf(sp, "%pA:%u",
        if ((ps = ssl_ds_table_get(t, key))) {
            bConflict = TRUE;
        ps = ssl_ds_table_push(t, key);
    ssl_ds_table_kill(t);
    apr_pool_destroy(sp);
    if (bConflict) {
static void ssl_init_PushCAList(STACK_OF(X509_NAME) *skCAList,
        if (sk_X509_NAME_find(skCAList, name) < 0) {
            /* this will be freed when skCAList is */
            sk_X509_NAME_push(skCAList, name);
                                         apr_pool_t *pp,
                                         const char *cpCAfile,
                                         const char *cpCApath)
    STACK_OF(X509_NAME) *skCAList;
    apr_pool_t *p;
    apr_pool_sub_make(&p, pp, NULL);
    skCAList = sk_X509_NAME_new(ssl_init_FindCAList_X509NameCmp);
    if (cpCAfile) {
        ssl_init_PushCAList(skCAList, s, cpCAfile);
    if (cpCApath) {
        if (apr_dir_open(&dir, cpCApath, p) != APR_SUCCESS) {
                    cpCApath);
            const char *cp;
            cp = apr_pstrcat(p, cpCApath, "/", direntry.name, NULL);
            ssl_init_PushCAList(skCAList, s, cp);
    sk_X509_NAME_set_cmp_func(skCAList, NULL);
    apr_pool_destroy(p);
    return skCAList;
    const char *cpType = "";
        cpType = "standard";
        cpType = "unclean";
        cpType = "accurate";
                conn->id, cpType,
    apr_array_header_t *apRequirement;
    ssl_require_t *pRequirements, *pRequirement;
    STACK_OF(X509_NAME) *skCAList;
    char *cpCAPath, *cpCAFile;
    STACK_OF(X509) *certstack;
    X509_STORE *certstore;
    X509_STORE_CTX certstorectx;
    STACK_OF(SSL_CIPHER) *skCipherOld, *skCipher = NULL;
    SSL_CIPHER *pCipher = NULL;
    int depth, nVerifyOld, nVerify, n;
            pCipher = SSL_get_current_cipher(ssl);
            skCipherOld = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);
            if (skCipherOld) {
                skCipherOld = sk_SSL_CIPHER_dup(skCipherOld);
            if (skCipherOld) {
                sk_SSL_CIPHER_free(skCipherOld);
        skCipher = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);
            if ((!pCipher && skCipher) ||
                (pCipher && !skCipher))
            else if (pCipher && skCipher &&
                     (sk_SSL_CIPHER_find(skCipher, pCipher) < 0))
            if ((!skCipherOld && skCipher) ||
                (skCipherOld && !skCipher))
            else if (skCipherOld && skCipher) {
                     !renegotiate && (n < sk_SSL_CIPHER_num(skCipher));
                    SSL_CIPHER *value = sk_SSL_CIPHER_value(skCipher, n);
                    if (sk_SSL_CIPHER_find(skCipherOld, value) < 0) {
                     !renegotiate && (n < sk_SSL_CIPHER_num(skCipherOld));
                    SSL_CIPHER *value = sk_SSL_CIPHER_value(skCipherOld, n);
                    if (sk_SSL_CIPHER_find(skCipher, value) < 0) {
        if (skCipherOld) {
            sk_SSL_CIPHER_free(skCipherOld);
        nVerifyOld = SSL_get_verify_mode(ssl);
        nVerify = SSL_VERIFY_NONE;
            nVerify |= SSL_VERIFY_PEER_STRICT;
            nVerify |= SSL_VERIFY_PEER;
        SSL_set_verify(ssl, nVerify, ssl_callback_SSLVerify);
        if (nVerify != nVerifyOld) {
            if (((nVerifyOld == SSL_VERIFY_NONE) &&
                 (nVerify    != SSL_VERIFY_NONE)) ||
                (!(nVerifyOld & SSL_VERIFY_PEER) &&
                  (nVerify    & SSL_VERIFY_PEER)) ||
                (!(nVerifyOld & SSL_VERIFY_PEER_STRICT) &&
                  (nVerify    & SSL_VERIFY_PEER_STRICT)))
                    (nVerifyOld == SSL_VERIFY_NONE) &&
        cpCAFile = dc->szCACertificateFile ?
        cpCAPath = dc->szCACertificatePath ?
           if (!SSL_load_verify_locations(ssl, cpCAFile, cpCAPath)) {
        if (!SSL_CTX_load_verify_locations(ctx, cpCAFile, cpCAPath)) {
        if (!(skCAList = ssl_init_FindCAList(r->server, r->pool,
                                             cpCAFile, cpCAPath)))
        SSL_set_client_CA_list(ssl, skCAList);
            if (!(certstore = SSL_CTX_get_cert_store(ctx))) {
            certstack = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl);
            if (!certstack || (sk_X509_num(certstack) == 0)) {
            cert = sk_X509_value(certstack, 0);
            X509_STORE_CTX_init(&certstorectx, certstore, cert, certstack);
                X509_STORE_CTX_set_depth(&certstorectx, depth);
            X509_STORE_CTX_set_ex_data(&certstorectx,
            if (!X509_verify_cert(&certstorectx)) {
            SSL_set_verify_result(ssl, certstorectx.error);
            X509_STORE_CTX_cleanup(&certstorectx);
            BOOL verify = (dc->nVerifyClient == SSL_CVERIFY_REQUIRE);
            if (verify && (SSL_get_verify_result(ssl) != X509_V_OK)) {
            if (verify && !SSL_get_peer_certificate(ssl)) {
    apRequirement = dc->aRequirement;
    pRequirements = (ssl_require_t *)apRequirement->elts;
    for (i = 0; i < apRequirement->nelts; i++) {
        pRequirement = &pRequirements[i];
        ok = ssl_expr_exec(r, pRequirement->mpExpr);
                    "Failed expression: %s", pRequirement->cpExpr);
    char b1[MAX_STRING_LEN], b2[MAX_STRING_LEN];
    const char *cpAL, *cpUN, *cpPW;
    if ((cpAL = apr_table_get(r->headers_in, "Authorization"))) {
        if (strcEQ(ap_getword(r->pool, &cpAL, ' '), "Basic")) {
            while ((*cpAL == ' ') || (*cpAL == '\t')) {
                cpAL++;
            cpAL = ap_pbase64decode(r->pool, cpAL);
            cpUN = ap_getword_nulls(r->pool, &cpAL, ':');
            cpPW = cpAL;
            if ((cpUN[0] == '/') && strEQ(cpPW, "password")) {
    apr_snprintf(b1, sizeof(b1), "%s:password", clientdn);
    ssl_util_uuencode(b2, b1, FALSE);
    apr_snprintf(b1, sizeof(b1), "Basic %s", b2);
    apr_table_set(r->headers_in, "Authorization", b1);
            "Faking HTTP Basic Auth header: \"Authorization: %s\"", b1);
    apr_table_t *e = r->subprocess_env;
    STACK_OF(X509) *sk;
    apr_table_setn(e, "HTTPS", "on"); 
                apr_table_set(e, var, val);
        apr_table_setn(e, "SSL_SERVER_CERT", val);
        apr_table_setn(e, "SSL_CLIENT_CERT", val);
        if ((sk = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl))) {
            for (i = 0; i < sk_X509_num(sk); i++) {
                     apr_table_setn(e, var, val);
RSA *ssl_callback_TmpRSA(SSL *pSSL, int nExport, int nKeyLen)
    conn_rec *c = (conn_rec *)SSL_get_app_data(pSSL);
    if (nExport) {
        if (nKeyLen == 512) {
        else if (nKeyLen == 1024) {
DH *ssl_callback_TmpDH(SSL *pSSL, int nExport, int nKeyLen)
    conn_rec *c = (conn_rec *)SSL_get_app_data(pSSL);
    if (nExport) {
        if (nKeyLen == 512) {
        else if (nKeyLen == 1024) {
    X509 *xs     = X509_STORE_CTX_get_current_cert(ctx);
        char *cp  = X509_NAME_oneline(X509_get_subject_name(xs), NULL, 0);
        char *cp2 = X509_NAME_oneline(X509_get_issuer_name(xs),  NULL, 0);
                cp ? cp : "-unknown-",
                cp2 ? cp2 : "-unknown-");
        if (cp) {
            free(cp);
        if (cp2) {
            free(cp2);
    X509 *xs;
    xs      = X509_STORE_CTX_get_current_cert(ctx);
    subject = X509_get_subject_name(xs);
    issuer  = X509_get_issuer_name(xs);
        if (X509_CRL_verify(crl, X509_get_pubkey(xs)) <= 0) {
            if (!ASN1_INTEGER_cmp(sn, X509_get_serialNumber(xs))) {
int ssl_callback_NewSessionCacheEntry(SSL *ssl, SSL_SESSION *pNew)
    SSL_set_timeout(pNew, timeout);
    session_id = SSL_SESSION_get_session_id(pNew);
    session_id_length = SSL_SESSION_get_session_id_length(pNew);
    timeout += SSL_get_time(pNew);
                          timeout, pNew);
     * return 0 which means to OpenSSL that the pNew is still
                                               int idlen, int *pCopy)
    SSL_SESSION *pSession;
    pSession = ssl_scache_retrieve(s, id, idlen);
    if (pSession) {
     * setting pCopy to 0) that the reference count on the
    *pCopy = 0;
    return pSession;
                                       SSL_SESSION *pSession)
    session_id = SSL_SESSION_get_session_id(pSession);
    session_id_length = SSL_SESSION_get_session_id_length(pSession);
    char *str;
            str = (where & SSL_CB_READ) ? "read" : "write";
    time_left = ccfg->timeout_at - now;
    if (time_left <= 0) {
        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c,
                      "Request %s read timeout", ccfg->type);
        return APR_TIMEUP;
    }
    if (time_left < apr_time_from_sec(1)) {
        time_left = apr_time_from_sec(1);
    }

    if (saved_sock_timeout >= time_left) {
        rv = apr_socket_timeout_set(ccfg->socket, time_left);
        AP_DEBUG_ASSERT(rv == APR_SUCCESS);
    }
    else {
        saved_sock_timeout = -1;
    }
    rv = ap_get_brigade(f->next, bb, mode, block, readbytes);
    if (saved_sock_timeout != -1) {
        apr_socket_timeout_set(ccfg->socket, saved_sock_timeout);
    }
    if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {
        extend_timeout(ccfg, bb);
#define MODULE_MAGIC_NUMBER_MAJOR 20051115
static int read_request_line(request_rec *r, apr_bucket_brigade *bb)

#if 0
    conn_rec *conn = r->connection;
#endif
    int num_blank_lines = 0;
    int max_blank_lines = r->server->limit_req_fields;

    if (max_blank_lines <= 0) {
        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
    }

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    do {
        apr_status_t rv;

        /* insure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */
        r->the_request = NULL;
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                         &len, r, 0, bb);

        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }
            return 0;
        }
    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));

    /* we've probably got something to do, ignore graceful restart requests */
    ll = r->the_request;
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method",
                                r->method);
#endif

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

             && (minor < HTTP_VERSION(1, 0)) ) /* don't allow HTTP/0.1000 */
    else
    return 1;
    char *last_field = NULL;
    apr_size_t last_len = 0;
    apr_size_t alloc_len = 0;
    char *value;
    int fields_read = 0;
    char *tmp_field;
        int folded = 0;

        if (last_field != NULL) {
            if ((len > 0) && ((*field == '\t') || *field == ' ')) {
                /* This line is a continuation of the preceding line(s),
                 * so append it to the line that we've set aside.
                 * Note: this uses a power-of-two allocator to avoid
                 * doing O(n) allocs and using O(n^2) space for
                 * continuations that span many many lines.
                 */
                apr_size_t fold_len = last_len + len + 1; /* trailing null */

                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field "
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                if (fold_len > alloc_len) {
                    char *fold_buf;
                    alloc_len += alloc_len;
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
                    }
                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);
                    memcpy(fold_buf, last_field, last_len);
                    last_field = fold_buf;
                }
                memcpy(last_field + last_len, field, len +1); /* +1 for nul */
                last_len += len;
                folded = 1;
            }
            else /* not a continuation line */ {

                if (r->server->limit_req_fields
                    && (++fields_read > r->server->limit_req_fields)) {
                    r->status = HTTP_BAD_REQUEST;
                    apr_table_setn(r->notes, "error-notes",
                                   "The number of request header fields "
                                   "exceeds this server's limit.");
                    return;
                }

                if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                    r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Request header field is "
                                               "missing ':' separator.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool,
                                                              last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                tmp_field = value - 1; /* last character of field-name */

                *value++ = '\0'; /* NUL-terminate at colon */

                while (*value == ' ' || *value == '\t') {
                    ++value;            /* Skip to start of value   */
                }

                /* Strip LWS after field-name: */
                while (tmp_field > last_field
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                /* Strip LWS after field-value: */
                tmp_field = last_field + last_len - 1;
                while (tmp_field > value
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                apr_table_addn(r->headers_in, last_field, value);

                /* reset the alloc_len so that we'll allocate a new
                 * buffer if we have to do any more folding: we can't
                 * use the previous buffer because its contents are
                 * now part of r->headers_in
                 */
                alloc_len = 0;

            } /* end if current line is not a continuation starting with tab */
        }

        /* Found a blank line, stop. */
        if (len == 0) {
            break;

        /* Keep track of this line so that we can parse it on
         * the next loop iteration.  (In the folded case, last_field
         * has been updated already.)
         */
        if (!folded) {
            last_field = field;
            last_len = len;

    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
request_rec *ap_read_request(conn_rec *conn)
    const char *expect;
    int access_status;
    apr_bucket_brigade *tmp_bb;
    apr_socket_t *csd;
    apr_interval_time_t cur_timeout;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);

    /* Get the request... */
    if (!read_request_line(r, tmp_bb)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        apr_brigade_destroy(tmp_bb);
        return NULL;
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_get(csd, &cur_timeout);
    if (cur_timeout != conn->base_server->timeout) {
        apr_socket_timeout_set(csd, conn->base_server->timeout);
        cur_timeout = conn->base_server->timeout;
    }

    if (!r->assbackwards) {
        ap_get_mime_headers_core(r, tmp_bb);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        if (apr_table_get(r->headers_in, "Transfer-Encoding")
            && apr_table_get(r->headers_in, "Content-Length")) {
            /* 2616 section 4.4, point 3: "if both Transfer-Encoding
             * and Content-Length are received, the latter MUST be
             * ignored"; so unset it here to prevent any confusion
             * later. */
            apr_table_unset(r->headers_in, "Content-Length");
        }
    }
    else {
        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }
    }
    apr_brigade_destroy(tmp_bb);
    if (cur_timeout != r->server->timeout) {
        apr_socket_timeout_set(csd, r->server->timeout);
        cur_timeout = r->server->timeout;

    ap_add_input_filter("HTTP_IN", NULL, NULL, c);
    ap_register_input_filter("DECHUNK", ap_dechunk_filter, AP_FTYPE_TRANSCODE);
struct dechunk_ctx {
    apr_size_t chunk_size;
    apr_size_t bytes_delivered;
    enum {
        WANT_HDR /* must have value zero */,
        WANT_BODY,
        WANT_TRL
    } state;
};

apr_status_t ap_dechunk_filter(ap_filter_t *f, apr_bucket_brigade *bb,
                               ap_input_mode_t mode, apr_off_t *readbytes)
{
    apr_status_t rv;
    struct dechunk_ctx *ctx = f->ctx;
    apr_bucket *b;
    const char *buf;
    apr_size_t len;

    if (!ctx) {
        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(struct dechunk_ctx));
    }

    do {
        if (ctx->chunk_size == ctx->bytes_delivered) {
            /* Time to read another chunk header or trailer...  ap_http_filter() is 
             * the next filter in line and it knows how to return a brigade with 
             * one line.
             */
            char line[30];
            
            if ((rv = ap_getline(line, sizeof(line), f->r,
                                 0 /* readline */)) < 0) {
                return rv;
            }
            switch(ctx->state) {
            case WANT_HDR:
                ctx->chunk_size = get_chunk_size(line);
                ctx->bytes_delivered = 0;
                if (ctx->chunk_size == 0) {
                    ctx->state = WANT_TRL;
                }
                else {
                    ctx->state = WANT_BODY;
                }
                break;
            case WANT_TRL:
                /* XXX sanity check end chunk here */
                if (strlen(line)) {
                    /* bad trailer */
                }
                if (ctx->chunk_size == 0) { /* we just finished the last chunk? */
                    /* ### woah... ap_http_filter() is doing this, too */
                    /* append eos bucket and get out */
                    b = apr_bucket_eos_create();
                    APR_BRIGADE_INSERT_TAIL(bb, b);
                    return APR_SUCCESS;
                }
                ctx->state = WANT_HDR;
                break;
            default:
                ap_assert(ctx->state == WANT_HDR || ctx->state == WANT_TRL);
            }
        }
    } while (ctx->state != WANT_BODY);

    if (ctx->state == WANT_BODY) {
        /* Tell ap_http_filter() how many bytes to deliver. */
        apr_off_t chunk_bytes = ctx->chunk_size - ctx->bytes_delivered;

        if ((rv = ap_get_brigade(f->next, bb, mode,
                                 &chunk_bytes)) != APR_SUCCESS) {
            return rv;
        }

        /* Walk through the body, accounting for bytes, and removing an eos
         * bucket if ap_http_filter() delivered the entire chunk.
         *
         * ### this shouldn't be necessary. 1) ap_http_filter shouldn't be
         * ### adding EOS buckets. 2) it shouldn't return more bytes than
         * ### we requested, therefore the total len can be found with a
         * ### simple call to apr_brigade_length(). no further munging
         * ### would be needed.
         */
        b = APR_BRIGADE_FIRST(bb);
        while (b != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(b)) {
            apr_bucket_read(b, &buf, &len, mode);
            AP_DEBUG_ASSERT(len <= ctx->chunk_size - ctx->bytes_delivered);
            ctx->bytes_delivered += len;
            b = APR_BUCKET_NEXT(b);
        }
        if (ctx->bytes_delivered == ctx->chunk_size) {
            AP_DEBUG_ASSERT(APR_BUCKET_IS_EOS(b));
            apr_bucket_delete(b);
            ctx->state = WANT_TRL;
        }
    }

    return APR_SUCCESS;
}

    apr_bucket_brigade *b;
    char *buff;
    apr_size_t len;
    char *pos;
        f->ctx = ctx = apr_pcalloc(f->c->pool, sizeof(*ctx));
        ctx->b = apr_brigade_create(f->c->pool);
    if (mode == AP_MODE_PEEK) {
        apr_bucket *e;
        const char *str;
        apr_size_t length;

        /* The purpose of this loop is to ignore any CRLF (or LF) at the end
         * of a request.  Many browsers send extra lines at the end of POST
         * requests.  We use the PEEK method to determine if there is more
         * data on the socket, so that we know if we should delay sending the
         * end of one request until we have served the second request in a
         * pipelined situation.  We don't want to actually delay sending a
         * response if the server finds a CRLF (or LF), becuause that doesn't
         * mean that there is another request, just a blank line.
         */
        while (1) {
            if (APR_BRIGADE_EMPTY(ctx->b)) {
                e = NULL;
            }
            else {
                e = APR_BRIGADE_FIRST(ctx->b);
            }
            if (!e || apr_bucket_read(e, &str, &length, APR_NONBLOCK_READ) != APR_SUCCESS) {
                return APR_EOF;
            else {
                const char *c = str;
                while (c < str + length) {
                    if (*c == APR_ASCII_LF)
                        c++;
                    else if (*c == APR_ASCII_CR && *(c + 1) == APR_ASCII_LF)
                        c += 2;
                    else return APR_SUCCESS;
                apr_bucket_delete(e);
    if (APR_BRIGADE_EMPTY(ctx->b)) {
        if ((rv = ap_get_brigade(f->next, ctx->b, mode, readbytes)) != APR_SUCCESS) {
            return rv;
        }
    }
    /* If readbytes is -1, we want to just read everything until the end
     * of the brigade, which in this case means the end of the socket.  To
     * do this, we loop through the entire brigade, until the socket is
     * exhausted, at which point, it will automagically remove itself from
     * the brigade.
     */
    if (*readbytes == -1) {
        apr_bucket *e;
        apr_off_t total;
        APR_BRIGADE_FOREACH(e, ctx->b) {
            const char *str;
            apr_size_t len;
            apr_bucket_read(e, &str, &len, APR_BLOCK_READ);
        }
        APR_BRIGADE_CONCAT(b, ctx->b);
        apr_brigade_length(b, 1, &total);
        *readbytes = total;
        e = apr_bucket_eos_create();
        APR_BRIGADE_INSERT_TAIL(b, e);
        return APR_SUCCESS;
    }
    /* readbytes == 0 is "read a single line". otherwise, read a block. */
    if (*readbytes) {
        apr_off_t total;

        /* ### the code below, which moves bytes from one brigade to the
           ### other is probably bogus. presuming the next filter down was
           ### working properly, it should not have returned more than
           ### READBYTES bytes, and we wouldn't have to do any work.
        */

        APR_BRIGADE_NORMALIZE(ctx->b);
        if (APR_BRIGADE_EMPTY(ctx->b)) {
            if ((rv = ap_get_brigade(f->next, ctx->b, mode, readbytes)) != APR_SUCCESS) {
                return rv;
            }
        }
            
        apr_brigade_partition(ctx->b, *readbytes, &e);
        APR_BRIGADE_CONCAT(b, ctx->b);
        if (e != APR_BRIGADE_SENTINEL(ctx->b)) {
            apr_bucket_brigade *temp;

            temp = apr_brigade_split(b, e);

            /* ### darn. gotta ensure the split brigade is in the proper pool.
               ### this is a band-aid solution; we shouldn't even be doing
               ### all of this brigade munging (per the comment above).
               ### until then, this will get the right lifetimes. */
            APR_BRIGADE_CONCAT(ctx->b, temp);
        }
        else {
            if (!APR_BRIGADE_EMPTY(ctx->b)) {
                ctx->b = NULL; /*XXX*/
        apr_brigade_length(b, 1, &total);
        *readbytes -= total;

        /* ### this is a hack. it is saying, "if we have read everything
           ### that was requested, then we are at the end of the request."
           ### it presumes that the next filter up will *only* call us
           ### with readbytes set to the Content-Length of the request.
           ### that may not always be true, and this code is *definitely*
           ### too presumptive of the caller's intent. the point is: this
           ### filter is not the guy that is parsing the headers or the
           ### chunks to determine where the end of the request is, so we
           ### shouldn't be monkeying with EOS buckets.
        */
        if (*readbytes == 0) {
            apr_bucket *eos = apr_bucket_eos_create();
                
            APR_BRIGADE_INSERT_TAIL(b, eos);
        }
        return APR_SUCCESS;
    /* we are reading a single line, e.g. the HTTP headers */
    while (!APR_BRIGADE_EMPTY(ctx->b)) {
        e = APR_BRIGADE_FIRST(ctx->b);
        if ((rv = apr_bucket_read(e, (const char **)&buff, &len, mode)) != APR_SUCCESS) {
            return rv;
        }
        pos = memchr(buff, APR_ASCII_LF, len);
        if (pos != NULL) {
            apr_bucket_split(e, pos - buff + 1);
            APR_BUCKET_REMOVE(e);
            APR_BRIGADE_INSERT_TAIL(b, e);
            return APR_SUCCESS;
        }
        APR_BUCKET_REMOVE(e);
        APR_BRIGADE_INSERT_TAIL(b, e);
    }
        ap_add_input_filter("DECHUNK", NULL, r, r->connection);
    if (!f->ctx) {    /* If we haven't passed up the socket yet... */
        f->ctx = (void *)1;
    else {            
        /* Either some code lost track of the socket
         * bucket or we already found out that the
         * client closed.
         */
        return APR_EOF;
    conn_rec *c = r->connection;
            if ((retval = ap_get_brigade(c->input_filters, b,
    r->output_filters  = conn->output_filters;
    r->input_filters   = conn->input_filters;
     * - white space around the '='
                value += strspn(value, " \t");  /* Move past WS */
            if (r->status == HTTP_BAD_REQUEST) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                              "request failed: invalid characters in URI");
            }
            else {
        ap_rvputs(r, ap_get_server_name(r), " (", r->connection->local_ip,
	apr_signal(SIGHUP, just_die);
	apr_signal(SIGINT, just_die);
	apr_signal(SIGTERM, just_die);

					  int propid, int insvalue,
    dav_prop_insert which;
    if (insvalue) {
	which = DAV_PROP_INSERT_VALUE;
    else {
	which = DAV_PROP_INSERT_NAME;
    /* we inserted a name or value (this prop is done) */
    return which;
                                 int insvalue, ap_text_header *phdr)
			      insvalue, phdr);
			      insvalue, phdr);
			      insvalue, phdr);
			      insvalue, phdr);
			      insvalue, phdr);
                                 int insvalue, ap_text_header *phdr);
    const char *options;
    const char *vsn_level;
    const char *uris;

    /* per HTTP/1.1 S9.2, we can discard this body */
    if ((result = ap_discard_request_body(r)) != OK) {
	return result;
    }

    /* no body */
    ap_set_content_length(r, 0);
    vsn_level = NULL;
    if (vsn_hooks != NULL
        && (vsn_level = (*vsn_hooks->get_vsn_header)()) != NULL) {
	dav_level = apr_pstrcat(r->pool, dav_level, ",", vsn_level, NULL);
    /* gather property set URIs from all the liveprop providers */
    uris = apr_array_pstrcat(r->pool, uri_ary, ',');
    if (*uris) {
        dav_level = apr_pstrcat(r->pool, dav_level, ",", uris, NULL);
    ** All cases support OPTIONS and LOCK.
    ** Lock-null support PROPFIND and UNLOCK.
	if (resource->collection) {
	    options = apr_pstrcat(r->pool,
		"OPTIONS, "
		"GET, HEAD, POST, DELETE, TRACE, "
		"PROPFIND, PROPPATCH, COPY, MOVE",
                locks_hooks != NULL ? ", LOCK, UNLOCK" : "",
                NULL);
	}
	else {
	    /* files also support PUT */
	    options = apr_pstrcat(r->pool,
		"OPTIONS, "
		"GET, HEAD, POST, DELETE, TRACE, "
		"PROPFIND, PROPPATCH, COPY, MOVE, PUT",
                locks_hooks != NULL ? ", LOCK, UNLOCK" : "",
                NULL);
	}
	break;
	options = apr_pstrcat(r->pool, "OPTIONS, MKCOL, PUT, PROPFIND",
                             locks_hooks != NULL ? ", LOCK, UNLOCK" : "",
                             NULL);
	break;
	options = apr_pstrcat(r->pool, "OPTIONS, MKCOL, PUT",
                             locks_hooks != NULL ? ", LOCK" : "",
                             NULL);
	break;
	options = "OPTIONS";
    /* If there is a versioning provider, add versioning options */
        const char *vsn_options = NULL;

            int vsn_control = (*vsn_hooks->versionable)(resource);
            int mkworkspace = vsn_hooks->can_be_workspace != NULL
                              && (*vsn_hooks->can_be_workspace)(resource);
            if (vsn_control && mkworkspace) {
                vsn_options = ", VERSION-CONTROL, MKWORKSPACE";
            }
            else if (vsn_control)
                vsn_options = ", VERSION-CONTROL";
            else if (mkworkspace) {
                vsn_options = ", MKWORKSPACE";
            }
            if ((*vsn_hooks->versionable)(resource)) {
                vsn_options = ", VERSION-CONTROL";
            }
        else if (resource->working)
            vsn_options = ", CHECKIN, UNCHECKOUT";
        else if (vsn_hooks->add_label != NULL)
            vsn_options = ", CHECKOUT, LABEL";
        else
            vsn_options = ", CHECKOUT";

        if (vsn_options != NULL)
            options = apr_pstrcat(r->pool, options, vsn_options, NULL);
    if (binding_hooks != NULL) {
	dav_level = apr_pstrcat(r->pool, dav_level, ",bindings", NULL);
        if ((*binding_hooks->is_bindable)(resource))
            options = apr_pstrcat(r->pool, options, ", BIND", NULL);
    apr_table_setn(r->headers_out, "Allow", options);
    apr_table_setn(r->headers_out, "DAV", dav_level);
    /* ### this will send a Content-Type. the default OPTIONS does not. */
    /* ### the default (ap_send_http_options) returns OK, but I believe
     * ### that is because it is the default handler and nothing else
     * ### will run after the thing. */
	propstats = dav_get_allprops(propdb,
			     ctx->propfind_type == DAV_PROPFIND_IS_ALLPROP);
                                  int insvalue, ap_text_header *phdr),
                                 (r, resource, insvalue, phdr));
                          int insvalue, ap_text_header *phdr))
typedef enum {
    DAV_PROP_INSERT_NOTDEF,	/* property is defined by this provider,
				   but nothing was inserted because the
				   (live) property is not defined for this
				   resource (it may be present as a dead
				   property). */
    DAV_PROP_INSERT_NAME,	/* a property name (empty elem) was
				   inserted into the text block */
    DAV_PROP_INSERT_VALUE	/* a property name/value pair was inserted
				   into the text block */
} dav_prop_insert;

    ** Insert a property name/value into a text block. The property to
    ** insert is identified by the propid value. If insvalue is true,
    ** then the property's value should be inserted; otherwise, an empty
    ** element (ie. just the prop's name) should be inserted.
				   int propid, int insvalue,
                                   int insvalue, ap_text_header *phdr);
    DAV_PROPID_supported_method_set,            /* from DeltaV I-D */
    DAV_PROPID_supported_live_property_set,     /* from DeltaV I-D */
    DAV_PROPID_supported_report_set,            /* from DeltaV I-D */
    int getvals);
    /* Return supported versioning level
     * for the Versioning header
    const char * (*get_vsn_header)(void);
    ** body. The report response is generated into the dav_text_header
static void dav_find_liveprop(dav_propdb *propdb, ap_xml_elem *elem)
    const char *ns_uri;
    dav_elem_private *priv = elem->private;
    const dav_hooks_liveprop *hooks;
    if (elem->ns == AP_XML_NS_DAV_ID) {
	    if (strcmp(elem->name, *p) == 0) {
		priv->propid = propid;
                /* priv->provider == NULL */
		return;
    else if (elem->ns == AP_XML_NS_NONE) {
	/* policy: liveprop providers cannot define no-namespace properties */
	priv->propid = DAV_PROPID_CORE_UNKNOWN;
        /* priv->provider == NULL */
	return;
    }

    /* get the URI for the element's namespace id */
    ns_uri = AP_XML_GET_URI_ITEM(propdb->ns_xlate, elem->ns);
    propid = dav_run_find_liveprop(propdb->resource, ns_uri, elem->name,
                                  &hooks);
        priv->propid = propid;
        priv->provider = hooks;
        return;
    priv->propid = DAV_PROPID_CORE_UNKNOWN;
    /* priv->provider == NULL */
				       int getvals,
				       int *inserted)
    *inserted = 0;
    case DAV_PROPID_CORE_UNKNOWN:
	if (getvals && *value != '\0') {
	*inserted = 1;
				       int getvals,
				       int *inserted)
    dav_prop_insert pi;
    *inserted = 0;
				   getvals, phdr, inserted);
    pi = (*priv->provider->insert_prop)(propdb->resource, priv->propid,
					getvals, phdr);
    if (pi != DAV_PROP_INSERT_NOTDEF)
	*inserted = 1;
    dav_error *err;
    if (!ro) {
	propdb->deferred = 1;
    }
    else if ((err = dav_really_open_db(propdb, 1 /* ro */)) != NULL) {
	return err;
    }
dav_get_props_result dav_get_allprops(dav_propdb *propdb, int getvals)
    int unused_inserted;
    /* generate all the namespaces that are in the propdb */
    dav_get_propdb_xmlns(propdb, &hdr_ns);

    /* initialize the result with some start tags... */
    ap_text_append(propdb->p, &hdr,
		   "<D:propstat>" DEBUG_CR
		   "<D:prop>" DEBUG_CR);

    /* if there ARE properties, then scan them */
    if (propdb->db != NULL) {
	dav_datum key;
	int dav_id = dav_find_dav_id(propdb);
	(void) (*db_hooks->firstkey)(propdb->db, &key);
	while (key.dptr) {
	    dav_datum prevkey;
	    /* any keys with leading capital letters should be skipped
	       (real keys start with a number or a colon) */
	    if (*key.dptr >= 'A' && *key.dptr <= 'Z')
		goto next_key;
	    /*
	    ** We also look for <DAV:getcontenttype> and
	    ** <DAV:getcontentlanguage>. If they are not stored as dead
	    ** properties, then we need to perform a subrequest to get
	    ** their values (if any).
	    */
	    if (dav_id != -1
		&& *key.dptr != ':'
		&& dav_id == atoi(key.dptr)) {
		const char *colon;
		/* find the colon */
		if ( key.dptr[1] == ':' ) {
		    colon = key.dptr + 1;
		}
		else {
		    colon = strchr(key.dptr + 2, ':');
		}
		if (colon[1] == 'g') {
		    if (strcmp(colon + 1, "getcontenttype") == 0) {
			found_contenttype = 1;
		    else if (strcmp(colon + 1, "getcontentlanguage") == 0) {
			found_contentlang = 1;
		}
	    }
	    if (getvals) {
		dav_datum value;
		(void) (*db_hooks->fetch)(propdb->db, key, &value);
		if (value.dptr == NULL) {
		    /* ### anything better to do? */
		    /* ### probably should enter a 500 error */
		    goto next_key;
		}
		/* put the prop name and value into the result */
		dav_append_prop(propdb, key.dptr, value.dptr, &hdr);
		(*db_hooks->freedatum)(propdb->db, value);
	    }
	    else {
		/* simple, empty element if a value isn't needed */
		dav_append_prop(propdb, key.dptr, DAV_EMPTY_VALUE, &hdr);
	  next_key:
	    prevkey = key;
	    (void) (*db_hooks->nextkey)(propdb->db, &key);
	    (*db_hooks->freedatum)(propdb->db, prevkey);
	}
    /* add namespaces for all the liveprop providers */
    dav_add_all_liveprop_xmlns(propdb->p, &hdr_ns);
    
    dav_run_insert_all_liveprops(propdb->r, propdb->resource, getvals, &hdr);
			      getvals, &hdr, &unused_inserted);
			      getvals, &hdr, &unused_inserted);
				  getvals, &hdr, &unused_inserted);
				  getvals, &hdr, &unused_inserted);
    /* terminate the result */
    ap_text_append(propdb->p, &hdr,
		   "</D:prop>" DEBUG_CR
		   "<D:status>HTTP/1.1 200 OK</D:status>" DEBUG_CR
		   "</D:propstat>" DEBUG_CR);
    /* generate all the namespaces that are in the propdb */
    dav_get_propdb_xmlns(propdb, &hdr_ns);

	dav_datum key;
	/*
	** Note: the key may be NULL if we have no properties that are in
	** a namespace that matches the requested prop's namespace.
	*/
	key = dav_gdbm_key(propdb, elem);

	/* fetch IF we have a db and a key. otherwise, value is NULL */
	if (propdb->db != NULL && key.dptr != NULL) {
	    (void) (*db_hooks->fetch)(propdb->db, key, &value);
	}
	/*
	** If we did not find the property in the database, then it may
	** be a liveprop that we can handle specially.
	*/
	if (value.dptr == NULL) {
	    dav_error *err;
	    int inserted;
	    /* cache the propid; dav_get_props() could be called many times */
	    if (priv->propid == 0)
		dav_find_liveprop(propdb, elem);
	    if ((err = dav_insert_liveprop(propdb, elem, 1, &hdr_good,
					   &inserted)) != NULL) {
	    if (inserted) {
	}
    { 0, "supported-live-property-set",
      DAV_PROPID_supported_live_property_set, 0 },
    { 0, "supported-method-set", DAV_PROPID_supported_method_set, 0 },
    { 0, "supported-report-set", DAV_PROPID_supported_report_set, 0 },
                                            int propid, int insvalue,
    dav_prop_insert which;
    case DAV_PROPID_supported_live_property_set:
        /* ### insert all live property names ### */
        return DAV_PROP_INSERT_NOTDEF;
        break;

    case DAV_PROPID_supported_method_set:
        /* ### leverage code from dav_method_options ### */
        return DAV_PROP_INSERT_NOTDEF;
        break;

    case DAV_PROPID_supported_report_set:
#if 0
    {
        /* ### where to get "r" ??? */
        const dav_hooks_vsn *vsn_hooks = dav_get_vsn_hooks(r);

        if (vsn_hooks != NULL) {
            const dav_report_elem *reports;
            dav_error *err;

            if ((err = (*vsn_hooks->avail_reports)(resource,
                                                   &reports)) != NULL) {
	        err = dav_push_error(p, err->status, 0,
                                     "DAV:supported-report-set could not "
                                     "be determined due to a problem "
                                     "fetching the available reports "
                                     "for this resource.",
                                     err);
                /* ### can't return err... sigh. punt for now. */
                return DAV_PROP_INSERT_NOTDEF;
            }

            value = "";

            if (reports == NULL) {
                /* no reports are defined. break with value="" */
                break;
            }

            for (; reports->nmspace != NULL; ++reports) {
                /* Note: presume reports->namespace is XML/URL quoted */
                const char *v = apr_psprintf(p, "<%s xmlns=\"%s\"/>" DEBUG_CR,
                                             reports->name, reports->nmspace);

                /* This isn't very memory-efficient, but there should only
                   be a small number of reports */
                value = apr_pstrcat(p, value, v, NULL);
            }
        }
        break;
    }
#endif
    /* above code disabled. FALLTHROUGH */

    if (insvalue && *value != '\0') {
        which = DAV_PROP_INSERT_VALUE;
        which = DAV_PROP_INSERT_NAME;
    /* we inserted a name or value (this prop is done) */
    return which;
                                   int insvalue, ap_text_header *phdr)
                                insvalue, phdr);
    (void) dav_core_insert_prop(resource,
                                DAV_PROPID_supported_live_property_set,
                                insvalue, phdr);
    (void) dav_core_insert_prop(resource, DAV_PROPID_supported_method_set,
                                insvalue, phdr);
    (void) dav_core_insert_prop(resource, DAV_PROPID_supported_report_set,
                                insvalue, phdr);
APR_HOOK_STRUCT(
    APR_HOOK_LINK(fatal_exception)
)

AP_IMPLEMENT_HOOK_RUN_ALL(int, fatal_exception,
                          (ap_exception_info_t *ei), (ei), OK, DECLINED)

    if (lim > DEFAULT_LIMIT_REQUEST_LINE) {
        return apr_psprintf(cmd->temp_pool, "LimitRequestLine \"%s\" "
                            "must not exceed the precompiled maximum of %d",
                            arg, DEFAULT_LIMIT_REQUEST_LINE);
    }

        rv = ap_rgetline(&(r->the_request), DEFAULT_LIMIT_REQUEST_LINE + 2,
    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     * The cast is safe, limit_req_line cannot be negative
     */
    if (len > (apr_size_t)r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }

                          "request failed: URI too long");
 * %...b:  bytes sent, excluding HTTP headers.
static const char *log_bytes_sent(request_rec *r, char *a)
        'b', log_bytes_sent, 0
     * - white space around the '='
                value += strspn(value, " \t");  /* Move past WS */
typedef struct {
    const char *name;                 /* matching module name */
    const char *info;                 /* additional info */
typedef struct {
static void *create_info_config(apr_pool_t *p, server_rec *s)
    info_svr_conf *conf = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t *p, void *basev, void *overridesv)
    info_svr_conf *new = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info = apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec * r, int nest, const char* thisfn, int linenum)
    const char *prevfn = ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL) thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n", thisfn);
    if (linenum > 0) sprintf(buf, "%d", linenum);
    else             buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i) ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i) ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec * r, const ap_directive_t * dir,
                                int nest)
        ap_escape_html(r->pool, dir->directive),
        ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec * r, const ap_directive_t * dir,
                                int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n", 
                  ap_escape_html(r->pool, dir->directive),
                  ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec * r, const ap_directive_t * dir,
            }
            else {
        ap_rprintf(r, "/%s</tt></dd>",
                   ap_escape_html(r->pool, dirname));
            }
    
static int mod_info_has_cmd(const command_rec * cmds, ap_directive_t * dir)
    const command_rec * cmd;
    if (cmds == NULL) return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0) return 1;
	}
static void mod_info_show_parents(request_rec * r, ap_directive_t * node, 
                                    int from, int to) {
    if (from < to) mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec * r, const command_rec * cmds,
    ap_directive_t * dir;
    if (level == 0) ap_set_module_config(r->request_config, &info_module, NULL);
                                                 shown, level + 1)) {
        } else if (mod_info_has_cmd(cmds, dir)) {
    }
typedef struct { /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc)(void); /* just to get the right size */
    const char * const *aszPredecessors;
    const char * const *aszSuccessors;
typedef apr_array_header_t * ( 
__stdcall 
* hook_get_t)(void);
typedef struct {
static int module_find_hook(module *modp,
                            hook_get_t hook_get)
    elts = (hook_struct_t *)hooks->elts;
    for (i=0; i< hooks->nelts; i++) {
                               hook_lookup_t *lookup,
                               int *comma)
    int i, comma=0;
    for (i=0; request_hooks[i].name; i++) {
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
	return DECLINED;
	     "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n", r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ", r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name, modp->name);
            ap_rprintf(r, "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                        ap_get_server_version());
            ap_rprintf(r, "<dt><strong>Server Built:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                        ap_get_server_built());
            ap_rprintf(r, "<dt><strong>API Version:</strong> "
                        "<tt>%d:%d</tt></dt>\n",
                        MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r, "<dt><strong>Hostname/port:</strong> "
                        "<tt>%s:%u</tt></dt>\n",
                        ap_get_server_name(r), ap_get_server_port(r));
            ap_rprintf(r, "<dt><strong>Timeouts:</strong> "
                        "<tt>connection: %d &nbsp;&nbsp; "
                        "keep-alive: %d</tt></dt>",
                        (int)(apr_time_sec(serv->timeout)), 
                        (int)(apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n", ap_show_mpm());
            ap_rprintf(r, "<dt><strong>MPM Information:</strong> "
		       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r, "<dt><strong>Server Root:</strong> "
                        "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r, "<dt><strong>Config File:</strong> "
		       "<tt>%s</tt></dt>\n", ap_conftree->filename);
        for (modp = ap_top_module; modp; modp = modp->next) {
            if (!r->args || !strcasecmp(modp->name, r->args)) {
                ap_rprintf(r, "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                            "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                            modp->name, modp->name);
                ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                hand = modp->handlers;
                if (hand) {
                    while (hand) {
                        if (hand->content_type) {
                            ap_rprintf(r, " <tt>%s</tt>\n", hand->content_type);
                        }
                        else {
                            break;
                        }
                        hand++;
                        if (hand && hand->content_type) {
                            ap_rputs(",", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                if (module_find_hook(modp, ap_hook_get_handler)) {
                    ap_rputs("<tt> <em>yes</em></tt>", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                ap_rputs("</dt>", r);
                ap_rputs("<dt><strong>Configuration Phase Participation:</strong>\n",
                      r);
                if (modp->create_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Directory Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Directory Configs</tt>", r);
                    comma = 1;
                }
                if (modp->create_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Server Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Server Configs</tt>", r);
                    comma = 1;
                }
                if (!comma)
                    ap_rputs("<tt> <em>none</em></tt>", r);
                comma = 0;
                ap_rputs("</dt>", r);

                module_request_hook_participate(r, modp);

                cmd = modp->cmds;
                if (cmd) {
                    ap_rputs("<dt><strong>Module Directives:</strong></dt>", r);
                    while (cmd) {
                        if (cmd->name) {
                            ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                ap_escape_html(r->pool, cmd->name),
                                cmd->name[0] == '<' ? "&gt;" : "");
                            if (cmd->errmsg) {
                                ap_rputs(cmd->errmsg, r);
                            ap_rputs("</i></tt></dd>\n", r);
                        }
                        else {
                            break;
                        cmd++;
                    ap_rputs("<dt><strong>Current Configuration:</strong></dt>\n", r);
                    mod_info_module_cmds(r, modp->cmds, ap_conftree, 0, 0);
                }
                else {
                    ap_rputs("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>", r);
                }
                more_info = find_more_info(serv, modp->name);
                if (more_info) {
                    ap_rputs("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                          r);
                    ap_rputs(more_info, r);
                    ap_rputs("</dd>", r);
                }
                ap_rputs("</dl><hr />\n", r);
                if (r->args) {
                    break;
        }
        if (!modp && r->args && strcasecmp(r->args, "server")) {
            ap_rputs("<p><b>No such module</b></p>\n", r);
        }
    ap_rputs(ap_psignature("",r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy, 
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
static const command_rec info_cmds[] =
{
static void register_hooks(apr_pool_t *p)
module AP_MODULE_DECLARE_DATA info_module =
{
typedef struct {
    const char *name;                 /* matching module name */
    const char *info;                 /* additional info */
typedef struct {
static void *create_info_config(apr_pool_t *p, server_rec *s)
    info_svr_conf *conf = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t *p, void *basev, void *overridesv)
    info_svr_conf *new = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info = apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec * r, int nest, const char* thisfn, int linenum)
    const char *prevfn = ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL) thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n", thisfn);
    if (linenum > 0) sprintf(buf, "%d", linenum);
    else             buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i) ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i) ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec * r, const ap_directive_t * dir,
                                int nest)
        ap_escape_html(r->pool, dir->directive),
        ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec * r, const ap_directive_t * dir,
                                int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n", 
                  ap_escape_html(r->pool, dir->directive),
                  ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec * r, const ap_directive_t * dir,
            }
            else {
        ap_rprintf(r, "/%s</tt></dd>",
                   ap_escape_html(r->pool, dirname));
            }
    
static int mod_info_has_cmd(const command_rec * cmds, ap_directive_t * dir)
    const command_rec * cmd;
    if (cmds == NULL) return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0) return 1;
	}
static void mod_info_show_parents(request_rec * r, ap_directive_t * node, 
                                    int from, int to) {
    if (from < to) mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec * r, const command_rec * cmds,
    ap_directive_t * dir;
    if (level == 0) ap_set_module_config(r->request_config, &info_module, NULL);
                                                 shown, level + 1)) {
        } else if (mod_info_has_cmd(cmds, dir)) {
    }
typedef struct { /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc)(void); /* just to get the right size */
    const char * const *aszPredecessors;
    const char * const *aszSuccessors;
typedef apr_array_header_t * ( 
__stdcall 
* hook_get_t)(void);
typedef struct {
static int module_find_hook(module *modp,
                            hook_get_t hook_get)
    elts = (hook_struct_t *)hooks->elts;
    for (i=0; i< hooks->nelts; i++) {
                               hook_lookup_t *lookup,
                               int *comma)
    int i, comma=0;
    for (i=0; request_hooks[i].name; i++) {
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
	return DECLINED;
	     "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n", r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ", r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name, modp->name);
            ap_rprintf(r, "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                        ap_get_server_version());
            ap_rprintf(r, "<dt><strong>Server Built:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                        ap_get_server_built());
            ap_rprintf(r, "<dt><strong>API Version:</strong> "
                        "<tt>%d:%d</tt></dt>\n",
                        MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r, "<dt><strong>Hostname/port:</strong> "
                        "<tt>%s:%u</tt></dt>\n",
                        ap_get_server_name(r), ap_get_server_port(r));
            ap_rprintf(r, "<dt><strong>Timeouts:</strong> "
                        "<tt>connection: %d &nbsp;&nbsp; "
                        "keep-alive: %d</tt></dt>",
                        (int)(apr_time_sec(serv->timeout)), 
                        (int)(apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n", ap_show_mpm());
            ap_rprintf(r, "<dt><strong>MPM Information:</strong> "
		       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r, "<dt><strong>Server Root:</strong> "
                        "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r, "<dt><strong>Config File:</strong> "
		       "<tt>%s</tt></dt>\n", ap_conftree->filename);
        for (modp = ap_top_module; modp; modp = modp->next) {
            if (!r->args || !strcasecmp(modp->name, r->args)) {
                ap_rprintf(r, "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                            "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                            modp->name, modp->name);
                ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                hand = modp->handlers;
                if (hand) {
                    while (hand) {
                        if (hand->content_type) {
                            ap_rprintf(r, " <tt>%s</tt>\n", hand->content_type);
                        }
                        else {
                            break;
                        }
                        hand++;
                        if (hand && hand->content_type) {
                            ap_rputs(",", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                if (module_find_hook(modp, ap_hook_get_handler)) {
                    ap_rputs("<tt> <em>yes</em></tt>", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                ap_rputs("</dt>", r);
                ap_rputs("<dt><strong>Configuration Phase Participation:</strong>\n",
                      r);
                if (modp->create_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Directory Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Directory Configs</tt>", r);
                    comma = 1;
                }
                if (modp->create_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Server Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Server Configs</tt>", r);
                    comma = 1;
                }
                if (!comma)
                    ap_rputs("<tt> <em>none</em></tt>", r);
                comma = 0;
                ap_rputs("</dt>", r);

                module_request_hook_participate(r, modp);

                cmd = modp->cmds;
                if (cmd) {
                    ap_rputs("<dt><strong>Module Directives:</strong></dt>", r);
                    while (cmd) {
                        if (cmd->name) {
                            ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                ap_escape_html(r->pool, cmd->name),
                                cmd->name[0] == '<' ? "&gt;" : "");
                            if (cmd->errmsg) {
                                ap_rputs(cmd->errmsg, r);
                            ap_rputs("</i></tt></dd>\n", r);
                        }
                        else {
                            break;
                        cmd++;
                    ap_rputs("<dt><strong>Current Configuration:</strong></dt>\n", r);
                    mod_info_module_cmds(r, modp->cmds, ap_conftree, 0, 0);
                }
                else {
                    ap_rputs("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>", r);
                }
                more_info = find_more_info(serv, modp->name);
                if (more_info) {
                    ap_rputs("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                          r);
                    ap_rputs(more_info, r);
                    ap_rputs("</dd>", r);
                }
                ap_rputs("</dl><hr />\n", r);
                if (r->args) {
                    break;
        }
        if (!modp && r->args && strcasecmp(r->args, "server")) {
            ap_rputs("<p><b>No such module</b></p>\n", r);
        }
    ap_rputs(ap_psignature("",r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy, 
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
static const command_rec info_cmds[] =
{
static void register_hooks(apr_pool_t *p)
module AP_MODULE_DECLARE_DATA info_module =
{
static char* process_tags(header_entry *hdr, request_rec *r)
            str = apr_pstrdup(r->pool, s);
            str = apr_pstrcat(r->pool, str, s, NULL);
            apr_table_addn(headers, hdr->header, process_tags(hdr, r));
            apr_table_mergen(headers, hdr->header, process_tags(hdr, r));
                apr_table_addn(headers, hdr->header, process_tags(hdr, r));
                char *new_val = process_tags(hdr, r);
                 ap_set_content_type(r, process_tags(hdr, r));
            apr_table_setn(headers, hdr->header, process_tags(hdr, r));
                ed.p = r->pool;
        cache_server_conf *conf =
          (cache_server_conf *)ap_get_module_config(r->server->module_config,
                                                    &cache_module);
                     "Incoming request may be asking for a uncached version of "
    if (cc_req && ap_cache_liststr(r->pool, cc_req, "max-age", &val)) {
    if (cc_req && ap_cache_liststr(r->pool, cc_req, "min-fresh", &val)) {
 * 20051231.0 (2.3.0-dev)  Added num_blank_lines, pending_header_line, and
 *                         pending_header_size to request_rec
    /** Number of leading blank lines encountered before request header */
    int num_blank_lines;

    /** A buffered header line, used to support header folding while
     *  reading the request */
    char *pending_header_line;

    /** If nonzero, the number of bytes allocated to hold pending_header_line */
    apr_size_t pending_header_size;

static void set_the_request(request_rec *r, char *line)
    apr_socket_t *csd;
    ll = r->the_request = line;
             && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */
    }
    else {
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(r->connection->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->connection->base_server->timeout);

    return;
}

static apr_status_t set_mime_header(request_rec *r, char *line)
{
    char *value, *tmp_field;

    if (r->server->limit_req_fields) {
        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);
        if (mime_headers->nelts >= r->server->limit_req_fields) {
            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields "
                           "exceeds this server's limit.");
            r->status = HTTP_BAD_REQUEST;
            return APR_ENOSPC;
        }
    }
    
    if (!(value = strchr(line, ':'))) { /* Find ':' or    */
        r->status = HTTP_BAD_REQUEST;      /* abort bad request */
        apr_table_setn(r->notes, "error-notes",
                       apr_pstrcat(r->pool,
                                   "Request header field is "
                                   "missing ':' separator.<br />\n"
                                   "<pre>\n",
                                   ap_escape_html(r->pool, line),
                                   "</pre>\n", NULL));
        return APR_EGENERAL;
    }

    tmp_field = value - 1; /* last character of field-name */

    *value++ = '\0'; /* NUL-terminate at colon */

    while (*value == ' ' || *value == '\t') {
        ++value;            /* Skip to start of value   */
    }

    /* Strip LWS after field-name: */
    while (tmp_field > line
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }

    /* Strip LWS after field-value: */
    tmp_field = strchr(value, '\0') - 1;
    while (tmp_field > value
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }
    apr_table_addn(r->headers_in, line, value);
    return APR_SUCCESS;
}

static apr_status_t process_request_line(request_rec *r, char *line,
                                         int skip_first)
{
    if (!skip_first && (r->the_request == NULL)) {
        /* This is the first line of the request */
        if ((line == NULL) || (*line == '\0')) {
            /* We skip empty lines because browsers have to tack a CRLF on to the end
             * of POSTs to support old CERN webservers.
             */
            int max_blank_lines = r->server->limit_req_fields;
            if (max_blank_lines <= 0) {
                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
            }
            r->num_blank_lines++;
            if (r->num_blank_lines < max_blank_lines) {
                return APR_SUCCESS;
            }
        }
        set_the_request(r, line);
    }
    else {
        /* We've already read the first line of the request.  This is either
         * a header field or the blank line terminating the header
         */
        if ((line == NULL) || (*line == '\0')) {
            if (r->pending_header_line != NULL) {
                apr_status_t rv = set_mime_header(r, r->pending_header_line);
                if (rv != APR_SUCCESS) {
                    return rv;
                }
                r->pending_header_line = NULL;
            }
            if (r->status == HTTP_REQUEST_TIME_OUT) {
                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
                r->status = HTTP_OK;
            }
        }
        else {
            if ((*line == ' ') || (*line == '\t')) {
                /* This line is a continuation of the previous one */
                if (r->pending_header_line == NULL) {
                    r->pending_header_line = line;
                    r->pending_header_size = 0;
                }
                else {
                    apr_size_t pending_len = strlen(r->pending_header_line);
                    apr_size_t fold_len = strlen(line);
                    if ((r->server->limit_req_fieldsize > 0)
						&& (pending_len + fold_len >
                               (apr_size_t) r->server->limit_req_fieldsize)) {
                        /* CVE-2004-0942 */
                        r->status = HTTP_BAD_REQUEST;
                        return APR_ENOSPC;
                    }
                    if (pending_len + fold_len + 1 > r->pending_header_size) {
                        /* Allocate a new buffer big enough to hold the
                         * concatenated lines
                         */
                        apr_size_t new_size = r->pending_header_size;
                        char *new_buf;
                        if (new_size == 0) {
                            new_size = pending_len + fold_len + 1;
                        }
                        else {
                            do {
                                new_size *= 2;
                            } while (new_size < pending_len + fold_len + 1);
                        }
                        new_buf = (char *)apr_palloc(r->pool, new_size);
                        memcpy(new_buf, r->pending_header_line, pending_len);
                        r->pending_header_line = new_buf;
                        r->pending_header_size = new_size;
                    }
                    memcpy(r->pending_header_line + pending_len, line,
                           fold_len + 1);
                }
            }
            else {
                /* Set aside this line in case the next line is a continuation
                 */
                if (r->pending_header_line != NULL) {
                    apr_status_t rv = set_mime_header(r, r->pending_header_line);
                    if (rv != APR_SUCCESS) {
                        return rv;
                    }
                }
                r->pending_header_line = line;
                r->pending_header_size = 0;
            }
        }
    }
    return APR_SUCCESS;
        rv = process_request_line(r, field, 1);
        if (rv != APR_SUCCESS) {
            return;
        if ((field == NULL) || (*field == '\0')) {
            return;
static request_rec *init_request(conn_rec *conn)
    
    return r;
}
static request_rec *request_post_read(request_rec *r, conn_rec *conn)
{
    apr_socket_t *csd;
    const char *expect;
    int access_status;
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->server->timeout);

    if (apr_table_get(r->headers_in, "Transfer-Encoding") &&
        apr_table_get(r->headers_in, "Content-Length")) {
        /* 2616 section 4.4, point 3: "if both Transfer-Encoding
         * and Content-Length are received, the latter MUST be
         * ignored"; so unset it here to prevent any confusion
         * later.
         */
        apr_table_unset(r->headers_in, "Content-Length");
static apr_status_t read_partial_request(request_rec *r) {
    apr_bucket_brigade *tmp_bb;
    apr_status_t rv = APR_SUCCESS;

    /* Read and process lines of the request until we
     * encounter a complete request header, an error, or EAGAIN
     */
    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    while (r->status == HTTP_REQUEST_TIME_OUT) {
        char *line = NULL;
        apr_size_t line_length;
        apr_size_t length_limit;
        int first_line = (r->the_request == NULL);
        if (first_line) {
            length_limit = r->server->limit_req_line;
        }
        else {
            if (r->assbackwards) {
                r->status = HTTP_OK;
                break;
            }
            length_limit = r->server->limit_req_fieldsize;
        }
        /* TODO: use a nonblocking call in place of ap_rgetline */
        rv = ap_rgetline(&line, length_limit + 2,
                         &line_length, r, 0, tmp_bb);
        if (rv == APR_SUCCESS) {
            rv = process_request_line(r, line, 0);
        }
        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();
            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                if (first_line) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: URI too long (longer than %d)",
                                  r->server->limit_req_line);
                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                    r->proto_num = HTTP_VERSION(1,0);
                    r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
                }
                else {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: header line too long "
                                  "(longer than %d)",
                                  r->server->limit_req_fieldsize);
                    r->status = HTTP_BAD_REQUEST;
                }
            }
            break;
        }
    }
    apr_brigade_destroy(tmp_bb);
    return rv;
}

request_rec *ap_read_request(conn_rec *conn)
{
    request_rec *r;
    apr_status_t rv;

    r = init_request(conn);

    rv = read_partial_request(r);
    /* TODO poll if EAGAIN */
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return NULL;
    }

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers! Have to dink things just to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "client sent invalid HTTP/0.9 request: HEAD %s",
                      r->uri);
        r->header_only = 0;
        r->status = HTTP_BAD_REQUEST;
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return r;
    }

    return request_post_read(r, conn);
}

    /* 
     * SSL renegotiations in conjunction with HTTP
     * requests using the POST method are not supported.
     *
     * Background:
     *
     * 1. When the client sends a HTTP/HTTPS request, Apache's core code
     * reads only the request line ("METHOD /path HTTP/x.y") and the
     * attached MIME headers ("Foo: bar") up to the terminating line ("CR
     * LF"). An attached request body (for instance the data of a POST
     * method) is _NOT_ read. Instead it is read by mod_cgi's content
     * handler and directly passed to the CGI script.
     *
     * 2. mod_ssl supports per-directory re-configuration of SSL parameters.
     * This is implemented by performing an SSL renegotiation of the
     * re-configured parameters after the request is read, but before the
     * response is sent. In more detail: the renegotiation happens after the
     * request line and MIME headers were read, but _before_ the attached
     * request body is read. The reason simply is that in the HTTP protocol
     * usually there is no acknowledgment step between the headers and the
     * body (there is the 100-continue feature and the chunking facility
     * only), so Apache has no API hook for this step.
     *
     * 3. the problem now occurs when the client sends a POST request for
     * URL /foo via HTTPS the server and the server has SSL parameters
     * re-configured on a per-URL basis for /foo. Then mod_ssl has to
     * perform an SSL renegotiation after the request was read and before
     * the response is sent. But the problem is the pending POST body data
     * in the receive buffer of SSL (which Apache still has not read - it's
     * pending until mod_cgi sucks it in). When mod_ssl now tries to perform
     * the renegotiation the pending data leads to an I/O error.
     *
     * Solution Idea:
     *
     * There are only two solutions: Either to simply state that POST
     * requests to URLs with SSL re-configurations are not allowed, or to
     * renegotiate really after the _complete_ request (i.e. including
     * the POST body) was read. Obviously the latter would be preferred,
     * but it cannot be done easily inside Apache, because as already
     * mentioned, there is no API step between the body reading and the body
     * processing. And even when we mod_ssl would hook directly into the
     * loop of mod_cgi, we wouldn't solve the problem for other handlers, of
     * course. So the only general solution is to suck in the pending data
     * of the request body from the OpenSSL BIO into the Apache BUFF. Then
     * the renegotiation can be done and after this step Apache can proceed
     * processing the request as before.
     *
     * Solution Implementation:
     *
     * We cannot simply suck in the data via an SSL_read-based loop because of
     * HTTP chunking. Instead we _have_ to use the Apache API for this step which
     * is aware of HTTP chunking. So the trick is to suck in the pending request
     * data via the Apache API (which uses Apache's BUFF code and in the
     * background mod_ssl's I/O glue code) and re-inject it later into the Apache
     * BUFF code again. This way the data flows twice through the Apache BUFF, of
     * course. But this way the solution doesn't depend on any Apache specifics
     * and is fully transparent to Apache modules.
     *
     * !! BUT ALL THIS IS STILL NOT RE-IMPLEMENTED FOR APACHE 2.0 !!
    if (renegotiate && !renegotiate_quick && (r->method_number == M_POST)) {
        ap_log_error(APLOG_MARK, APLOG_ERR, 0, r->server,
                     "SSL Re-negotiation in conjunction "
                     "with POST method not supported! "
                     "hint: try SSLOptions +OptRenegotiate");

        return HTTP_METHOD_NOT_ALLOWED;
    int pasvmode = 0;
		 "proxy: FTP connecting %s to %s:%d", url, connectname, connectport);
                      "proxy: error creating socket");
		     "proxy: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
		 "proxy: socket has been created");
			     "proxy: attempt to connect to %pI (%s) failed", connect_addr, connectname);
		     "proxy: an error occurred creating a new connection to %pI (%s)", connect_addr, connectname);
		 "proxy: connection complete");
    apr_table_set(r->notes, "Directory-README", buffer);
     * Try PASV, if that fails try normally.
/* this temporarily switches off PASV */
    /* try to set up PASV data connection first */
/* IPV6 FIXME:
 * The EPSV command replaces PASV where both IPV4 and IPV6 is supported. Only
 * the port is returned, the IP address is always the same as that on the
 * control connection. Example:
 *   Entering Extended Passive Mode (|||6446|)
 */
    buf = apr_pstrcat(p, "PASV", CRLF, NULL);
    e = apr_bucket_pool_create(buf, strlen(buf), p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    ap_pass_brigade(origin->output_filters, bb);
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                 "proxy: FTP: PASV");
    /* possible results: 227, 421, 500, 501, 502, 530 */
    /*   227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
    /*   421 Service not available, closing control connection. */
    /*   500 Syntax error, command unrecognized. */
    /*   501 Syntax error in parameters or arguments. */
    /*   502 Command not implemented. */
    /*   530 Not logged in. */
    i = ftp_getrc_msg(origin, cbb, buffer, sizeof(buffer));
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
		 "proxy: FTP: %d %s", i, buffer);
    if (i == -1) {
	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
			     "Error reading from remote server");
    }
    if (i != 227 && i != 502) {
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, buffer);
    }
    else if (i == 227) {
	unsigned int h0, h1, h2, h3, p0, p1;
	char *pstr;
/* FIXME: Check PASV against RFC1123 */
	pstr = apr_pstrdup(p, buffer);
	pstr = strtok(pstr, " ");	/* separate result code */
	if (pstr != NULL) {
	    if (*(pstr + strlen(pstr) + 1) == '=') {
	        pstr += strlen(pstr) + 2;
	        pstr = strtok(NULL, "(");  /* separate address & port params */
		if (pstr != NULL)
		    pstr = strtok(NULL, ")");
	if (pstr != NULL && (sscanf(pstr,
		 "%d,%d,%d,%d,%d,%d", &h3, &h2, &h1, &h0, &p1, &p0) == 6)) {
	    apr_sockaddr_t *pasv_addr;
	    int pasvport = (p1 << 8) + p0;
            ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, r->server,
                         "proxy: FTP: PASV contacting host %d.%d.%d.%d:%d",
                         h3, h2, h1, h0, pasvport);
	    if ((rv = apr_socket_create(&remote_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
		ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
			     "proxy: error creating PASV socket");
		return HTTP_INTERNAL_SERVER_ERROR;
	    }
	    if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(remote_sock, APR_SO_RCVBUF,
		conf->recv_buffer_size))) {
				 "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
	    }
	    /* make the connection */
	    apr_sockaddr_info_get(&pasv_addr, apr_psprintf(p, "%d.%d.%d.%d", h3, h2, h1, h0), APR_INET, pasvport, 0, p);
	    rv = apr_connect(remote_sock, pasv_addr);
            if (rv != APR_SUCCESS) {
		ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
			     "proxy: FTP: PASV error creating socket");
		return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_psprintf(r->pool,
				     "PASV attempt to connect to %pI failed - firewall/NAT?", pasv_addr));
            }
		pasvmode = 1;
	else
	    /* and try the regular way */
	    apr_socket_close(remote_sock);
    /* set up data connection */
    if (!pasvmode) {
	    return ap_proxyerror(r, HTTP_NOT_IMPLEMENTED, "Connect to IPV6 ftp server not supported");
    if (!pasvmode) {
    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                  "proxy: FTP: ready to suck data");

        if (ap_open(&s->error_log, fname, APR_BUFFERED | APR_APPEND | 
    char errstr[MAX_STRING_LEN];
	len = ap_snprintf(errstr, sizeof(errstr), "[%s] ", ap_get_time());
    len += ap_snprintf(errstr + len, sizeof(errstr) - len,
	len += ap_snprintf(errstr + len, sizeof(errstr) - len,
	len += ap_snprintf(errstr + len, sizeof(errstr) - len,
	len += ap_snprintf(errstr + len, sizeof(errstr) - len,
	len += ap_snprintf(errstr + len, sizeof(errstr) - len,
	    sizeof(errstr) - len,
	    len += ap_snprintf(errstr + len, sizeof(errstr) - len,
    len += ap_vsnprintf(errstr + len, sizeof(errstr) - len, fmt, args);
      /* ZZZ let's just use AP funcs to Write to the error log.  If failure,
	 can we output a message to the console??? */
	ap_putc('\n', logf);
    if(ap_open(&pid_file, fname, APR_WRITE | APR_BUFFERED | APR_CREATE, APR_OS_DEFAULT, p) != APR_SUCCESS) {
            ap_rvputs(r, "value=\"", wsel->route, NULL);
            ap_rvputs(r, "value=\"", wsel->redirect, NULL);
module AP_MODULE_DECLARE_DATA imap_module;
    icr = ap_get_module_config(r->per_dir_config, &imap_module);
module AP_MODULE_DECLARE_DATA imap_module =
 * created at config time in the parent are valid across children.  For
 * example, the vhostrec pointer in the scoreboard below is valid in all
 * children of the same generation.
 *
 * The safe way to access the vhost pointer is like this:
 *
 * worker_score *ss = pointer to whichver slot is interesting;
 * process_score *ps = pointer to whichver slot is interesting;
 * server_rec *vh = ss->vhostrec;
 *
 * if (ps->generation != ap_my_generation) {
 *     vh = NULL;
 * }
 *
 * then if vh is not NULL it's valid in this child.
 *
 * This avoids various race conditions around restarts.
    SB_SHARED = 1,
    SB_NOT_SHARED = 2
    server_rec *vhostrec;	/* What virtual host is being accessed? */
                                /* SEE ABOVE FOR SAFE USAGE! */
    worker_score *next;
    global_score global;
#define KEY_LENGTH 16
#define VALUE_LENGTH 64
typedef struct {
    char key[KEY_LENGTH];
    char value[VALUE_LENGTH];
} status_table_entry;
AP_DECLARE_NONSTD(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e t);
AP_DECLARE(void) ap_increment_counts(void *sbh, request_rec *r);
void ap_init_scoreboard(void);

AP_DECLARE(void) reopen_scoreboard(apr_pool_t *p);

AP_DECLARE(void) ap_create_sb_handle(void **new_handle, apr_pool_t *p,
AP_DECLARE(int) ap_update_child_status(void *sbh, int status, request_rec *r);
AP_DECLARE(worker_score *) ap_get_servers_scoreboard(int x, int y);
AP_DECLARE(process_score *) ap_get_parent_scoreboard(int x);
AP_DECLARE(global_score *) ap_get_global_scoreboard(void);
/* Disable shmem until pools/init gets sorted out - remove next line when fixed */
#define APR_HAS_SHARED_MEMORY 0

#if APR_HAS_SHARED_MEMORY
#include "apr_shmem.h"
#else
/* just provide dummies - the code does run-time checks anyway */
typedef   void apr_shmem_t;
typedef   void apr_shm_name_t;

/*
static apr_status_t apr_shm_init(apr_shmem_t **m, apr_size_t reqsize, const char *file, apr_pool_t *cont) {
    return APR_ENOTIMPL;
}
*/
static apr_status_t apr_shm_destroy(apr_shmem_t *m) {
    return APR_ENOTIMPL;
}
static void *apr_shm_malloc(apr_shmem_t *c, apr_size_t reqsize) {
    return NULL;
}
/*
static void *apr_shm_calloc(apr_shmem_t *shared, apr_size_t size) {
    return NULL;
}
*/
static apr_status_t apr_shm_free(apr_shmem_t *shared, void *free) {
    return APR_ENOTIMPL;
}
/*
static apr_status_t apr_shm_name_get(apr_shmem_t *c, apr_shm_name_t **name) {
    return APR_ENOTIMPL;
}
static apr_status_t apr_shm_name_set(apr_shmem_t *c, apr_shm_name_t *name) {
    return APR_ENOTIMPL;
}
static apr_status_t apr_shm_open(apr_shmem_t *c) {
    return APR_ENOTIMPL;
}
static apr_status_t apr_shm_avail(apr_shmem_t *c, apr_size_t *avail) {
    return APR_ENOTIMPL;
}
*/
#endif /* ndef APR_HAS_SHARED_MEMORY */

static apr_shmem_t    *client_shm = NULL;
static unsigned long *opaque_cntr;
    ap_log_rerror(APLOG_MARK, APLOG_STARTUP | APLOG_NOERRNO, 0, NULL, 
    sts = apr_shm_init(&client_shm, shmem_size, tmpnam(NULL), ctx);
    client_list = apr_shm_malloc(client_shm, sizeof(*client_list) +
    opaque_cntr = apr_shm_malloc(client_shm, sizeof(*opaque_cntr));
    otn_counter = apr_shm_malloc(client_shm, sizeof(*otn_counter));
            apr_shm_free(client_shm, entry);
    entry = apr_shm_malloc(client_shm, sizeof(client_entry));
        entry = apr_shm_malloc(client_shm, sizeof(client_entry));
    server_rec *vhost;
	    vhost = ws_record.vhostrec;
	    if (ps_record.generation != ap_my_generation) {
		vhost = NULL;
	    }

			    vhost ? ap_escape_html(r->pool, 
				vhost->server_hostname) : "(unavailable)");
			     vhost ? ap_escape_html(r->pool, 
				vhost->server_hostname) : "(unavailable)",
                    n = ssl_rand_choosenum(0, sizeof(scoreboard)-1024-1);
#ifndef lint
static char const 
ssl_expr_yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
#endif
#include <stdlib.h>
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYLEX ssl_expr_yylex()
#define YYEMPTY -1
#define ssl_expr_yyclearin (ssl_expr_yychar=(YYEMPTY))
#define ssl_expr_yyerrok (ssl_expr_yyerrflag=0)
#define YYRECOVERING() (ssl_expr_yyerrflag!=0)
static int ssl_expr_yygrowstack();
#define YYPREFIX "ssl_expr_yy"
#line 69 "ssl_expr_parse.y"
#line 24 "y.tab.c"
#define YYERRCODE 256
#define T_TRUE 257
#define T_FALSE 258
#define T_DIGIT 259
#define T_ID 260
#define T_STRING 261
#define T_REGEX 262
#define T_REGEX_I 263
#define T_FUNC_FILE 264
#define T_OP_EQ 265
#define T_OP_NE 266
#define T_OP_LT 267
#define T_OP_LE 268
#define T_OP_GT 269
#define T_OP_GE 270
#define T_OP_REG 271
#define T_OP_NRE 272
#define T_OP_IN 273
#define T_OP_OR 274
#define T_OP_AND 275
#define T_OP_NOT 276
const short ssl_expr_yylhs[] = {                                        -1,
    0,    1,    1,    1,    1,    1,    1,    1,    2,    2,
    2,    2,    2,    2,    2,    2,    2,    5,    5,    6,
    6,    6,    6,    4,    4,    3,
const short ssl_expr_yylen[] = {                                         2,
    1,    1,    1,    2,    3,    3,    1,    3,    3,    3,
    3,    3,    3,    3,    5,    3,    3,    1,    3,    1,
    1,    4,    1,    1,    1,    4,
const short ssl_expr_yydefred[] = {                                      0,
    2,    3,   20,   21,    0,    0,    0,    0,    0,    0,
    7,   23,    0,    0,    4,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    8,
    0,    0,    6,    9,   10,   11,   12,   13,   14,   24,
   25,   16,   17,    0,   26,   22,    0,   18,   15,    0,
   19,
const short ssl_expr_yydgoto[] = {                                       9,
   10,   11,   12,   42,   47,   13,
const short ssl_expr_yysindex[] = {                                    -37,
    0,    0,    0,    0,  -35,  -37,  -37,  -99,    0, -247,
    0,    0, -250, -229,    0,  -39, -227,  -37,  -37,  -33,
  -33,  -33,  -33,  -33,  -33, -233, -233,  -89,   -6,    0,
  -87, -239,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  -33,    0,    0,  -38,    0,    0,  -33,
    0,
const short ssl_expr_yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   39,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    1,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,
const short ssl_expr_yygindex[] = {                                      0,
    7,    0,    0,   13,    0,  -13,
#define YYTABLESIZE 275
const short ssl_expr_yytable[] = {                                       8,
    5,   30,    7,    8,   14,   50,   34,   35,   36,   37,
   38,   39,   15,   16,   20,   21,   22,   23,   24,   25,
   26,   27,   28,   17,   32,   33,   18,   19,   40,   41,
   48,   29,   31,   44,   45,   19,   51,   46,    1,   43,
    0,    5,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   49,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
    2,    3,    0,    4,    0,    3,    5,    4,    0,    0,
    5,    0,    0,    0,   18,   19,    0,    0,    6,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    5,
const short ssl_expr_yycheck[] = {                                      37,
    0,   41,   40,   37,   40,   44,   20,   21,   22,   23,
   24,   25,    6,    7,  265,  266,  267,  268,  269,  270,
  271,  272,  273,  123,   18,   19,  274,  275,  262,  263,
   44,  261,  260,  123,   41,  275,   50,  125,    0,   27,
   -1,   41,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  125,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
  258,  259,   -1,  261,   -1,  259,  264,  261,   -1,   -1,
  264,   -1,   -1,   -1,  274,  275,   -1,   -1,  276,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  274,
#define YYFINAL 9
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 276
#if YYDEBUG
const char * const ssl_expr_yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,"'%'",0,0,"'('","')'",0,0,"','",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"T_TRUE",
"T_FALSE","T_DIGIT","T_ID","T_STRING","T_REGEX","T_REGEX_I","T_FUNC_FILE",
"T_OP_EQ","T_OP_NE","T_OP_LT","T_OP_LE","T_OP_GT","T_OP_GE","T_OP_REG",
"T_OP_NRE","T_OP_IN","T_OP_OR","T_OP_AND","T_OP_NOT",
const char * const ssl_expr_yyrule[] = {
"$accept : root",
"root : expr",
"expr : T_TRUE",
"expr : T_FALSE",
"expr : T_OP_NOT expr",
"expr : expr T_OP_OR expr",
"expr : expr T_OP_AND expr",
"expr : comparison",
"expr : '(' expr ')'",
"comparison : word T_OP_EQ word",
"comparison : word T_OP_NE word",
"comparison : word T_OP_LT word",
"comparison : word T_OP_LE word",
"comparison : word T_OP_GT word",
"comparison : word T_OP_GE word",
"comparison : word T_OP_IN '{' words '}'",
"comparison : word T_OP_REG regex",
"comparison : word T_OP_NRE regex",
"words : word",
"words : words ',' word",
"word : T_DIGIT",
"word : T_STRING",
"word : '%' '{' T_ID '}'",
"word : funccall",
"regex : T_REGEX",
"regex : T_REGEX_I",
"funccall : T_FUNC_FILE '(' T_STRING ')'",
#if YYDEBUG
#include <stdio.h>
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#define YYSTACKSIZE 10000
#define YYMAXDEPTH 10000
#define YYINITSTACKSIZE 200
int ssl_expr_yydebug;
int ssl_expr_yynerrs;
int ssl_expr_yyerrflag;
int ssl_expr_yychar;
short *ssl_expr_yyssp;
YYSTYPE *ssl_expr_yyvsp;
YYSTYPE ssl_expr_yyval;
YYSTYPE ssl_expr_yylval;
short *ssl_expr_yyss;
short *ssl_expr_yysslim;
YYSTYPE *ssl_expr_yyvs;
int ssl_expr_yystacksize;
#line 177 "ssl_expr_parse.y"
int ssl_expr_yyerror(char *s)
    ssl_expr_error = s;
    return 2;
#line 230 "y.tab.c"
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int ssl_expr_yygrowstack()
    int newsize, i;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = ssl_expr_yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;
    i = ssl_expr_yyssp - ssl_expr_yyss;
    newss = ssl_expr_yyss ? (short *)realloc(ssl_expr_yyss, newsize * sizeof *newss) :
      (short *)malloc(newsize * sizeof *newss);
    if (newss == NULL)
        return -1;
    ssl_expr_yyss = newss;
    ssl_expr_yyssp = newss + i;
    newvs = ssl_expr_yyvs ? (YYSTYPE *)realloc(ssl_expr_yyvs, newsize * sizeof *newvs) :
      (YYSTYPE *)malloc(newsize * sizeof *newvs);
    if (newvs == NULL)
        return -1;
    ssl_expr_yyvs = newvs;
    ssl_expr_yyvsp = newvs + i;
    ssl_expr_yystacksize = newsize;
    ssl_expr_yysslim = ssl_expr_yyss + newsize - 1;
    return 0;
#define YYABORT goto ssl_expr_yyabort
#define YYREJECT goto ssl_expr_yyabort
#define YYACCEPT goto ssl_expr_yyaccept
#define YYERROR goto ssl_expr_yyerrlab
#ifndef YYPARSE_PARAM
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG void
#else	/* ! ANSI-C/C++ */
#endif	/* ANSI-C/C++ */
#else	/* YYPARSE_PARAM */
#ifndef YYPARSE_PARAM_TYPE
#define YYPARSE_PARAM_TYPE void *
#if defined(__cplusplus) || __STDC__
#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#else	/* ! ANSI-C/C++ */
#define YYPARSE_PARAM_ARG YYPARSE_PARAM
#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
#endif	/* ANSI-C/C++ */
#endif	/* ! YYPARSE_PARAM */
ssl_expr_yyparse (YYPARSE_PARAM_ARG)
    YYPARSE_PARAM_DECL
    register int ssl_expr_yym, ssl_expr_yyn, ssl_expr_yystate;
#if YYDEBUG
    register const char *ssl_expr_yys;
    if ((ssl_expr_yys = getenv("YYDEBUG")))
        ssl_expr_yyn = *ssl_expr_yys;
        if (ssl_expr_yyn >= '0' && ssl_expr_yyn <= '9')
            ssl_expr_yydebug = ssl_expr_yyn - '0';
    ssl_expr_yynerrs = 0;
    ssl_expr_yyerrflag = 0;
    ssl_expr_yychar = (-1);
    if (ssl_expr_yyss == NULL && ssl_expr_yygrowstack()) goto ssl_expr_yyoverflow;
    ssl_expr_yyssp = ssl_expr_yyss;
    ssl_expr_yyvsp = ssl_expr_yyvs;
    *ssl_expr_yyssp = ssl_expr_yystate = 0;
ssl_expr_yyloop:
    if ((ssl_expr_yyn = ssl_expr_yydefred[ssl_expr_yystate])) goto ssl_expr_yyreduce;
    if (ssl_expr_yychar < 0)
        if ((ssl_expr_yychar = ssl_expr_yylex()) < 0) ssl_expr_yychar = 0;
#if YYDEBUG
        if (ssl_expr_yydebug)
        {
            ssl_expr_yys = 0;
            if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
            if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, ssl_expr_yystate, ssl_expr_yychar, ssl_expr_yys);
        }
    if ((ssl_expr_yyn = ssl_expr_yysindex[ssl_expr_yystate]) && (ssl_expr_yyn += ssl_expr_yychar) >= 0 &&
            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yychar)
#if YYDEBUG
        if (ssl_expr_yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, ssl_expr_yystate, ssl_expr_yytable[ssl_expr_yyn]);
#endif
        if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
        {
            goto ssl_expr_yyoverflow;
        }
        *++ssl_expr_yyssp = ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
        *++ssl_expr_yyvsp = ssl_expr_yylval;
        ssl_expr_yychar = (-1);
        if (ssl_expr_yyerrflag > 0)  --ssl_expr_yyerrflag;
        goto ssl_expr_yyloop;
    if ((ssl_expr_yyn = ssl_expr_yyrindex[ssl_expr_yystate]) && (ssl_expr_yyn += ssl_expr_yychar) >= 0 &&
            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yychar)
        ssl_expr_yyn = ssl_expr_yytable[ssl_expr_yyn];
        goto ssl_expr_yyreduce;
    }
    if (ssl_expr_yyerrflag) goto ssl_expr_yyinrecovery;
#if defined(lint) || defined(__GNUC__)
    goto ssl_expr_yynewerror;
ssl_expr_yynewerror:
    ssl_expr_yyerror("syntax error");
#if defined(lint) || defined(__GNUC__)
    goto ssl_expr_yyerrlab;
ssl_expr_yyerrlab:
    ++ssl_expr_yynerrs;
ssl_expr_yyinrecovery:
    if (ssl_expr_yyerrflag < 3)
    {
        ssl_expr_yyerrflag = 3;
        for (;;)
        {
            if ((ssl_expr_yyn = ssl_expr_yysindex[*ssl_expr_yyssp]) && (ssl_expr_yyn += YYERRCODE) >= 0 &&
                    ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (ssl_expr_yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *ssl_expr_yyssp, ssl_expr_yytable[ssl_expr_yyn]);
#endif
                if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
                {
                    goto ssl_expr_yyoverflow;
                }
                *++ssl_expr_yyssp = ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
                *++ssl_expr_yyvsp = ssl_expr_yylval;
                goto ssl_expr_yyloop;
            }
            else
            {
#if YYDEBUG
                if (ssl_expr_yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *ssl_expr_yyssp);
#endif
                if (ssl_expr_yyssp <= ssl_expr_yyss) goto ssl_expr_yyabort;
                --ssl_expr_yyssp;
                --ssl_expr_yyvsp;
            }
        }
    else
        if (ssl_expr_yychar == 0) goto ssl_expr_yyabort;
#if YYDEBUG
        if (ssl_expr_yydebug)
        {
            ssl_expr_yys = 0;
            if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
            if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, ssl_expr_yystate, ssl_expr_yychar, ssl_expr_yys);
        }
#endif
        ssl_expr_yychar = (-1);
        goto ssl_expr_yyloop;
#if YYDEBUG
    if (ssl_expr_yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, ssl_expr_yystate, ssl_expr_yyn, ssl_expr_yyrule[ssl_expr_yyn]);
#endif
    ssl_expr_yym = ssl_expr_yylen[ssl_expr_yyn];
    ssl_expr_yyval = ssl_expr_yyvsp[1-ssl_expr_yym];
    switch (ssl_expr_yyn)
{ ssl_expr_info.expr = ssl_expr_yyvsp[0].exVal; }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_True,  NULL, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_False, NULL, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Not,   ssl_expr_yyvsp[0].exVal,   NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Or,    ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_And,   ssl_expr_yyvsp[-2].exVal,   ssl_expr_yyvsp[0].exVal);   }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Comp,  ssl_expr_yyvsp[0].exVal,   NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[-1].exVal; }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_EQ,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_LE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GT,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_GE,  ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_IN,  ssl_expr_yyvsp[-4].exVal, ssl_expr_yyvsp[-1].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_REG, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_NRE, ssl_expr_yyvsp[-2].exVal, ssl_expr_yyvsp[0].exVal); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_ListElement, ssl_expr_yyvsp[0].exVal, ssl_expr_yyvsp[-2].exVal);   }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Digit,  ssl_expr_yyvsp[0].cpVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_String, ssl_expr_yyvsp[0].cpVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_make(op_Var,    ssl_expr_yyvsp[-1].cpVal, NULL); }
break;
{ ssl_expr_yyval.exVal = ssl_expr_yyvsp[0].exVal; }
break;
            }
break;
            }
break;
            }
break;
#line 550 "y.tab.c"
    ssl_expr_yyssp -= ssl_expr_yym;
    ssl_expr_yystate = *ssl_expr_yyssp;
    ssl_expr_yyvsp -= ssl_expr_yym;
    ssl_expr_yym = ssl_expr_yylhs[ssl_expr_yyn];
    if (ssl_expr_yystate == 0 && ssl_expr_yym == 0)
#if YYDEBUG
        if (ssl_expr_yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        ssl_expr_yystate = YYFINAL;
        *++ssl_expr_yyssp = YYFINAL;
        *++ssl_expr_yyvsp = ssl_expr_yyval;
        if (ssl_expr_yychar < 0)
        {
            if ((ssl_expr_yychar = ssl_expr_yylex()) < 0) ssl_expr_yychar = 0;
#if YYDEBUG
            if (ssl_expr_yydebug)
            {
                ssl_expr_yys = 0;
                if (ssl_expr_yychar <= YYMAXTOKEN) ssl_expr_yys = ssl_expr_yyname[ssl_expr_yychar];
                if (!ssl_expr_yys) ssl_expr_yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, ssl_expr_yychar, ssl_expr_yys);
            }
#endif
        }
        if (ssl_expr_yychar == 0) goto ssl_expr_yyaccept;
        goto ssl_expr_yyloop;
    if ((ssl_expr_yyn = ssl_expr_yygindex[ssl_expr_yym]) && (ssl_expr_yyn += ssl_expr_yystate) >= 0 &&
            ssl_expr_yyn <= YYTABLESIZE && ssl_expr_yycheck[ssl_expr_yyn] == ssl_expr_yystate)
        ssl_expr_yystate = ssl_expr_yytable[ssl_expr_yyn];
    else
        ssl_expr_yystate = ssl_expr_yydgoto[ssl_expr_yym];
#if YYDEBUG
    if (ssl_expr_yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *ssl_expr_yyssp, ssl_expr_yystate);
#endif
    if (ssl_expr_yyssp >= ssl_expr_yysslim && ssl_expr_yygrowstack())
        goto ssl_expr_yyoverflow;
    *++ssl_expr_yyssp = ssl_expr_yystate;
    *++ssl_expr_yyvsp = ssl_expr_yyval;
    goto ssl_expr_yyloop;
ssl_expr_yyoverflow:
    ssl_expr_yyerror("yacc stack overflow");
ssl_expr_yyabort:
    return (1);
ssl_expr_yyaccept:
    return (0);
#ifndef YYERRCODE
#define YYERRCODE 256
#endif

#define T_TRUE 257
#define T_FALSE 258
#define T_DIGIT 259
#define T_ID 260
#define T_STRING 261
#define T_REGEX 262
#define T_REGEX_I 263
#define T_FUNC_FILE 264
#define T_OP_EQ 265
#define T_OP_NE 266
#define T_OP_LT 267
#define T_OP_LE 268
#define T_OP_GT 269
#define T_OP_GE 270
#define T_OP_REG 271
#define T_OP_NRE 272
#define T_OP_IN 273
#define T_OP_OR 274
#define T_OP_AND 275
#define T_OP_NOT 276
    void *sbh;
    void *sbh;
        ap_scoreboard_image->global.running_generation = ap_my_generation;
        rc = DosAllocSharedMem((PPVOID)&ap_scoreboard_image, ap_scoreboard_fname,
        ap_init_scoreboard();
    } while (!shutdown_pending && ap_my_generation == ap_scoreboard_image->global.running_generation);
    void *sbh;
    void *sbh;
        ap_scoreboard_image->global.running_generation = ap_my_generation;
    void *sbh;
    void *sbh;
    reopen_scoreboard(pchild);
    ap_scoreboard_image->global.running_generation = ap_my_generation;
	ap_scoreboard_image->global.running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
	ap_scoreboard_image->global.running_generation != thread_control[THREAD_GLOBAL(thread_num)].generation) {
    void *sbh;
    thread_control[THREAD_GLOBAL(thread_num)].generation = ap_scoreboard_image->global.running_generation;
    ++ap_scoreboard_image->global.running_generation;
    void *sbh;
        /* Set up the scoreboard. */
        ap_run_pre_mpm(pconf, SB_NOT_SHARED);
        /* Humm... Should we put the parent pid here? Does it matter 
         * since the scoreboard is not shared?
         */
        ap_scoreboard_image->parent[0].pid = parent_pid;
        ap_scoreboard_image->parent[0].quiescing = 0;
    void *sbh;
    reopen_scoreboard(pchild);
    ap_scoreboard_image->global.running_generation = ap_my_generation;
AP_DECLARE(const char *) ap_mpm_set_scoreboard(cmd_parms *cmd, void *dummy,
					       const char *arg)

AP_DECLARE(const char *) ap_mpm_set_lockfile(cmd_parms *cmd, void *dummy,
					     const char *arg)
#include "apr_shmem.h"
static apr_shmem_t *scoreboard_shm = NULL;
typedef struct sb_handle {
} sb_handle;
    apr_shm_free(scoreboard_shm, ap_scoreboard_image);
    scoreboard_size = sizeof(scoreboard);
    scoreboard_size += sizeof(worker_score * ) * server_limit;
void ap_init_scoreboard(void)
    memset(ap_scoreboard_image, 0, scoreboard_size);
    more_storage = (char *)(ap_scoreboard_image + 1);
    ap_scoreboard_image->servers = (worker_score **)more_storage;
    more_storage += server_limit * sizeof(worker_score *);

    ap_assert(more_storage == (char *)ap_scoreboard_image + scoreboard_size);
static apr_status_t setup_shared(apr_pool_t *p)
    const char *fname;
    fname = ap_server_root_relative(p, ap_scoreboard_fname);
    rv = apr_shm_init(&scoreboard_shm, scoreboard_size, fname, p);
    ap_scoreboard_image = apr_shm_malloc(scoreboard_shm, scoreboard_size);
    if (ap_scoreboard_image == NULL) {
        ap_log_error(APLOG_MARK, APLOG_CRIT | APLOG_NOERRNO, 0, NULL,
                     "Fatal error: cannot allocate scoreboard");
        apr_shm_destroy(scoreboard_shm);
        return APR_EGENERAL;
    }
AP_DECLARE(void) reopen_scoreboard(apr_pool_t *p)
/* ap_cleanup_scoreboard
 * 
 */
    if (ap_scoreboard_image->global.sb_type == SB_SHARED) {
/* ap_create_scoreboard(apr_pool_t*, ap_scoreboard_e t)
 *
 * Create or reinit an existing scoreboard. The MPM can control whether
 *
 * ###: Is there any reason to export this symbol in the first place?
AP_DECLARE_NONSTD(void) ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)
	running_gen = ap_scoreboard_image->global.running_generation;
            rv = setup_shared(p);
            if (rv) {
            ap_scoreboard_image = (scoreboard *) malloc(scoreboard_size);
            if (ap_scoreboard_image == NULL) {
    ap_init_scoreboard(); /* can't just memset() */
    ap_scoreboard_image->global.sb_type = sb_type;
    ap_scoreboard_image->global.running_generation = running_gen;
    ap_restart_time = apr_time_now();
    apr_pool_cleanup_register(p, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);
				       worker_score *new_score_rec)
    lseek(scoreboard_fd, (long) child_num * sizeof(worker_score), 0);
    lseek(scoreboard_fd,
	  (char *) &ap_scoreboard_image->global -(char *) ap_scoreboard_image, 0);
AP_DECLARE(void) ap_increment_counts(void *sbh, request_rec *r)
    sb_handle *sb = sbh;
AP_DECLARE(void) ap_create_sb_handle(void **new_handle, apr_pool_t *p,
    sb_handle *sbh;

    sbh = (sb_handle *)apr_palloc(p, sizeof *sbh);
    *new_handle = sbh;
    sbh->child_num = child_num;
    sbh->thread_num = thread_num;
    int old_status, i;
        if (ps->generation != ap_my_generation) {
            for (i = 0; i < thread_limit; i++) {
                ap_scoreboard_image->servers[child_num][i].vhostrec = NULL;
            }
            ps->generation = ap_my_generation;
        }
	    ws->vhostrec =  r->server;
AP_DECLARE(int)ap_update_child_status(void *sbh, int status, request_rec *r)
    sb_handle *sb = sbh;
    
    return ap_update_child_status_from_indexes(sb->child_num, sb->thread_num,
AP_DECLARE(worker_score *) ap_get_servers_scoreboard(int x, int y)
AP_DECLARE(process_score *) ap_get_parent_scoreboard(int x)
AP_DECLARE(global_score *) ap_get_global_scoreboard()
    return(&ap_scoreboard_image->global);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type("text/xml", r);
    ap_rset_content_type(apr_pstrdup(r->pool, info->content_type), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html;charset=utf-8", r);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html", r);
                    ap_rset_content_type("text/plain", r);
    ap_rset_content_type("message/http", r);
AP_DECLARE(void) ap_rset_content_type(const char *ct, request_rec *r)
        ap_rset_content_type("text/html; charset=iso-8859-1", r);
            ap_rset_content_type(apr_pstrcat(r->pool, "multipart",
                                             use_range_x(r) ? "/x-" : "/",
                                             "byteranges; boundary=",
                                             r->boundary, NULL), r);
    ap_rset_content_type(rr->content_type, r);
        ap_rset_content_type(r->content_type, new);
        ap_rset_content_type(DIR_MAGIC_TYPE, r);
                ap_rset_content_type((char*) type, r);
                ap_rset_content_type(exinfo->forced_type, r);
	    ap_rset_content_type(apr_pstrcat(r->pool, ctp->type, "/",
                                             ctp->subtype, NULL), r);
			ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                         "; charset=", charset,
                                                         NULL), r);
		    ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                     "; ", pp->attr,
                                                     "=", pp->val,
                                                     NULL), r);
		ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                 "; charset=", charset,
                                                 NULL), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type(CGI_MAGIC_TYPE, sub_req);
        ap_rset_content_type(t, r);
                ap_rset_content_type(p->forced_mimetype, r);
	    ap_rset_content_type(tmp, r);
	ap_rset_content_type(tmp, r);
	ap_rset_content_type(apr_pstrdup(r->pool, sub->content_type), r);
        ap_rset_content_type("text/html", r);
            ap_rset_content_type(ap_default_type(r), r);
                    ap_rset_content_type(apr_pstrdup(p, buf), r);
    apr_status_t stat = APR_EINIT;
	    stat = apr_accept(&csd, sd, ptrans);
   	    if (stat == APR_SUCCESS || !APR_STATUS_IS_EINTR(stat))
	    if (stat == APR_SUCCESS)
                switch (stat) {
		    ap_log_error(APLOG_MARK, APLOG_EMERG, stat, ap_server_conf,
		    ap_log_error(APLOG_MARK, APLOG_EMERG, stat, ap_server_conf,
			"select/accept error (%d)", stat);
		    ap_log_error(APLOG_MARK, APLOG_ERR, stat, ap_server_conf,
                if (last_len + len > alloc_len) {
                    if (last_len + len > alloc_len) {
                        alloc_len = last_len + len;
    imap_conf_rec *new = (imap_conf_rec *) apr_pcalloc(p, sizeof(imap_conf_rec));
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted") && *comment) {
    if (!strcasecmp(menu, "unformatted") && *comment) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    apr_pool_t *p = r->connection->pool;
    apr_bucket *e;
    apr_bucket_brigade *bb = apr_brigade_create(p);
    err = apr_sockaddr_info_get(&uri_addr, uri.hostname, APR_UNSPEC, uri.port, 0, r->server->process->pconf);
        err = apr_sockaddr_info_get(&connect_addr, proxyname, APR_UNSPEC, proxyport, 0, r->server->process->pconf);
	if ((conf->id == r->connection->id) &&
    if (conf->client_socket) {
	/* allocate this out of the process pool - if this socket gets lost then the proxy
	 * hangs when the socket is closed...! */
	if ((apr_socket_create(&sock, APR_INET, SOCK_STREAM, r->server->process->pconf)) != APR_SUCCESS) {
    /* the socket is now open, create a new connection */
	     "proxy: error reading from remote server %s using ap_proxy_string_read()",
	/* no chunked / no length therefore read till EOF */
	    origin->remain = -1;
#include "apr_lib.h"
#include "http_log.h"
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;
 
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;
 
    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */
 
    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
            /* this is a hack to make sure that request time is set,
             * it's not perfect, but it's better than nothing
             */
            r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */
 
    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk
 
#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */
 
    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);
 
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method);
#endif
    uri = ap_getword_white(r->pool, &ll);
 
    /* Provide quick information about the request method as soon as known */
 
    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }
 
    ap_parse_uri(r, uri);
 
    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }
 
    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);
 
    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */
 
    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))    /* don't allow HTTP/0.1000 */
        r->proto_num = HTTP_VERSION(major, minor);
    else
        r->proto_num = HTTP_VERSION(1,0);
 
    return 1;
}

static int http_create_request(request_rec *r)
{
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
    int keptalive;

    hconn = apr_pcalloc(r->pool, sizeof(*hconn));
    ap_set_module_config(r->connection->conn_config, &http_module, hconn);

    if (!r->main && !r->prev && !r->next) {
        keptalive = r->connection->keepalive == 1;
        r->connection->keepalive    = 0;
 
        /* XXX can we optimize these timeouts at all? gstein */
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(keptalive
                         ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                         : r->server->timeout * APR_USEC_PER_SEC));
 
        /* Get the request... */
        if (!read_request_line(r)) {
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                              "request failed: URI too long");
                ap_send_error_response(r, 0);
                ap_run_log_transaction(r);
                return OK;
            }
            return DONE;
        }
        if (keptalive) {
            apr_setsocketopt(r->connection->client_socket,
                             APR_SO_TIMEOUT,
                             (int)(r->server->timeout * APR_USEC_PER_SEC));
        }
    }
    return OK;
}

    ap_hook_create_request(http_create_request, NULL, NULL, APR_HOOK_MIDDLE);
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
	    || (r->server->keep_alive_max > hconn->keepalives))
        int left = r->server->keep_alive_max - hconn->keepalives;
        hconn->keepalives++;
typedef struct ap_http_conn_rec ap_http_conn_rec;

struct ap_http_conn_rec {
    /** How many times have we used it? */
    int keepalives;
};

AP_DECLARE_DATA extern module http_module;

#include "mod_core.h"
    if (ap_run_create_request(r) != OK) {
        return NULL;
    }
    int received_continue = 1; /* flag to indicate if we should
                                * loop over response parsing logic
                                * in the case that the origin told us
                                * to HTTP_CONTINUE
                                */
    while (received_continue) {
        if ( r->status != HTTP_CONTINUE ) {
            received_continue = 0;
        } else {
                         "proxy: HTTP: received 100 CONTINUE");
            (!ap_is_HTTP_INFO(r->status)) &&       /* not any 1xx response */
    }
            if ((status > 199) && /* not any 1xx response */
                (status != HTTP_NO_CONTENT) && /* not 204 */
        ap_rvputs(r, ap_get_server_name(r), " (", r->connection->local_ip,
        else if (  (strlen(r->filename) > 7 &&
                    strncasecmp(r->filename, "http://",   7) == 0)
                || (strlen(r->filename) > 8 &&
                    strncasecmp(r->filename, "https://",  8) == 0)
                || (strlen(r->filename) > 9 &&
                    strncasecmp(r->filename, "gopher://", 9) == 0)
                || (strlen(r->filename) > 6 &&
                    strncasecmp(r->filename, "ftp://",    6) == 0)
                || (strlen(r->filename) > 5 &&
                    strncasecmp(r->filename, "ldap:",     5) == 0)
                || (strlen(r->filename) > 5 &&
                    strncasecmp(r->filename, "news:",     5) == 0)
                || (strlen(r->filename) > 7 &&
                    strncasecmp(r->filename, "mailto:",   7) == 0)) {
        else if (  (strlen(r->filename) > 7 &&
                    strncasecmp(r->filename, "http://",   7) == 0)
                || (strlen(r->filename) > 8 &&          
                    strncasecmp(r->filename, "https://",  8) == 0)
                || (strlen(r->filename) > 9 &&
                    strncasecmp(r->filename, "gopher://", 9) == 0)
                || (strlen(r->filename) > 6 &&
                    strncasecmp(r->filename, "ftp://",    6) == 0)
                || (strlen(r->filename) > 5 &&
                    strncasecmp(r->filename, "ldap:",     5) == 0)
                || (strlen(r->filename) > 5 &&
                    strncasecmp(r->filename, "news:",     5) == 0)
                || (strlen(r->filename) > 7 &&
                    strncasecmp(r->filename, "mailto:",   7) == 0)) {
    char env[MAX_STRING_LEN];
        for (i = 0; p->env[i] != NULL; i++) {
            /*  1. take the string  */
            apr_cpystrn(env, p->env[i], sizeof(env));
            /*  2. expand $N (i.e. backrefs to RewriteRule pattern)  */
            expand_backref_inbuffer(r->pool, env, sizeof(env), briRR, '$');
            /*  3. expand %N (i.e. backrefs to latest RewriteCond pattern)  */
            expand_backref_inbuffer(r->pool, env, sizeof(env), briRC, '%');
            /*  4. expand %{...} (i.e. variables) */
            expand_variables_inbuffer(r, env, sizeof(env));
            /*  5. expand ${...} (RewriteMap lookups)  */
            expand_map_lookups(r, env, sizeof(env));
            /*  and add the variable to Apache's structures  */
            add_env_variable(r, env);
        }
    /*  1. take the output string  */
    apr_cpystrn(newuri, output, sizeof(newuri));
    /*  2. expand $N (i.e. backrefs to RewriteRule pattern)  */
    expand_backref_inbuffer(r->pool, newuri, sizeof(newuri), briRR, '$');
    /*  3. expand %N (i.e. backrefs to latest RewriteCond pattern)  */
    expand_backref_inbuffer(r->pool, newuri, sizeof(newuri), briRC, '%');
    /*  4. expand %{...} (i.e. variables) */
    expand_variables_inbuffer(r, newuri, sizeof(newuri));
    /*  5. expand ${...} (RewriteMap lookups)  */
    expand_map_lookups(r, newuri, sizeof(newuri));
    /*  and log the result... */
    for (i = 0; p->env[i] != NULL; i++) {
        /*  1. take the string  */
        apr_cpystrn(env, p->env[i], sizeof(env));
        /*  2. expand $N (i.e. backrefs to RewriteRule pattern)  */
        expand_backref_inbuffer(r->pool, env, sizeof(env), briRR, '$');
        /*  3. expand %N (i.e. backrefs to latest RewriteCond pattern)  */
        expand_backref_inbuffer(r->pool, env, sizeof(env), briRC, '%');
        /*  4. expand %{...} (i.e. variables) */
        expand_variables_inbuffer(r, env, sizeof(env));
        /*  5. expand ${...} (RewriteMap lookups)  */
        expand_map_lookups(r, env, sizeof(env));
        /*  and add the variable to Apache's structures  */
        add_env_variable(r, env);
    }
    i = strlen(r->filename);
    if (   prefixstrip
        && !(   r->filename[0] == '/'
             || (   (i > 7 && strncasecmp(r->filename, "http://",   7) == 0)
                 || (i > 8 && strncasecmp(r->filename, "https://",  8) == 0)
                 || (i > 9 && strncasecmp(r->filename, "gopher://", 9) == 0)
                 || (i > 6 && strncasecmp(r->filename, "ftp://",    6) == 0)
                 || (i > 5 && strncasecmp(r->filename, "ldap:",     5) == 0)
                 || (i > 5 && strncasecmp(r->filename, "news:",     5) == 0)
                 || (i > 7 && strncasecmp(r->filename, "mailto:",   7) == 0)))) {
    i = strlen(r->filename);
    if (   (i > 7 && strncasecmp(r->filename, "http://",   7) == 0)
        || (i > 8 && strncasecmp(r->filename, "https://",  8) == 0)
        || (i > 9 && strncasecmp(r->filename, "gopher://", 9) == 0)
        || (i > 6 && strncasecmp(r->filename, "ftp://",    6) == 0)
        || (i > 5 && strncasecmp(r->filename, "ldap:",     5) == 0)
        || (i > 5 && strncasecmp(r->filename, "news:",     5) == 0)
        || (i > 7 && strncasecmp(r->filename, "mailto:",   7) == 0) ) {
    /*  1. take the string  */
    apr_cpystrn(input, p->input, sizeof(input));
    /*  2. expand $N (i.e. backrefs to RewriteRule pattern)  */
    expand_backref_inbuffer(r->pool, input, sizeof(input), briRR, '$');
    /*  3. expand %N (i.e. backrefs to latest RewriteCond pattern)  */
    expand_backref_inbuffer(r->pool, input, sizeof(input), briRC, '%');
    /*  4. expand %{...} (i.e. variables) */
    expand_variables_inbuffer(r, input, sizeof(input));
    /*  5. expand ${...} (RewriteMap lookups)  */
    expand_map_lookups(r, input, sizeof(input));
        if (strlen(input) > 0               /* nonempty path, and            */
            && (   r->main == NULL          /* - either not in a subrequest  */
                || (   r->main->uri != NULL /* - or in a subrequest...       */
                    && r->uri != NULL       /*   ...and URIs aren't NULL...  */
                                            /*   ...and sub/main URIs differ */
                    && strcmp(r->main->uri, r->uri) != 0) ) ) {
        if (strlen(input) > 0               /* nonempty path, and            */
            && (   r->main == NULL          /* - either not in a subrequest  */
                || (   r->main->uri != NULL /* - or in a subrequest...       */
                    && r->uri != NULL       /*   ...and URIs aren't NULL...  */
                                            /*   ...and sub/main URIs differ */
                    && strcmp(r->main->uri, r->uri) != 0) ) ) {
    int i;
    i = strlen(r->filename);
    if (!(   (i > 7 && strncasecmp(r->filename, "http://",   7) == 0)
          || (i > 8 && strncasecmp(r->filename, "https://",  8) == 0)
          || (i > 9 && strncasecmp(r->filename, "gopher://", 9) == 0)
          || (i > 6 && strncasecmp(r->filename, "ftp://",    6) == 0)
          || (i > 5 && strncasecmp(r->filename, "ldap:",     5) == 0)
          || (i > 5 && strncasecmp(r->filename, "news:",     5) == 0)
          || (i > 7 && strncasecmp(r->filename, "mailto:",   7) == 0))) {
**  Expand the %0-%9 or $0-$9 regex backreferences
static void expand_backref_inbuffer(apr_pool_t *p, char *buf, int nbuf,
                                    backrefinfo *bri, char c)
    register int i;

    /* protect existing $N and & backrefs and replace <c>N with $N backrefs */
    for (i = 0; buf[i] != '\0' && i < nbuf; i++) {
        if (buf[i] == '\\' && (buf[i+1] != '\0' && i < (nbuf-1))) {
            i++; /* protect next */
        }
        else if (buf[i] == '&') {
            buf[i] = '\001';
        }
        else if (c != '$' && buf[i] == '$' && (buf[i+1] >= '0' && buf[i+1] <= '9')) {
            buf[i] = '\002';
            i++; /* speedup */
        }
        else if (buf[i] == c && (buf[i+1] >= '0' && buf[i+1] <= '9')) {
            buf[i] = '$';
            i++; /* speedup */
        }

    /* now apply the standard regex substitution function */
    apr_cpystrn(buf, ap_pregsub(p, buf, bri->source,
                               bri->nsub+1, bri->regmatch), nbuf);

    /* restore the original $N and & backrefs */
    for (i = 0; buf[i] != '\0' && i < nbuf; i++) {
        if (buf[i] == '\001') {
            buf[i] = '&';
        }
        else if (buf[i] == '\002') {
            buf[i] = '$';
        }
/*
**
**  mapfile expansion support
**  i.e. expansion of MAP lookup directives
**  ${<mapname>:<key>} in RewriteRule rhs
**
*/

#define limit_length(n) (n > LONG_STRING_LEN-1 ? LONG_STRING_LEN-1 : n)

static void expand_map_lookups(request_rec *r, char *uri, int uri_len)
{
    char newuri[MAX_STRING_LEN];
    char *cpI;
    char *cpIE;
    char *cpO;
    char *cpT;
    char *cpT2;
    char mapname[LONG_STRING_LEN];
    char mapkey[LONG_STRING_LEN];
    char defaultvalue[LONG_STRING_LEN];
    int n;

    cpI = uri;
    cpIE = cpI+strlen(cpI);
    cpO = newuri;
    while (cpI < cpIE) {
        if (cpI+6 < cpIE && strncmp(cpI, "${", 2) == 0) {
            /* missing delimiter -> take it as plain text */
            if (   strchr(cpI+2, ':') == NULL
                || strchr(cpI+2, '}') == NULL) {
                memcpy(cpO, cpI, 2);
                cpO += 2;
                cpI += 2;
                continue;
            }
            cpI += 2;

            cpT = strchr(cpI, ':');
            n = cpT-cpI;
            memcpy(mapname, cpI, limit_length(n));
            mapname[limit_length(n)] = '\0';
            cpI += n+1;

            cpT2 = strchr(cpI, '|');
            cpT = strchr(cpI, '}');
            if (cpT2 != NULL && cpT2 < cpT) {
                n = cpT2-cpI;
                memcpy(mapkey, cpI, limit_length(n));
                mapkey[limit_length(n)] = '\0';
                cpI += n+1;

                n = cpT-cpI;
                memcpy(defaultvalue, cpI, limit_length(n));
                defaultvalue[limit_length(n)] = '\0';
                cpI += n+1;
            }
            else {
                n = cpT-cpI;
                memcpy(mapkey, cpI, limit_length(n));
                mapkey[limit_length(n)] = '\0';
                cpI += n+1;

                defaultvalue[0] = '\0';
            }

            cpT = lookup_map(r, mapname, mapkey);
            if (cpT != NULL) {
                n = strlen(cpT);
                if (cpO + n >= newuri + sizeof(newuri)) {
                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR,
                                 0, r, "insufficient space in "
                                 "expand_map_lookups, aborting");
                    return;
                }
                memcpy(cpO, cpT, n);
                cpO += n;
            }
            else {
                n = strlen(defaultvalue);
                if (cpO + n >= newuri + sizeof(newuri)) {
                    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 
                                 0, r, "insufficient space in "
                                 "expand_map_lookups, aborting");
                    return;
                }
                memcpy(cpO, defaultvalue, n);
                cpO += n;
            }
        }
        else {
            cpT = strstr(cpI, "${");
            if (cpT == NULL)
                cpT = cpI+strlen(cpI);
            n = cpT-cpI;
            if (cpO + n >= newuri + sizeof(newuri)) {
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 
                             0, r, "insufficient space in "
                             "expand_map_lookups, aborting");
                return;
            }
            memcpy(cpO, cpI, n);
            cpO += n;
            cpI += n;
        }
    }
    *cpO = '\0';
    apr_cpystrn(uri, newuri, uri_len);
    return;
}

#undef limit_length

static void expand_variables_inbuffer(request_rec *r, char *buf, int buf_len)
{
    char *newbuf;
    newbuf = expand_variables(r, buf);
    if (strcmp(newbuf, buf) != 0) {
        apr_cpystrn(buf, newbuf, buf_len);
    }
    return;
}

static char *expand_variables(request_rec *r, char *str)
{
    char output[MAX_STRING_LEN];
    char input[MAX_STRING_LEN];
    char *cp;
    char *cp2;
    char *cp3;
    int expanded;
    char *outp;
    char *endp;

    apr_cpystrn(input, str, sizeof(input));
    output[0] = '\0';
    outp = output;
    endp = output + sizeof(output);
    expanded = 0;
    for (cp = input; cp < input+MAX_STRING_LEN; ) {
        if ((cp2 = strstr(cp, "%{")) != NULL) {
            if ((cp3 = strstr(cp2, "}")) != NULL) {
                *cp2 = '\0';
                outp = apr_cpystrn(outp, cp, endp - outp);

                cp2 += 2;
                *cp3 = '\0';
                outp = apr_cpystrn(outp, lookup_variable(r, cp2), endp - outp);

                cp = cp3+1;
                expanded = 1;
                continue;
            }
        }
        outp = apr_cpystrn(outp, cp, endp - outp);
        break;
    }
    return expanded ? apr_pstrdup(r->pool, output) : str;
}

static void  expand_backref_inbuffer(apr_pool_t *p, char *buf, int nbuf,
                                     backrefinfo *bri, char c);
static void  expand_map_lookups(request_rec *r, char *uri, int uri_len);
static void  expand_variables_inbuffer(request_rec *r, char *buf, int buf_len);
static char *expand_variables(request_rec *r, char *str);
AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char *segment)
    char *copy = apr_palloc(p, 3 * strlen(segment) + 1);

    if ((rv = apr_socket_create(&sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                      "proxy: FTP: error creating socket");
        return HTTP_INTERNAL_SERVER_ERROR;
    }

#if !defined(TPF) && !defined(BEOS)
    if (conf->recv_buffer_size > 0
        && (rv = apr_socket_opt_set(sock, APR_SO_RCVBUF,
                                    conf->recv_buffer_size))) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                      "apr_socket_opt_set(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
    }
#endif

    if ((rv = apr_socket_opt_set(sock, APR_SO_REUSEADDR, one)) 
            != APR_SUCCESS) {
#ifndef _OSD_POSIX              /* BS2000 has this option "always on" */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r,
                      "proxy: FTP: error setting reuseaddr option: apr_socket_opt_set(SO_REUSEADDR)");
        return HTTP_INTERNAL_SERVER_ERROR;
#endif                          /* _OSD_POSIX */
    }

    /* Set a timeout on the socket */
    if (conf->timeout_set == 1) {
        apr_socket_timeout_set(sock, conf->timeout);
    }
    else {
        apr_socket_timeout_set(sock, r->server->timeout);
    }

    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "proxy: FTP: socket has been created");


            /* FIXME: @@@: We created an APR_INET socket. Now there may be
             * IPv6 (AF_INET6) DNS addresses in the list... IMO the socket
             * should be created with the correct family in the first place.
             * (either do it in this loop, or make at least two attempts
             * with the AF_INET and AF_INET6 elements in the list)
             */
                         "proxy: FTP: trying to connect to %pI (%s)...", connect_addr, connectname);
                if ((rv = apr_socket_create(&data_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                apr_sockaddr_info_get(&epsv_addr, data_ip, APR_INET, data_port, 0, p);
                if ((rv = apr_socket_create(&data_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
                apr_sockaddr_info_get(&pasv_addr, apr_psprintf(p, "%d.%d.%d.%d", h3, h2, h1, h0), APR_INET, pasvport, 0, p);
        if ((rv = apr_socket_create(&local_sock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
        else if (!strcasecmp(w, "Options")) {
        else if (!strcasecmp(w, "execCGI")) {
        /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        if (action == '-') {
    note = apr_pstrcat(r->pool, MOD_SESSION_COOKIE, name, NULL);
    zz = (session_rec *) apr_pcalloc(r->pool, sizeof(session_rec));
    zz->pool = r->pool;
    zz->entries = apr_table_make(r->pool, 10);
    zz->uuid = (apr_uuid_t *) apr_pcalloc(r->pool, sizeof(apr_uuid_t));
 * by Alexei Kosut <akosut@apache.org>
 * This module implements Microsoft's ISAPI, allowing Apache (when running
 * under Windows) to load Internet Server Applications (ISAPI extensions).
 * It implements all of the ISAPI 2.0 specification, except for the 
 * "Microsoft-only" extensions dealing with asynchronous I/O. All ISAPI
 * extensions that use only synchronous I/O and are compatible with the
 * ISAPI 2.0 specification should work (most ISAPI 1.0 extensions should
 * function as well).
 * To load, simply place the ISA in a location in the document tree.
 * Then add an "AddHandler isapi-isa dll" into your config file.
 * You should now be able to load ISAPI DLLs just be reffering to their
 * URLs. Make sure the ExecCGI option is active in the directory
 * the ISA is in.
#include "apr_strings.h"
#include "apr_portable.h"
#include "apr_buckets.h"
/* We use the exact same header file as the original */
#include <HttpExt.h>
#if !defined(HSE_REQ_MAP_URL_TO_PATH_EX) \
 || !defined(HSE_REQ_SEND_RESPONSE_HEADER_EX)
#pragma message("WARNING: This build of Apache is missing the recent changes")
#pragma message("in the Microsoft Win32 Platform SDK; some mod_isapi features")
#pragma message("will be disabled.  To obtain the latest Platform SDK files,")
#pragma message("please refer to:")
#pragma message("http://msdn.microsoft.com/downloads/sdks/platform/platform.asp")
#endif
/* Our isapi global config values */
static struct isapi_global_conf {
    apr_pool_t         *pool;
    apr_array_header_t *modules;
} loaded;

static apr_status_t isapi_load(apr_pool_t *p, request_rec *r, 
                               const char *fpath, isapi_loaded** isa);
    isapi_loaded *isa, **newisa;
    
	             "ISAPI: Invalid module path %s, skipping", filename);
	    "ISAPI: unable to stat(%s), skipping", fspec);
	    "ISAPI: %s isn't a regular file, skipping", fspec);
    /* Load the extention as cached (passing NULL for r) */
    rv = isapi_load(loaded.pool, NULL, fspec, &isa); 
                     "ISAPI: unable to cache %s, skipping", fspec);
    /* Add to cached list of loaded modules */
    newisa = apr_array_push(loaded.modules);
    *newisa = isa;
    
    const char *filename;
    apr_dso_handle_t *handle;
    HSE_VERSION_INFO *pVer;
    int   refcount;
    DWORD timeout;
    BOOL  fakeasync;
    DWORD report_version;
static apr_status_t isapi_unload(isapi_loaded* isa, int force)
     * If optionally cached, pass HSE_TERM_ADVISORY_UNLOAD,
     * and if it returns TRUE, unload, otherwise, cache it.
    if (((--isa->refcount > 0) && !force) || !isa->handle)
        if (force)
        else if (!(*isa->TerminateExtension)(HSE_TERM_ADVISORY_UNLOAD))
static apr_status_t cleanup_isapi(void *isa)
    return isapi_unload((isapi_loaded*) isa, TRUE);
static apr_status_t isapi_load(apr_pool_t *p, request_rec *r, 
                               const char *fpath, isapi_loaded** isa)
    isapi_loaded **found = (isapi_loaded **)loaded.modules->elts;
    int n;
    for (n = 0; n < loaded.modules->nelts; ++n) {
        if (strcasecmp(fpath, (*found)->filename) == 0) {
            break;
        }
        ++found;
    }
    
    if (n < loaded.modules->nelts) 
    {
        *isa = *found;
        if ((*isa)->handle) 
        {
            ++(*isa)->refcount;
            return APR_SUCCESS;
        }
        /* Otherwise we fall through and have to reload the resource
         * into this existing mod_isapi cache bucket.
         */
    }
    else
    {
        *isa = apr_pcalloc(p, sizeof(isapi_module));
        (*isa)->filename = fpath;
        (*isa)->pVer = apr_pcalloc(p, sizeof(HSE_VERSION_INFO));
    
        /* TODO: These need to become overrideable, so that we
         * assure a given isapi can be fooled into behaving well.
         */
        (*isa)->timeout = INFINITE; /* microsecs */
        (*isa)->fakeasync = TRUE;
        (*isa)->report_version = MAKELONG(0, 5); /* Revision 5.0 */
    }
    rv = apr_dso_load(&(*isa)->handle, fpath, p);
        ap_log_rerror(APLOG_MARK, APLOG_ALERT, rv, r,
                      "ISAPI: %s failed to load", fpath);
        (*isa)->handle = NULL;
    rv = apr_dso_sym((void**)&(*isa)->GetExtensionVersion, (*isa)->handle,
        ap_log_rerror(APLOG_MARK, APLOG_ALERT, rv, r,
                      "ISAPI: %s is missing GetExtensionVersion()",
                      fpath);
        apr_dso_unload((*isa)->handle);
        (*isa)->handle = NULL;
    rv = apr_dso_sym((void**)&(*isa)->HttpExtensionProc, (*isa)->handle,
        ap_log_rerror(APLOG_MARK, APLOG_ALERT, rv, r,
                      "ISAPI: %s is missing HttpExtensionProc()",
                      fpath);
        apr_dso_unload((*isa)->handle);
        (*isa)->handle = NULL;
    rv = apr_dso_sym((void**)&(*isa)->TerminateExtension, (*isa)->handle,
    if (!((*isa)->GetExtensionVersion)((*isa)->pVer)) {
        ap_log_rerror(APLOG_MARK, APLOG_ALERT, rv, r,
                      "ISAPI: %s call GetExtensionVersion() failed", 
                      fpath);
        apr_dso_unload((*isa)->handle);
        (*isa)->handle = NULL;
    ++(*isa)->refcount;

    apr_pool_cleanup_register(p, *isa, cleanup_isapi, 
                                   apr_pool_cleanup_null);
    LPEXTENSION_CONTROL_BLOCK ecb;
BOOL WINAPI GetServerVariable (HCONN hConn, LPSTR lpszVariableName,
                               LPVOID lpvBuffer, LPDWORD lpdwSizeofBuffer)
    request_rec *r = ((isapi_cid *)hConn)->r;
    DWORD len;
            return FALSE;
        return TRUE;
            return FALSE;
        return TRUE;
            return FALSE;
        return TRUE;
    return FALSE;
BOOL WINAPI WriteClient (HCONN ConnID, LPVOID Buffer, LPDWORD lpdwBytes,
                         DWORD dwReserved)
    return TRUE;
BOOL WINAPI ReadClient (HCONN ConnID, LPVOID lpvBuffer, LPDWORD lpdwSize)
    DWORD read = 0;
    return TRUE;
static apr_ssize_t send_response_header(isapi_cid *cid, const char *stat,
                                        const char *head, apr_size_t statlen,
    /* Parse them out, or die trying */
BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwHSERequest,
                                  LPVOID lpvBuffer, LPDWORD lpdwSize,
                                  LPDWORD lpdwDataType)
    isapi_cid *cid = (isapi_cid *)hConn;
        return TRUE;
    case 2: /* HSE_REQ_SEND_URL */
        return TRUE;
    case 3: /* HSE_REQ_SEND_RESPONSE_HEADER */
            return FALSE;
        return TRUE;
    case 4: /* HSE_REQ_DONE_WITH_SESSION */
            SetEvent(cid->complete);            
        return TRUE;
    case 1001: /* HSE_REQ_MAP_URL_TO_PATH */
        DWORD len;
        return TRUE;
    case 1002: /* HSE_REQ_GET_SSPI_INFO */
        return FALSE;
    case 1003: /* HSE_APPEND_LOG_PARAMETER */
        return TRUE;
    case 1005: /* HSE_REQ_IO_COMPLETION */
        if (!cid->isa->fakeasync) {
            if (cid->dconf.log_unsupported)
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
                          "ISAPI: ServerSupportFunction HSE_REQ_IO_COMPLETION "
                          "is not supported: %s", r->filename);
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        cid->completion = (PFN_HSE_IO_COMPLETION) lpvBuffer;
        cid->completion_arg = (PVOID) lpdwDataType;
        return TRUE;
    case 1006: /* HSE_REQ_TRANSMIT_FILE */
        if (!cid->isa->fakeasync && (tf->dwFlags & HSE_IO_ASYNC)) {
            return FALSE;
            return FALSE;
                return FALSE;
        return TRUE;
    case 1007: /* HSE_REQ_REFRESH_ISAPI_ACL */
        return FALSE;
    case 1008: /* HSE_REQ_IS_KEEP_CONN */
        *((LPBOOL) lpvBuffer) = (r->connection->keepalive == 1);
        return TRUE;
    case 1010: /* XXX: Fake it : HSE_REQ_ASYNC_READ_CLIENT */
        return FALSE;
    case 1011: /* HSE_REQ_GET_IMPERSONATION_TOKEN  Added in ISAPI 4.0 */
        return FALSE;
#ifdef HSE_REQ_MAP_URL_TO_PATH_EX
    case 1012: /* HSE_REQ_MAP_URL_TO_PATH_EX */
        LPHSE_URL_MAPEX_INFO info = (LPHSE_URL_MAPEX_INFO) lpdwDataType;
                                            MAX_PATH) - info->lpszPath;
        return TRUE;
#endif
    case 1014: /* HSE_REQ_ABORTIVE_CLOSE */
        return FALSE;
    case 1015: /* HSE_REQ_GET_CERT_INFO_EX  Added in ISAPI 4.0 */
        return FALSE;
#ifdef HSE_REQ_SEND_RESPONSE_HEADER_EX
    case 1016: /* HSE_REQ_SEND_RESPONSE_HEADER_EX  Added in ISAPI 4.0 */
        LPHSE_SEND_HEADER_EX_INFO shi
                                  = (LPHSE_SEND_HEADER_EX_INFO) lpvBuffer;
        /* XXX: ignore shi->fKeepConn?  We shouldn't need the advise */
        /* r->connection->keepalive = shi->fKeepConn; */
            return FALSE;
        return TRUE;

#endif
    case 1017: /* HSE_REQ_CLOSE_CONNECTION  Added after ISAPI 4.0 */
        return FALSE;
    case 1018: /* HSE_REQ_IS_CONNECTED  Added after ISAPI 4.0 */
        *((LPBOOL) lpvBuffer) = (r->connection->aborted == 0);
        return TRUE;
    case 1020: /* HSE_REQ_EXTENSION_TRIGGER  Added after ISAPI 4.0 */
        return FALSE;
        return FALSE;
    DWORD read;
    if(strcmp(r->handler, "isapi-isa"))

    if (!(ap_allow_options(r) & OPT_EXECCGI))

    if (r->finfo.filetype == APR_NOFILE)

    if (r->finfo.filetype != APR_REG)

        r->path_info && *r->path_info)
    {
    /* Load the isapi extention without caching (pass r value) 
     * but note that we will recover an existing cached module.
     */
    if (isapi_load(loaded.pool, r, r->filename, &isa) != APR_SUCCESS)
        

    cid->ecb = apr_pcalloc(r->pool, sizeof(struct _EXTENSION_CONTROL_BLOCK));
    cid->ecb->ConnID = (HCONN)cid;
        isapi_unload(isa, FALSE);
         * TODO: add the httpd.conf option for read_ahead_buflen.
            if (cid->ecb->cbTotalBytes > (DWORD)cid->dconf.read_ahead_buflen)
            isapi_unload(isa, FALSE);
             * the ISA's "advice".
        case HSE_STATUS_PENDING:    
            
            if (!isa->fakeasync) {
                if (cid->dconf.log_unsupported)
                {
                     ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, r,
                                   "ISAPI: %s asynch I/O request refused", 
                                   r->filename);
                     cid->r->status = HTTP_INTERNAL_SERVER_ERROR;
                }
            }
            else {
                cid->complete = CreateEvent(NULL, FALSE, FALSE, NULL);
    /* All done with the DLL... get rid of it... */
    isapi_unload(isa, FALSE);
    
    loaded.modules = apr_array_make(loaded.pool, 20, sizeof(isapi_loaded*));
    if (!loaded.modules) {
	ap_log_error(APLOG_MARK, APLOG_ERR, APR_EGENERAL, NULL,
                     "ISAPI: could not create the isapi cache");
    return OK;
}

static int compare_loaded(const void *av, const void *bv)
{
    const isapi_loaded **a = av;
    const isapi_loaded **b = bv;

    return strcmp((*a)->filename, (*b)->filename);
}

static int isapi_post_config(apr_pool_t *p, apr_pool_t *plog,
                             apr_pool_t *ptemp, server_rec *s)
{
    isapi_loaded **elts = (isapi_loaded **)loaded.modules->elts;
    int nelts = loaded.modules->nelts;

    /* sort the elements of the main_server, by filename */
    qsort(elts, nelts, sizeof(isapi_loaded*), compare_loaded);

    ap_hook_post_config(isapi_post_config, NULL, NULL, APR_HOOK_MIDDLE);
        ap_rvputs(r, ap_get_server_name(r), " (", r->connection->local_ip,
        cache_run_remove_url(type, url);
    cache_request_rec *cache = (cache_request_rec *) ap_get_module_config(r->request_config, 
                                                                          &cache_module);
        switch (rv = cache_run_create_entity(h, type, url, size)) {
    cache_request_rec *cache = (cache_request_rec *) ap_get_module_config(r->request_config, 
                                                                          &cache_module);

        switch ((rv = cache_run_open_entity(cache->handle, type, url))) {
apr_status_t cache_write_entity_headers(cache_handle_t *h, request_rec *r, cache_info *info,
                                        apr_table_t *headers)
    h->write_headers(h, r, info, headers);
apr_status_t cache_read_entity_headers(cache_handle_t *h, request_rec *r, 
                                       apr_table_t **headers)
    *headers = apr_table_make(r->pool, 15);

    h->read_headers(h, r, *headers);
                                      char *url, apr_size_t len),(h,type,url,len),DECLINED)
                                      char *url),(h,type,url),DECLINED)
                                    (const char *type, char *url),(type,url),OK,DECLINED)
#if 0
/* BillS doesn't think these should be hooks.
 * All functions which accept a cache_handle * argument should use
 * function pointers in the cache_handle. Leave them here for now as 
 * points for discussion...
 */

APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(cache, CACHE, int, remove_entity, 
                                     (cache_handle *h),(h),DECLINED)

APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(cache, CACHE, int, read_entity_headers, 
                                     (cache_handle *h, request_rec *r,
                                      apr_table_t **headers),
                                      (h,info,headers_in,headers_out),DECLINED)
APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(cache, CACHE, int, read_entity_body, 
                                     (cache_handle *h,
                                      apr_bucket_brigade *out),(h,out),DECLINED)
APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(cache, CACHE, int, write_entity_headers, 
                                     (cache_handle *h, cache_info *info,
                                      apr_table_t *headers_in, 
                                      apr_table_t *headers_out),
                                      (h,info,headers_in,headers_out),DECLINED)
APR_IMPLEMENT_EXTERNAL_HOOK_RUN_FIRST(cache, CACHE, int, write_entity_body, 
                                     (cache_handle *h,
                                      apr_bucket_brigade *in),(h,in),DECLINED)
#endif
	return 1;
const char *ap_cache_get_cachetype(request_rec *r, cache_server_conf *conf, const char *url)
	struct cache_enable *ent = (struct cache_enable *) conf->cacheenable->elts;
	const char *thisurl = ent[i].url;
	const char *thistype = ent[i].type;
	if ((thisurl) && !strncasecmp(thisurl, url, strlen(thisurl))) {
	    if (!type) {
		type = thistype;
	    }
	    else {
		type = apr_pstrcat(r->pool, type, ",", thistype, NULL);
	    }
	}
	struct cache_disable *ent = (struct cache_disable *) conf->cachedisable->elts;
	const char *thisurl = ent[i].url;
	if ((thisurl) && !strncasecmp(thisurl, url, strlen(thisurl))) {
	    type = NULL;
	}
	p = strchr((char *) list, ',');
	if (p != NULL) {
	    i = p - list;
	    do
		p++;
	    while (ap_isspace(*p));
	}
	else
	    i = strlen(list);

	while (i > 0 && ap_isspace(list[i - 1]))
	    i--;
	if (i == len && strncasecmp(list, key, len) == 0) {
	    if (val) {
		p = strchr((char *) list, ',');
		while (ap_isspace(*list)) {
		    list++;
		}
		if ('=' == list[0])
		    list++;
		while (ap_isspace(*list)) {
		    list++;
		}
		strncpy(valbuf, list, MIN(p-list, sizeof(valbuf)-1));
		*val = valbuf;
	    }
	    return 1;
	}
	list = p;
	i = s - list;
	do
	    s++;
	while (apr_isspace(*s));
	i = strlen(list);
	i--;
	return apr_pstrndup(p, list, i);
	return NULL;
int ap_url_cache_handler(request_rec *r);

    cache_server_conf *conf = (cache_server_conf *) ap_get_module_config(r->server->module_config, 
                                                                         &cache_module);
    cache = (cache_request_rec *) ap_get_module_config(r->request_config, &cache_module);
                         "cache: fresh cache - add cache_out filter and handle request");
                             "cache: error returned while trying to return %s cached data", cache->type);
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
                             "cache: conditional - add cache_in filter and DECLINE");
                    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
                                 "cache: nonconditional - fudge conditional by etag");
                    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
                                 "cache: nonconditional - fudge conditional by lastmod");
                    apr_table_set(r->headers_in, "If-Modified-Since", info->lastmods);
                    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
                                 "cache: nonconditional - no cached etag/lastmods - add cache_in and DECLINE");
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
                             "cache: nonconditional - add cache_conditional and DECLINE");
                ap_add_output_filter("CACHE_CONDITIONAL", NULL, r, r->connection);
        ap_log_error(APLOG_MARK, APLOG_ERR, rv, r->server,
                     "cache: error returned while checking for cached file by %s cache", cache->type);
int ap_cache_out_filter(ap_filter_t *f, apr_bucket_brigade *bb);

    apr_table_t *headers;
    cache_request_rec *cache = (cache_request_rec *) ap_get_module_config(r->request_config, 
                                                                          &cache_module);
		 "cache: running CACHE_OUT filter");
    cache_read_entity_headers(cache->handle, r, &headers);
    r->headers_out = headers;
int ap_cache_conditional_filter(ap_filter_t *f, apr_bucket_brigade *in);
int ap_cache_in_filter(ap_filter_t *f, apr_bucket_brigade *in);
    /* have we already run the cachability check and set up the cached file handle? */
         r->status != HTTP_MOVED_PERMANENTLY && r->status != HTTP_NOT_MODIFIED) ||
    /* 200 OK response from HTTP/1.0 and up without a Last-Modified header/Etag */
        (r->status == HTTP_OK && lastmods == NULL && etag == NULL) ||
        else
            size = -1;
    if (info->date == APR_DATE_BAD) {	/* No, or bad date */
        /* add one; N.B. use the time _now_ rather than when we were checking the cache */
	/* if its in the future, then replace by date */
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, 0, r->server,
                     "cache: Last modified is in the future, replacing with now");
    cache_write_entity_headers(cache->handle, r, info, r->headers_out);
    ps->cacheon = (overrides->cacheon_set == 0) ? base->cacheon : overrides->cacheon;
    ps->cachedisable = ap_append_arrays(p, base->cachedisable, overrides->cachedisable);
    ps->cacheenable = ap_append_arrays(p, base->cacheenable, overrides->cacheenable);
    ps->complete = (overrides->complete_set == 0) ? base->complete : overrides->complete;
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, &cache_module);
*add_cache_enable(cmd_parms *parms, void *dummy, const char *type, const char *url)
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, &cache_module);
    cache_server_conf *conf = ap_get_module_config(parms->server->module_config, &cache_module);
    ap_register_output_filter("CACHE_IN", ap_cache_in_filter, AP_FTYPE_CONTENT);
    ap_register_output_filter("CACHE_OUT", ap_cache_out_filter, AP_FTYPE_CONTENT);
    ap_register_output_filter("CACHE_CONDITIONAL", ap_cache_conditional_filter, AP_FTYPE_CONTENT);
    NULL,			/* create per-directory config structure */
    NULL,			/* merge per-directory config structures */
    create_cache_config,	/* create per-server config structure */
    merge_cache_config,		/* merge per-server config structures */
    cache_cmds,			/* command apr_table_t */
    apr_time_t defex;			/* default time to keep cached file in msecs */
    double factor;			/* factor for estimating expires date */
    int complete;			/* Force cache completion after this point */
    const char *lastmods;	/* last modified of cache entity */
    int (*write_headers)(cache_handle_t *h, request_rec *r, cache_info *i, apr_table_t *headers);
    int (*read_headers) (cache_handle_t *h, request_rec *r, apr_table_t *headers);
apr_status_t cache_write_entity_headers(cache_handle_t *h, request_rec *r, cache_info *info, 
                                        apr_table_t *headers);
apr_status_t cache_read_entity_headers(cache_handle_t *h, request_rec *r, apr_table_t **headers);
                           char *url, apr_size_t len))
                           char *url))
                          (const char *type, char *url))

#if 0
APR_DECLARE_EXTERNAL_HOOK(cache, CACHE, int, remove_entity, 
                          (cache_handle *h))
APR_DECLARE_EXTERNAL_HOOK(cache, CACHE, int, read_entity_headers, 
                          (cache_handle *h, cache_info **info,
                           apr_table_t **headers))
APR_DECLARE_EXTERNAL_HOOK(cache, CACHE, int, read_entity_body, 
                          (cache_handle *h,
                           apr_bucket_brigade *out))
APR_DECLARE_EXTERNAL_HOOK(cache, CACHE, int, write_entity_headers, 
                          (cache_handle *h, cache_info *info,
                           apr_table_t *headers))
APR_DECLARE_EXTERNAL_HOOK(cache, CACHE, int, write_entity_body, 
                          (cache_handle *h,
                           apr_bucket_brigade *in))
#endif
#define MAX_CACHE 5000
    apr_ssize_t num_headers;
    cache_header_tbl_t *tbl;
static int write_headers(cache_handle_t *h, request_rec *r, cache_info *i,
                         apr_table_t *headers);
static int read_headers(cache_handle_t *h, request_rec *r, apr_table_t *headers);

    if (mobj->num_headers) {
#if 0
    sconf->maxexpire = DEFAULT_CACHE_MAXEXPIRE;
    sconf->defaultexpire = DEFAULT_CACHE_EXPIRE;
#endif
static int create_entity(cache_handle_t *h, const char *type, char *key, apr_size_t len) 
    if (len < 0 || len > MAX_CACHE) {
    obj->vobj = mobj;    /* Reference the mem_cache_object_t out of cache_object_t */
    tmp_obj = (cache_object_t *) apr_hash_get(sconf->cacheht, key, APR_HASH_KEY_STRING);
static int open_entity(cache_handle_t *h, const char *type, char *key) 
    obj = (cache_object_t *) apr_hash_get(sconf->cacheht, key, APR_HASH_KEY_STRING);
static int remove_url(const char *type, char *key) 
    obj = (cache_object_t *) apr_hash_get(sconf->cacheht, key, APR_HASH_KEY_STRING);
static int read_headers(cache_handle_t *h, request_rec *r, apr_table_t *headers) 
    int i;
    for (i = 0; i < mobj->num_headers; ++i) {
        apr_table_setn(headers, mobj->tbl[i].hdr, mobj->tbl[i].val);
    } 
    return OK;
static int write_headers(cache_handle_t *h, request_rec *r, cache_info *info, apr_table_t *headers)
    apr_table_entry_t *elts = (apr_table_entry_t *) headers->a.elts;
    apr_ssize_t i;
    apr_size_t len = 0;
    apr_size_t idx = 0;
    char *buf;
    mobj->tbl = malloc(sizeof(cache_header_tbl_t) * headers->a.nelts);
    if (NULL == mobj->tbl) {
        /* cleanup_cache_obj(h->cache_obj); */
        return DECLINED;
    for (i = 0; i < headers->a.nelts; ++i) {
        len += strlen(elts[i].key);
        len += strlen(elts[i].val);
        len += 2;        /* Extra space for NULL string terminator for key and val */
    /* Transfer the headers into a contiguous memory block */
    buf = malloc(len);
    if (!buf) {
        free(mobj->tbl);
        mobj->tbl = NULL;
        /* cleanup_cache_obj(h->cache_obj); */
        return DECLINED;
    }
    mobj->num_headers = headers->a.nelts;
    for (i = 0; i < mobj->num_headers; ++i) {
        mobj->tbl[i].hdr = &buf[idx];
        len = strlen(elts[i].key) + 1;              /* Include NULL terminator */
        strncpy(&buf[idx], elts[i].key, len);
        idx+=len;

        mobj->tbl[i].val = &buf[idx];
        len = strlen(elts[i].val) + 1;
        strncpy(&buf[idx], elts[i].val, len);
        idx+=len;

#if 0
static const char
*set_cache_factor(cmd_parms *parms, void *dummy, char *arg)
    double val;

    if (sscanf(arg, "%lg", &val) != 1)
        return "CacheLastModifiedFactor value must be a float";
    sconf->lmfactor = val;
#endif
#if 0
static const char
*set_cache_maxex(cmd_parms *parms, void *dummy, char *arg)
{
    mem_cache_conf *pc = ap_get_module_config(parms->server->module_config, &mem_cache_module);
    double val;
    if (sscanf(arg, "%lg", &val) != 1)
        return "CacheMaxExpire value must be a float";
    sconf->maxexpire = (apr_time_t) (val * MSEC_ONE_HR);
    return NULL;
}
#endif
#if 0
static const char
*set_cache_defex(cmd_parms *parms, void *dummy, char *arg)
{
    mem_cache_conf *pc = ap_get_module_config(parms->server->module_config, &mem_cache_module);
    double val;
    if (sscanf(arg, "%lg", &val) != 1)
        return "CacheDefaultExpire value must be a float";
    pc->defaultexpire = (apr_time_t) (val * MSEC_ONE_HR);
    return NULL;
}
#endif
    AP_INIT_TAKE1("CacheSizeMem", set_cache_size, NULL, RSRC_CONF,
     "The maximum disk space used by the cache in Kb"),
    char *cp, *cp2;
        else if (is_absolute_uri(r->filename)) {
            /* skip 'scheme:' */
            for (cp = r->filename; *cp != ':' && *cp != '\0'; cp++)
                ;
            /* skip '://' */
            cp += 3;
            /* skip host part */
            for ( ; *cp != '/' && *cp != '\0'; cp++)
                ;
            if (*cp != '\0') {
                if (rulestatus != ACTION_NOESCAPE) {
                    rewritelog(r, 1, "escaping %s for redirect", r->filename);
                    cp2 = ap_escape_uri(r->pool, cp);
                }
                else {
                    cp2 = apr_pstrdup(r->pool, cp);
                }
                *cp = '\0';
                r->filename = apr_pstrcat(r->pool, r->filename, cp2, NULL);
            if (r->args != NULL) {
                char *args;
                if (rulestatus == ACTION_NOESCAPE) {
                    args = r->args;
                }
                else {
                    args = ap_escape_uri(r->pool, r->args);
                }
                                          args, NULL);
        else if (is_absolute_uri(r->filename)) {
                /* skip 'scheme:' */
                for (cp = r->filename; *cp != ':' && *cp != '\0'; cp++)
                    ;
                /* skip '://' */
                cp += 3;

            /* skip 'scheme:' */
            for (cp = r->filename; *cp != ':' && *cp != '\0'; cp++)
                ;
            /* skip '://' */
            cp += 3;
            /* skip host part */
            for ( ; *cp != '/' && *cp != '\0'; cp++)
                ;
            if (*cp != '\0') {
                if (rulestatus != ACTION_NOESCAPE) {
                    rewritelog(r, 1, "[per-dir %s] escaping %s for redirect",
                               dconf->directory, r->filename);
                    cp2 = ap_escape_uri(r->pool, cp);
                }
                else {
                    cp2 = apr_pstrdup(r->pool, cp);
                }
                *cp = '\0';
                r->filename = apr_pstrcat(r->pool, r->filename, cp2, NULL);
            if (r->args != NULL) {
                char *args;
                if (rulestatus == ACTION_NOESCAPE) {
                    args = r->args;
                }
                else {
                    args = ap_escape_uri(r->pool, r->args);
                }
                                          args, NULL);
/*
**
**  return non-zero if the URI is absolute (includes a scheme etc.)
**
*/
static int is_absolute_uri(char *uri)
    int i = strlen(uri);
    if (   (i > 7 && strncasecmp(uri, "http://",   7) == 0)
        || (i > 8 && strncasecmp(uri, "https://",  8) == 0)
        || (i > 9 && strncasecmp(uri, "gopher://", 9) == 0)
        || (i > 6 && strncasecmp(uri, "ftp://",    6) == 0)
        || (i > 5 && strncasecmp(uri, "ldap:",     5) == 0)
        || (i > 5 && strncasecmp(uri, "news:",     5) == 0)
        || (i > 7 && strncasecmp(uri, "mailto:",   7) == 0) ) {
        return 1;
    else {
        return 0;
static int   is_absolute_uri(char *uri);
typedef struct {
    const char *name;                 /* matching module name */
    const char *info;                 /* additional info */
typedef struct {
static void *create_info_config(apr_pool_t *p, server_rec *s)
    info_svr_conf *conf = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
static void *merge_info_config(apr_pool_t *p, void *basev, void *overridesv)
    info_svr_conf *new = (info_svr_conf *) apr_pcalloc(p, sizeof(info_svr_conf));
    new->more_info = apr_array_append(p, overrides->more_info, base->more_info);
static void mod_info_indent(request_rec * r, int nest, const char* thisfn, int linenum)
    const char *prevfn = ap_get_module_config(r->request_config, &info_module);
    if (thisfn == NULL) thisfn = "*UNKNOWN*";
        ap_rprintf(r, "<dd><tt><strong>In file: %s</strong></tt></dd>\n", thisfn);
    if (linenum > 0) sprintf(buf, "%d", linenum);
    else             buf[0] = '\0';
    for (i = strlen(buf); i < 4; ++i) ap_rputs("&nbsp;", r);
    for (i = 1; i <= nest; ++i) ap_rputs("&nbsp;&nbsp;", r);
static void mod_info_show_cmd(request_rec * r, const ap_directive_t * dir,
                                int nest)
        ap_escape_html(r->pool, dir->directive),
        ap_escape_html(r->pool, dir->args));
static void mod_info_show_open(request_rec * r, const ap_directive_t * dir,
                                int nest)
    ap_rprintf(r, "%s %s</tt></dd>\n", 
                  ap_escape_html(r->pool, dir->directive),
                  ap_escape_html(r->pool, dir->args));
static void mod_info_show_close(request_rec * r, const ap_directive_t * dir,
            }
            else {
        ap_rprintf(r, "/%s</tt></dd>",
                   ap_escape_html(r->pool, dirname));
            }
    
static int mod_info_has_cmd(const command_rec * cmds, ap_directive_t * dir)
    const command_rec * cmd;
    if (cmds == NULL) return 1;
        if (strcasecmp(cmd->name, dir->directive) == 0) return 1;
	}
static void mod_info_show_parents(request_rec * r, ap_directive_t * node, 
                                    int from, int to) {
    if (from < to) mod_info_show_parents(r, node->parent, from, to - 1);
static int mod_info_module_cmds(request_rec * r, const command_rec * cmds,
    ap_directive_t * dir;
    if (level == 0) ap_set_module_config(r->request_config, &info_module, NULL);
                                                 shown, level + 1)) {
        } else if (mod_info_has_cmd(cmds, dir)) {
    }
typedef struct { /*XXX: should get something from apr_hooks.h instead */
    void (*pFunc)(void); /* just to get the right size */
    const char * const *aszPredecessors;
    const char * const *aszSuccessors;
typedef apr_array_header_t * ( 
__stdcall 
* hook_get_t)(void);
typedef struct {
static int module_find_hook(module *modp,
                            hook_get_t hook_get)
    elts = (hook_struct_t *)hooks->elts;
    for (i=0; i< hooks->nelts; i++) {
                               hook_lookup_t *lookup,
                               int *comma)
    int i, comma=0;
    for (i=0; request_hooks[i].name; i++) {
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
	return DECLINED;
	     "<html><head><title>Server Information</title></head>\n", r);
    ap_rputs("<body><h1 align=\"center\">Apache Server Information</h1>\n", r);
            ap_rputs("<dl><dt><tt><a href=\"#server\">Server Settings</a>, ", r);
                ap_rprintf(r, "<a href=\"#%s\">%s</a>", modp->name, modp->name);
            ap_rprintf(r, "<dl><dt><a name=\"server\"><strong>Server Version:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                        ap_get_server_version());
            ap_rprintf(r, "<dt><strong>Server Built:</strong> "
                        "<font size=\"+1\"><tt>%s</tt></font></dt>\n",
                        ap_get_server_built());
            ap_rprintf(r, "<dt><strong>API Version:</strong> "
                        "<tt>%d:%d</tt></dt>\n",
                        MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
            ap_rprintf(r, "<dt><strong>Hostname/port:</strong> "
                        "<tt>%s:%u</tt></dt>\n",
                        ap_get_server_name(r), ap_get_server_port(r));
            ap_rprintf(r, "<dt><strong>Timeouts:</strong> "
                        "<tt>connection: %d &nbsp;&nbsp; "
                        "keep-alive: %d</tt></dt>",
                        (int)(apr_time_sec(serv->timeout)), 
                        (int)(apr_time_sec(serv->timeout)));
            ap_rprintf(r, "<dt><strong>MPM Name:</strong> <tt>%s</tt></dt>\n", ap_show_mpm());
            ap_rprintf(r, "<dt><strong>MPM Information:</strong> "
		       "<tt>Max Daemons: %d Threaded: %s Forked: %s</tt></dt>\n",
            ap_rprintf(r, "<dt><strong>Server Root:</strong> "
                        "<tt>%s</tt></dt>\n", ap_server_root);
            ap_rprintf(r, "<dt><strong>Config File:</strong> "
		       "<tt>%s</tt></dt>\n", ap_conftree->filename);
        for (modp = ap_top_module; modp; modp = modp->next) {
            if (!r->args || !strcasecmp(modp->name, r->args)) {
                ap_rprintf(r, "<dl><dt><a name=\"%s\"><strong>Module Name:</strong> "
                            "<font size=\"+1\"><tt>%s</tt></font></a></dt>\n",
                            modp->name, modp->name);
                ap_rputs("<dt><strong>Content handlers:</strong> ", r);
                hand = modp->handlers;
                if (hand) {
                    while (hand) {
                        if (hand->content_type) {
                            ap_rprintf(r, " <tt>%s</tt>\n", hand->content_type);
                        }
                        else {
                            break;
                        }
                        hand++;
                        if (hand && hand->content_type) {
                            ap_rputs(",", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                if (module_find_hook(modp, ap_hook_get_handler)) {
                    ap_rputs("<tt> <em>yes</em></tt>", r);
                }
                else {
                    ap_rputs("<tt> <em>none</em></tt>", r);
                }
                ap_rputs("</dt>", r);
                ap_rputs("<dt><strong>Configuration Phase Participation:</strong>\n",
                      r);
                if (modp->create_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Directory Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_dir_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Directory Configs</tt>", r);
                    comma = 1;
                }
                if (modp->create_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Create Server Config</tt>", r);
                    comma = 1;
                }
                if (modp->merge_server_config) {
                    if (comma) {
                        ap_rputs(", ", r);
                    ap_rputs("<tt>Merge Server Configs</tt>", r);
                    comma = 1;
                }
                if (!comma)
                    ap_rputs("<tt> <em>none</em></tt>", r);
                comma = 0;
                ap_rputs("</dt>", r);

                module_request_hook_participate(r, modp);

                cmd = modp->cmds;
                if (cmd) {
                    ap_rputs("<dt><strong>Module Directives:</strong></dt>", r);
                    while (cmd) {
                        if (cmd->name) {
                            ap_rprintf(r, "<dd><tt>%s%s - <i>",
                                ap_escape_html(r->pool, cmd->name),
                                cmd->name[0] == '<' ? "&gt;" : "");
                            if (cmd->errmsg) {
                                ap_rputs(cmd->errmsg, r);
                            ap_rputs("</i></tt></dd>\n", r);
                        }
                        else {
                            break;
                        cmd++;
                    ap_rputs("<dt><strong>Current Configuration:</strong></dt>\n", r);
                    mod_info_module_cmds(r, modp->cmds, ap_conftree, 0, 0);
                }
                else {
                    ap_rputs("<dt><strong>Module Directives:</strong> <tt>none</tt></dt>", r);
                }
                more_info = find_more_info(serv, modp->name);
                if (more_info) {
                    ap_rputs("<dt><strong>Additional Information:</strong>\n</dt><dd>",
                          r);
                    ap_rputs(more_info, r);
                    ap_rputs("</dd>", r);
                }
                ap_rputs("</dl><hr />\n", r);
                if (r->args) {
                    break;
        }
        if (!modp && r->args && strcasecmp(r->args, "server")) {
            ap_rputs("<p><b>No such module</b></p>\n", r);
        }
    ap_rputs(ap_psignature("",r), r);
static const char *add_module_info(cmd_parms *cmd, void *dummy, 
    info_svr_conf *conf = (info_svr_conf *) ap_get_module_config(s->module_config,
                                                              &info_module);
static const command_rec info_cmds[] =
{
static void register_hooks(apr_pool_t *p)
module AP_MODULE_DECLARE_DATA info_module =
{
    cfgMerge(sc, NULL);

                                  SSLSrvConfigRec *sc)
    if (!sc->server->pks->cert_files[0]) {
    if (sc->server->pks->certs[SSL_AIDX_RSA] ||
        sc->server->pks->certs[SSL_AIDX_DSA])
static SSL_CTX *ssl_init_ctx(server_rec *s,
                             apr_pool_t *p,
                             apr_pool_t *ptemp,
                             SSLSrvConfigRec *sc)
    int protocol = sc->server->protocol;
    sc->server->ssl_ctx = ctx;

    return ctx;
                                       SSLSrvConfigRec *sc)
    SSL_CTX *ctx = sc->server->ssl_ctx;
                                   SSLSrvConfigRec *sc)
    SSL_CTX *ctx = sc->server->ssl_ctx;
    if (sc->log_level >= SSL_LOG_INFO) {
                                SSLSrvConfigRec *sc)
    SSL_CTX *ctx = sc->server->ssl_ctx;
    if (sc->server->auth.verify_mode == SSL_CVERIFY_UNSET) {
        sc->server->auth.verify_mode = SSL_CVERIFY_NONE;
    if (sc->server->auth.verify_depth == UNSET) {
        sc->server->auth.verify_depth = 1;
    if (sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE) {
    if ((sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL) ||
        (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA))
    if (sc->server->auth.ca_cert_file || sc->server->auth.ca_cert_path) {
                                           sc->server->auth.ca_cert_file,
                                           sc->server->auth.ca_cert_path))
                                      sc->server->auth.ca_cert_file,
                                      sc->server->auth.ca_cert_path);
    if (sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE) {
                                      SSLSrvConfigRec *sc)
    SSL_CTX *ctx = sc->server->ssl_ctx;
    const char *suite = sc->server->auth.cipher_suite;
                             SSLSrvConfigRec *sc)
    if (!(sc->server->crl_file || sc->server->crl_path)) {
    sc->server->crl =
        SSL_X509_STORE_create((char *)sc->server->crl_file,
                              (char *)sc->server->crl_path);
    if (!sc->server->crl) {
                                    SSLSrvConfigRec *sc)
    const char *chain = sc->server->cert_chain;
    for (i = 0; (i < SSL_AIDX_MAX) && sc->server->pks->cert_files[i]; i++) {
        if (strEQ(sc->server->pks->cert_files[i], chain)) {
    n = SSL_CTX_use_certificate_chain(sc->server->ssl_ctx,
                                  SSLSrvConfigRec *sc,
    if (SSL_CTX_use_certificate(sc->server->ssl_ctx, cert) <= 0) {
    sc->server->pks->certs[idx] = cert;
                                 SSLSrvConfigRec *sc,
    if (SSL_CTX_use_PrivateKey(sc->server->ssl_ctx, pkey) <= 0) {
    if ((pkey_type == EVP_PKEY_DSA) && sc->server->pks->certs[idx]) {
        EVP_PKEY *pubkey = X509_get_pubkey(sc->server->pks->certs[idx]);
    sc->server->pks->keys[idx] = pkey;
                                  SSLSrvConfigRec *sc)
    const char *vhost_id = sc->vhost_id;
    have_rsa = ssl_server_import_cert(s, sc, rsa_id, SSL_AIDX_RSA);
    have_dsa = ssl_server_import_cert(s, sc, dsa_id, SSL_AIDX_DSA);
        ssl_check_public_cert(s, ptemp, sc->server->pks->certs[i], i);
    have_rsa = ssl_server_import_key(s, sc, rsa_id, SSL_AIDX_RSA);
    have_dsa = ssl_server_import_key(s, sc, dsa_id, SSL_AIDX_DSA);
    ssl_init_server_check(s, p, ptemp, sc);
    ssl_init_ctx(s, p, ptemp, sc);
    ssl_init_ctx_session_cache(s, p, ptemp, sc);
    ssl_init_ctx_callbacks(s, p, ptemp, sc);
    ssl_init_ctx_verify(s, p, ptemp, sc);
    ssl_init_ctx_cipher_suite(s, p, ptemp, sc);
    ssl_init_ctx_crl(s, p, ptemp, sc);
    ssl_init_ctx_cert_chain(s, p, ptemp, sc);
    ssl_init_server_certs(s, p, ptemp, sc);
#include "http_main.h"
#include "apr_strings.h"
static void skiplf(BUFF *foo)
{
	char c;
	do
	{
		c = ap_bgetc(foo);
	} while(c != '\n');
}
/*
 * Returns the ftp status code;
 *  or -1 on I/O error, 0 on data error
 */
static int ftp_getrc(BUFF *f)
{
    int len, status;
    char linebuff[100], buff[5];

    len = ap_bgets(linebuff, sizeof linebuff, f);
    if (len == -1)
	return -1;
/* check format */
    if (len < 5 || !apr_isdigit(linebuff[0]) || !apr_isdigit(linebuff[1]) ||
	!apr_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
	status = 0;
    else
	status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';

    if (linebuff[len - 1] != '\n') {
		skiplf(f);
    }

/* skip continuation lines */
    if (linebuff[3] == '-') {
	memcpy(buff, linebuff, 3);
	buff[3] = ' ';
	do {
	    len = ap_bgets(linebuff, sizeof linebuff, f);
	    if (len == -1)
		return -1;
	    if (linebuff[len - 1] != '\n') {
			skiplf(f);
	    }
	} while (memcmp(linebuff, buff, 4) != 0);
    }

    return status;
}
static int ftp_getrc_msg(BUFF *f, char *msgbuf, int msglen)
    char linebuff[100], buff[5];
    len = ap_bgets(linebuff, sizeof linebuff, f);
    if (len == -1)
    if (len < 5 || !apr_isdigit(linebuff[0]) || !apr_isdigit(linebuff[1]) ||
	!apr_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
	status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';
    mb = apr_cpystrn(mb, linebuff+4, me - mb);
    if (linebuff[len - 1] != '\n')
		skiplf(f);
    if (linebuff[3] == '-') {
	memcpy(buff, linebuff, 3);
	    len = ap_bgets(linebuff, sizeof linebuff, f);
	    if (linebuff[len - 1] != '\n') {
			skiplf(f);
	    }
	    mb = apr_cpystrn(mb, linebuff+4, me - mb);
	} while (memcmp(linebuff, buff, 4) != 0);
int ap_proxy_ftp_handler(request_rec *r, ap_cache_el *c, char *url)
    char *host, *path, *strp, *parms;
    apr_socket_t *sock, *dsock, *inc;
    int port, i, j, len, rc, nocache = 0;
    apr_socket_t *csd;
    struct in_addr destaddr;
    apr_table_t *resp_hdrs;
    BUFF *f;
    BUFF *data = NULL;
    apr_file_t *cachefp = NULL;
    apr_pool_t *p = r->pool;
    const long int zero = 0L;
    struct noproxy_entry *npent = (struct noproxy_entry *) conf->noproxies->elts;
    struct nocache_entry *ncent = (struct nocache_entry *) conf->nocaches->elts;
    apr_sockaddr_t *localsa;

/* stuff for PASV mode */
    unsigned int presult, h0, h1, h2, h3, p0, p1;
    unsigned short pport;
    int pasvmode = 0;
    char pasv[64];
    char *pstr, dates[AP_RFC822_DATE_LEN];
    char *npaddr;
    apr_port_t npport;
	
/* stuff for responses */
    char resp[MAX_STRING_LEN];
    char *size = NULL;
/* we only support GET and HEAD */
/* We break the URL into host, port, path-search */

    host = r->parsed_uri.hostname;
    port = (r->parsed_uri.port != 0)
	    ? r->parsed_uri.port
	    : ap_default_port_for_request(r);
	nocache = 1;	/* This resource only accessible with username/password */
	nocache = 1;	/* This resource only accessible with username/password */
/* check if ProxyBlock directive on this host */
    destaddr.s_addr = ap_inet_addr(host);
    for (i = 0; i < conf->noproxies->nelts; i++) {
	if ((npent[i].name != NULL && ap_strstr_c(host, npent[i].name) != NULL)
	    || destaddr.s_addr == npent[i].addr.s_addr || npent[i].name[0] == '*')
	    return ap_proxyerror(r, HTTP_FORBIDDEN,
				 "Connect to remote machine blocked");
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                 "FTP: connect to %s:%d", host, port);
    parms = strchr(path, ';');
    if (parms != NULL)
	*(parms++) = '\0';
    if (ap_proxy_doconnect(sock, host, port, r) != APR_SUCCESS) {
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_pstrcat(r->pool,
				"Could not connect to remote machine: ",
				host, NULL));
    f = ap_bcreate(p, B_RDWR);
    ap_bpush_socket(f, sock);
/* shouldn't we implement telnet control options here? */
#if APR_CHARSET_EBCDIC
    ap_bsetflag(f, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 1);
#endif /*APR_CHARSET_EBCDIC*/
/* possible results: */
    /* 120 Service ready in nnn minutes. */
    /* 220 Service ready for new user. */
    /* 421 Service not available, closing control connection. */
    i = ftp_getrc_msg(f, resp, sizeof resp);
				 "FTP: returned status %d", i);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, resp);
    ap_bvputs(f, "USER ", user, CRLF, NULL);
    ap_bflush(f);			/* capture any errors */
/* possible results; 230, 331, 332, 421, 500, 501, 530 */
/* states: 1 - error, 2 - success; 3 - send password, 4,5 fail */
    /* 230 User logged in, proceed. */
    /* 331 User name okay, need password. */
    /* 332 Need account for login. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /*     (This may include errors such as command line too long.) */
    /* 501 Syntax error in parameters or arguments. */
    /* 530 Not logged in. */
    i = ftp_getrc(f);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
			     "Error reading from remote server");
	ap_bvputs(f, "PASS ", password, CRLF, NULL);
	ap_bflush(f);
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
/* possible results 202, 230, 332, 421, 500, 501, 503, 530 */
    /* 230 User logged in, proceed. */
    /* 332 Need account for login. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 503 Bad sequence of commands. */
    /* 530 Not logged in. */
	i = ftp_getrc(f);
				 "Need account for login");
/* set the directory (walk directory component by component):
 * this is what we must do if we don't know the OS type of the remote
 * machine
 */
	ap_bvputs(f, "CWD ", path, CRLF, NULL);
	ap_bflush(f);
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
/* responses: 250, 421, 500, 501, 502, 530, 550 */
    /* 250 Requested file action okay, completed. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 530 Not logged in. */
    /* 550 Requested action not taken. */
	i = ftp_getrc(f);
	    return HTTP_NOT_FOUND;
	    return HTTP_BAD_GATEWAY;
	/* TM - Added CRLF to the end of TYPE I, otherwise it hangs the
	   connection */
	ap_bputs("TYPE I" CRLF, f);
	ap_bflush(f);
/* responses: 200, 421, 500, 501, 504, 530 */
    /* 200 Command okay. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 504 Command not implemented for that parameter. */
    /* 530 Not logged in. */
	i = ftp_getrc(f);
	    return HTTP_BAD_GATEWAY;
/* Allow not implemented */
/* try to set up PASV data connection first */
    if ((apr_socket_create(&dsock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
	ap_bclose(f);
    if (conf->recv_buffer_size > 0 && apr_setsocketopt(dsock, APR_SO_RCVBUF,
    ap_bputs("PASV" CRLF, f);
    ap_bflush(f);
/* possible results: 227, 421, 500, 501, 502, 530 */
    /* 227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 530 Not logged in. */
    i = ap_bgets(pasv, sizeof(pasv), f);
    if (i == -1) {
	apr_socket_close(dsock);
	ap_bclose(f);
	return HTTP_INTERNAL_SERVER_ERROR;
	pasv[i - 1] = '\0';
                     "FTP: returned status %d", presult);
	    /* pardon the parens, but it makes gcc happy */
	    destaddr.s_addr = htonl((((((h3 << 8) + h2) << 8) + h1) << 8) + h0);
	    pport = (p1 << 8) + p0;
                         "FTP: contacting host %d.%d.%d.%d:%d",
                         h3, h2, h1, h0, pport);
/* scary */
            if (ap_proxy_doconnect(dsock, inet_ntoa(destaddr), pport, r) == APR_SUCCESS) {
		return ap_proxyerror(r, HTTP_BAD_GATEWAY,
		    apr_pstrcat(r->pool,
		    "Could not connect to remote machine: ",
		    inet_ntoa(destaddr), NULL));
	    }
	    apr_socket_close(dsock);	/* and try the regular way */
    if (!pasvmode) {		/* set up data connection */
	if ((apr_socket_create(&dsock, APR_INET, SOCK_STREAM, r->pool)) != APR_SUCCESS) {
	    ap_bclose(f);
        apr_socket_addr_get(&localsa, APR_LOCAL, sock);
        apr_sockaddr_port_get(&npport, localsa);
        apr_sockaddr_ip_get(&npaddr, localsa);
	if (apr_setsocketopt(dsock, APR_SO_REUSEADDR, one) != APR_SUCCESS) {
	    apr_socket_close(dsock);
	    ap_bclose(f);
        if (apr_sockaddr_info_get(&localsa, npaddr, APR_INET, npport, 0, r->pool) 
            != APR_SUCCESS) {
            ap_bclose(f);
	if (apr_bind(dsock, localsa) != APR_SUCCESS) {
	    apr_snprintf(buff, sizeof(buff), "%s:%d", npaddr, npport);
	    ap_bclose(f);
	    apr_socket_close(dsock);
	apr_listen(dsock, 2);	/* only need a short queue */
/* set request; "path" holds last path component */
	ap_bvputs(f, "SIZE ", path, CRLF, NULL);
	ap_bflush(f);
	i = ftp_getrc_msg(f, resp, sizeof resp);
                     "FTP: returned status %d with response %s", i, resp);
		ap_bvputs(f, "CWD ", path, CRLF, NULL);
		ap_bflush(f);
		i = ftp_getrc(f);
		    return HTTP_NOT_FOUND;
		    return HTTP_BAD_GATEWAY;
		for (j = 0; j < sizeof resp && apr_isdigit(resp[j]); j++)
			;
		resp[j] = '\0';
		if (resp[0] != '\0')
		    size = apr_pstrdup(p, resp);
    ap_bvputs(f, "PWD", CRLF, NULL);
    ap_bflush(f);
/* responses: 257, 500, 501, 502, 421, 550 */
    /* 257 "<directory-name>" <commentary> */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 550 Requested action not taken. */
    i = ftp_getrc_msg(f, resp, sizeof resp);
	return HTTP_NOT_FOUND;
	const char *dirp = resp;
			ap_bvputs(f, "LIST ", path, CRLF, NULL);
			ap_bputs("LIST -lag" CRLF, f);
					 "FTP: LIST %s", (len == 0 ? "" : path));
		ap_bvputs(f, "RETR ", path, CRLF, NULL);
    ap_bflush(f);
/* RETR: 110, 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 530, 550
   NLST: 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 502, 530 */
    /* 110 Restart marker reply. */
    /* 125 Data connection already open; transfer starting. */
    /* 150 File status okay; about to open data connection. */
    /* 226 Closing data connection. */
    /* 250 Requested file action okay, completed. */
    /* 421 Service not available, closing control connection. */
    /* 425 Can't open data connection. */
    /* 426 Connection closed; transfer aborted. */
    /* 450 Requested file action not taken. */
    /* 451 Requested action aborted. Local error in processing. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 530 Not logged in. */
    /* 550 Requested action not taken. */
    rc = ftp_getrc(f);
	ap_bvputs(f, "CWD ", path, CRLF, NULL);
	ap_bflush(f);
	rc = ftp_getrc(f);
	    return HTTP_NOT_FOUND;
	    return HTTP_BAD_GATEWAY;
	ap_bvputs(f, "PWD", CRLF, NULL);
	ap_bflush(f);
	i = ftp_getrc_msg(f, resp, sizeof resp);
	    return HTTP_NOT_FOUND;
	    const char *dirp = resp;
	ap_bputs("LIST -lag" CRLF, f);
	ap_bflush(f);
	rc = ftp_getrc(f);
    if (rc != 125 && rc != 150 && rc != 226 && rc != 250)
	return HTTP_BAD_GATEWAY;
    resp_hdrs = ap_make_table(p, 2);
	
    apr_table_setn(resp_hdrs, "Date", dates);
    apr_table_setn(resp_hdrs, "Server", ap_get_server_version());
		apr_table_setn(resp_hdrs, "Content-Type", "text/html");
	    apr_table_setn(resp_hdrs, "Content-Type", r->content_type);
		ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
		 "FTP: Content-Type set to %s", r->content_type);
	    apr_table_setn(resp_hdrs, "Content-Type", ap_default_type(r));
	    apr_table_setn(resp_hdrs, "Content-Length", size);
	apr_table_setn(resp_hdrs, "Content-Encoding", r->content_encoding);
    }
	ap_cache_el_header_merge(c, resp_hdrs);
	
/* check if NoCache directive on this host */
    for (i = 0; i < conf->nocaches->nelts; i++) {
	if ((ncent[i].name != NULL && ap_strstr_c(host, ncent[i].name) != NULL)
	    || destaddr.s_addr == ncent[i].addr.s_addr || ncent[i].name[0] == '*')
	    nocache = 1;
    }

#if 0
    i = ap_proxy_cache_update(c, resp_hdrs, 0, nocache);

    if (i != DECLINED) {
	ap_pclosesocket(p, dsock);
	ap_bclose(f);
	return i;
#endif

    if(nocache || !ap_proxy_cache_should_cache(r, resp_hdrs, 0))
        ap_proxy_cache_error(&c);
    else
        ap_cache_el_data(c, &cachefp);
    if (!pasvmode) {		/* wait for connection */
            switch(apr_accept(&inc, dsock, r->pool))
                apr_socket_close(dsock);
                ap_bclose(f);
                if (c != NULL) ap_proxy_cache_error(&c);
        data = ap_bcreate(p, B_RDWR);
        ap_bpush_socket(f, csd);
    }
    else {
	data = ap_bcreate(p, B_RDWR);
	ap_bpush_socket(data, dsock);
/* send response */
/* write status line */
    if (!r->assbackwards)
	ap_rvputs(r, "HTTP/1.0 ", r->status_line, CRLF, NULL);
        if (cachefp && apr_file_puts(apr_pstrcat(r->pool, "HTTP/1.0 ",
          r->status_line, CRLF, NULL), cachefp) != APR_SUCCESS) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
		"proxy: error writing CRLF to cache");
	    ap_proxy_cache_error(&c);
            cachefp = NULL;
/* send headers */
    ap_cache_el_header_walk(c, ap_proxy_send_hdr_line, r, NULL);
    if (!r->assbackwards)
	ap_rputs(CRLF, r);
    if (cachefp && apr_file_puts(CRLF, cachefp) == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
	    "proxy: error writing CRLF to cache");
	ap_proxy_cache_error(&c);
        cachefp = NULL;
    }
/* This is done by a filter now, so this can probably be removed cleanly.
    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
*/
/* send body */
	if (parms[0] != 'd') {
	    ap_proxy_send_fb(NULL, data, r, c);
	} else
	    send_dir(data, r, c, cwd);

	if (rc == 125 || rc == 150)
	    rc = ftp_getrc(f);

	/* XXX: we checked for 125||150||226||250 above. This is redundant. */
	if (rc != 226 && rc != 250)
            /* XXX: we no longer log an "error writing to c->tempfile" - should we? */
	    ap_proxy_cache_error(&c);
/* abort the transfer */
	ap_bputs("ABOR" CRLF, f);
	ap_bflush(f);
	if (!pasvmode)
	    ap_bclose(data);
/* responses: 225, 226, 421, 500, 501, 502 */
    /* 225 Data connection open; no transfer in progress. */
    /* 226 Closing data connection. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    i = ftp_getrc(f);
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                 "FTP: returned status %d", i);
/* finish */
    ap_bputs("QUIT" CRLF, f);
    ap_bflush(f);
/* responses: 221, 500 */
    /* 221 Service closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    i = ftp_getrc(f);
    if (pasvmode)
	ap_bclose(data);
    ap_bclose(f);

    ap_rflush(r);	/* flush before garbage collection */

    if(c) ap_proxy_cache_update(c);
module AP_MODULE_DECLARE_DATA imap_module;
    icr = ap_get_module_config(r->per_dir_config, &imap_module);
module AP_MODULE_DECLARE_DATA imap_module =
        cl_val = atol(old_cl_val);
 * 20051231.0 (2.3.0-dev)  Added num_blank_lines, pending_header_line, and
 *                         pending_header_size to request_rec
    /** Number of leading blank lines encountered before request header */
    int num_blank_lines;

    /** A buffered header line, used to support header folding while
     *  reading the request */
    char *pending_header_line;

    /** If nonzero, the number of bytes allocated to hold pending_header_line */
    apr_size_t pending_header_size;

static void set_the_request(request_rec *r, char *line)
    apr_socket_t *csd;
    ll = r->the_request = line;
             && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */
    }
    else {
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(r->connection->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->connection->base_server->timeout);

    return;
}

static apr_status_t set_mime_header(request_rec *r, char *line)
{
    char *value, *tmp_field;

    if (r->server->limit_req_fields) {
        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);
        if (mime_headers->nelts >= r->server->limit_req_fields) {
            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields "
                           "exceeds this server's limit.");
            r->status = HTTP_BAD_REQUEST;
            return APR_ENOSPC;
        }
    }
    
    if (!(value = strchr(line, ':'))) { /* Find ':' or    */
        r->status = HTTP_BAD_REQUEST;      /* abort bad request */
        apr_table_setn(r->notes, "error-notes",
                       apr_pstrcat(r->pool,
                                   "Request header field is "
                                   "missing ':' separator.<br />\n"
                                   "<pre>\n",
                                   ap_escape_html(r->pool, line),
                                   "</pre>\n", NULL));
        return APR_EGENERAL;
    }

    tmp_field = value - 1; /* last character of field-name */

    *value++ = '\0'; /* NUL-terminate at colon */

    while (*value == ' ' || *value == '\t') {
        ++value;            /* Skip to start of value   */
    }

    /* Strip LWS after field-name: */
    while (tmp_field > line
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }

    /* Strip LWS after field-value: */
    tmp_field = strchr(value, '\0') - 1;
    while (tmp_field > value
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }
    apr_table_addn(r->headers_in, line, value);
    return APR_SUCCESS;
}

static apr_status_t process_request_line(request_rec *r, char *line,
                                         int skip_first)
{
    if (!skip_first && (r->the_request == NULL)) {
        /* This is the first line of the request */
        if ((line == NULL) || (*line == '\0')) {
            /* We skip empty lines because browsers have to tack a CRLF on to the end
             * of POSTs to support old CERN webservers.
             */
            int max_blank_lines = r->server->limit_req_fields;
            if (max_blank_lines <= 0) {
                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
            }
            r->num_blank_lines++;
            if (r->num_blank_lines < max_blank_lines) {
                return APR_SUCCESS;
            }
        }
        set_the_request(r, line);
    }
    else {
        /* We've already read the first line of the request.  This is either
         * a header field or the blank line terminating the header
         */
        if ((line == NULL) || (*line == '\0')) {
            if (r->pending_header_line != NULL) {
                apr_status_t rv = set_mime_header(r, r->pending_header_line);
                if (rv != APR_SUCCESS) {
                    return rv;
                }
                r->pending_header_line = NULL;
            }
            if (r->status == HTTP_REQUEST_TIME_OUT) {
                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
                r->status = HTTP_OK;
            }
        }
        else {
            if ((*line == ' ') || (*line == '\t')) {
                /* This line is a continuation of the previous one */
                if (r->pending_header_line == NULL) {
                    r->pending_header_line = line;
                    r->pending_header_size = 0;
                }
                else {
                    apr_size_t pending_len = strlen(r->pending_header_line);
                    apr_size_t fold_len = strlen(line);
                    if ((r->server->limit_req_fieldsize > 0)
						&& (pending_len + fold_len >
                               (apr_size_t) r->server->limit_req_fieldsize)) {
                        /* CVE-2004-0942 */
                        r->status = HTTP_BAD_REQUEST;
                        return APR_ENOSPC;
                    }
                    if (pending_len + fold_len + 1 > r->pending_header_size) {
                        /* Allocate a new buffer big enough to hold the
                         * concatenated lines
                         */
                        apr_size_t new_size = r->pending_header_size;
                        char *new_buf;
                        if (new_size == 0) {
                            new_size = pending_len + fold_len + 1;
                        }
                        else {
                            do {
                                new_size *= 2;
                            } while (new_size < pending_len + fold_len + 1);
                        }
                        new_buf = (char *)apr_palloc(r->pool, new_size);
                        memcpy(new_buf, r->pending_header_line, pending_len);
                        r->pending_header_line = new_buf;
                        r->pending_header_size = new_size;
                    }
                    memcpy(r->pending_header_line + pending_len, line,
                           fold_len + 1);
                }
            }
            else {
                /* Set aside this line in case the next line is a continuation
                 */
                if (r->pending_header_line != NULL) {
                    apr_status_t rv = set_mime_header(r, r->pending_header_line);
                    if (rv != APR_SUCCESS) {
                        return rv;
                    }
                }
                r->pending_header_line = line;
                r->pending_header_size = 0;
            }
        }
    }
    return APR_SUCCESS;
        rv = process_request_line(r, field, 1);
        if (rv != APR_SUCCESS) {
            return;
        if ((field == NULL) || (*field == '\0')) {
            return;
static request_rec *init_request(conn_rec *conn)
    
    return r;
}
static request_rec *request_post_read(request_rec *r, conn_rec *conn)
{
    apr_socket_t *csd;
    const char *expect;
    int access_status;
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->server->timeout);

    if (apr_table_get(r->headers_in, "Transfer-Encoding") &&
        apr_table_get(r->headers_in, "Content-Length")) {
        /* 2616 section 4.4, point 3: "if both Transfer-Encoding
         * and Content-Length are received, the latter MUST be
         * ignored"; so unset it here to prevent any confusion
         * later.
         */
        apr_table_unset(r->headers_in, "Content-Length");
static apr_status_t read_partial_request(request_rec *r) {
    apr_bucket_brigade *tmp_bb;
    apr_status_t rv = APR_SUCCESS;

    /* Read and process lines of the request until we
     * encounter a complete request header, an error, or EAGAIN
     */
    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    while (r->status == HTTP_REQUEST_TIME_OUT) {
        char *line = NULL;
        apr_size_t line_length;
        apr_size_t length_limit;
        int first_line = (r->the_request == NULL);
        if (first_line) {
            length_limit = r->server->limit_req_line;
        }
        else {
            if (r->assbackwards) {
                r->status = HTTP_OK;
                break;
            }
            length_limit = r->server->limit_req_fieldsize;
        }
        /* TODO: use a nonblocking call in place of ap_rgetline */
        rv = ap_rgetline(&line, length_limit + 2,
                         &line_length, r, 0, tmp_bb);
        if (rv == APR_SUCCESS) {
            rv = process_request_line(r, line, 0);
        }
        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();
            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                if (first_line) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: URI too long (longer than %d)",
                                  r->server->limit_req_line);
                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                    r->proto_num = HTTP_VERSION(1,0);
                    r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
                }
                else {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: header line too long "
                                  "(longer than %d)",
                                  r->server->limit_req_fieldsize);
                    r->status = HTTP_BAD_REQUEST;
                }
            }
            break;
        }
    }
    apr_brigade_destroy(tmp_bb);
    return rv;
}

request_rec *ap_read_request(conn_rec *conn)
{
    request_rec *r;
    apr_status_t rv;

    r = init_request(conn);

    rv = read_partial_request(r);
    /* TODO poll if EAGAIN */
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return NULL;
    }

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers! Have to dink things just to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "client sent invalid HTTP/0.9 request: HEAD %s",
                      r->uri);
        r->header_only = 0;
        r->status = HTTP_BAD_REQUEST;
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return r;
    }

    return request_post_read(r, conn);
}

        else if (!strcasecmp(w, "Options")) {
        else if (!strcasecmp(w, "execCGI")) {
        /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        if (action == '-') {
    bracket = apr_pstrcat(p, orig_directive + 1, ">", NULL);
        cmd_name = ap_getword_conf(cmd->pool, &args);
    char *dir = apr_pstrdup(parms->pool, cmd_line);
    conf->gprof_dir = apr_pstrdup(cmd->pool, arg);
    limited_methods = apr_pstrndup(cmd->pool, arg, endp - arg);
        char *method = ap_getword_conf(cmd->pool, &limited_methods);
            methnum = ap_method_register(cmd->pool, method);
    arg = apr_pstrndup(cmd->pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->pool, arg, endp - arg);
    arg = apr_pstrndup(cmd->pool, arg, endp - arg);
        || !ap_is_directory(cmd->pool, ap_server_root)) {
        else if (!strcasecmp(w, "Options")) {
        else if (!strcasecmp(w, "execCGI")) {
        /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        if (action == '-') {
/*    ps->client_socket = NULL;*/
    ps->connection = NULL;
    ap_register_output_filter("PROXY_SEND_DIR", ap_proxy_send_dir_filter, AP_FTYPE_CONNECTION);
    long id;
    const char *connectname;
    apr_port_t connectport;
/*    apr_socket_t *client_socket;*/
    conn_rec *connection;
apr_status_t ap_proxy_send_dir_filter(ap_filter_t *f, apr_bucket_brigade *bb);
apr_status_t ap_proxy_string_read(conn_rec *c, apr_bucket_brigade *bb, char *buff, size_t bufflen);

    if (APR_SUCCESS != (rv = ap_proxy_string_read(c, bb, response, sizeof(response)))) {
	    if (APR_SUCCESS != (rv = ap_proxy_string_read(c, bb, response, sizeof(response)))) {
apr_status_t ap_proxy_send_dir_filter(ap_filter_t *f, apr_bucket_brigade *bb)
    conn_rec *c = f->r->connection;
    apr_pool_t *p = f->r->pool;
    char buf[MAX_STRING_LEN];
    char buf2[MAX_STRING_LEN];
    char *filename;
    int searchidx = 0;
    char *searchptr = NULL;
    int firstfile = 1;
    char *dir, *path, *reldir, *site;
    char *cwd = NULL;
    /* Save "scheme://site" prefix without password */
    site = ap_unparse_uri_components(p, &f->r->parsed_uri, UNP_OMITPASSWORD|UNP_OMITPATHINFO);
    /* ... and path without query args */
    path = ap_unparse_uri_components(p, &f->r->parsed_uri, UNP_OMITSITEPART|UNP_OMITQUERY);
    (void)decodeenc(path);
    /* Copy path, strip (all except the last) trailing slashes */
    path = dir = apr_pstrcat(p, path, "/", NULL);
    while ((n = strlen(path)) > 1 && path[n-1] == '/' && path[n-2] == '/')
	path[n-1] = '\0';
    /* print "ftp://host/" */
    n = apr_snprintf(buf, sizeof(buf), DOCTYPE_HTML_3_2
		"<HTML><HEAD><TITLE>%s%s</TITLE>\n"
		"<BASE HREF=\"%s%s\"></HEAD>\n"
		"<BODY><H2>Directory of "
		"<A HREF=\"/\">%s</A>/",
		site, path, site, path, site);
    e = apr_bucket_pool_create(buf, n, p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    while ((dir = strchr(dir+1, '/')) != NULL)
    {
	*dir = '\0';
	if ((reldir = strrchr(path+1, '/'))==NULL)
	    reldir = path+1;
	else
	    ++reldir;
	/* print "path/" component */
	n = apr_snprintf(buf, sizeof(buf), "<A HREF=\"/%s/\">%s</A>/", path+1, reldir);
	e = apr_bucket_pool_create(buf, n, p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	*dir = '/';
    }
    /* If the caller has determined the current directory, and it differs */
    /* from what the client requested, then show the real name */
    if (cwd == NULL || strncmp (cwd, path, strlen(cwd)) == 0) {
	n = apr_snprintf(buf, sizeof(buf), "</H2>\n<HR><PRE>");
    } else {
	n = apr_snprintf(buf, sizeof(buf), "</H2>\n(%s)\n<HR><PRE>", cwd);
    e = apr_bucket_pool_create(buf, n, p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
    while (!c->aborted) {
	n = ap_getline(buf, sizeof(buf), f->r, 0);
	if (n == -1) {		/* input error */
	if (n == 0) {
	    break;		/* EOF */
	if (buf[0] == 'l' && (filename=strstr(buf, " -> ")) != NULL) {
	    apr_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s %s</A>\n", buf, filename, filename, link_ptr);
	    apr_cpystrn(buf, buf2, sizeof(buf));
	    n = strlen(buf);
	else if (buf[0] == 'd' || buf[0] == '-' || buf[0] == 'l' || apr_isdigit(buf[0])) {
	    if (apr_isdigit(buf[0])) {	/* handle DOS dir */
		searchptr = strchr(buf, '<');
		searchptr = strchr(buf, '>');
	    filename = strrchr(buf, ' ');
		searchidx = filename - buf;
	    else if (searchidx != 0 && buf[searchidx] != 0) {
		buf[searchidx - 1] = 0;
		filename = &buf[searchidx];
	    if (!strcmp(filename, ".") || !strcmp(filename, "..") || buf[0] == 'd') {
		apr_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s/\">%s</A>\n",
		    buf, filename, filename);
		apr_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s</A>\n", buf, filename, filename);
	    apr_cpystrn(buf, buf2, sizeof(buf));
	    n = strlen(buf);
	e = apr_bucket_pool_create(buf, n, p);
	APR_BRIGADE_INSERT_TAIL(bb, e);
	APR_BRIGADE_INSERT_TAIL(bb, e);
    n = apr_snprintf(buf, sizeof(buf), "</PRE><HR>\n%s</BODY></HTML>\n", ap_psignature("", f->r));
    e = apr_bucket_pool_create(buf, n, p);
    APR_BRIGADE_INSERT_TAIL(bb, e);
    e = apr_bucket_eos_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
/* probably not necessary */
/*    e = apr_bucket_flush_create();
    APR_BRIGADE_INSERT_TAIL(bb, e);
*/
    char *cwd = NULL;
    if ((conf->id == r->connection->id) && conf->connection) {
	apr_socket_close(conf->connection->client_socket);
	conf->connection = NULL;
    conf->id = r->connection->id;
    /* allocate this out of the connection pool - the check on r->connection->id makes
     * sure that this string does not get accessed past the connection lifetime */
    conf->connectname = apr_pstrdup(r->connection->pool, connectname);
    conf->connectport = connectport;
		 "proxy: FTP: initial connect returned status %d", i);
                 "proxy: FTP: returned status %d", i);
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                     "proxy: FTP: returned status %d [%s]", i, buffer);
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                     "proxy: FTP: returned status %d", i);
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
		 "proxy: FTP: returned status %d", i);
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
		 "proxy: FTP: returned status %d", i);
/* FIXME: Only supports IPV4 */
        apr_socket_addr_get(&local_addr, APR_LOCAL, local_sock);
        if (apr_sockaddr_info_get(&local_addr, local_ip, APR_INET,
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                             "proxy: FTP: returned status %d", i);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
				 "proxy: FTP: PWD returned status %d", i);
	cwd = ap_getword_conf(r->pool, &dirp);
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                 "proxy: FTP: returned status %d", rc);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
				 "proxy: FTP: returned status %d", rc);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
				 "proxy: FTP: PWD returned status %d", i);
	    cwd = ap_getword_conf(r->pool, &dirp);
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
				 "proxy: FTP: returned status %d", rc);
    if (parms[0] == 'd')
		apr_table_setn(r->headers_out, "Content-Type", "text/plain");
		ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
		 "proxy: FTP: Content-Encoding set to %s", r->content_encoding);
/* XXX temporary end here while testing */
/*return HTTP_NOT_IMPLEMENTED;*/
#ifdef FTP_FILTER
   if (parms[0] == 'd') {
   }
#endif
		     "proxy: FTP end body send");

	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
		     "proxy: FTP: returned status %d", i);
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, NULL,
                 "proxy: FTP: QUIT: status %d", i);
    int i, len, backasswards, close=0, failed=0, new=0;
    if (APR_SUCCESS != (rv = ap_proxy_string_read(origin, bb, buffer, sizeof(buffer)))) {
apr_status_t ap_proxy_string_read(conn_rec *c, apr_bucket_brigade *bb, char *buff, size_t bufflen)
        ap_rvputs(r, ap_get_server_name(r), " (", r->connection->local_ip,
                site, basedir, ap_escape_html(p, path),
                site, str);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type("text/xml", r);
    ap_rset_content_type(apr_pstrdup(r->pool, info->content_type), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html;charset=utf-8", r);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html", r);
                    ap_rset_content_type("text/plain", r);
    ap_rset_content_type("message/http", r);
AP_DECLARE(void) ap_rset_content_type(const char *ct, request_rec *r)
        ap_rset_content_type("text/html; charset=iso-8859-1", r);
            ap_rset_content_type(apr_pstrcat(r->pool, "multipart",
                                             use_range_x(r) ? "/x-" : "/",
                                             "byteranges; boundary=",
                                             r->boundary, NULL), r);
    ap_rset_content_type(rr->content_type, r);
        ap_rset_content_type(r->content_type, new);
        ap_rset_content_type(DIR_MAGIC_TYPE, r);
                ap_rset_content_type((char*) type, r);
                ap_rset_content_type(exinfo->forced_type, r);
	    ap_rset_content_type(apr_pstrcat(r->pool, ctp->type, "/",
                                             ctp->subtype, NULL), r);
			ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                         "; charset=", charset,
                                                         NULL), r);
		    ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                     "; ", pp->attr,
                                                     "=", pp->val,
                                                     NULL), r);
		ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                 "; charset=", charset,
                                                 NULL), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type(CGI_MAGIC_TYPE, sub_req);
        ap_rset_content_type(t, r);
                ap_rset_content_type(p->forced_mimetype, r);
	    ap_rset_content_type(tmp, r);
	ap_rset_content_type(tmp, r);
	ap_rset_content_type(apr_pstrdup(r->pool, sub->content_type), r);
        ap_rset_content_type("text/html", r);
            ap_rset_content_type(ap_default_type(r), r);
                    ap_rset_content_type(apr_pstrdup(p, buf), r);
#define MODULE_MAGIC_NUMBER_MAJOR 20051115
static int read_request_line(request_rec *r, apr_bucket_brigade *bb)

#if 0
    conn_rec *conn = r->connection;
#endif
    int num_blank_lines = 0;
    int max_blank_lines = r->server->limit_req_fields;

    if (max_blank_lines <= 0) {
        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
    }

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */

    do {
        apr_status_t rv;

        /* insure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */
        r->the_request = NULL;
        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                         &len, r, 0, bb);

        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();

            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
            }
            return 0;
        }
    } while ((len <= 0) && (++num_blank_lines < max_blank_lines));

    /* we've probably got something to do, ignore graceful restart requests */
    ll = r->the_request;
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method",
                                r->method);
#endif

    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */

             && (minor < HTTP_VERSION(1, 0)) ) /* don't allow HTTP/0.1000 */
    else
    return 1;
    char *last_field = NULL;
    apr_size_t last_len = 0;
    apr_size_t alloc_len = 0;
    char *value;
    int fields_read = 0;
    char *tmp_field;
        int folded = 0;

        if (last_field != NULL) {
            if ((len > 0) && ((*field == '\t') || *field == ' ')) {
                /* This line is a continuation of the preceding line(s),
                 * so append it to the line that we've set aside.
                 * Note: this uses a power-of-two allocator to avoid
                 * doing O(n) allocs and using O(n^2) space for
                 * continuations that span many many lines.
                 */
                apr_size_t fold_len = last_len + len + 1; /* trailing null */

                if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {
                    r->status = HTTP_BAD_REQUEST;
                    /* report what we have accumulated so far before the
                     * overflow (last_field) as the field with the problem
                     */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Size of a request header field "
                                               "after folding "
                                               "exceeds server limit.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool, last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                if (fold_len > alloc_len) {
                    char *fold_buf;
                    alloc_len += alloc_len;
                    if (fold_len > alloc_len) {
                        alloc_len = fold_len;
                    }
                    fold_buf = (char *)apr_palloc(r->pool, alloc_len);
                    memcpy(fold_buf, last_field, last_len);
                    last_field = fold_buf;
                }
                memcpy(last_field + last_len, field, len +1); /* +1 for nul */
                last_len += len;
                folded = 1;
            }
            else /* not a continuation line */ {

                if (r->server->limit_req_fields
                    && (++fields_read > r->server->limit_req_fields)) {
                    r->status = HTTP_BAD_REQUEST;
                    apr_table_setn(r->notes, "error-notes",
                                   "The number of request header fields "
                                   "exceeds this server's limit.");
                    return;
                }

                if (!(value = strchr(last_field, ':'))) { /* Find ':' or    */
                    r->status = HTTP_BAD_REQUEST;      /* abort bad request */
                    apr_table_setn(r->notes, "error-notes",
                                   apr_pstrcat(r->pool,
                                               "Request header field is "
                                               "missing ':' separator.<br />\n"
                                               "<pre>\n",
                                               ap_escape_html(r->pool,
                                                              last_field),
                                               "</pre>\n", NULL));
                    return;
                }

                tmp_field = value - 1; /* last character of field-name */

                *value++ = '\0'; /* NUL-terminate at colon */

                while (*value == ' ' || *value == '\t') {
                    ++value;            /* Skip to start of value   */
                }

                /* Strip LWS after field-name: */
                while (tmp_field > last_field
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                /* Strip LWS after field-value: */
                tmp_field = last_field + last_len - 1;
                while (tmp_field > value
                       && (*tmp_field == ' ' || *tmp_field == '\t')) {
                    *tmp_field-- = '\0';
                }

                apr_table_addn(r->headers_in, last_field, value);

                /* reset the alloc_len so that we'll allocate a new
                 * buffer if we have to do any more folding: we can't
                 * use the previous buffer because its contents are
                 * now part of r->headers_in
                 */
                alloc_len = 0;

            } /* end if current line is not a continuation starting with tab */
        }

        /* Found a blank line, stop. */
        if (len == 0) {
            break;

        /* Keep track of this line so that we can parse it on
         * the next loop iteration.  (In the folded case, last_field
         * has been updated already.)
         */
        if (!folded) {
            last_field = field;
            last_len = len;

    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
request_rec *ap_read_request(conn_rec *conn)
    const char *expect;
    int access_status;
    apr_bucket_brigade *tmp_bb;
    apr_socket_t *csd;
    apr_interval_time_t cur_timeout;

    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);

    /* Get the request... */
    if (!read_request_line(r, tmp_bb)) {
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: URI too long (longer than %d)", r->server->limit_req_line);
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        apr_brigade_destroy(tmp_bb);
        return NULL;
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_get(csd, &cur_timeout);
    if (cur_timeout != conn->base_server->timeout) {
        apr_socket_timeout_set(csd, conn->base_server->timeout);
        cur_timeout = conn->base_server->timeout;
    }

    if (!r->assbackwards) {
        ap_get_mime_headers_core(r, tmp_bb);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }

        if (apr_table_get(r->headers_in, "Transfer-Encoding")
            && apr_table_get(r->headers_in, "Content-Length")) {
            /* 2616 section 4.4, point 3: "if both Transfer-Encoding
             * and Content-Length are received, the latter MUST be
             * ignored"; so unset it here to prevent any confusion
             * later. */
            apr_table_unset(r->headers_in, "Content-Length");
        }
    }
    else {
        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
            ap_run_log_transaction(r);
            apr_brigade_destroy(tmp_bb);
            return r;
        }
    }
    apr_brigade_destroy(tmp_bb);
    if (cur_timeout != r->server->timeout) {
        apr_socket_timeout_set(csd, r->server->timeout);
        cur_timeout = r->server->timeout;

AP_DECLARE(char *) ap_escape_path_segment(apr_pool_t *p, const char *segment)
    char *copy = apr_palloc(p, 3 * strlen(segment) + 1);
#define MODULE_MAGIC_NUMBER_MINOR 22                   /* 0...n */
static int clear_conn_headers(void *data, const char *key, const char *val)
{
    apr_table_t *headers = ((header_dptr*)data)->table;
    apr_pool_t *pool = ((header_dptr*)data)->pool;
    const char *name;
    char *next = apr_pstrdup(pool, val);
    while (*next) {
        name = next;
        while (*next && !apr_isspace(*next) && (*next != ',')) {
            ++next;
        }
        while (*next && (apr_isspace(*next) || (*next == ','))) {
            *next++ = '\0';
        }
        apr_table_unset(headers, name);
    }
    return 1;
}
static void ap_proxy_clear_connection(apr_pool_t *p, apr_table_t *headers)
{
    header_dptr x;
    x.pool = p;
    x.table = headers;
    apr_table_unset(headers, "Proxy-Connection");
    apr_table_do(clear_conn_headers, &x, headers, "Connection", NULL);
    apr_table_unset(headers, "Connection");
}
            if (ap_find_token(p, apr_table_get(r->headers_out, "Connection"),
                              "close"))
                backend->close = 1;
            ap_proxy_clear_connection(p, r->headers_out);
void proxy_util_register_hooks(apr_pool_t *p)
{
    APR_REGISTER_OPTIONAL_FN(ap_proxy_retry_worker);
}

/* Clear all connection-based headers from the incoming headers table */
typedef struct header_dptr {
    apr_table_t *table;
    apr_time_t time;
} header_dptr;
static int clear_conn_headers(void *data, const char *key, const char *val)
    apr_table_t *headers = ((header_dptr*)data)->table;
    apr_pool_t *pool = ((header_dptr*)data)->pool;
    char *next = apr_pstrdup(pool, val);
    while (*next) {
        name = next;
        while (*next && !apr_isspace(*next) && (*next != ',')) {
            ++next;
        while (*next && (apr_isspace(*next) || (*next == ','))) {
            *next++ = '\0';
        apr_table_unset(headers, name);
    }
static void proxy_clear_connection(apr_pool_t *p, apr_table_t *headers)
    header_dptr x;
    x.pool = p;
    x.table = headers;
    apr_table_do(clear_conn_headers, &x, headers, "Connection", NULL);
    apr_table_unset(headers, "Connection");
    proxy_clear_connection(p, headers_in_copy);
    apr_pool_t *pPool;
                          s->process->pool);
    pPool = s->process->pool;
    mc = (SSLModConfigRec *)apr_palloc(pPool, sizeof(*mc));
    mc->pPool = pPool;
    mc->aRandSeed              = apr_array_make(pPool, 4,
    mc->tVHostKeys             = apr_hash_make(pPool);
    mc->tPrivateKey            = apr_hash_make(pPool);
    mc->tPublicCert            = apr_hash_make(pPool);
    mc->tTmpKeys               = apr_hash_make(pPool);
                          s->process->pool);
    ssl_randseed_t *pRS;
    pRS = apr_array_push(mc->aRandSeed);
        pRS->nCtx = SSL_RSCTX_STARTUP;
        pRS->nCtx = SSL_RSCTX_CONNECT;
        pRS->nSrc   = SSL_RSSRC_FILE;
        pRS->cpPath = ap_server_root_relative(mc->pPool, arg2+5);
        pRS->nSrc   = SSL_RSSRC_EXEC;
        pRS->cpPath = ap_server_root_relative(mc->pPool, arg2+5);
        pRS->nSrc   = SSL_RSSRC_EGD;
        pRS->cpPath = ap_server_root_relative(mc->pPool, arg2+4);
        pRS->nSrc   = SSL_RSSRC_BUILTIN;
        pRS->cpPath = NULL;
        pRS->nSrc   = SSL_RSSRC_FILE;
        pRS->cpPath = ap_server_root_relative(mc->pPool, arg2);
    if (pRS->nSrc != SSL_RSSRC_BUILTIN) {
        if (!ssl_util_path_check(SSL_PCM_EXISTS, pRS->cpPath, cmd->pool)) {
                               pRS->cpPath, "' does not exist", NULL);
        pRS->nBytes = 0; /* read whole file */
        if (pRS->nSrc == SSL_RSSRC_BUILTIN) {
        pRS->nBytes = atoi(arg3);
        if (pRS->nBytes < 0) {
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
            sc->szPublicCertFile[i] = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
            sc->szPrivateKeyFile[i] = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
    sc->szCertificateChain = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, cpPath, cmd->pool)) {
                           cpPath, "' does not exist", NULL);
        sc->szCACertificatePath = cpPath;
        dc->szCACertificatePath = cpPath;
    sc->szCACertificatePath = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
        sc->szCACertificateFile = cpPath;
        dc->szCACertificateFile = cpPath;
    sc->szCACertificateFile = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, cpPath, cmd->pool)) {
                           cpPath, "' does not exist", NULL);
    sc->szCARevocationPath = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
    sc->szCARevocationFile = cpPath;
                               const char *cpLine)
    while (*cpLine) {
        w = ap_getword_conf(cmd->pool, &cpLine);
                               const char *cpExpr)
    ssl_expr *mpExpr;
    ssl_require_t *pReqRec;
    if (!(mpExpr = ssl_expr_comp(cmd->pool, (char *)cpExpr))) {
    pReqRec = apr_array_push(dc->aRequirement);
    pReqRec->cpExpr = apr_pstrdup(cmd->pool, cpExpr);
    pReqRec->mpExpr = mpExpr;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
    sc->szProxyCACertificateFile = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, cpPath, cmd->pool)) {
                           cpPath, "' does not exist", NULL);
    sc->szProxyCACertificatePath = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_FILE, cpPath, cmd->pool)) {
                           cpPath, "' does not exist or is empty", NULL);
    sc->szProxyClientCertificateFile = cpPath;
    const char *cpPath = ap_server_root_relative(cmd->pool, arg);
    if (!ssl_util_path_check(SSL_FLAGS_CHECK_DIR, cpPath, cmd->pool)) {
                           cpPath, "' does not exist", NULL);
    sc->szProxyClientCertificatePath = cpPath;
    unsigned char *ucp;
        ucp = ssl_asn1_table_set(mc->tTmpKeys, "RSA:512", length);
        (void)i2d_RSAPrivateKey(rsa, &ucp); /* 2nd arg increments */
        ucp = ssl_asn1_table_set(mc->tTmpKeys, "RSA:1024", length);
        (void)i2d_RSAPrivateKey(rsa, &ucp); /* 2nd arg increments */
        ucp = ssl_asn1_table_set(mc->tTmpKeys, "DH:512", length);
        (void)i2d_DHparams(dh, &ucp); /* 2nd arg increments */
        ucp = ssl_asn1_table_set(mc->tTmpKeys, "DH:1024", length);
        (void)i2d_DHparams(dh, &ucp); /* 2nd arg increments */
            ucp = asn1->cpData;
                  d2i_RSAPrivateKey(NULL, &ucp, asn1->nData)))
            ucp = asn1->cpData;
                  d2i_RSAPrivateKey(NULL, &ucp, asn1->nData)))
            ucp = asn1->cpData;
                  d2i_DHparams(NULL, &ucp, asn1->nData)))
            ucp = asn1->cpData;
                  d2i_DHparams(NULL, &ucp, asn1->nData)))
    int nVerify = SSL_VERIFY_NONE;
    char *cp, *cpVHostID;
    EVP_PKEY *pKey;
    STACK_OF(X509_NAME) *skCAList;
    unsigned char *ucp;
    int isca, pathlen;
    sc->szVHostID = cpVHostID = ssl_util_vhostid(p, s);
                cpVHostID);
                "(theoretically shouldn't happen!)", cpVHostID);
                cpVHostID);
            cpVHostID, cp);
        nVerify |= SSL_VERIFY_PEER_STRICT;
        nVerify |= SSL_VERIFY_PEER;
    SSL_CTX_set_verify(ctx, nVerify,  ssl_callback_SSLVerify);
                cpVHostID, sc->szCipherSuite);
                    cpVHostID);
                "Init: (%s) Configuring client authentication", cpVHostID);
                    "for client authentication", cpVHostID);
        skCAList = ssl_init_FindCAList(s, p,
                                       sc->szCACertificateFile,
                                       sc->szCACertificatePath);
        if (!skCAList) {
                    cpVHostID);
        SSL_CTX_set_client_CA_list(sc->pSSLCtx, (STACK *)skCAList);
                cpVHostID);
                    cpVHostID);
        skCAList = (STACK_OF(X509_NAME) *)SSL_CTX_get_client_CA_list(ctx);
        if (sk_X509_NAME_num(skCAList) == 0) {
    cp = apr_psprintf(p, "%s:RSA", cpVHostID);
                cpVHostID);
        ucp = asn1->cpData;
              d2i_X509(NULL, &ucp, asn1->nData)))
                    cpVHostID);
                    cpVHostID);
    cp = apr_psprintf(p, "%s:DSA", cpVHostID);
                cpVHostID);
        ucp = asn1->cpData;
              d2i_X509(NULL, &ucp, asn1->nData)))
                    cpVHostID);
                    cpVHostID);
                cpVHostID);
                cpVHostID);
                        cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
            if (SSL_X509_getBC(sc->pPublicCert[i], &isca, &pathlen)) {
                if (isca) {
                            cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
                            cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
                            cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
                            cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"),
    cp = apr_psprintf(p, "%s:RSA", cpVHostID);
                cpVHostID);
        ucp = asn1->cpData;
              d2i_PrivateKey(EVP_PKEY_RSA, NULL, &ucp, asn1->nData)))
                    cpVHostID);
                    cpVHostID);
    cp = apr_psprintf(p, "%s:DSA", cpVHostID);
                cpVHostID);
        ucp = asn1->cpData;
              d2i_PrivateKey(EVP_PKEY_DSA, NULL, &ucp, asn1->nData)))
                    cpVHostID);
                    cpVHostID);
                cpVHostID);
        pKey = X509_get_pubkey(sc->pPublicCert[SSL_AIDX_DSA]);
        if (pKey && (EVP_PKEY_key_type(pKey) == EVP_PKEY_DSA) &&
            EVP_PKEY_missing_parameters(pKey))
            EVP_PKEY_copy_parameters(pKey,
        BOOL bSkipFirst = FALSE;
                bSkipFirst = TRUE;
                                          bSkipFirst, NULL);
                    cpVHostID);
                cpVHostID, n, n == 1 ? "" : "s");
    server_rec *s;
    server_rec **ps;
    ssl_ds_table *t;
    apr_pool_t *sp;
    BOOL bConflict = FALSE;
    apr_pool_create(&sp, p);
    t = ssl_ds_table_make(sp, sizeof(server_rec *));
        key = apr_psprintf(sp, "%pA:%u",
        if ((ps = ssl_ds_table_get(t, key))) {
            bConflict = TRUE;
        ps = ssl_ds_table_push(t, key);
    ssl_ds_table_kill(t);
    apr_pool_destroy(sp);
    if (bConflict) {
static void ssl_init_PushCAList(STACK_OF(X509_NAME) *skCAList,
        if (sk_X509_NAME_find(skCAList, name) < 0) {
            /* this will be freed when skCAList is */
            sk_X509_NAME_push(skCAList, name);
                                         apr_pool_t *pp,
                                         const char *cpCAfile,
                                         const char *cpCApath)
    STACK_OF(X509_NAME) *skCAList;
    apr_pool_t *p;
    apr_pool_sub_make(&p, pp, NULL);
    skCAList = sk_X509_NAME_new(ssl_init_FindCAList_X509NameCmp);
    if (cpCAfile) {
        ssl_init_PushCAList(skCAList, s, cpCAfile);
    if (cpCApath) {
        if (apr_dir_open(&dir, cpCApath, p) != APR_SUCCESS) {
                    cpCApath);
            const char *cp;
            cp = apr_pstrcat(p, cpCApath, "/", direntry.name, NULL);
            ssl_init_PushCAList(skCAList, s, cp);
    sk_X509_NAME_set_cmp_func(skCAList, NULL);
    apr_pool_destroy(p);
    return skCAList;
    const char *cpType = "";
        cpType = "standard";
        cpType = "unclean";
        cpType = "accurate";
                conn->id, cpType,
    apr_array_header_t *apRequirement;
    ssl_require_t *pRequirements, *pRequirement;
    STACK_OF(X509_NAME) *skCAList;
    char *cpCAPath, *cpCAFile;
    STACK_OF(X509) *certstack;
    X509_STORE *certstore;
    X509_STORE_CTX certstorectx;
    STACK_OF(SSL_CIPHER) *skCipherOld, *skCipher = NULL;
    SSL_CIPHER *pCipher = NULL;
    int depth, nVerifyOld, nVerify, n;
            pCipher = SSL_get_current_cipher(ssl);
            skCipherOld = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);
            if (skCipherOld) {
                skCipherOld = sk_SSL_CIPHER_dup(skCipherOld);
            if (skCipherOld) {
                sk_SSL_CIPHER_free(skCipherOld);
        skCipher = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);
            if ((!pCipher && skCipher) ||
                (pCipher && !skCipher))
            else if (pCipher && skCipher &&
                     (sk_SSL_CIPHER_find(skCipher, pCipher) < 0))
            if ((!skCipherOld && skCipher) ||
                (skCipherOld && !skCipher))
            else if (skCipherOld && skCipher) {
                     !renegotiate && (n < sk_SSL_CIPHER_num(skCipher));
                    SSL_CIPHER *value = sk_SSL_CIPHER_value(skCipher, n);
                    if (sk_SSL_CIPHER_find(skCipherOld, value) < 0) {
                     !renegotiate && (n < sk_SSL_CIPHER_num(skCipherOld));
                    SSL_CIPHER *value = sk_SSL_CIPHER_value(skCipherOld, n);
                    if (sk_SSL_CIPHER_find(skCipher, value) < 0) {
        if (skCipherOld) {
            sk_SSL_CIPHER_free(skCipherOld);
        nVerifyOld = SSL_get_verify_mode(ssl);
        nVerify = SSL_VERIFY_NONE;
            nVerify |= SSL_VERIFY_PEER_STRICT;
            nVerify |= SSL_VERIFY_PEER;
        SSL_set_verify(ssl, nVerify, ssl_callback_SSLVerify);
        if (nVerify != nVerifyOld) {
            if (((nVerifyOld == SSL_VERIFY_NONE) &&
                 (nVerify    != SSL_VERIFY_NONE)) ||
                (!(nVerifyOld & SSL_VERIFY_PEER) &&
                  (nVerify    & SSL_VERIFY_PEER)) ||
                (!(nVerifyOld & SSL_VERIFY_PEER_STRICT) &&
                  (nVerify    & SSL_VERIFY_PEER_STRICT)))
                    (nVerifyOld == SSL_VERIFY_NONE) &&
        cpCAFile = dc->szCACertificateFile ?
        cpCAPath = dc->szCACertificatePath ?
           if (!SSL_load_verify_locations(ssl, cpCAFile, cpCAPath)) {
        if (!SSL_CTX_load_verify_locations(ctx, cpCAFile, cpCAPath)) {
        if (!(skCAList = ssl_init_FindCAList(r->server, r->pool,
                                             cpCAFile, cpCAPath)))
        SSL_set_client_CA_list(ssl, skCAList);
            if (!(certstore = SSL_CTX_get_cert_store(ctx))) {
            certstack = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl);
            if (!certstack || (sk_X509_num(certstack) == 0)) {
            cert = sk_X509_value(certstack, 0);
            X509_STORE_CTX_init(&certstorectx, certstore, cert, certstack);
                X509_STORE_CTX_set_depth(&certstorectx, depth);
            X509_STORE_CTX_set_ex_data(&certstorectx,
            if (!X509_verify_cert(&certstorectx)) {
            SSL_set_verify_result(ssl, certstorectx.error);
            X509_STORE_CTX_cleanup(&certstorectx);
            BOOL verify = (dc->nVerifyClient == SSL_CVERIFY_REQUIRE);
            if (verify && (SSL_get_verify_result(ssl) != X509_V_OK)) {
            if (verify && !SSL_get_peer_certificate(ssl)) {
    apRequirement = dc->aRequirement;
    pRequirements = (ssl_require_t *)apRequirement->elts;
    for (i = 0; i < apRequirement->nelts; i++) {
        pRequirement = &pRequirements[i];
        ok = ssl_expr_exec(r, pRequirement->mpExpr);
                    "Failed expression: %s", pRequirement->cpExpr);
    char b1[MAX_STRING_LEN], b2[MAX_STRING_LEN];
    const char *cpAL, *cpUN, *cpPW;
    if ((cpAL = apr_table_get(r->headers_in, "Authorization"))) {
        if (strcEQ(ap_getword(r->pool, &cpAL, ' '), "Basic")) {
            while ((*cpAL == ' ') || (*cpAL == '\t')) {
                cpAL++;
            cpAL = ap_pbase64decode(r->pool, cpAL);
            cpUN = ap_getword_nulls(r->pool, &cpAL, ':');
            cpPW = cpAL;
            if ((cpUN[0] == '/') && strEQ(cpPW, "password")) {
    apr_snprintf(b1, sizeof(b1), "%s:password", clientdn);
    ssl_util_uuencode(b2, b1, FALSE);
    apr_snprintf(b1, sizeof(b1), "Basic %s", b2);
    apr_table_set(r->headers_in, "Authorization", b1);
            "Faking HTTP Basic Auth header: \"Authorization: %s\"", b1);
    apr_table_t *e = r->subprocess_env;
    STACK_OF(X509) *sk;
    apr_table_setn(e, "HTTPS", "on"); 
                apr_table_set(e, var, val);
        apr_table_setn(e, "SSL_SERVER_CERT", val);
        apr_table_setn(e, "SSL_CLIENT_CERT", val);
        if ((sk = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl))) {
            for (i = 0; i < sk_X509_num(sk); i++) {
                     apr_table_setn(e, var, val);
RSA *ssl_callback_TmpRSA(SSL *pSSL, int nExport, int nKeyLen)
    conn_rec *c = (conn_rec *)SSL_get_app_data(pSSL);
    if (nExport) {
        if (nKeyLen == 512) {
        else if (nKeyLen == 1024) {
DH *ssl_callback_TmpDH(SSL *pSSL, int nExport, int nKeyLen)
    conn_rec *c = (conn_rec *)SSL_get_app_data(pSSL);
    if (nExport) {
        if (nKeyLen == 512) {
        else if (nKeyLen == 1024) {
    X509 *xs     = X509_STORE_CTX_get_current_cert(ctx);
        char *cp  = X509_NAME_oneline(X509_get_subject_name(xs), NULL, 0);
        char *cp2 = X509_NAME_oneline(X509_get_issuer_name(xs),  NULL, 0);
                cp ? cp : "-unknown-",
                cp2 ? cp2 : "-unknown-");
        if (cp) {
            free(cp);
        if (cp2) {
            free(cp2);
    X509 *xs;
    xs      = X509_STORE_CTX_get_current_cert(ctx);
    subject = X509_get_subject_name(xs);
    issuer  = X509_get_issuer_name(xs);
        if (X509_CRL_verify(crl, X509_get_pubkey(xs)) <= 0) {
            if (!ASN1_INTEGER_cmp(sn, X509_get_serialNumber(xs))) {
int ssl_callback_NewSessionCacheEntry(SSL *ssl, SSL_SESSION *pNew)
    SSL_set_timeout(pNew, timeout);
    session_id = SSL_SESSION_get_session_id(pNew);
    session_id_length = SSL_SESSION_get_session_id_length(pNew);
    timeout += SSL_get_time(pNew);
                          timeout, pNew);
     * return 0 which means to OpenSSL that the pNew is still
                                               int idlen, int *pCopy)
    SSL_SESSION *pSession;
    pSession = ssl_scache_retrieve(s, id, idlen);
    if (pSession) {
     * setting pCopy to 0) that the reference count on the
    *pCopy = 0;
    return pSession;
                                       SSL_SESSION *pSession)
    session_id = SSL_SESSION_get_session_id(pSession);
    session_id_length = SSL_SESSION_get_session_id_length(pSession);
    char *str;
            str = (where & SSL_CB_READ) ? "read" : "write";
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type(DAV_XML_CONTENT_TYPE, r);
    ap_rset_content_type("text/xml", r);
    ap_rset_content_type(apr_pstrdup(r->pool, info->content_type), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html;charset=utf-8", r);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type(CGI_MAGIC_TYPE, rr);
    ap_rset_content_type("text/html", r);
    ap_rset_content_type("text/html", r);
                    ap_rset_content_type("text/plain", r);
    ap_rset_content_type("message/http", r);
AP_DECLARE(void) ap_rset_content_type(const char *ct, request_rec *r)
        ap_rset_content_type("text/html; charset=iso-8859-1", r);
            ap_rset_content_type(apr_pstrcat(r->pool, "multipart",
                                             use_range_x(r) ? "/x-" : "/",
                                             "byteranges; boundary=",
                                             r->boundary, NULL), r);
    ap_rset_content_type(rr->content_type, r);
        ap_rset_content_type(r->content_type, new);
        ap_rset_content_type(DIR_MAGIC_TYPE, r);
                ap_rset_content_type((char*) type, r);
                ap_rset_content_type(exinfo->forced_type, r);
	    ap_rset_content_type(apr_pstrcat(r->pool, ctp->type, "/",
                                             ctp->subtype, NULL), r);
			ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                         "; charset=", charset,
                                                         NULL), r);
		    ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                     "; ", pp->attr,
                                                     "=", pp->val,
                                                     NULL), r);
		ap_rset_content_type(apr_pstrcat(r->pool, r->content_type,
                                                 "; charset=", charset,
                                                 NULL), r);
    ap_rset_content_type("text/html", r);
            ap_rset_content_type(CGI_MAGIC_TYPE, sub_req);
        ap_rset_content_type(t, r);
                ap_rset_content_type(p->forced_mimetype, r);
	    ap_rset_content_type(tmp, r);
	ap_rset_content_type(tmp, r);
	ap_rset_content_type(apr_pstrdup(r->pool, sub->content_type), r);
        ap_rset_content_type("text/html", r);
            ap_rset_content_type(ap_default_type(r), r);
                    ap_rset_content_type(apr_pstrdup(p, buf), r);
#include "http_conf_globals.h"	/* for user_id & group_id */

    tms = gmtime(&sec);

    register int x, y, badesc, badpath;
    for (x = 0, y = 0; url[y]; ++x, ++y) {
	if (url[y] != '%')
	    url[x] = url[y];
	    if (!ap_isxdigit(url[y + 1]) || !ap_isxdigit(url[y + 2])) {
		url[x] = '%';
		url[x] = x2c(&url[y + 1]);
		if (url[x] == '/' || url[x] == '\0')
    url[x] = '\0';
                                       base->forced_types);
static const char *add_type(cmd_parms *cmd, mime_dir_config * m, char *ct,
        ++ext;
static const char *add_encoding(cmd_parms *cmd, mime_dir_config * m, char *enc,
static const char *add_language(cmd_parms *cmd, mime_dir_config * m, char *lang,
    if (*ext == '.')
        ++ext;
static const char *add_handler(cmd_parms *cmd, mime_dir_config * m, char *hdlr,
    if (fn == NULL)
        fn = r->filename;
        if ((type = ap_table_get(conf->handlers, ext)) && !r->proxyreq) {
        }
#include "http_conf_globals.h"	/* for user_id & group_id */

    tms = gmtime(&sec);

    register int x, y, badesc, badpath;
    for (x = 0, y = 0; url[y]; ++x, ++y) {
	if (url[y] != '%')
	    url[x] = url[y];
	    if (!ap_isxdigit(url[y + 1]) || !ap_isxdigit(url[y + 2])) {
		url[x] = '%';
		url[x] = x2c(&url[y + 1]);
		if (url[x] == '/' || url[x] == '\0')
    url[x] = '\0';
    /* since is_absolute(conf->d) was being called so frequently in
     * directory_walk() and its relatives, this field was created and
     * is set to the result of that call.
     */
    unsigned d_is_absolute : 1;

    if (!dir || dir[strlen(dir) - 1] == '/') {
        conf->d = dir;
    }
    else if (strncmp(dir, "proxy:", 6) == 0) {
        conf->d = apr_pstrdup(a, dir);
    }
    else {
        conf->d = apr_pstrcat(a, dir, "/", NULL);
    }
    conf->d_is_fnmatch = conf->d ? (apr_is_fnmatch(conf->d) != 0) : 0;

    /* On all platforms, "/" is (at minimum) a faux root */
    conf->d_is_absolute = conf->d ? (ap_os_is_path_absolute(a, conf->d) 
                                      || (strcmp(conf->d, "/") == 0)) : 0;

    /* Make this explicit - the "/" root has 0 elements, that is, we
     * will always merge it, and it will always sort and merge first.
     * All others are sorted and tested by the number of slashes.
     */
    if (!conf->d || strcmp(conf->d, "/") == 0)
        conf->d_components = 0;
    else
        conf->d_components = ap_count_dirs(conf->d);
    conf->d_is_absolute = new->d_is_absolute;
/* core_reorder_directories reorders the directory sections such that the
 * 1-component sections come first, then the 2-component, and so on, finally
 * followed by the "special" sections.  A section is "special" if it's a regex,
 * or if it doesn't start with / -- consider proxy: matching.  All movements
 * are in-order to preserve the ordering of the sections from the config files.
 * See directory_walk().
 */

#if defined(HAVE_DRIVE_LETTERS)
#define IS_SPECIAL(entry_core)	\
    ((entry_core)->r != NULL \
	|| ((entry_core)->d[0] != '/' && (entry_core)->d[1] != ':'))
#elif defined(NETWARE)
/* XXX: Fairly certain this is correct... '/' must prefix the path
 *      or else in the case xyz:/ or abc/xyz:/, '/' must follow the ':'.
 *      If there is no leading '/' or embedded ':/', then we are special.
 */
#define IS_SPECIAL(entry_core)	\
    ((entry_core)->r != NULL \
	|| ((entry_core)->d[0] != '/' \
            && strchr((entry_core)->d, ':') \
            && *(strchr((entry_core)->d, ':') + 1) != '/'))
#else
#define IS_SPECIAL(entry_core)	\
    ((entry_core)->r != NULL || (entry_core)->d[0] != '/')
#endif

 * components (where a "special" section has infinite components).
    if (IS_SPECIAL(core_a)) {
	if (!IS_SPECIAL(core_b)) {
	    return 1;
	}
    else if (IS_SPECIAL(core_b)) {
	return -1;
    else {
	/* we know they're both not special */
	if (core_a->d_components < core_b->d_components) {
	    return -1;
	}
	else if (core_a->d_components > core_b->d_components) {
	    return 1;
	}
    /* Either they're both special, or they're both not special and have the
     * same number of components.  In any event, we now have to compare
     * the minor key. */
    if (thiscmd->cmd_data) { /* <DirectoryMatch> */
	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
    }
    else if (!strcmp(cmd->path, "~")) {
	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
    else if (strcmp(cmd->path, "/") == 0) {
        /* Treat 'default' path "/" as the inalienable root */
        cmd->path = apr_pstrdup(cmd->pool, cmd->path);
    else {
        char *newpath;
	/* Ensure that the pathname is canonical */
        if (apr_filepath_merge(&newpath, NULL, cmd->path, 
                               APR_FILEPATH_TRUENAME, cmd->pool) != APR_SUCCESS) {
            return apr_pstrcat(cmd->pool, "<Directory \"", cmd->path,
                               "\"> path is invalid.", NULL);
        cmd->path = newpath;

    conf->d = apr_pstrdup(cmd->pool, cmd->path);	/* No mangling, please */
    conf->d_is_absolute = (conf->d && (*conf->d == '/'));
    conf->d_is_absolute = 0;
     * Are we dealing with a file? If not, we can (hopefuly) safely assume we
     * have a handler that doesn't require one, but for safety's sake, and so
     * we have something find_types() can get something out of, fake one. But
     * don't run through the directory entries.

    if (r->filename == NULL) {
        r->filename = apr_pstrdup(r->pool, r->uri);
        r->finfo.filetype = APR_NOFILE;
        r->per_dir_config = per_dir_defaults;

        return OK;
     *
     * Fake filenames (i.e. proxy:) only match Directory sections.
     */

    if (!ap_os_is_path_absolute(r->pool, r->filename))
    {
        const char *entry_dir;

        for (j = 0; j < num_sec; ++j) {

            entry_config = sec_dir[j];
            entry_core = ap_get_module_config(entry_config, &core_module);
            entry_dir = entry_core->d;

            this_conf = NULL;
            if (entry_core->r) {
                if (!ap_regexec(entry_core->r, r->filename, 0, NULL, 0))
                    this_conf = entry_config;
            }
            else if (entry_core->d_is_fnmatch) {
                if (!apr_fnmatch(entry_dir, r->filename, 0))
                    this_conf = entry_config;
            }
            else if (!strncmp(r->filename, entry_dir, strlen(entry_dir)))
                this_conf = entry_config;

            if (this_conf)
                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
                                                            per_dir_defaults,
                                                            this_conf);
        }

        r->per_dir_config = per_dir_defaults;

        return OK;
    }

    /* The replacement code [below] for directory_walk eliminates this issue.
    /* XXX These exception cases go away if apr_stat() returns the
     * APR_PATHINCOMPLETE status, so we skip hard filesystem testing
     * of the initial 'pseudo' elements:
            if (entry_core->r || !entry_core->d_is_absolute
                || entry_core->d_components > i)
     * There's two types of IS_SPECIAL sections (see http_core.c), and we've
     * already handled the proxy:-style stuff.  Now we'll deal with the
     * regexes.
        if (entry_core->r) {
            if (!ap_regexec(entry_core->r, test_dirname, 0, NULL, REG_NOTEOL)) {
                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
                                                            per_dir_defaults,
                                                            entry_config);
            }
     * Are we dealing with a file? If not, we simply assume we have a 
     * handler that doesn't require one, but for safety's sake, and so
     * we have something find_types() can get something out of, fake 
     * one. But don't run through the directory entries.

    if (r->filename == NULL) {
        r->filename = apr_pstrdup(r->pool, r->uri);
        r->finfo.filetype = APR_NOFILE;
        r->per_dir_config = per_dir_defaults;

        return OK;
    }
    else {
        const char *entry_dir;

        /* Fake filenames (i.e. proxy:) only match Directory sections.
         */
        if (rv != APR_EBADPATH)
            return HTTP_FORBIDDEN;
        }

        for (sec_idx = 0; sec_idx < num_sec; ++sec_idx) {

            entry_config = sec_ent[sec_idx];
            entry_core = ap_get_module_config(entry_config, &core_module);
            entry_dir = entry_core->d;

            this_conf = NULL;
            if (entry_core->r) {
                if (!ap_regexec(entry_core->r, r->filename, 0, NULL, 0))
                    this_conf = entry_config;
            }
            else if (entry_core->d_is_fnmatch) {
                /* XXX: Gut instinct tells me this could be very, very nasty,
                 * have we thought through what 'faux' resource might be
                 * case senstitive or not?
                 */
                if (!apr_fnmatch(entry_dir, r->filename, 0))
                    this_conf = entry_config;
            }
            else if (!strncmp(r->filename, entry_dir, strlen(entry_dir)))
                this_conf = entry_config;

            if (this_conf)
                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
                                                            per_dir_defaults,
                                                            this_conf);

        r->per_dir_config = per_dir_defaults;

        return OK;
            if (entry_core->r || !entry_core->d_is_absolute
                              || entry_core->d_components > seg)
     * There's two types of IS_SPECIAL sections (see http_core.c), and we've
     * already handled the proxy:-style stuff.  Now we'll deal with the
     * regexes.
        if (entry_core->r) {
            if (!ap_regexec(entry_core->r, r->filename, 0, NULL, REG_NOTEOL)) {
                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
                                                            per_dir_defaults,
                                                            entry_config);
            }
 * %...h:  the request protocol
#include "mpm.h"
static apr_socket_t *csd;
static apr_socket_t **listensocks;
    int sockdes, i;
    apr_socket_t *sd;
    for (lr = ap_listeners, i = 0; i < num_listensocks; lr = lr->next, i++)
        listensocks[i]=lr->sd;
        apr_poll_socket_add(pollset, listensocks[i], APR_POLLIN);
                sd = ap_listeners->sd;
                    apr_poll_revents_get(&event, listensocks[curr_pollfd], pollset);
                        sd=listensocks[curr_pollfd];
	    status = apr_accept(&csd, sd, ptrans);
   	    if (status == APR_SUCCESS || !APR_STATUS_IS_EINTR(status))
	        break;
	    }

	    if (status == APR_SUCCESS)
		break;		/* We have a socket ready for reading */
	    else {
		/* Our old behaviour here was to continue after accept()
		 * errors.  But this leads us into lots of troubles
		 * because most of the errors are quite fatal.  For
		 * example, EMFILE can be caused by slow descriptor
		 * leaks (say in a 3rd party module, or libc).  It's
		 * foolish for us to continue after an EMFILE.  We also
		 * seem to tickle kernel bugs on some platforms which
		 * lead to never-ending loops here.  So it seems best
		 * to just exit in most cases.
		 */
                switch (status) {
#ifdef EPROTO
		    /* EPROTO on certain older kernels really means
		     * ECONNABORTED, so we need to ignore it for them.
		     * See discussion in new-httpd archives nh.9701
		     * search for EPROTO.
		     *
		     * Also see nh.9603, search for EPROTO:
		     * There is potentially a bug in Solaris 2.x x<6,
		     * and other boxes that implement tcp sockets in
		     * userland (i.e. on top of STREAMS).  On these
		     * systems, EPROTO can actually result in a fatal
		     * loop.  See PR#981 for example.  It's hard to
		     * handle both uses of EPROTO.
		     */
                case EPROTO:
#endif
#ifdef ECONNABORTED
                case ECONNABORTED:
#endif
		    /* Linux generates the rest of these, other tcp
		     * stacks (i.e. bsd) tend to hide them behind
		     * getsockopt() interfaces.  They occur when
		     * the net goes sour or the client disconnects
		     * after the three-way handshake has been done
		     * in the kernel but before userland has picked
		     * up the socket.
		     */
#ifdef ECONNRESET
                case ECONNRESET:
#endif
#ifdef ETIMEDOUT
                case ETIMEDOUT:
#endif
#ifdef EHOSTUNREACH
		case EHOSTUNREACH:
#endif
#ifdef ENETUNREACH
		case ENETUNREACH:
#endif
                    break;
#ifdef ENETDOWN
		case ENETDOWN:
		     /*
		      * When the network layer has been shut down, there
		      * is not much use in simply exiting: the parent
		      * would simply re-create us (and we'd fail again).
		      * Use the CHILDFATAL code to tear the server down.
		      * @@@ Martin's idea for possible improvement:
		      * A different approach would be to define
		      * a new APEXIT_NETDOWN exit code, the reception
		      * of which would make the parent shutdown all
		      * children, then idle-loop until it detected that
		      * the network is up again, and restart the children.
		      * Ben Hyde noted that temporary ENETDOWN situations
		      * occur in mobile IP.
		      */
		    ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
			"apr_accept: giving up.");
		    clean_child_exit(APEXIT_CHILDFATAL);
#endif /*ENETDOWN*/

#ifdef TPF
		case EINACT:
		    ap_log_error(APLOG_MARK, APLOG_EMERG, status, ap_server_conf,
			"offload device inactive");
		    clean_child_exit(APEXIT_CHILDFATAL);
		    break;
		default:
		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, ap_server_conf,
			"select/accept error (%d)", status);
		    clean_child_exit(APEXIT_CHILDFATAL);
#else
		default:
		    ap_log_error(APLOG_MARK, APLOG_ERR, status, ap_server_conf,
				"apr_accept: (client socket)");
		    clean_child_exit(1);
#endif
		}
	    }
	}

        apr_os_sock_get(&sockdes, csd);

        if (sockdes >= FD_SETSIZE) {
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, 0, NULL,
                         "new file descriptor %d is too large; you probably need "
                         "to rebuild Apache with a larger FD_SETSIZE "
                         "(currently %d)", 
                         sockdes, FD_SETSIZE);
	    apr_socket_close(csd);
            ap_sync_scoreboard_image();
	    continue;
        }

#ifdef TPF
	if (sockdes == 0) {                  /* 0 is invalid socket for TPF */
	    ap_sync_scoreboard_image();
            continue;
        }
#endif

        ap_rvputs(r, ap_get_server_name(r), " (", r->connection->local_ip,
    time_left = ccfg->timeout_at - now;
    if (time_left <= 0) {
        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c,
                      "Request %s read timeout", ccfg->type);
        return APR_TIMEUP;
    }
    if (time_left < apr_time_from_sec(1)) {
        time_left = apr_time_from_sec(1);
    }

    if (saved_sock_timeout >= time_left) {
        rv = apr_socket_timeout_set(ccfg->socket, time_left);
        AP_DEBUG_ASSERT(rv == APR_SUCCESS);
    }
    else {
        saved_sock_timeout = -1;
    }
    rv = ap_get_brigade(f->next, bb, mode, block, readbytes);
    if (saved_sock_timeout != -1) {
        apr_socket_timeout_set(ccfg->socket, saved_sock_timeout);
    }
    if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {
        extend_timeout(ccfg, bb);
APR_HOOK_STRUCT(
    APR_HOOK_LINK(fatal_exception)
)

AP_IMPLEMENT_HOOK_RUN_ALL(int, fatal_exception,
                          (ap_exception_info_t *ei), (ei), OK, DECLINED)

 * 20051231.0 (2.3.0-dev)  Added num_blank_lines, pending_header_line, and
 *                         pending_header_size to request_rec
    /** Number of leading blank lines encountered before request header */
    int num_blank_lines;

    /** A buffered header line, used to support header folding while
     *  reading the request */
    char *pending_header_line;

    /** If nonzero, the number of bytes allocated to hold pending_header_line */
    apr_size_t pending_header_size;

static void set_the_request(request_rec *r, char *line)
    apr_socket_t *csd;
    ll = r->the_request = line;
             && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */
    }
    else {
    }

    /* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */
    csd = ap_get_module_config(r->connection->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->connection->base_server->timeout);

    return;
}

static apr_status_t set_mime_header(request_rec *r, char *line)
{
    char *value, *tmp_field;

    if (r->server->limit_req_fields) {
        const apr_array_header_t *mime_headers = apr_table_elts(r->headers_in);
        if (mime_headers->nelts >= r->server->limit_req_fields) {
            apr_table_setn(r->notes, "error-notes",
                           "The number of request header fields "
                           "exceeds this server's limit.");
            r->status = HTTP_BAD_REQUEST;
            return APR_ENOSPC;
        }
    }
    
    if (!(value = strchr(line, ':'))) { /* Find ':' or    */
        r->status = HTTP_BAD_REQUEST;      /* abort bad request */
        apr_table_setn(r->notes, "error-notes",
                       apr_pstrcat(r->pool,
                                   "Request header field is "
                                   "missing ':' separator.<br />\n"
                                   "<pre>\n",
                                   ap_escape_html(r->pool, line),
                                   "</pre>\n", NULL));
        return APR_EGENERAL;
    }

    tmp_field = value - 1; /* last character of field-name */

    *value++ = '\0'; /* NUL-terminate at colon */

    while (*value == ' ' || *value == '\t') {
        ++value;            /* Skip to start of value   */
    }

    /* Strip LWS after field-name: */
    while (tmp_field > line
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }

    /* Strip LWS after field-value: */
    tmp_field = strchr(value, '\0') - 1;
    while (tmp_field > value
           && (*tmp_field == ' ' || *tmp_field == '\t')) {
        *tmp_field-- = '\0';
    }
    apr_table_addn(r->headers_in, line, value);
    return APR_SUCCESS;
}

static apr_status_t process_request_line(request_rec *r, char *line,
                                         int skip_first)
{
    if (!skip_first && (r->the_request == NULL)) {
        /* This is the first line of the request */
        if ((line == NULL) || (*line == '\0')) {
            /* We skip empty lines because browsers have to tack a CRLF on to the end
             * of POSTs to support old CERN webservers.
             */
            int max_blank_lines = r->server->limit_req_fields;
            if (max_blank_lines <= 0) {
                max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
            }
            r->num_blank_lines++;
            if (r->num_blank_lines < max_blank_lines) {
                return APR_SUCCESS;
            }
        }
        set_the_request(r, line);
    }
    else {
        /* We've already read the first line of the request.  This is either
         * a header field or the blank line terminating the header
         */
        if ((line == NULL) || (*line == '\0')) {
            if (r->pending_header_line != NULL) {
                apr_status_t rv = set_mime_header(r, r->pending_header_line);
                if (rv != APR_SUCCESS) {
                    return rv;
                }
                r->pending_header_line = NULL;
            }
            if (r->status == HTTP_REQUEST_TIME_OUT) {
                apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
                r->status = HTTP_OK;
            }
        }
        else {
            if ((*line == ' ') || (*line == '\t')) {
                /* This line is a continuation of the previous one */
                if (r->pending_header_line == NULL) {
                    r->pending_header_line = line;
                    r->pending_header_size = 0;
                }
                else {
                    apr_size_t pending_len = strlen(r->pending_header_line);
                    apr_size_t fold_len = strlen(line);
                    if ((r->server->limit_req_fieldsize > 0)
						&& (pending_len + fold_len >
                               (apr_size_t) r->server->limit_req_fieldsize)) {
                        /* CVE-2004-0942 */
                        r->status = HTTP_BAD_REQUEST;
                        return APR_ENOSPC;
                    }
                    if (pending_len + fold_len + 1 > r->pending_header_size) {
                        /* Allocate a new buffer big enough to hold the
                         * concatenated lines
                         */
                        apr_size_t new_size = r->pending_header_size;
                        char *new_buf;
                        if (new_size == 0) {
                            new_size = pending_len + fold_len + 1;
                        }
                        else {
                            do {
                                new_size *= 2;
                            } while (new_size < pending_len + fold_len + 1);
                        }
                        new_buf = (char *)apr_palloc(r->pool, new_size);
                        memcpy(new_buf, r->pending_header_line, pending_len);
                        r->pending_header_line = new_buf;
                        r->pending_header_size = new_size;
                    }
                    memcpy(r->pending_header_line + pending_len, line,
                           fold_len + 1);
                }
            }
            else {
                /* Set aside this line in case the next line is a continuation
                 */
                if (r->pending_header_line != NULL) {
                    apr_status_t rv = set_mime_header(r, r->pending_header_line);
                    if (rv != APR_SUCCESS) {
                        return rv;
                    }
                }
                r->pending_header_line = line;
                r->pending_header_size = 0;
            }
        }
    }
    return APR_SUCCESS;
        rv = process_request_line(r, field, 1);
        if (rv != APR_SUCCESS) {
            return;
        if ((field == NULL) || (*field == '\0')) {
            return;
static request_rec *init_request(conn_rec *conn)
    
    return r;
}
static request_rec *request_post_read(request_rec *r, conn_rec *conn)
{
    apr_socket_t *csd;
    const char *expect;
    int access_status;
    csd = ap_get_module_config(conn->conn_config, &core_module);
    apr_socket_timeout_set(csd, r->server->timeout);

    if (apr_table_get(r->headers_in, "Transfer-Encoding") &&
        apr_table_get(r->headers_in, "Content-Length")) {
        /* 2616 section 4.4, point 3: "if both Transfer-Encoding
         * and Content-Length are received, the latter MUST be
         * ignored"; so unset it here to prevent any confusion
         * later.
         */
        apr_table_unset(r->headers_in, "Content-Length");
static apr_status_t read_partial_request(request_rec *r) {
    apr_bucket_brigade *tmp_bb;
    apr_status_t rv = APR_SUCCESS;

    /* Read and process lines of the request until we
     * encounter a complete request header, an error, or EAGAIN
     */
    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);
    while (r->status == HTTP_REQUEST_TIME_OUT) {
        char *line = NULL;
        apr_size_t line_length;
        apr_size_t length_limit;
        int first_line = (r->the_request == NULL);
        if (first_line) {
            length_limit = r->server->limit_req_line;
        }
        else {
            if (r->assbackwards) {
                r->status = HTTP_OK;
                break;
            }
            length_limit = r->server->limit_req_fieldsize;
        }
        /* TODO: use a nonblocking call in place of ap_rgetline */
        rv = ap_rgetline(&line, length_limit + 2,
                         &line_length, r, 0, tmp_bb);
        if (rv == APR_SUCCESS) {
            rv = process_request_line(r, line, 0);
        }
        if (rv != APR_SUCCESS) {
            r->request_time = apr_time_now();
            /* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */
            if (rv == APR_ENOSPC) {
                if (first_line) {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: URI too long (longer than %d)",
                                  r->server->limit_req_line);
                    r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                    r->proto_num = HTTP_VERSION(1,0);
                    r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
                }
                else {
                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                                  "request failed: header line too long "
                                  "(longer than %d)",
                                  r->server->limit_req_fieldsize);
                    r->status = HTTP_BAD_REQUEST;
                }
            }
            break;
        }
    }
    apr_brigade_destroy(tmp_bb);
    return rv;
}

request_rec *ap_read_request(conn_rec *conn)
{
    request_rec *r;
    apr_status_t rv;

    r = init_request(conn);

    rv = read_partial_request(r);
    /* TODO poll if EAGAIN */
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return NULL;
    }

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers! Have to dink things just to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                      "client sent invalid HTTP/0.9 request: HEAD %s",
                      r->uri);
        r->header_only = 0;
        r->status = HTTP_BAD_REQUEST;
        ap_send_error_response(r, 0);
        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, r);
        ap_run_log_transaction(r);
        return r;
    }

    return request_post_read(r, conn);
}

    time_left = ccfg->timeout_at - now;
    if (time_left <= 0) {
        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c,
                      "Request %s read timeout", ccfg->type);
        return APR_TIMEUP;
    }
    if (time_left < apr_time_from_sec(1)) {
        time_left = apr_time_from_sec(1);
    }

    if (saved_sock_timeout >= time_left) {
        rv = apr_socket_timeout_set(ccfg->socket, time_left);
        AP_DEBUG_ASSERT(rv == APR_SUCCESS);
    }
    else {
        saved_sock_timeout = -1;
    }
    rv = ap_get_brigade(f->next, bb, mode, block, readbytes);
    if (saved_sock_timeout != -1) {
        apr_socket_timeout_set(ccfg->socket, saved_sock_timeout);
    }
    if (ccfg->min_rate > 0 && rv == APR_SUCCESS) {
        extend_timeout(ccfg, bb);
            if (r->status == HTTP_BAD_REQUEST) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,
                              "request failed: invalid characters in URI");
            }
            else {
#include "apr_lib.h"
#include "http_log.h"
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;
 
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;
 
    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */
 
    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
            /* this is a hack to make sure that request time is set,
             * it's not perfect, but it's better than nothing
             */
            r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */
 
    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk
 
#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */
 
    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);
 
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method);
#endif
    uri = ap_getword_white(r->pool, &ll);
 
    /* Provide quick information about the request method as soon as known */
 
    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }
 
    ap_parse_uri(r, uri);
 
    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }
 
    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);
 
    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */
 
    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))    /* don't allow HTTP/0.1000 */
        r->proto_num = HTTP_VERSION(major, minor);
    else
        r->proto_num = HTTP_VERSION(1,0);
 
    return 1;
}

static int http_create_request(request_rec *r)
{
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
    int keptalive;

    hconn = apr_pcalloc(r->pool, sizeof(*hconn));
    ap_set_module_config(r->connection->conn_config, &http_module, hconn);

    if (!r->main && !r->prev && !r->next) {
        keptalive = r->connection->keepalive == 1;
        r->connection->keepalive    = 0;
 
        /* XXX can we optimize these timeouts at all? gstein */
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(keptalive
                         ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                         : r->server->timeout * APR_USEC_PER_SEC));
 
        /* Get the request... */
        if (!read_request_line(r)) {
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                              "request failed: URI too long");
                ap_send_error_response(r, 0);
                ap_run_log_transaction(r);
                return OK;
            }
            return DONE;
        }
        if (keptalive) {
            apr_setsocketopt(r->connection->client_socket,
                             APR_SO_TIMEOUT,
                             (int)(r->server->timeout * APR_USEC_PER_SEC));
        }
    }
    return OK;
}

    ap_hook_create_request(http_create_request, NULL, NULL, APR_HOOK_MIDDLE);
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
	    || (r->server->keep_alive_max > hconn->keepalives))
        int left = r->server->keep_alive_max - hconn->keepalives;
        hconn->keepalives++;
typedef struct ap_http_conn_rec ap_http_conn_rec;

struct ap_http_conn_rec {
    /** How many times have we used it? */
    int keepalives;
};

AP_DECLARE_DATA extern module http_module;

#include "mod_core.h"
    if (ap_run_create_request(r) != OK) {
        return NULL;
    }
        conf->provider_name = apr_pstrdup(cmd->pool, arg1);
        const char *vary = apr_table_get(out_req->headers_out, "Vary");
    char *note_ratio_name;
    char *note_input_name;
    char *note_output_name;
        c->note_ratio_name = apr_pstrdup(cmd->pool, arg1);
        c->note_ratio_name = apr_pstrdup(cmd->pool, arg2);
        c->note_input_name = apr_pstrdup(cmd->pool, arg2);
        c->note_output_name = apr_pstrdup(cmd->pool, arg2);
        rv = HTTP_INTERNAL_SERVER_ERROR ;
                    return ;
                        return ;
                        return ;
        for (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --
end)
        process_proxy_header(r, dconf, buffer, value) ;
            if (s[1] == '{' && (e = ap_strchr_c(s, '}'))) {
                char *name = apr_pstrndup(p, s+2, e-s-2);
    limited_methods = apr_pstrndup(cmd->temp_pool, arg, endp - arg);
            /* method has not been registered yet, but resorce restriction
#include "mod_proxy.h"
module AP_MODULE_DECLARE_DATA imap_module;
    icr = ap_get_module_config(r->per_dir_config, &imap_module);
module AP_MODULE_DECLARE_DATA imap_module =
    bio_filter_out_ctx_t *b = (bio_filter_out_ctx_t *)(bio->ptr);
    if (!b->length && (inl + b->blen < sizeof(b->buffer))) {
        memcpy(&b->buffer[b->blen], in, inl);
        b->blen += inl;
                                                         b->bb->bucket_alloc);
        b->length += inl;
        APR_BRIGADE_INSERT_TAIL(b->bb, bucket);
    bio_filter_out_ctx_t *b = (bio_filter_out_ctx_t *)(bio->ptr);
        b->blen = b->length = 0;
        ret = (long)((b->blen + b->length) == 0);
        b->blen = b->length = (apr_size_t)num;
        ret = (long)(b->blen + b->length);
            *pptr = (char *)&(b->buffer[0]);
        ret = (long)(b->blen + b->length);
    bio_filter_in_ctx_t *ctx = (bio_filter_in_ctx_t *)(bio->ptr);
    apr_read_type_e block = ctx->block;
    SSLConnRec *sslconn = myConnConfig(ctx->f->c);
    ctx->rc = APR_SUCCESS;
    if ((SSL_version(ctx->ssl) == SSL2_VERSION) || sslconn->is_proxy) {
        bio_filter_out_flush(ctx->wbio);
    if (!ctx->bb) {
        ctx->rc = APR_EOF;
    if (APR_BRIGADE_EMPTY(ctx->bb)) {
        ctx->rc = ap_get_brigade(ctx->f->next, ctx->bb,
        if (APR_STATUS_IS_EAGAIN(ctx->rc) || APR_STATUS_IS_EINTR(ctx->rc)
               || (ctx->rc == APR_SUCCESS && APR_BRIGADE_EMPTY(ctx->bb))) {
        if (ctx->rc != APR_SUCCESS) {
            apr_brigade_cleanup(ctx->bb);
            ctx->bb = NULL;
    ctx->rc = brigade_consume(ctx->bb, block, in, &inl);
    if (ctx->rc == APR_SUCCESS) {
    if (APR_STATUS_IS_EAGAIN(ctx->rc) 
            || APR_STATUS_IS_EINTR(ctx->rc)) {
    apr_brigade_cleanup(ctx->bb);
    ctx->bb = NULL;
    if (APR_STATUS_IS_EOF(ctx->rc) && inl) {
    SSLFilterRec *ctx = f->ctx;
    n = ssl_io_hook_write(ctx->pssl, (unsigned char *)data, len);
        if (SSL_total_renegotiations(ctx->pssl)) {
    SSLFilterRec *ctx = f->ctx;
    if (!ctx->pssl) {
    if ((status = ssl_hook_process_connection(ctx)) != APR_SUCCESS) {
            if ((status = bio_filter_out_flush(ctx->pbioWrite)) != APR_SUCCESS) {
static apr_status_t ssl_io_input_read(bio_filter_in_ctx_t *ctx,
    if ((bytes = char_buffer_read(&ctx->cbuf, buf, wanted))) {
        if (ctx->mode == AP_MODE_SPECULATIVE) {
            ctx->cbuf.value -= bytes;
            ctx->cbuf.length += bytes;
        if ((*len >= wanted) || ctx->mode == AP_MODE_GETLINE) {
        rc = SSL_read(ctx->frec->pssl, buf + bytes, wanted - bytes);
            if (ctx->mode == AP_MODE_SPECULATIVE) {
                char_buffer_write(&ctx->cbuf, buf, rc);
            return ctx->rc;
            if (APR_STATUS_IS_EAGAIN(ctx->rc)
                    || APR_STATUS_IS_EINTR(ctx->rc)) {
                if (ctx->block == APR_NONBLOCK_READ) {
                ctx->rc = APR_EOF;
            int ssl_err = SSL_get_error(ctx->frec->pssl, rc);
                if (ctx->block == APR_NONBLOCK_READ) {
                    ctx->rc = APR_EAGAIN;
                conn_rec *c = (conn_rec *)SSL_get_app_data(ctx->frec->pssl);
                ap_log_error(APLOG_MARK, APLOG_ERR, ctx->rc, c->base_server,
                conn_rec *c = (conn_rec *)SSL_get_app_data(ctx->frec->pssl);
                ap_log_error(APLOG_MARK, APLOG_ERR, ctx->rc, c->base_server,
                if (ctx->rc == APR_SUCCESS) {
                    ctx->rc = APR_EGENERAL;
    return ctx->rc;
static apr_status_t ssl_io_input_getline(bio_filter_in_ctx_t *ctx,
        status = ssl_io_input_read(ctx, buf + offset, &tmplen);
        char_buffer_write(&ctx->cbuf, value, length);
    bio_filter_in_ctx_t *ctx = f->ctx;
    ctx->ssl = NULL;
    ctx->frec->pssl = NULL;
    bio_filter_in_ctx_t *ctx = f->ctx;
    apr_size_t len = sizeof(ctx->buffer);
    if (!ctx->ssl) {
    ctx->mode = mode;
    ctx->block = block;
    status = ssl_hook_process_connection(ctx->frec);
    if (ctx->mode == AP_MODE_READBYTES || 
        ctx->mode == AP_MODE_SPECULATIVE) {
        status = ssl_io_input_read(ctx, ctx->buffer, &len);
    else if (ctx->mode == AP_MODE_GETLINE) {
        status = ssl_io_input_getline(ctx, ctx->buffer, &len);
            apr_bucket_transient_create(ctx->buffer, len, f->c->bucket_alloc);
    bio_filter_in_ctx_t *ctx;
    ctx = apr_palloc(c->pool, sizeof(*ctx));
    frec->pInputFilter = ap_add_input_filter(ssl_io_filter, ctx, NULL, c);
    frec->pbioRead->ptr = (void *)ctx;
    ctx->frec = frec;
    ctx->ssl = ssl;
    ctx->wbio = frec->pbioWrite;
    ctx->f = frec->pInputFilter;
    ctx->bb = apr_brigade_create(c->pool, c->bucket_alloc);
    ctx->cbuf.length = 0;
    ctx->pool = c->pool;
    imap_conf_rec *new = (imap_conf_rec *) apr_pcalloc(p, sizeof(imap_conf_rec));
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted") && *comment) {
    if (!strcasecmp(menu, "unformatted") && *comment) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    for (lr = head_listener; lr ; lr = lr->next) {
	if (FD_ISSET(nsd, main_fds)) {
	    head_listener = lr->next;
            if (head_listener == NULL)

	    return (lr);
	}
    }
#include "apr_lib.h"
#include "http_log.h"
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;
 
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;
 
    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */
 
    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
            /* this is a hack to make sure that request time is set,
             * it's not perfect, but it's better than nothing
             */
            r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */
 
    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk
 
#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */
 
    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);
 
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method);
#endif
    uri = ap_getword_white(r->pool, &ll);
 
    /* Provide quick information about the request method as soon as known */
 
    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }
 
    ap_parse_uri(r, uri);
 
    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }
 
    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);
 
    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */
 
    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))    /* don't allow HTTP/0.1000 */
        r->proto_num = HTTP_VERSION(major, minor);
    else
        r->proto_num = HTTP_VERSION(1,0);
 
    return 1;
}

static int http_create_request(request_rec *r)
{
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
    int keptalive;

    hconn = apr_pcalloc(r->pool, sizeof(*hconn));
    ap_set_module_config(r->connection->conn_config, &http_module, hconn);

    if (!r->main && !r->prev && !r->next) {
        keptalive = r->connection->keepalive == 1;
        r->connection->keepalive    = 0;
 
        /* XXX can we optimize these timeouts at all? gstein */
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(keptalive
                         ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                         : r->server->timeout * APR_USEC_PER_SEC));
 
        /* Get the request... */
        if (!read_request_line(r)) {
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                              "request failed: URI too long");
                ap_send_error_response(r, 0);
                ap_run_log_transaction(r);
                return OK;
            }
            return DONE;
        }
        if (keptalive) {
            apr_setsocketopt(r->connection->client_socket,
                             APR_SO_TIMEOUT,
                             (int)(r->server->timeout * APR_USEC_PER_SEC));
        }
    }
    return OK;
}

    ap_hook_create_request(http_create_request, NULL, NULL, APR_HOOK_MIDDLE);
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
	    || (r->server->keep_alive_max > hconn->keepalives))
        int left = r->server->keep_alive_max - hconn->keepalives;
        hconn->keepalives++;
typedef struct ap_http_conn_rec ap_http_conn_rec;

struct ap_http_conn_rec {
    /** How many times have we used it? */
    int keepalives;
};

AP_DECLARE_DATA extern module http_module;

#include "mod_core.h"
    if (ap_run_create_request(r) != OK) {
        return NULL;
    }
        else if (!strcasecmp(w, "Options")) {
        else if (!strcasecmp(w, "execCGI")) {
        /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
        if (action == '-') {
int ap_proxy_ajp_canon(request_rec *r, char *url);
int ap_proxy_ajp_handler(request_rec *r, proxy_server_conf *conf,
                          char *url, const char *proxyname, 
                          apr_port_t proxyport);

typedef struct {
    const char     *name;
    apr_port_t      port;
    apr_sockaddr_t *addr;
    apr_socket_t   *sock;
    int             close;
    void           *data;  /* To store ajp data */
} proxy_ajp_conn_t;

static apr_status_t ap_proxy_ajp_cleanup(request_rec *r,
                                          proxy_ajp_conn_t *p_conn,
                                          proxy_conn_rec *backend);

static
apr_status_t ap_proxy_http_determine_connection(apr_pool_t *p, request_rec *r,
                                                proxy_ajp_conn_t *p_conn,
                                                conn_rec *c,
                                                proxy_server_conf *conf,
                                                apr_uri_t *uri,
                                                char **url,
                                                const char *proxyname,
                                                apr_port_t proxyport,
                                                char *server_portstr,
                                                int server_portstr_size) {
    int server_port;
    apr_status_t err;
    apr_sockaddr_t *uri_addr;
    /*
     * Break up the URL to determine the host to connect to
     */

    /* we break the URL into host, port, uri */
    if (APR_SUCCESS != apr_uri_parse(p, *url, uri)) {
        return ap_proxyerror(r, HTTP_BAD_REQUEST,
                             apr_pstrcat(p,"URI cannot be parsed: ", *url,
                                         NULL));
    }
    if (!uri->port) {
        uri->port = apr_uri_port_of_scheme(uri->scheme);
    }

    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "proxy: AJP connecting %s to %s:%d", *url, uri->hostname,
                 uri->port);

    /* do a DNS lookup for the destination host */
    /* see memory note above */
    err = apr_sockaddr_info_get(&uri_addr, apr_pstrdup(c->pool, uri->hostname),
                                APR_UNSPEC, uri->port, 0, c->pool);

    /* allocate these out of the connection pool - the check on
     * r->connection->id makes sure that this string does not get accessed
     * past the connection lifetime */
    /* are we connecting directly, or via a proxy? */
    if (proxyname) {
        p_conn->name = apr_pstrdup(c->pool, proxyname);
        p_conn->port = proxyport;
        /* see memory note above */
        err = apr_sockaddr_info_get(&p_conn->addr, p_conn->name, APR_UNSPEC,
                                    p_conn->port, 0, c->pool);
    } else {
        p_conn->name = apr_pstrdup(c->pool, uri->hostname);
        p_conn->port = uri->port;
        p_conn->addr = uri_addr;
        *url = apr_pstrcat(p, uri->path, uri->query ? "?" : "",
                           uri->query ? uri->query : "",
                           uri->fragment ? "#" : "",
                           uri->fragment ? uri->fragment : "", NULL);
    }

    if (err != APR_SUCCESS) {
        return ap_proxyerror(r, HTTP_BAD_GATEWAY,
                             apr_pstrcat(p, "DNS lookup failure for: ",
                                         p_conn->name, NULL));
    }

    /* Get the server port for the Via headers */
    {
        server_port = ap_get_server_port(r);
        if (ap_is_default_port(server_port, r)) {
            strcpy(server_portstr,"");
        } else {
            apr_snprintf(server_portstr, server_portstr_size, ":%d",
                         server_port);
        }
    }

    /* check if ProxyBlock directive on this host */
    if (OK != ap_proxy_checkproxyblock(r, conf, uri_addr)) {
        return ap_proxyerror(r, HTTP_FORBIDDEN,
                             "Connect to remote machine blocked");
    }
    return OK;
}

static
apr_status_t ap_proxy_http_create_connection(apr_pool_t *p, request_rec *r,
                                             proxy_ajp_conn_t *p_conn,
                                             conn_rec *c, conn_rec **origin,
                                             proxy_conn_rec *backend,
                                             proxy_server_conf *conf,
                                             const char *proxyname) {
    int failed = 0, new_conn = 0;
    apr_socket_t *client_socket = NULL;

    /* We have determined who to connect to. Now make the connection, supporting
     * a KeepAlive connection.
     */

    /* get all the possible IP addresses for the destname and loop through them
     * until we get a successful connection
     */

    /* if a keepalive socket is already open, check whether it must stay
     * open, or whether it should be closed and a new socket created.
     */
    /* see memory note above */
    if (backend->connection) {
        client_socket = ap_get_module_config(backend->connection->conn_config, &core_module);
        if ((backend->connection->id == c->id) &&
            (backend->port == p_conn->port) &&
            (backend->hostname) &&
            (!apr_strnatcasecmp(backend->hostname, p_conn->name))) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                         "proxy: keepalive address match (keep original socket)");
        } else {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                         "proxy: keepalive address mismatch / connection has"
                         " changed (close old socket (%s/%s, %d/%d))", 
                         p_conn->name, backend->hostname, p_conn->port,
                         backend->port);
            apr_socket_close(client_socket);
            backend->connection = NULL;
        }
    }

    /* get a socket - either a keepalive one, or a new one */
    new_conn = 1;
    if ((backend->connection) && (backend->connection->id == c->id)) {
        apr_size_t buffer_len = 1;
        char test_buffer[1]; 
        apr_status_t socket_status;
        apr_interval_time_t current_timeout;

        /* use previous keepalive socket */
        *origin = backend->connection;
        p_conn->sock = client_socket;
        new_conn = 0;

        /* save timeout */
        apr_socket_timeout_get(p_conn->sock, &current_timeout);
        /* set no timeout */
        apr_socket_timeout_set(p_conn->sock, 0);
        socket_status = apr_socket_recv(p_conn->sock, test_buffer, &buffer_len);
        /* put back old timeout */
        apr_socket_timeout_set(p_conn->sock, current_timeout);
        if ( APR_STATUS_IS_EOF(socket_status) ) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
                         "proxy: AJP: previous connection is closed");
            new_conn = 1;
        }
    }
    if (new_conn) {

        /* create a new socket */
        backend->connection = NULL;

        /*
         * At this point we have a list of one or more IP addresses of
         * the machine to connect to. If configured, reorder this
         * list so that the "best candidate" is first try. "best
         * candidate" could mean the least loaded server, the fastest
         * responding server, whatever.
         *
         * For now we do nothing, ie we get DNS round robin.
         * XXX FIXME
         */
        failed = ap_proxy_connect_to_backend(&p_conn->sock, "AJP",
                                             p_conn->addr, p_conn->name,
                                             conf, r->server, c->pool);

        /* handle a permanent error on the connect */
        if (failed) {
            if (proxyname) {
                return DECLINED;
            } else {
                return HTTP_BAD_GATEWAY;
            }
        }

        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "proxy: socket is connected");

        /* the socket is now open, create a new backend server connection */
        *origin = ap_run_create_connection(c->pool, r->server, p_conn->sock,
                                           r->connection->id,
                                           r->connection->sbh, c->bucket_alloc);
        if (!*origin) {
        /* the peer reset the connection already; ap_run_create_connection() 
         * closed the socket
         */
            ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                         r->server, "proxy: an error occurred creating a "
                         "new connection to %pI (%s)", p_conn->addr,
                         p_conn->name);
            apr_socket_close(p_conn->sock);
            return HTTP_INTERNAL_SERVER_ERROR;
        }
        backend->connection = *origin;
        backend->hostname = apr_pstrdup(c->pool, p_conn->name);
        backend->port = p_conn->port;

        if (backend->is_ssl) {
            if (!ap_proxy_ssl_enable(backend->connection)) {
                ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                             r->server, "proxy: failed to enable ssl support "
                             "for %pI (%s)", p_conn->addr, p_conn->name);
                return HTTP_INTERNAL_SERVER_ERROR;
            }
        }
        else {
            ap_proxy_ssl_disable(backend->connection);
        }

        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "proxy: connection complete to %pI (%s)",
                     p_conn->addr, p_conn->name);

        /* set up the connection filters */
        ap_run_pre_connection(*origin, p_conn->sock);
    }
    return OK;
}


                                   proxy_ajp_conn_t *p_conn, conn_rec *origin, 
    status = ajp_send_header(p_conn->sock,r);
                     p_conn->addr, p_conn->name);
            status = ajp_send_data_msg(p_conn->sock, r, msg, bufsiz);
                             p_conn->addr, p_conn->name);
    status = ajp_read_header(p_conn->sock, r,
                             (ajp_msg_t **)&(p_conn->data));
                     p_conn->addr, p_conn->name);
    result = ajp_parse_type(r, p_conn->data);
                     p_conn->addr, p_conn->name);
                                            proxy_ajp_conn_t *p_conn,
    type = ajp_parse_type(r, p_conn->data);
            status = ajp_parse_header(r, p_conn->data); 
        } else if  (type == CMD_AJP13_SEND_BODY_CHUNK) {
            status = ajp_parse_data(r, p_conn->data, &size, &buff);
        } else {
        status = ajp_read_header(p_conn->sock, r,
                                 (ajp_msg_t **)&(p_conn->data));
        type = ajp_parse_type(r, p_conn->data);
                      "server %s:%d", p_conn->name, p_conn->port);
static
apr_status_t ap_proxy_ajp_cleanup(request_rec *r, proxy_ajp_conn_t *p_conn,
                                   proxy_conn_rec *backend) {
    /* If the connection has been signalled
     * to close, close the socket and clean up
     */

    /* if the connection is < HTTP/1.1, or Connection: close,
     * we close the socket, otherwise we leave it open for KeepAlive support
     */
    if (p_conn->close) {
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                      "ap_proxy_ajp_cleanup closing");
        if (p_conn->sock) {
            apr_socket_close(p_conn->sock);
            p_conn->sock = NULL;
            backend->connection = NULL;
        }
    }
    return OK;
}

int ap_proxy_ajp_handler(request_rec *r, proxy_server_conf *conf,
                          char *url, const char *proxyname, 
                          apr_port_t proxyport)
    proxy_ajp_conn_t *p_conn = apr_pcalloc(r->connection->pool,
                                           sizeof(*p_conn));
    /* only use stored info for top-level pages. Sub requests don't share 
     * in keepalives
     */
    if (!r->main) {
        backend = (proxy_conn_rec *) ap_get_module_config(c->conn_config,
                                                      &proxy_ajp_module);
    }
    /* create space for state information */
    if (!backend) {
        backend = apr_pcalloc(c->pool, sizeof(proxy_conn_rec));
        backend->connection = NULL;
        backend->hostname = NULL;
        backend->port = 0;
        if (!r->main) {
            ap_set_module_config(c->conn_config, &proxy_ajp_module, backend);
        }
    }

    
        backend = apr_pcalloc(c->pool, sizeof(proxy_conn_rec));
        backend->connection = NULL;
        backend->hostname = NULL;
        backend->port = 0;
    backend->is_ssl = is_ssl;
    status = ap_proxy_http_determine_connection(p, r, p_conn, c, conf, uri,
                                                &url, proxyname, proxyport,
                                                server_portstr,
                                                sizeof(server_portstr));
    if ( status != OK ) {
        return status;
    }
    status = ap_proxy_http_create_connection(p, r, p_conn, c, &origin, backend,
                                             conf, proxyname);
    if ( status != OK ) {
        return status;
    /* Step Three: Send the Request */
    status = ap_proxy_ajp_request(p, r, p_conn, origin, conf, uri, url,
                                   server_portstr);
    if ( status != OK ) {
        p_conn->close++;
        ap_proxy_ajp_cleanup(r, p_conn, backend);
        return status;
    }

    /* Step Four: Receive the Response */
    status = ap_proxy_ajp_process_response(p, r, p_conn, origin, backend,
    if ( status != OK ) {
        /* clean up even if there is an error */
        p_conn->close++;
        ap_proxy_ajp_cleanup(r, p_conn, backend);
        return status;
    }

    /* Step Five: Clean Up */
    status = ap_proxy_ajp_cleanup(r, p_conn, backend);
    if ( status != OK ) {
        return status;
    }

    return OK;
        path = dir = apr_pstrcat(p, path, "/", NULL);
        while ((n = strlen(path)) > 1 && path[n - 1] == '/' && path[n - 2] == '/')
                           "\n\n<html>\n<head>\n<title>%s%s</title>\n"
                           "<base href=\"%s%s\">\n</head>\n\n"
                           "<body>\n\n<h2>Directory of "
                           "<a href=\"/\">%s</a>/",
                           site, ap_escape_html(p, path),
                           site, ap_escape_uri(p, path), site);
        while ((dir = strchr(dir + 1, '/')) != NULL) {
            if ((reldir = strrchr(path + 1, '/')) == NULL)
                reldir = path + 1;
            str = apr_psprintf(p, "<a href=\"/%s/\">%s</a>/",
                               ap_escape_uri(p, path + 1),
                               ap_escape_html(p, reldir));
            e = apr_bucket_pool_create(str, strlen(str), p);
            APR_BRIGADE_INSERT_TAIL(out, e);
            str = apr_psprintf(p, "</h2>\n\n<hr />\n\n<pre>");
            str = apr_psprintf(p, "</h2>\n\n(%s)\n\n<hr />\n\n<pre>", pwd);
/* strncat works here, but apr_cpystrn does not - the last char gets chopped, dunno why */
/*            strncat(ctx->buffer, response, len);*/
            /* +1 to leave spave for the trailing nil char */
            if (ctx->buffer[n-1] == '\n')  /* strip trailing '\n' */
            if (ctx->buffer[n-1] == '\r')  /* strip trailing '\r' if present */
        str = apr_psprintf(p, "</pre>\n\n<hr />\n\n%s\n\n</body>\n</html>\n", ap_psignature("", r));
	     * should be created with the correct family in the first place.
	     */
	 * So we need to escape the URI metacharacters.
	        ;
static apr_status_t ssl_abort(SSLFilterRec *filter, conn_rec *c)
{
    SSLConnRec *sslconn = myConnConfig(c);
    /*
     * try to gracefully shutdown the connection:
     * - send an own shutdown message (be gracefully)
     * - don't wait for peer's shutdown message (deadloop)
     * - kick away the SSL stuff immediately
     * - block the socket, so Apache cannot operate any more
     */

    SSL_set_shutdown(filter->pssl, SSL_RECEIVED_SHUTDOWN);
    SSL_smart_shutdown(filter->pssl);
    SSL_free(filter->pssl);

    filter->pssl = NULL; /* so filters know we've been shutdown */
    sslconn->ssl = NULL;
    c->aborted = 1;

    return APR_EGENERAL;
}

/*
 * The hook is NOT registered with ap_hook_process_connection. Instead, it is
 * called manually from the churn () before it tries to read any data.
 * There is some problem if I accept conn_rec *. Still investigating..
 * Adv. if conn_rec * can be accepted is we can hook this function using the
 * ap_hook_process_connection hook.
 */
int ssl_hook_process_connection(SSLFilterRec *filter)
{
    conn_rec *c         = (conn_rec *)SSL_get_app_data(filter->pssl);
    SSLConnRec *sslconn = myConnConfig(c);
    SSLSrvConfigRec *sc = mySrvConfig(c->base_server);
    X509 *cert;
    int n, err;
    long verify_result;

    if (!SSL_is_init_finished(filter->pssl)) {
        if (sslconn->is_proxy) {
            if ((n = SSL_connect(filter->pssl)) <= 0) {
                ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                             c->base_server,
                             "SSL Proxy connect failed");
                ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);
                return ssl_abort(filter, c);
            }

            return APR_SUCCESS;
        }

        if ((n = SSL_accept(filter->pssl)) <= 0) {
            err = SSL_get_error(filter->pssl, n);

            if (err == SSL_ERROR_ZERO_RETURN) {
                /*
                 * The case where the connection was closed before any data
                 * was transferred. That's not a real error and can occur
                 * sporadically with some clients.
                 */
                ap_log_error(APLOG_MARK, APLOG_INFO, 0,
                             c->base_server,
                             "SSL handshake stopped: connection was closed");
            }
            else if (err == SSL_ERROR_WANT_READ) {
                /*
                 * This is in addition to what was present earlier. It is 
                 * borrowed from openssl_state_machine.c [mod_tls].
                 * TBD.
                 */
                return SSL_ERROR_WANT_READ;
            }
            else if (ERR_GET_REASON(ERR_peek_error()) == SSL_R_HTTP_REQUEST) {
                /*
                 * The case where OpenSSL has recognized a HTTP request:
                 * This means the client speaks plain HTTP on our HTTPS port.
                 * ssl_io_filter_error will disable the ssl filters when it
                 * sees this status code.
                 */
                return HTTP_BAD_REQUEST;
            }
            else if ((SSL_get_error(filter->pssl, n) == SSL_ERROR_SYSCALL) &&
                     (errno != EINTR))
            {
                if (errno > 0) {
                    ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                                 c->base_server,
                                 "SSL handshake interrupted by system "
                                 "[Hint: Stop button pressed in browser?!]");
                    ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);
                }
                else {
                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, 
                                 c->base_server,
                                 "Spurious SSL handshake interrupt [Hint: "
                                 "Usually just one of those OpenSSL "
                                 "confusions!?]");
                    ssl_log_ssl_error(APLOG_MARK, APLOG_INFO, c->base_server);
                }
            }
            else {
                /*
                 * Ok, anything else is a fatal error
                 */
                ap_log_error(APLOG_MARK, APLOG_ERR, 0, 
                             c->base_server,
                             "SSL handshake failed (server %s, client %s)",
                             ssl_util_vhostid(c->pool, c->base_server),
                             c->remote_ip ? c->remote_ip : "unknown");
                ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);
            }

            return ssl_abort(filter, c);
        }

        /*
         * Check for failed client authentication
         */
        verify_result = SSL_get_verify_result(filter->pssl);

        if ((verify_result != X509_V_OK) ||
            sslconn->verify_error)
        {
            if (ssl_verify_error_is_optional(verify_result) &&
                (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA))
            {
                /* leaving this log message as an error for the moment,
                 * according to the mod_ssl docs:
                 * "level optional_no_ca is actually against the idea
                 *  of authentication (but can be used to establish 
                 * SSL test pages, etc.)"
                 * optional_no_ca doesn't appear to work as advertised
                 * in 1.x
                 */
                ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                             c->base_server,
                             "SSL client authentication failed, "
                             "accepting certificate based on "
                             "\"SSLVerifyClient optional_no_ca\" "
                             "configuration");
                ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);
            }
            else {
                const char *error = sslconn->verify_error ?
                    sslconn->verify_error :
                    X509_verify_cert_error_string(verify_result);

                ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                             c->base_server,
                             "SSL client authentication failed: %s",
                             error ? error : "unknown");
                ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);

                return ssl_abort(filter, c);
            }
        }

        /*
         * Remember the peer certificate's DN
         */
        if ((cert = SSL_get_peer_certificate(filter->pssl))) {
            sslconn->client_cert = cert;
            sslconn->client_dn = NULL;
            X509_free(cert);
        }

        /*
         * Make really sure that when a peer certificate
         * is required we really got one... (be paranoid)
         */
        if ((sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE) &&
            !sslconn->client_cert)
        {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, c->base_server,
                         "No acceptable peer certificate available");

            return ssl_abort(filter, c);
        }
    }

    return APR_SUCCESS;
}

typedef struct {
    SSL                *pssl;
    BIO                *pbioRead;
    BIO                *pbioWrite;
    ap_filter_t        *pInputFilter;
    ap_filter_t        *pOutputFilter;
} SSLFilterRec;

void         ssl_hook_NewConnection(conn_rec *);
void         ssl_hook_TimeoutConnection(int);
int          ssl_hook_process_connection(SSLFilterRec *pRec);
apr_status_t ssl_hook_CloseConnection(SSLFilterRec *);
int          ssl_hook_Handler(request_rec *);
 * - ssl_io_filter_Input    (Apache input filter)
 * - ssl_io_filter_Output   (Apache output filter)
 * ssl_io_filter_Input->ssl_io_input_read->SSL_read->...
 * Note that the filter context of ssl_io_filter_Input and bio_filter_in_*
    SSLFilterRec *filter_ctx;
static bio_filter_out_ctx_t *bio_filter_out_ctx_new(SSLFilterRec *filter_ctx,
    SSLFilterRec *filter_ctx;
static const char ssl_io_filter[] = "SSL/TLS Filter";

static apr_status_t ssl_filter_write(ap_filter_t *f,
                                     const char *data,
                                     apr_size_t len)
{
    SSLFilterRec *filter_ctx = f->ctx;
    bio_filter_out_ctx_t *outctx = 
           (bio_filter_out_ctx_t *)(filter_ctx->pbioWrite->ptr);
    int res;

    /* write SSL */
    if (filter_ctx->pssl == NULL) {
        return APR_EGENERAL;
    }

    res = SSL_write(filter_ctx->pssl, (unsigned char *)data, len);

    if (res < 0) {
        int ssl_err = SSL_get_error(filter_ctx->pssl, res);

        if (ssl_err == SSL_ERROR_WANT_WRITE) {
            /*
             * If OpenSSL wants to write more, and we were nonblocking,
             * report as an EAGAIN.  Otherwise loop, pushing more
             * data at the network filter.
             *
             * (This is usually the case when the client forces an SSL
             * renegotation which is handled implicitly by OpenSSL.)
             */
            outctx->rc = APR_EAGAIN;
        }
        else if (ssl_err == SSL_ERROR_SYSCALL) {
            conn_rec *c = (conn_rec*)SSL_get_app_data(outctx->filter_ctx->pssl);
            ap_log_error(APLOG_MARK, APLOG_ERR, outctx->rc, c->base_server,
                        "SSL filter out error writing data");
        }
        else /* if (ssl_err == SSL_ERROR_SSL) */ {
            /*
             * Log SSL errors
             */
            conn_rec *c = (conn_rec *)SSL_get_app_data(filter_ctx->pssl);
            ap_log_error(APLOG_MARK, APLOG_ERR, outctx->rc, c->base_server,
                    "SSL library out error writing data");
            ssl_log_ssl_error(APLOG_MARK, APLOG_ERR, c->base_server);

        }
        if (outctx->rc == APR_SUCCESS) {
            outctx->rc = APR_EGENERAL;
        }
    }
    else if ((apr_size_t)res != len) {
        conn_rec *c = f->c;
        char *reason = "reason unknown";

        /* XXX: probably a better way to determine this */
        if (SSL_total_renegotiations(filter_ctx->pssl)) {
            reason = "likely due to failed renegotiation";
        }

        ap_log_error(APLOG_MARK, APLOG_ERR, outctx->rc, c->base_server,
                     "failed to write %d of %d bytes (%s)",
                     len - (apr_size_t)res, len, reason);

        outctx->rc = APR_EGENERAL;
    }
    return outctx->rc;
}

static apr_status_t ssl_io_filter_Output(ap_filter_t *f,
                                         apr_bucket_brigade *bb)
{
    apr_status_t status = APR_SUCCESS;
    SSLFilterRec *filter_ctx = f->ctx;

    if (f->c->aborted) {
        apr_brigade_cleanup(bb);
        return APR_ECONNABORTED;
    }

    if (!filter_ctx->pssl) {
        /* ssl_abort() has been called */
        return ap_pass_brigade(f->next, bb);
    }

    if ((status = ssl_hook_process_connection(filter_ctx)) != APR_SUCCESS) {
        return status;
    }

    while (!APR_BRIGADE_EMPTY(bb)) {
        apr_bucket *bucket = APR_BRIGADE_FIRST(bb);

        /* If it is a flush or EOS, we need to pass this down. 
         * These types do not require translation by OpenSSL.  
         */
        if (APR_BUCKET_IS_EOS(bucket) || APR_BUCKET_IS_FLUSH(bucket)) {
            if (bio_filter_out_flush(filter_ctx->pbioWrite) < 0) {
                bio_filter_out_ctx_t *outctx = 
                       (bio_filter_out_ctx_t *)(filter_ctx->pbioWrite->ptr);
                status = outctx->rc;
                break;
            }

            if (APR_BUCKET_IS_EOS(bucket)) {
                /*
                 * By definition, nothing can come after EOS.
                 * which also means we can pass the rest of this brigade
                 * without creating a new one since it only contains the
                 * EOS bucket.
                 */

                if ((status = ap_pass_brigade(f->next, bb)) != APR_SUCCESS) {
                    return status;
                }
                break;
            }
            else {
                /* bio_filter_out_flush() already passed down a flush bucket
                 * if there was any data to be flushed.
                 */
                apr_bucket_delete(bucket);
            }
        }
        else {
            /* read filter */
            const char *data;
            apr_size_t len;
            
            status = apr_bucket_read(bucket, &data, &len, APR_BLOCK_READ);

            if (!APR_STATUS_IS_EOF(status) && (status != APR_SUCCESS)) {
                break;
            }

            status = ssl_filter_write(f, data, len);
            apr_bucket_delete(bucket);

            if (status != APR_SUCCESS) {
                break;
            }
        }
    }

    return status;
}
static apr_status_t ssl_io_filter_Input(ap_filter_t *f,
    /* XXX: we could actually move ssl_hook_process_connection to an
    status = ssl_hook_process_connection(inctx->filter_ctx);
static void ssl_io_input_add_filter(SSLFilterRec *filter_ctx, conn_rec *c,
static apr_status_t ssl_io_filter_cleanup (void *data)
{
    apr_status_t ret;
    SSLFilterRec *filter_ctx = (SSLFilterRec *)data;

    if (!filter_ctx->pssl) {
        /* already been shutdown */
        return APR_SUCCESS;
    }

    if ((ret = ssl_hook_CloseConnection(filter_ctx)) != APR_SUCCESS) {
        ap_log_error(APLOG_MARK, APLOG_ERR, ret, NULL,
                     "Error in ssl_hook_CloseConnection");
    }

    return ret;
}

    SSLFilterRec *filter_ctx;
    filter_ctx = apr_palloc(c->pool, sizeof(SSLFilterRec));
    ap_register_input_filter  (ssl_io_filter, ssl_io_filter_Input,  NULL, AP_FTYPE_CONNECTION + 5);
    ap_register_output_filter (ssl_io_filter, ssl_io_filter_Output, NULL, AP_FTYPE_CONNECTION + 5);
/*
 *  Close the SSL part of the socket connection
 *  (called immediately _before_ the socket is closed)
 */
/* XXX: perhaps ssl_abort() should call us or vice-versa
 * lot of the same happening in both places
 */
apr_status_t ssl_hook_CloseConnection(SSLFilterRec *filter)
{
    SSL *ssl = filter->pssl;
    const char *type = "";
    conn_rec *conn;
    SSLConnRec *sslconn;

    if (!ssl) {
        return APR_SUCCESS;
    }

    conn = (conn_rec *)SSL_get_app_data(ssl);
    sslconn = myConnConfig(conn);

    /*
     * Now close the SSL layer of the connection. We've to take
     * the TLSv1 standard into account here:
     *
     * | 7.2.1. Closure alerts
     * |
     * | The client and the server must share knowledge that the connection is
     * | ending in order to avoid a truncation attack. Either party may
     * | initiate the exchange of closing messages.
     * |
     * | close_notify
     * |     This message notifies the recipient that the sender will not send
     * |     any more messages on this connection. The session becomes
     * |     unresumable if any connection is terminated without proper
     * |     close_notify messages with level equal to warning.
     * |
     * | Either party may initiate a close by sending a close_notify alert.
     * | Any data received after a closure alert is ignored.
     * |
     * | Each party is required to send a close_notify alert before closing
     * | the write side of the connection. It is required that the other party
     * | respond with a close_notify alert of its own and close down the
     * | connection immediately, discarding any pending writes. It is not
     * | required for the initiator of the close to wait for the responding
     * | close_notify alert before closing the read side of the connection.
     *
     * This means we've to send a close notify message, but haven't to wait
     * for the close notify of the client. Actually we cannot wait for the
     * close notify of the client because some clients (including Netscape
     * 4.x) don't send one, so we would hang.
     */

    /*
     * exchange close notify messages, but allow the user
     * to force the type of handshake via SetEnvIf directive
     */
    switch (sslconn->shutdown_type) {
      case SSL_SHUTDOWN_TYPE_UNSET:
      case SSL_SHUTDOWN_TYPE_STANDARD:
        /* send close notify, but don't wait for clients close notify
           (standard compliant and safe, so it's the DEFAULT!) */
        SSL_set_shutdown(ssl, SSL_RECEIVED_SHUTDOWN);
        type = "standard";
        break;
      case SSL_SHUTDOWN_TYPE_UNCLEAN:
        /* perform no close notify handshake at all
           (violates the SSL/TLS standard!) */
        SSL_set_shutdown(ssl, SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
        type = "unclean";
        break;
      case SSL_SHUTDOWN_TYPE_ACCURATE:
        /* send close notify and wait for clients close notify
           (standard compliant, but usually causes connection hangs) */
        SSL_set_shutdown(ssl, 0);
        type = "accurate";
        break;
    }

    SSL_smart_shutdown(ssl);

    /* and finally log the fact that we've closed the connection */
    if (conn->base_server->loglevel >= APLOG_INFO) {
        ap_log_error(APLOG_MARK, APLOG_INFO, 0, conn->base_server,
                     "Connection to child %ld closed with %s shutdown"
                     "(server %s, client %s)",
                     conn->id, type,
                     ssl_util_vhostid(conn->pool, conn->base_server),
                     conn->remote_ip ? conn->remote_ip : "unknown");
    }

    /* deallocate the SSL connection */
    SSL_free(ssl);
    sslconn->ssl = NULL;
    filter->pssl = NULL; /* so filters know we've been shutdown */

    return APR_SUCCESS;
}

    /* If we have a saved brigade from a previous run, concat the passed
     * brigade with our saved brigade.  Otherwise just continue.
     */
    if (!APR_BRIGADE_EMPTY(ctx->bb)) {
        APR_BRIGADE_CONCAT(ctx->bb, bb);
        bb = ctx->bb;
    }
    apr_brigade_destroy(ctx->bb);
APR_DECLARE_OPTIONAL_FN(int, ssl_proxy_enable, (conn_rec *));
APR_DECLARE_OPTIONAL_FN(int, ssl_engine_disable, (conn_rec *));

/*                      _             _
 *  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
 * | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
 * | | | | | | (_) | (_| |   \__ \__ \ |
 * |_| |_| |_|\___/ \__,_|___|___/___/_|
 *                      |_____|
 *  mod_ssl.h
 *  Global header
 */
                             /* ``The Apache Group: a collection
                                  of talented individuals who are
                                  trying to perfect the art of
                                  never finishing something.''
                                             -- Rob Hartill         */
/*
 * Power up our brain...
 */

/* Apache headers */
#include "http_config.h"
#include "http_core.h"
#include "http_log.h"
#include "http_main.h"
#include "http_connection.h"
#include "http_request.h"
#include "http_protocol.h"
#include "util_script.h"
#include "util_filter.h"
#include "util_ebcdic.h"
#include "mpm.h"
#include "apr.h"
#include "apr_strings.h"
#define APR_WANT_STRFUNC
#include "apr_want.h"
#include "apr_tables.h"
#include "apr_lib.h"
#include "apr_fnmatch.h"
#include "apr_strings.h"
#include "apr_dbm.h"
#include "apr_rmm.h"
#include "apr_shm.h"
#include "apr_global_mutex.h"
#define MOD_SSL_VERSION AP_SERVER_BASEREVISION

/* mod_ssl headers */
#include "ssl_toolkit_compat.h"
#include "ssl_expr.h"
#include "ssl_util_ssl.h"

/* The #ifdef macros are only defined AFTER including the above
 * therefore we cannot include these system files at the top  :-(
 */
#if APR_HAVE_SYS_TIME_H
#include <sys/time.h>
#endif
#if APR_HAVE_UNISTD_H
#include <unistd.h> /* needed for STDIN_FILENO et.al., at least on FreeBSD */
#endif

/*
 * Provide reasonable default for some defines
 */
#ifndef FALSE
#define FALSE (0)
#endif
#ifndef TRUE
#define TRUE (!FALSE)
#endif
#ifndef PFALSE
#define PFALSE ((void *)FALSE)
#endif
#ifndef PTRUE
#define PTRUE ((void *)TRUE)
#endif
#ifndef UNSET
#define UNSET (-1)
#endif
#ifndef NUL
#define NUL '\0'
#endif
#ifndef RAND_MAX
#include <limits.h>
#define RAND_MAX INT_MAX
#endif

/*
 * Provide reasonable defines for some types
 */
#ifndef BOOL
#define BOOL unsigned int
#endif
#ifndef UCHAR
#define UCHAR unsigned char
#endif

/*
 * Provide useful shorthands
 */
#define strEQ(s1,s2)     (strcmp(s1,s2)        == 0)
#define strNE(s1,s2)     (strcmp(s1,s2)        != 0)
#define strEQn(s1,s2,n)  (strncmp(s1,s2,n)     == 0)
#define strNEn(s1,s2,n)  (strncmp(s1,s2,n)     != 0)

#define strcEQ(s1,s2)    (strcasecmp(s1,s2)    == 0)
#define strcNE(s1,s2)    (strcasecmp(s1,s2)    != 0)
#define strcEQn(s1,s2,n) (strncasecmp(s1,s2,n) == 0)
#define strcNEn(s1,s2,n) (strncasecmp(s1,s2,n) != 0)

#define strIsEmpty(s)    (s == NULL || s[0] == NUL)

#define myConnConfig(c) \
(SSLConnRec *)ap_get_module_config(c->conn_config, &ssl_module)
#define myCtxConfig(sslconn, sc) (sslconn->is_proxy ? sc->proxy : sc->server)
#define myConnConfigSet(c, val) \
ap_set_module_config(c->conn_config, &ssl_module, val)
#define mySrvConfig(srv) (SSLSrvConfigRec *)ap_get_module_config(srv->module_config,  &ssl_module)
#define myDirConfig(req) (SSLDirConfigRec *)ap_get_module_config(req->per_dir_config, &ssl_module)
#define myModConfig(srv) (mySrvConfig((srv)))->mc

#define myCtxVarSet(mc,num,val)  mc->rCtx.pV##num = val
#define myCtxVarGet(mc,num,type) (type)(mc->rCtx.pV##num)

/*
 * Defaults for the configuration
 */
#ifndef SSL_SESSION_CACHE_TIMEOUT
#define SSL_SESSION_CACHE_TIMEOUT  300
#endif

/*
 * Support for MM library
 */
#define SSL_MM_FILE_MODE ( APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD )

/*
 * Support for DBM library
 */
#define SSL_DBM_FILE_MODE ( APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD )

#if !defined(SSL_DBM_FILE_SUFFIX_DIR) && !defined(SSL_DBM_FILE_SUFFIX_PAG)
#if defined(DBM_SUFFIX)
#define SSL_DBM_FILE_SUFFIX_DIR DBM_SUFFIX
#define SSL_DBM_FILE_SUFFIX_PAG DBM_SUFFIX
#elif defined(__FreeBSD__) || (defined(DB_LOCK) && defined(DB_SHMEM))
#define SSL_DBM_FILE_SUFFIX_DIR ".db"
#define SSL_DBM_FILE_SUFFIX_PAG ".db"
#else
#define SSL_DBM_FILE_SUFFIX_DIR ".dir"
#define SSL_DBM_FILE_SUFFIX_PAG ".pag"
#endif
#endif

/*
 * Define the certificate algorithm types
 */

typedef int ssl_algo_t;

#define SSL_ALGO_UNKNOWN (0)
#define SSL_ALGO_RSA     (1<<0)
#define SSL_ALGO_DSA     (1<<1)
#define SSL_ALGO_ALL     (SSL_ALGO_RSA|SSL_ALGO_DSA)

#define SSL_AIDX_RSA     (0)
#define SSL_AIDX_DSA     (1)
#define SSL_AIDX_MAX     (2)


/*
 * Define IDs for the temporary RSA keys and DH params
 */

#define SSL_TMP_KEY_RSA_512  (0)
#define SSL_TMP_KEY_RSA_1024 (1)
#define SSL_TMP_KEY_DH_512   (2)
#define SSL_TMP_KEY_DH_1024  (3)
#define SSL_TMP_KEY_MAX      (4)

/*
 * Define the SSL options
 */
#define SSL_OPT_NONE           (0)
#define SSL_OPT_RELSET         (1<<0)
#define SSL_OPT_STDENVVARS     (1<<1)
#define SSL_OPT_COMPATENVVARS  (1<<2)
#define SSL_OPT_EXPORTCERTDATA (1<<3)
#define SSL_OPT_FAKEBASICAUTH  (1<<4)
#define SSL_OPT_STRICTREQUIRE  (1<<5)
#define SSL_OPT_OPTRENEGOTIATE (1<<6)
#define SSL_OPT_ALL            (SSL_OPT_STDENVVARS|SSL_OPT_COMPATENVVAR|SSL_OPT_EXPORTCERTDATA|SSL_OPT_FAKEBASICAUTH|SSL_OPT_STRICTREQUIRE|SSL_OPT_OPTRENEGOTIATE)
typedef int ssl_opt_t;

/*
 * Define the SSL Protocol options
 */
#define SSL_PROTOCOL_NONE  (0)
#define SSL_PROTOCOL_SSLV2 (1<<0)
#define SSL_PROTOCOL_SSLV3 (1<<1)
#define SSL_PROTOCOL_TLSV1 (1<<2)
#define SSL_PROTOCOL_ALL   (SSL_PROTOCOL_SSLV2|SSL_PROTOCOL_SSLV3|SSL_PROTOCOL_TLSV1)
typedef int ssl_proto_t;

/*
 * Define the SSL verify levels
 */
typedef enum {
    SSL_CVERIFY_UNSET           = UNSET,
    SSL_CVERIFY_NONE            = 0,
    SSL_CVERIFY_OPTIONAL        = 1,
    SSL_CVERIFY_REQUIRE         = 2,
    SSL_CVERIFY_OPTIONAL_NO_CA  = 3
} ssl_verify_t;

#define SSL_VERIFY_PEER_STRICT \
     (SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT)

#ifndef X509_V_ERR_CERT_UNTRUSTED
#define X509_V_ERR_CERT_UNTRUSTED 27
#endif

#define ssl_verify_error_is_optional(errnum) \
   ((errnum == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT) \
    || (errnum == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN) \
    || (errnum == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY) \
    || (errnum == X509_V_ERR_CERT_UNTRUSTED) \
    || (errnum == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE))

/*
 * Define the SSL pass phrase dialog types
 */
typedef enum {
    SSL_PPTYPE_UNSET   = UNSET,
    SSL_PPTYPE_BUILTIN = 0,
    SSL_PPTYPE_FILTER  = 1,
	SSL_PPTYPE_PIPE    = 2
} ssl_pphrase_t;

/*
 * Define the Path Checking modes
 */
#define SSL_PCM_EXISTS     1
#define SSL_PCM_ISREG      2
#define SSL_PCM_ISDIR      4
#define SSL_PCM_ISNONZERO  8
typedef unsigned int ssl_pathcheck_t;

/*
 * Define the SSL session cache modes and structures
 */
typedef enum {
    SSL_SCMODE_UNSET = UNSET,
    SSL_SCMODE_NONE  = 0,
    SSL_SCMODE_DBM   = 1,
    SSL_SCMODE_SHMCB = 3,
    SSL_SCMODE_DC    = 4
} ssl_scmode_t;

/*
 * Define the SSL mutex modes
 */
typedef enum {
    SSL_MUTEXMODE_UNSET  = UNSET,
    SSL_MUTEXMODE_NONE   = 0,
    SSL_MUTEXMODE_USED   = 1
} ssl_mutexmode_t;

/*
 * Define the SSL requirement structure
 */
typedef struct {
    char     *cpExpr;
    ssl_expr *mpExpr;
} ssl_require_t;

/*
 * Define the SSL random number generator seeding source
 */
typedef enum {
    SSL_RSCTX_STARTUP = 1,
    SSL_RSCTX_CONNECT = 2
} ssl_rsctx_t;
typedef enum {
    SSL_RSSRC_BUILTIN = 1,
    SSL_RSSRC_FILE    = 2,
    SSL_RSSRC_EXEC    = 3,
    SSL_RSSRC_EGD     = 4
} ssl_rssrc_t;
typedef struct {
    ssl_rsctx_t  nCtx;
    ssl_rssrc_t  nSrc;
    char        *cpPath;
    int          nBytes;
} ssl_randseed_t;

/*
 * Define the structure of an ASN.1 anything
 */
typedef struct {
    long int       nData;
    unsigned char *cpData;
    apr_time_t     source_mtime;
} ssl_asn1_t;

/*
 * Define the mod_ssl per-module configuration structure
 * (i.e. the global configuration for each httpd process)
 */

typedef enum {
    SSL_SHUTDOWN_TYPE_UNSET,
    SSL_SHUTDOWN_TYPE_STANDARD,
    SSL_SHUTDOWN_TYPE_UNCLEAN,
    SSL_SHUTDOWN_TYPE_ACCURATE
} ssl_shutdown_type_e;

typedef struct {
    SSL *ssl;
    const char *client_dn;
    X509 *client_cert;
    ssl_shutdown_type_e shutdown_type;
    const char *verify_info;
    const char *verify_error;
    int verify_depth;
    int is_proxy;
    int disabled;
    int non_ssl_request;
} SSLConnRec;

typedef struct {
    pid_t           pid;
    apr_pool_t     *pPool;
    BOOL            bFixed;
    int             nSessionCacheMode;
    char           *szSessionCacheDataFile;
    int             nSessionCacheDataSize;
    apr_shm_t      *pSessionCacheDataMM;
    apr_rmm_t      *pSessionCacheDataRMM;
    void           *tSessionCacheDataTable;
    ssl_mutexmode_t nMutexMode;
    apr_lockmech_e  nMutexMech;
    const char     *szMutexFile;
    apr_global_mutex_t   *pMutex;
    apr_array_header_t   *aRandSeed;
    apr_hash_t     *tVHostKeys;
    void           *pTmpKeys[SSL_TMP_KEY_MAX];
    apr_hash_t     *tPublicCert;
    apr_hash_t     *tPrivateKey;
#if defined(HAVE_OPENSSL_ENGINE_H) && defined(HAVE_ENGINE_INIT)
    const char     *szCryptoDevice;
#endif
    struct {
        void *pV1, *pV2, *pV3, *pV4, *pV5, *pV6, *pV7, *pV8, *pV9, *pV10;
    } rCtx;
} SSLModConfigRec;

/* public cert/private key */
typedef struct {
    /* 
     * server only has 1-2 certs/keys
     * 1 RSA and/or 1 DSA
     */
    const char  *cert_files[SSL_AIDX_MAX];
    const char  *key_files[SSL_AIDX_MAX];
    X509        *certs[SSL_AIDX_MAX];
    EVP_PKEY    *keys[SSL_AIDX_MAX];
} modssl_pk_server_t;

typedef struct {
    /* proxy can have any number of cert/key pairs */
    const char  *cert_file;
    const char  *cert_path;
    STACK_OF(X509_INFO) *certs;
} modssl_pk_proxy_t;

/* stuff related to authentication that can also be per-dir */
typedef struct {
    /* known/trusted CAs */
    const char  *ca_cert_path;
    const char  *ca_cert_file;

    const char  *cipher_suite;

    /* for client or downstream server authentication */
    int          verify_depth;
    ssl_verify_t verify_mode;
} modssl_auth_ctx_t;

typedef struct SSLSrvConfigRec SSLSrvConfigRec;

typedef struct {
    SSLSrvConfigRec *sc; /* pointer back to server config */
    SSL_CTX *ssl_ctx;

    /* we are one or the other */
    modssl_pk_server_t *pks;
    modssl_pk_proxy_t  *pkp;

    ssl_proto_t  protocol;

    /* config for handling encrypted keys */
    ssl_pphrase_t pphrase_dialog_type;
    const char   *pphrase_dialog_path;

    const char  *cert_chain;

    /* certificate revocation list */
    const char  *crl_path;
    const char  *crl_file;
    X509_STORE  *crl;

    modssl_auth_ctx_t auth;
} modssl_ctx_t;

struct SSLSrvConfigRec {
    SSLModConfigRec *mc;
    BOOL             enabled;
    BOOL             proxy_enabled;
    const char      *vhost_id;
    int              vhost_id_len;
    int              session_cache_timeout;
    modssl_ctx_t    *server;
    modssl_ctx_t    *proxy;
};

/*
 * Define the mod_ssl per-directory configuration structure
 * (i.e. the local configuration for all <Directory>
 *  and .htaccess contexts)
 */
typedef struct {
    BOOL          bSSLRequired;
    apr_array_header_t *aRequirement;
    ssl_opt_t     nOptions;
    ssl_opt_t     nOptionsAdd;
    ssl_opt_t     nOptionsDel;
    const char   *szCipherSuite;
    ssl_verify_t  nVerifyClient;
    int           nVerifyDepth;
    const char   *szCACertificatePath;
    const char   *szCACertificateFile;
} SSLDirConfigRec;

/*
 *  function prototypes
 */

/*  API glue structures  */
extern module AP_MODULE_DECLARE_DATA ssl_module;

/* "global" stuff */
extern const char ssl_valid_ssl_mutex_string[];

/*  configuration handling   */
SSLModConfigRec *ssl_config_global_create(server_rec *);
void         ssl_config_global_fix(SSLModConfigRec *);
BOOL         ssl_config_global_isfixed(SSLModConfigRec *);
void        *ssl_config_server_create(apr_pool_t *, server_rec *);
void        *ssl_config_server_merge(apr_pool_t *, void *, void *);
void        *ssl_config_perdir_create(apr_pool_t *, char *);
void        *ssl_config_perdir_merge(apr_pool_t *, void *, void *);
const char  *ssl_cmd_SSLMutex(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLPassPhraseDialog(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCryptoDevice(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLRandomSeed(cmd_parms *, void *, const char *, const char *, const char *);
const char  *ssl_cmd_SSLEngine(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCipherSuite(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCertificateFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCertificateKeyFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCertificateChainFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCACertificatePath(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCACertificateFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCARevocationPath(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLCARevocationFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLVerifyClient(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLVerifyDepth(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLSessionCache(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLSessionCacheTimeout(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProtocol(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLOptions(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLRequireSSL(cmd_parms *, void *);
const char  *ssl_cmd_SSLRequire(cmd_parms *, void *, const char *);

const char *ssl_cmd_SSLProxyEngine(cmd_parms *cmd, void *dcfg, int flag);
const char  *ssl_cmd_SSLProxyProtocol(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyCipherSuite(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyVerify(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyVerifyDepth(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyCACertificatePath(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyCACertificateFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyCARevocationPath(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyCARevocationFile(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyMachineCertificatePath(cmd_parms *, void *, const char *);
const char  *ssl_cmd_SSLProxyMachineCertificateFile(cmd_parms *, void *, const char *);

/*  module initialization  */
int          ssl_init_Module(apr_pool_t *, apr_pool_t *, apr_pool_t *, server_rec *);
void         ssl_init_Engine(server_rec *, apr_pool_t *);
void         ssl_init_ConfigureServer(server_rec *, apr_pool_t *, apr_pool_t *, SSLSrvConfigRec *);
void         ssl_init_CheckServers(server_rec *, apr_pool_t *);
STACK_OF(X509_NAME) 
            *ssl_init_FindCAList(server_rec *, apr_pool_t *, const char *, const char *);
void         ssl_init_Child(apr_pool_t *, server_rec *);
apr_status_t ssl_init_ModuleKill(void *data);

/*  Apache API hooks  */
int          ssl_hook_Translate(request_rec *);
int          ssl_hook_Auth(request_rec *);
int          ssl_hook_UserCheck(request_rec *);
int          ssl_hook_Access(request_rec *);
int          ssl_hook_Fixup(request_rec *);
int          ssl_hook_ReadReq(request_rec *);
int          ssl_hook_Upgrade(request_rec *);

/*  OpenSSL callbacks */
RSA         *ssl_callback_TmpRSA(SSL *, int, int);
DH          *ssl_callback_TmpDH(SSL *, int, int);
int          ssl_callback_SSLVerify(int, X509_STORE_CTX *);
int          ssl_callback_SSLVerify_CRL(int, X509_STORE_CTX *, conn_rec *);
int          ssl_callback_proxy_cert(SSL *ssl, MODSSL_CLIENT_CERT_CB_ARG_TYPE **x509, EVP_PKEY **pkey);
int          ssl_callback_NewSessionCacheEntry(SSL *, SSL_SESSION *);
SSL_SESSION *ssl_callback_GetSessionCacheEntry(SSL *, unsigned char *, int, int *);
void         ssl_callback_DelSessionCacheEntry(SSL_CTX *, SSL_SESSION *);
void         ssl_callback_LogTracingState(MODSSL_INFO_CB_ARG_TYPE, int, int);

/*  Session Cache Support  */
void         ssl_scache_init(server_rec *, apr_pool_t *);
void         ssl_scache_status_register(apr_pool_t *p);
void         ssl_scache_kill(server_rec *);
BOOL         ssl_scache_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
SSL_SESSION *ssl_scache_retrieve(server_rec *, UCHAR *, int);
void         ssl_scache_remove(server_rec *, UCHAR *, int);
void         ssl_scache_expire(server_rec *);

char        *ssl_scache_id2sz(UCHAR *, int);
void         ssl_scache_dbm_init(server_rec *, apr_pool_t *);
void         ssl_scache_dbm_kill(server_rec *);
BOOL         ssl_scache_dbm_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
SSL_SESSION *ssl_scache_dbm_retrieve(server_rec *, UCHAR *, int);
void         ssl_scache_dbm_remove(server_rec *, UCHAR *, int);
void         ssl_scache_dbm_expire(server_rec *);
void         ssl_scache_dbm_status(request_rec *r, int flags, apr_pool_t *pool);

void         ssl_scache_shmcb_init(server_rec *, apr_pool_t *);
void         ssl_scache_shmcb_kill(server_rec *);
BOOL         ssl_scache_shmcb_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
SSL_SESSION *ssl_scache_shmcb_retrieve(server_rec *, UCHAR *, int);
void         ssl_scache_shmcb_remove(server_rec *, UCHAR *, int);
void         ssl_scache_shmcb_expire(server_rec *);
void         ssl_scache_shmcb_status(request_rec *r, int flags, apr_pool_t *pool);

void         ssl_scache_dc_init(server_rec *, apr_pool_t *);
void         ssl_scache_dc_kill(server_rec *);
BOOL         ssl_scache_dc_store(server_rec *, UCHAR *, int, time_t, SSL_SESSION *);
SSL_SESSION *ssl_scache_dc_retrieve(server_rec *, UCHAR *, int);
void         ssl_scache_dc_remove(server_rec *, UCHAR *, int);
void         ssl_scache_dc_expire(server_rec *);
void         ssl_scache_dc_status(request_rec *r, int flags, apr_pool_t *pool);

/*  Pass Phrase Support  */
void         ssl_pphrase_Handle(server_rec *, apr_pool_t *);

/*  Diffie-Hellman Parameter Support  */
DH           *ssl_dh_GetTmpParam(int);
DH           *ssl_dh_GetParamFromFile(char *);

unsigned char *ssl_asn1_table_set(apr_hash_t *table,
                                  const char *key,
                                  long int length);

ssl_asn1_t *ssl_asn1_table_get(apr_hash_t *table,
                               const char *key);

void ssl_asn1_table_unset(apr_hash_t *table,
                          const char *key);

const char *ssl_asn1_keystr(int keytype);

const char *ssl_asn1_table_keyfmt(apr_pool_t *p,
                                  const char *id,
                                  int keytype);
/*  Mutex Support  */
int          ssl_mutex_init(server_rec *, apr_pool_t *);
int          ssl_mutex_reinit(server_rec *, apr_pool_t *);
int          ssl_mutex_on(server_rec *);
int          ssl_mutex_off(server_rec *);

/*  Logfile Support  */
void         ssl_die(void);
void         ssl_log_ssl_error(const char *, int, int, server_rec *);

/*  Variables  */
void         ssl_var_register(void);
char        *ssl_var_lookup(apr_pool_t *, server_rec *, conn_rec *, request_rec *, char *);
void         ssl_var_log_config_register(apr_pool_t *p);

/* Proxy Support */
int ssl_proxy_enable(conn_rec *c);
int ssl_engine_disable(conn_rec *c);
/*  I/O  */
void         ssl_io_filter_init(conn_rec *, SSL *);
void         ssl_io_filter_register(apr_pool_t *);
long         ssl_io_data_cb(BIO *, int, MODSSL_BIO_CB_ARG_TYPE *, int, long, long);

/*  PRNG  */
int          ssl_rand_seed(server_rec *, apr_pool_t *, ssl_rsctx_t, char *);

/*  Utility Functions  */
char        *ssl_util_vhostid(apr_pool_t *, server_rec *);
void         ssl_util_strupper(char *);
void         ssl_util_uuencode(char *, const char *, BOOL);
void         ssl_util_uuencode_binary(unsigned char *, const unsigned char *, int, BOOL);
apr_file_t  *ssl_util_ppopen(server_rec *, apr_pool_t *, const char *,
                             const char * const *);
void         ssl_util_ppclose(server_rec *, apr_pool_t *, apr_file_t *);
char        *ssl_util_readfilter(server_rec *, apr_pool_t *, const char *,
                                 const char * const *);
BOOL         ssl_util_path_check(ssl_pathcheck_t, const char *, apr_pool_t *);
ssl_algo_t   ssl_util_algotypeof(X509 *, EVP_PKEY *); 
char        *ssl_util_algotypestr(ssl_algo_t);
char        *ssl_util_ptxtsub(apr_pool_t *, const char *, const char *, char *);
void         ssl_util_thread_setup(apr_pool_t *);
int          ssl_init_ssl_connection(conn_rec *c);


#define APR_SHM_MAXSIZE (64 * 1024 * 1024)
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
 * $Header: /home/striker/cvs2svn/dumps/httpd-2.0/../../httpd-2.0/modules/ssl/ssl_expr_scan.c,v 1.18 2004/02/09 20:29:22 nd Exp $
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
#include "mod_ssl.h"
        if (ap_proxy_isvalidenc(url, NULL) != APR_SUCCESS) {
            return HTTP_BAD_REQUEST;
        }
apr_inline void ap_sync_scoreboard_image(void);
    ap_sync_scoreboard_image();
static int ap_threads_per_child = 0;
extern int ap_threads_per_child;
extern int ap_extended_status;



static void setup_shared_mem(apr_pool_t *p)
    apr_register_cleanup(p, NULL, ap_cleanup_shared_mem, apr_null_cleanup);
void reopen_scoreboard(apr_pool_t *p)
#endif   /* APR_SHARED_MEM */
/* Called by parent process */
void reinit_scoreboard(apr_pool_t *p)
        setup_shared_mem(p);
apr_inline void ap_sync_scoreboard_image(void)
    backrefinfo *briRR;
    backrefinfo *briRC;
            backrefinfo *bri = (*p == '$') ? ctx->briRR : ctx->briRC;
            if (bri && n <= bri->nsub
            ctx->briRC->source = input;
            ctx->briRC->nsub   = p->regexp->re_nsub;
            memcpy(ctx->briRC->regmatch, regmatch, sizeof(regmatch));
 *  Apply a single RewriteRule
    char *uri;
    char *output;
    char *newuri;
    regex_t *regexp;
    rewritecond_entry *c;
    int i;
    int rc;
    char *perdir = ctx->perdir;
    /*
     *  Initialisation
     */
    uri     = r->filename;
    regexp  = p->regexp;
    output  = p->output;
    /*
     *  Add (perhaps splitted away) PATH_INFO postfix to URL to
     *  make sure we really match against the complete URL.
     */
    if (perdir != NULL && r->path_info != NULL && r->path_info[0] != '\0') {
        rewritelog((r, 3, perdir, "add path info postfix: %s -> %s%s",
                    uri, uri, r->path_info));
        uri = apr_pstrcat(r->pool, uri, r->path_info, NULL);
    }
    /*
     *  On per-directory context (.htaccess) strip the location
     *  prefix from the URL to make sure patterns apply only to
     *  the local part.  Additionally indicate this special
     *  threatment in the logfile.
     */
    if (perdir) {
        if (   strlen(uri) >= strlen(perdir)
            && strncmp(uri, perdir, strlen(perdir)) == 0) {
            rewritelog((r, 3, perdir, "strip per-dir prefix: %s -> %s",
                        uri, uri+strlen(perdir)));
            uri = uri+strlen(perdir);
    /*
     *  Try to match the URI against the RewriteRule pattern
     *  and exit immeddiately if it didn't apply.
    rewritelog((r, 3, perdir, "applying pattern '%s' to uri '%s'", p->pattern,
                uri));
    rc = (ap_regexec(regexp, uri, regexp->re_nsub+1, regmatch, 0) == 0);
    /*
     * init context data for this particular rule
    ctx->uri       = uri;
    ctx->briRR = apr_palloc(r->pool, sizeof(*ctx->briRR));
    if (!rc && (p->flags & RULEFLAG_NOTMATCH)) {
        /* empty info on negative patterns  */
        ctx->briRR->source = "";
        ctx->briRR->nsub   = 0;
        ctx->briRR->source = apr_pstrdup(r->pool, uri);
        ctx->briRR->nsub   = regexp->re_nsub;
        memcpy((void *)(ctx->briRR->regmatch), (void *)(regmatch),
               sizeof(regmatch));
    ctx->briRC = apr_pcalloc(r->pool, sizeof(*ctx->briRC));
    ctx->briRC->source = "";
    ctx->briRC->nsub   = 0;

    /*
     *  Ok, we already know the pattern has matched, but we now
     *  additionally have to check for all existing preconditions
     *  (RewriteCond) which have to be also true. We do this at
     *  this very late stage to avoid unnessesary checks which
     *  would slow down the rewriting engine!!
    for (i = 0; i < rewriteconds->nelts; i++) {
        c = &conds[i];
            /*
             *  The "OR" case
             */
            if (rc == 0) {
                /*  One condition is false, but another can be
                 *  still true, so we have to continue...
                 */
                /*  One true condition is enough in "or" case, so
                 *  skip the other conditions which are "ornext"
                 *  chained
                 */
                    i++;
                    c = &conds[i];
        else {
            /* The "AND" case, i.e. no "or" flag,
             * so a single failure means total failure.
             */
            if (rc == 0) {
                return 0;
            }
    /*
     *  If this is a pure matching rule (`RewriteRule <pat> -')
     *  we stop processing and return immediately. The only thing
     *  we have not to forget are the environment variables and
     *  cookies:
     *  (`RewriteRule <pat> - [E=...,CO=...,T=...]')
     */
    if (output[0] == '-' && !output[1]) {
        do_expand_env(p->env, ctx);
        do_expand_cookie(p->cookie, ctx);
            rewritelog((r, 2, perdir, "remember %s to have MIME-type '%s'",
    /*
     *  Ok, now we finally know all patterns have matched and
     *  that there is something to replace, so we create the
     *  substitution URL string in `newuri'.
     */
    newuri = do_expand(output, ctx);
    rewritelog((r, 2, perdir, "rewrite %s -> %s", uri, newuri));

    /*
     *  Additionally do expansion for the environment variable
     *  strings (`RewriteRule .. .. [E=<string>]').
     */
    do_expand_env(p->env, ctx);

    /*
     *  Also set cookies for any cookie strings
     *  (`RewriteRule .. .. [CO=<string>]').
     */
    do_expand_cookie(p->cookie, ctx);

    /*
     *  Now replace API's knowledge of the current URI:
     *  Replace r->filename with the new URI string and split out
     *  an on-the-fly generated QUERY_STRING part into r->args
     */
    r->filename = apr_pstrdup(r->pool, newuri);
    /*
     *   Add the previously stripped per-directory location
     *   prefix if the new URI is not a new one for this
     *   location, i.e. if it's not an absolute URL (!) path nor
     *   a fully qualified URL scheme.
    if (perdir && *r->filename != '/' && !is_absolute_uri(r->filename)) {
        rewritelog((r, 3, perdir, "add per-dir prefix: %s -> %s%s",
                    r->filename, perdir, r->filename));
        r->filename = apr_pstrcat(r->pool, perdir, r->filename, NULL);
    /*
     *  If this rule is forced for proxy throughput
     *  (`RewriteRule ... ... [P]') then emulate mod_proxy's
     *  URL-to-filename handler to be sure mod_proxy is triggered
     *  for this URL later in the Apache API. But make sure it is
     *  a fully-qualified URL. (If not it is qualified with
     *  ourself).
        rewritelog((r, 2, perdir, "forcing proxy-throughput with %s",
    /*
     *  If this rule is explicitly forced for HTTP redirection
     *  (`RewriteRule .. .. [R]') then force an external HTTP
     *  redirect. But make sure it is a fully-qualified URL. (If
     *  not it is qualified with ourself).
        rewritelog((r, 2, perdir, "explicitly forcing redirect with %s",
    /*
     *  Special Rewriting Feature: Self-Reduction
     *  We reduce the URL by stripping a possible
     *  http[s]://<ourhost>[:<port>] prefix, i.e. a prefix which
     *  corresponds to ourself. This is to simplify rewrite maps
     *  and to avoid recursion, etc. When this prefix is not a
     *  coincidence then the user has to use [R] explicitly (see
     *  above).
    /*
     *  If this rule is still implicitly forced for HTTP
     *  redirection (`RewriteRule .. <scheme>://...') then
     *  directly force an external HTTP redirect.
        rewritelog((r, 2, perdir, "implicitly forcing redirect (rc=%d) with %s",
                    p->forced_responsecode, r->filename));
    /*
     *  Finally we had to remember if a MIME-type should be
     *  forced for this URL (`RewriteRule .. .. [T=<type>]')
     *  Later in the API processing phase this is forced by our
     *  MIME API-hook function. This time it's no problem even for
     *  the per-directory context (where the MIME-type hook was
     *  already processed) because a sub-request happens ;-)
     */
    if (p->forced_mimetype != NULL) {
        apr_table_setn(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR,
                      p->forced_mimetype);
        
        rewritelog((r, 2, perdir, "remember %s to have MIME-type '%s'",
    /*
     *  Puuhhhhhhhh... WHAT COMPLICATED STUFF ;_)
     *  But now we're done for this particular rule.
                (!(verify_old & SSL_VERIFY_PEER_STRICT) &&
                  (verify     & SSL_VERIFY_PEER_STRICT)))
    imap_conf_rec *new = (imap_conf_rec *) apr_pcalloc(p, sizeof(imap_conf_rec));
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted") && *comment) {
    if (!strcasecmp(menu, "unformatted") && *comment) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
    if (!strcasecmp(menu, "semiformatted")) {
    if (!strcasecmp(menu, "unformatted")) {
#include "apr_lib.h"
#include "http_log.h"
static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    const char *pro;
 
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len;
 
    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */
 
    while ((len = ap_getline(l, sizeof(l), r, 0)) <= 0) {
        if (len < 0) {             /* includes EOF */
            /* this is a hack to make sure that request time is set,
             * it's not perfect, but it's better than nothing
             */
            r->request_time = apr_time_now();
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */
 
    /* XXX - sigwait doesn't work if the signal has been SIG_IGNed (under
     * linux 2.0 w/ glibc 2.0, anyway), and this step isn't necessary when
     * we're running a sigwait thread anyway. If/when unthreaded mode is
     * put back in, we should make sure to ignore this signal iff a sigwait
     * thread isn't used. - mvsk
 
#ifdef SIGWINCH
    apr_signal(SIGWINCH, SIG_IGN);
#endif
    */
 
    r->request_time = apr_time_now();
    r->the_request = apr_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);
 
#if 0
/* XXX If we want to keep track of the Method, the protocol module should do
 * it.  That support isn't in the scoreboard yet.  Hopefully next week
 * sometime.   rbb */
    ap_update_connection_status(AP_CHILD_THREAD_FROM_ID(conn->id), "Method", r->method);
#endif
    uri = ap_getword_white(r->pool, &ll);
 
    /* Provide quick information about the request method as soon as known */
 
    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }
 
    ap_parse_uri(r, uri);
 
    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = apr_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }
 
    if (ll[0]) {
        r->assbackwards = 0;
        pro = ll;
        len = strlen(ll);
    } else {
        r->assbackwards = 1;
        pro = "HTTP/0.9";
        len = 8;
    }
    r->protocol = apr_pstrndup(r->pool, pro, len);
 
    /* XXX ap_update_connection_status(conn->id, "Protocol", r->protocol); */
 
    /* Avoid sscanf in the common case */
    if (len == 8 &&
        pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P' &&
        pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.' &&
        apr_isdigit(pro[7])) {
        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
    } else if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
               && minor < HTTP_VERSION(1,0))    /* don't allow HTTP/0.1000 */
        r->proto_num = HTTP_VERSION(major, minor);
    else
        r->proto_num = HTTP_VERSION(1,0);
 
    return 1;
}

static int http_create_request(request_rec *r)
{
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
    int keptalive;

    hconn = apr_pcalloc(r->pool, sizeof(*hconn));
    ap_set_module_config(r->connection->conn_config, &http_module, hconn);

    if (!r->main && !r->prev && !r->next) {
        keptalive = r->connection->keepalive == 1;
        r->connection->keepalive    = 0;
 
        /* XXX can we optimize these timeouts at all? gstein */
        apr_setsocketopt(r->connection->client_socket, APR_SO_TIMEOUT,
                         (int)(keptalive
                         ? r->server->keep_alive_timeout * APR_USEC_PER_SEC
                         : r->server->timeout * APR_USEC_PER_SEC));
 
        /* Get the request... */
        if (!read_request_line(r)) {
            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, r,
                              "request failed: URI too long");
                ap_send_error_response(r, 0);
                ap_run_log_transaction(r);
                return OK;
            }
            return DONE;
        }
        if (keptalive) {
            apr_setsocketopt(r->connection->client_socket,
                             APR_SO_TIMEOUT,
                             (int)(r->server->timeout * APR_USEC_PER_SEC));
        }
    }
    return OK;
}

    ap_hook_create_request(http_create_request, NULL, NULL, APR_HOOK_MIDDLE);
    ap_http_conn_rec *hconn = ap_get_module_config(r->connection->conn_config, &http_module);
	    || (r->server->keep_alive_max > hconn->keepalives))
        int left = r->server->keep_alive_max - hconn->keepalives;
        hconn->keepalives++;
typedef struct ap_http_conn_rec ap_http_conn_rec;

struct ap_http_conn_rec {
    /** How many times have we used it? */
    int keepalives;
};

AP_DECLARE_DATA extern module http_module;

#include "mod_core.h"
    if (ap_run_create_request(r) != OK) {
        return NULL;
    }
        apr_setsocketopt(csd, APR_INCOMPLETE_READ, 1);
        && (rv = apr_setsocketopt(sock, APR_SO_RCVBUF,
                                  conf->recv_buffer_size))) {
                      "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
    if (APR_SUCCESS != (rv = apr_setsocketopt(sock, APR_SO_REUSEADDR, one))) {
                      "proxy: FTP: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
                if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(data_sock, APR_SO_RCVBUF,
                                                 conf->recv_buffer_size))) {
                                  "proxy: FTP: setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
                if (conf->recv_buffer_size > 0 && (rv = apr_setsocketopt(data_sock, APR_SO_RCVBUF,
                                                 conf->recv_buffer_size))) {
                                  "proxy: FTP: setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
        if ((rv = apr_setsocketopt(local_sock, APR_SO_REUSEADDR, one)) != APR_SUCCESS) {
            (rv = apr_setsocketopt(*newsock, APR_SO_RCVBUF,
                                   conf->recv_buffer_size))) {
                         "setsockopt(SO_RCVBUF): Failed to set "
    apr_setsocketopt(csd, APR_INCOMPLETE_READ, 1);
    stat = apr_setsocketopt(s, APR_SO_REUSEADDR, one);
                      "make_sock: for address %pI, setsockopt: (SO_REUSEADDR)",
    stat = apr_setsocketopt(s, APR_SO_KEEPALIVE, one);
                      "make_sock: for address %pI, setsockopt: (SO_KEEPALIVE)",
        stat = apr_setsocketopt(s, APR_SO_SNDBUF,  send_buffer_size);
    stat = apr_setsocketopt(s, APR_SO_REUSEADDR, one);
                    "make_sock: for address %pI, setsockopt: (SO_REUSEADDR)", 
        apr_setsocketopt(lr->sd, APR_SO_NONBLOCK, 1);
                apr_setsocketopt(csd, APR_SO_NONBLOCK, 0);
        apr_setsocketopt(lr->sd, APR_SO_NONBLOCK, 1);
            apr_getsocketopt(context->sock, APR_SO_DISCONNECTED, &disconnected);
    apr_status_t status = apr_setsocketopt(s, APR_TCP_NODELAY, 1);
                     "setsockopt: (TCP_NODELAY)");
	    apr_setsocketopt(c->aprsock, APR_SO_TIMEOUT, 0);
    if ((rv = apr_setsocketopt(c->aprsock, APR_SO_NONBLOCK, 1))
	printf("This is ApacheBench, Version %s\n", AP_AB_BASEREVISION " <$Revision: 1.110 $> apache-2.0");
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-2.0<br>\n", AP_AB_BASEREVISION, "$Revision: 1.110 $");
module AP_MODULE_DECLARE_DATA imap_module;
    icr = ap_get_module_config(r->per_dir_config, &imap_module);
module AP_MODULE_DECLARE_DATA imap_module =
    rnew->headers_in      = r->headers_in;
#define MODULE_MAGIC_NUMBER_MINOR 2                 /* 0...n */
            if (access_status == OK) {
                ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,
                              "request authorized without authentication by "
                              "access_checker_ex hook: %s", r->uri);
            }
            else if (access_status != DECLINED) {
                return decl_die(access_status, "check access", r);
            }
            else {
            if (access_status == OK) {
                ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,
                              "request authorized without authentication by "
                              "access_checker_ex hook: %s", r->uri);
            }
            else if (access_status != DECLINED) {
                return decl_die(access_status, "check access", r);
            }
            else {
int ap_proxy_ajp_canon(request_rec *r, char *url);
int ap_proxy_ajp_handler(request_rec *r, proxy_server_conf *conf,
                          char *url, const char *proxyname, 
                          apr_port_t proxyport);

typedef struct {
    const char     *name;
    apr_port_t      port;
    apr_sockaddr_t *addr;
    apr_socket_t   *sock;
    int             close;
    void           *data;  /* To store ajp data */
} proxy_ajp_conn_t;

static apr_status_t ap_proxy_ajp_cleanup(request_rec *r,
                                          proxy_ajp_conn_t *p_conn,
                                          proxy_conn_rec *backend);

static
apr_status_t ap_proxy_http_determine_connection(apr_pool_t *p, request_rec *r,
                                                proxy_ajp_conn_t *p_conn,
                                                conn_rec *c,
                                                proxy_server_conf *conf,
                                                apr_uri_t *uri,
                                                char **url,
                                                const char *proxyname,
                                                apr_port_t proxyport,
                                                char *server_portstr,
                                                int server_portstr_size) {
    int server_port;
    apr_status_t err;
    apr_sockaddr_t *uri_addr;
    /*
     * Break up the URL to determine the host to connect to
     */

    /* we break the URL into host, port, uri */
    if (APR_SUCCESS != apr_uri_parse(p, *url, uri)) {
        return ap_proxyerror(r, HTTP_BAD_REQUEST,
                             apr_pstrcat(p,"URI cannot be parsed: ", *url,
                                         NULL));
    }
    if (!uri->port) {
        uri->port = apr_uri_port_of_scheme(uri->scheme);
    }

    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                 "proxy: AJP connecting %s to %s:%d", *url, uri->hostname,
                 uri->port);

    /* do a DNS lookup for the destination host */
    /* see memory note above */
    err = apr_sockaddr_info_get(&uri_addr, apr_pstrdup(c->pool, uri->hostname),
                                APR_UNSPEC, uri->port, 0, c->pool);

    /* allocate these out of the connection pool - the check on
     * r->connection->id makes sure that this string does not get accessed
     * past the connection lifetime */
    /* are we connecting directly, or via a proxy? */
    if (proxyname) {
        p_conn->name = apr_pstrdup(c->pool, proxyname);
        p_conn->port = proxyport;
        /* see memory note above */
        err = apr_sockaddr_info_get(&p_conn->addr, p_conn->name, APR_UNSPEC,
                                    p_conn->port, 0, c->pool);
    } else {
        p_conn->name = apr_pstrdup(c->pool, uri->hostname);
        p_conn->port = uri->port;
        p_conn->addr = uri_addr;
        *url = apr_pstrcat(p, uri->path, uri->query ? "?" : "",
                           uri->query ? uri->query : "",
                           uri->fragment ? "#" : "",
                           uri->fragment ? uri->fragment : "", NULL);
    }

    if (err != APR_SUCCESS) {
        return ap_proxyerror(r, HTTP_BAD_GATEWAY,
                             apr_pstrcat(p, "DNS lookup failure for: ",
                                         p_conn->name, NULL));
    }

    /* Get the server port for the Via headers */
    {
        server_port = ap_get_server_port(r);
        if (ap_is_default_port(server_port, r)) {
            strcpy(server_portstr,"");
        } else {
            apr_snprintf(server_portstr, server_portstr_size, ":%d",
                         server_port);
        }
    }

    /* check if ProxyBlock directive on this host */
    if (OK != ap_proxy_checkproxyblock(r, conf, uri_addr)) {
        return ap_proxyerror(r, HTTP_FORBIDDEN,
                             "Connect to remote machine blocked");
    }
    return OK;
}

static
apr_status_t ap_proxy_http_create_connection(apr_pool_t *p, request_rec *r,
                                             proxy_ajp_conn_t *p_conn,
                                             conn_rec *c, conn_rec **origin,
                                             proxy_conn_rec *backend,
                                             proxy_server_conf *conf,
                                             const char *proxyname) {
    int failed = 0, new_conn = 0;
    apr_socket_t *client_socket = NULL;

    /* We have determined who to connect to. Now make the connection, supporting
     * a KeepAlive connection.
     */

    /* get all the possible IP addresses for the destname and loop through them
     * until we get a successful connection
     */

    /* if a keepalive socket is already open, check whether it must stay
     * open, or whether it should be closed and a new socket created.
     */
    /* see memory note above */
    if (backend->connection) {
        client_socket = ap_get_module_config(backend->connection->conn_config, &core_module);
        if ((backend->connection->id == c->id) &&
            (backend->port == p_conn->port) &&
            (backend->hostname) &&
            (!apr_strnatcasecmp(backend->hostname, p_conn->name))) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                         "proxy: keepalive address match (keep original socket)");
        } else {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                         "proxy: keepalive address mismatch / connection has"
                         " changed (close old socket (%s/%s, %d/%d))", 
                         p_conn->name, backend->hostname, p_conn->port,
                         backend->port);
            apr_socket_close(client_socket);
            backend->connection = NULL;
        }
    }

    /* get a socket - either a keepalive one, or a new one */
    new_conn = 1;
    if ((backend->connection) && (backend->connection->id == c->id)) {
        apr_size_t buffer_len = 1;
        char test_buffer[1]; 
        apr_status_t socket_status;
        apr_interval_time_t current_timeout;

        /* use previous keepalive socket */
        *origin = backend->connection;
        p_conn->sock = client_socket;
        new_conn = 0;

        /* save timeout */
        apr_socket_timeout_get(p_conn->sock, &current_timeout);
        /* set no timeout */
        apr_socket_timeout_set(p_conn->sock, 0);
        socket_status = apr_socket_recv(p_conn->sock, test_buffer, &buffer_len);
        /* put back old timeout */
        apr_socket_timeout_set(p_conn->sock, current_timeout);
        if ( APR_STATUS_IS_EOF(socket_status) ) {
            ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,
                         "proxy: AJP: previous connection is closed");
            new_conn = 1;
        }
    }
    if (new_conn) {

        /* create a new socket */
        backend->connection = NULL;

        /*
         * At this point we have a list of one or more IP addresses of
         * the machine to connect to. If configured, reorder this
         * list so that the "best candidate" is first try. "best
         * candidate" could mean the least loaded server, the fastest
         * responding server, whatever.
         *
         * For now we do nothing, ie we get DNS round robin.
         * XXX FIXME
         */
        failed = ap_proxy_connect_to_backend(&p_conn->sock, "AJP",
                                             p_conn->addr, p_conn->name,
                                             conf, r->server, c->pool);

        /* handle a permanent error on the connect */
        if (failed) {
            if (proxyname) {
                return DECLINED;
            } else {
                return HTTP_BAD_GATEWAY;
            }
        }

        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "proxy: socket is connected");

        /* the socket is now open, create a new backend server connection */
        *origin = ap_run_create_connection(c->pool, r->server, p_conn->sock,
                                           r->connection->id,
                                           r->connection->sbh, c->bucket_alloc);
        if (!*origin) {
        /* the peer reset the connection already; ap_run_create_connection() 
         * closed the socket
         */
            ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                         r->server, "proxy: an error occurred creating a "
                         "new connection to %pI (%s)", p_conn->addr,
                         p_conn->name);
            apr_socket_close(p_conn->sock);
            return HTTP_INTERNAL_SERVER_ERROR;
        }
        backend->connection = *origin;
        backend->hostname = apr_pstrdup(c->pool, p_conn->name);
        backend->port = p_conn->port;

        if (backend->is_ssl) {
            if (!ap_proxy_ssl_enable(backend->connection)) {
                ap_log_error(APLOG_MARK, APLOG_ERR, 0,
                             r->server, "proxy: failed to enable ssl support "
                             "for %pI (%s)", p_conn->addr, p_conn->name);
                return HTTP_INTERNAL_SERVER_ERROR;
            }
        }
        else {
            ap_proxy_ssl_disable(backend->connection);
        }

        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                     "proxy: connection complete to %pI (%s)",
                     p_conn->addr, p_conn->name);

        /* set up the connection filters */
        ap_run_pre_connection(*origin, p_conn->sock);
    }
    return OK;
}


                                   proxy_ajp_conn_t *p_conn, conn_rec *origin, 
    status = ajp_send_header(p_conn->sock,r);
                     p_conn->addr, p_conn->name);
            status = ajp_send_data_msg(p_conn->sock, r, msg, bufsiz);
                             p_conn->addr, p_conn->name);
    status = ajp_read_header(p_conn->sock, r,
                             (ajp_msg_t **)&(p_conn->data));
                     p_conn->addr, p_conn->name);
    result = ajp_parse_type(r, p_conn->data);
                     p_conn->addr, p_conn->name);
                                            proxy_ajp_conn_t *p_conn,
    type = ajp_parse_type(r, p_conn->data);
            status = ajp_parse_header(r, p_conn->data); 
        } else if  (type == CMD_AJP13_SEND_BODY_CHUNK) {
            status = ajp_parse_data(r, p_conn->data, &size, &buff);
        } else {
        status = ajp_read_header(p_conn->sock, r,
                                 (ajp_msg_t **)&(p_conn->data));
        type = ajp_parse_type(r, p_conn->data);
                      "server %s:%d", p_conn->name, p_conn->port);
static
apr_status_t ap_proxy_ajp_cleanup(request_rec *r, proxy_ajp_conn_t *p_conn,
                                   proxy_conn_rec *backend) {
    /* If the connection has been signalled
     * to close, close the socket and clean up
     */

    /* if the connection is < HTTP/1.1, or Connection: close,
     * we close the socket, otherwise we leave it open for KeepAlive support
     */
    if (p_conn->close) {
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                      "ap_proxy_ajp_cleanup closing");
        if (p_conn->sock) {
            apr_socket_close(p_conn->sock);
            p_conn->sock = NULL;
            backend->connection = NULL;
        }
    }
    return OK;
}

int ap_proxy_ajp_handler(request_rec *r, proxy_server_conf *conf,
                          char *url, const char *proxyname, 
                          apr_port_t proxyport)
    proxy_ajp_conn_t *p_conn = apr_pcalloc(r->connection->pool,
                                           sizeof(*p_conn));
    /* only use stored info for top-level pages. Sub requests don't share 
     * in keepalives
     */
    if (!r->main) {
        backend = (proxy_conn_rec *) ap_get_module_config(c->conn_config,
                                                      &proxy_ajp_module);
    }
    /* create space for state information */
    if (!backend) {
        backend = apr_pcalloc(c->pool, sizeof(proxy_conn_rec));
        backend->connection = NULL;
        backend->hostname = NULL;
        backend->port = 0;
        if (!r->main) {
            ap_set_module_config(c->conn_config, &proxy_ajp_module, backend);
        }
    }

    
        backend = apr_pcalloc(c->pool, sizeof(proxy_conn_rec));
        backend->connection = NULL;
        backend->hostname = NULL;
        backend->port = 0;
    backend->is_ssl = is_ssl;
    status = ap_proxy_http_determine_connection(p, r, p_conn, c, conf, uri,
                                                &url, proxyname, proxyport,
                                                server_portstr,
                                                sizeof(server_portstr));
    if ( status != OK ) {
        return status;
    }
    status = ap_proxy_http_create_connection(p, r, p_conn, c, &origin, backend,
                                             conf, proxyname);
    if ( status != OK ) {
        return status;
    /* Step Three: Send the Request */
    status = ap_proxy_ajp_request(p, r, p_conn, origin, conf, uri, url,
                                   server_portstr);
    if ( status != OK ) {
        p_conn->close++;
        ap_proxy_ajp_cleanup(r, p_conn, backend);
        return status;
    }

    /* Step Four: Receive the Response */
    status = ap_proxy_ajp_process_response(p, r, p_conn, origin, backend,
    if ( status != OK ) {
        /* clean up even if there is an error */
        p_conn->close++;
        ap_proxy_ajp_cleanup(r, p_conn, backend);
        return status;
    }

    /* Step Five: Clean Up */
    status = ap_proxy_ajp_cleanup(r, p_conn, backend);
    if ( status != OK ) {
        return status;
    }

    return OK;
    int save_errno = errno;
    err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, errcode, errstr);
    err->save_errno = save_errno;
                                 DAV_ERR_PROP_BAD_MAJOR,
                                 DAV_ERR_PROP_BAD_MAJOR,
                             HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN,
        return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN,
                             DAV_ERR_LOCK_NO_DB,
                             HTTP_INTERNAL_SERVER_ERROR, 0,
                                 DAV_ERR_LOCK_CORRUPT_DB,
                         DAV_ERR_LOCK_CORRUPT_DB,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
    if (apr_file_read(file, pbuf->buf, &amt) != APR_SUCCESS
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        if (apr_file_remove(pathname, p) != 0) {
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
    if (apr_file_open(&file, pathname,
                APR_WRITE | APR_CREATE | APR_TRUNCATE | APR_BINARY,
                APR_OS_DEFAULT, p) != APR_SUCCESS) {
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
    if (apr_file_write(file, pbuf->buf, &amt) != APR_SUCCESS
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
                             HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(ctx->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
            if (apr_file_perms_set(dst, perms)) {
                return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
    if ((apr_file_open(&inf, src, APR_READ | APR_BINARY, APR_OS_DEFAULT, p))
            != APR_SUCCESS) {
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(p, MAP_IO2HTTP(status), 0,
            if (apr_file_remove(dst, p) != APR_SUCCESS) {
                return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            if (apr_file_remove(dst, p) != APR_SUCCESS) {
            return dav_new_error(p, MAP_IO2HTTP(status), 0,
        int save_errno = errno;   /* save the errno that got us here */
             err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            err->save_errno = save_errno;
        else if (apr_file_remove(dst, p) != APR_SUCCESS) {
            /* Note that we use the latest errno */
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        err->save_errno = save_errno;
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
                return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
        return dav_new_error(p, MAP_IO2HTTP(rv), 0,
            if (apr_file_remove(stream->pathname, stream->p) != APR_SUCCESS) {
            return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, rv,
        return dav_new_error(stream->p, HTTP_INSUFFICIENT_STORAGE, 0,
        return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0,
    if (apr_file_seek(stream->f, APR_SET, &abs_pos) != APR_SUCCESS) {
        return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(pool, HTTP_CONFLICT, 0,
        return dav_new_error(pool, HTTP_CONFLICT, 0,
        return dav_new_error(pool, HTTP_FORBIDDEN, 0,
        return dav_new_error(pool, HTTP_FORBIDDEN, 0,
        return dav_new_error(ctx->pool, HTTP_INSUFFICIENT_STORAGE, 0,
        return dav_new_error(ctx->pool, HTTP_CONFLICT, 0,
        return dav_new_error(ctx->pool, HTTP_FORBIDDEN, 0,
            if (apr_dir_make(dstinfo->pathname, APR_OS_DEFAULT,
                             ctx->pool) != APR_SUCCESS) {
                err = dav_new_error(ctx->pool, HTTP_FORBIDDEN, 0, NULL);
            return dav_new_error(src->info->pool, HTTP_MULTI_STATUS, 0,
        return dav_new_error(src->info->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(src->info->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(srcinfo->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(info->pool, HTTP_MULTI_STATUS, 0,
    if (apr_file_remove(info->pathname, info->pool) != APR_SUCCESS) {
        return dav_new_error(info->pool, HTTP_FORBIDDEN, 0, NULL);
    if ((apr_dir_open(&dirp, fsctx->path1.buf, pool)) != APR_SUCCESS) {
        return dav_new_error(pool, HTTP_NOT_FOUND, 0, NULL);
        apr_status_t status;
            err = dav_new_error(pool, HTTP_NOT_FOUND, 0, NULL);
        return dav_new_error(params->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0,
            return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0,
        return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0,
    return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0,
    if (apr_file_perms_set(resource->info->pathname, perms) != APR_SUCCESS) {
                             HTTP_INTERNAL_SERVER_ERROR, 0,
    if (apr_file_perms_set(resource->info->pathname, perms) != APR_SUCCESS) {
                             HTTP_INTERNAL_SERVER_ERROR, 0,
    int save_errno = errno;
    err = dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, errcode, errstr);
    err->save_errno = save_errno;
                             HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN,
        return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN,
                             DAV_ERR_LOCK_NO_DB,
                             HTTP_INTERNAL_SERVER_ERROR, 0,
                                 DAV_ERR_LOCK_CORRUPT_DB,
                         DAV_ERR_LOCK_CORRUPT_DB,
                             HTTP_INTERNAL_SERVER_ERROR, 0,
        if (errscan->save_errno != 0) {
            errno = errscan->save_errno;
            ap_log_rerror(APLOG_MARK, level, errno, r, "%s  [%d, #%d]",
                          errscan->desc, errscan->status, errscan->error_id);
        }
        else {
            ap_log_rerror(APLOG_MARK, level, 0, r,
                          "%s  [%d, #%d]",
                          errscan->desc, errscan->status, errscan->error_id);
        }
        return dav_new_error(r->pool, HTTP_NOT_FOUND, 0,
                err = dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
                    err = dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
                    return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
                    err = dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
                            return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0,
                    err424_set = dav_new_error(p, HTTP_FAILED_DEPENDENCY, 0,
                    err424_delete = dav_new_error(p, HTTP_FAILED_DEPENDENCY, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
        err = dav_new_error(ctx->w.pool, HTTP_CONFLICT, 0,
        err = dav_new_error(ctx->w.pool, HTTP_CONFLICT, 0,
            err = dav_new_error(r->pool, multi_status->status, 0, multi_status->desc);
            err = dav_new_error(r->pool, HTTP_MULTI_STATUS, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
        err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
      err = dav_new_error(r->pool, HTTP_FORBIDDEN, 0,
    int save_errno;             /* copy of errno causing the error */
                                      int error_id, const char *desc);
** namespace may be NULL, which means "DAV:". save_errno will be
** filled with the current errno value.
                                          int error_id, const char *desc,
        return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
                                 DAV_ERR_PROP_READONLY,
                                 DAV_ERR_PROP_NO_DATABASE,
DAV_DECLARE(dav_error*) dav_new_error(apr_pool_t *p, int status,
                                      int error_id, const char *desc)
    int save_errno = errno;
    err->save_errno = save_errno;
                                          int error_id, const char *desc,
    dav_error *err = dav_new_error(p, status, error_id, desc);
                                     DAV_ERR_IF_TAGGED,
            if (apr_uri_parse(r->pool, uri, &parsed_uri) != APR_SUCCESS) {
                                     DAV_ERR_IF_TAGGED,
                                     DAV_ERR_IF_UNCLOSED_PAREN,
                                     DAV_ERR_IF_PARSE,
                                             DAV_ERR_IF_PARSE, NULL);
                                             DAV_ERR_IF_PARSE, NULL);
                                                 DAV_ERR_IF_MULTIPLE_NOT,
                                         DAV_ERR_IF_UNK_CHAR,
                                 DAV_ERR_IF_UNK_CHAR,
            return dav_new_error(p, HTTP_LOCKED, 0,
                return dav_new_error(p, HTTP_LOCKED, 0,
        return dav_new_error(p, HTTP_LOCKED, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0,
                        return dav_new_error(p, HTTP_FORBIDDEN, 0, errmsg);
            return dav_new_error(p, HTTP_LOCKED, 0 /* error_id */,
            return dav_new_error(p, HTTP_BAD_REQUEST, 0,
            return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0,
        return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0,
    return dav_new_error(p, HTTP_LOCKED, 1 /* error_id */,
        return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
        return dav_new_error(r->pool, result, 0, NULL);
            err = dav_new_error(r->pool, HTTP_FORBIDDEN, 0,
            return dav_new_error(r->pool, HTTP_FAILED_DEPENDENCY, 0,
        return dav_new_error(r->pool, HTTP_MULTI_STATUS, 0,
        return dav_new_error(r->pool, HTTP_BAD_REQUEST, DAV_ERR_IF_ABSENT,
                return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
                err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
            err = dav_new_error(r->pool, HTTP_CONFLICT, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0,
        return dav_new_error(p, HTTP_BAD_REQUEST, 0,
        return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0,
            return dav_new_error(r->pool, HTTP_MULTI_STATUS, 0,
            return dav_new_error(p, HTTP_BAD_REQUEST, 0,
    return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0,
            return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
    if (apr_table_get(r->subprocess_env, "force-proxy-request-1.0")
         || ((r->proto_num < HTTP_VERSION(1,1)) 
             && !apr_table_get(r->subprocess_env, "force-proxy-request-1.1"))) {
        p_conn->close++;
    int received_continue = 1; /* flag to indicate if we should
                                * loop over response parsing logic
                                * in the case that the origin told us
                                * to HTTP_CONTINUE
                                */
    while (received_continue) {
        if ( r->status != HTTP_CONTINUE ) {
            received_continue = 0;
        } else {
                         "proxy: HTTP: received 100 CONTINUE");
            (!ap_is_HTTP_INFO(r->status)) &&       /* not any 1xx response */
    }
            if ((status > 199) && /* not any 1xx response */
                (status != HTTP_NO_CONTENT) && /* not 204 */
    "            ['indexOf', 'slice', 'split', 'substr']);\n"
  params.is_main_frame = true;
  params.is_main_frame = true;
  fail_load_params.is_main_frame = true;
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, true, url1);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, true, url2);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, true, url1);
      main_test_rfh(), -1, true, GURL(kUnreachableWebDataURL));
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, true, url1);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, true, url2);
                                       bool main_frame,
      bool is_main_frame,
      bool is_main_frame,
      bool is_main_frame,
    bool is_main_frame,
  // TODO(creis): This is a hack for now, until we mirror the frame tree and do
  // cross-process subframe navigations in actual subframes.  As a result, we
  // can currently only support a single cross-process subframe per RVH.
  if (pending_entry &&
      pending_entry->frame_tree_node_id() != -1 &&
      CommandLine::ForCurrentProcess()->HasSwitch(switches::kSitePerProcess))
    is_main_frame = false;

        render_frame_host, parent_routing_id, is_main_frame,
          << ", is_main_frame: " << params.is_main_frame
    bool is_main_frame,
        render_frame_host, url, is_main_frame, error_code,
  // Use entry->frame_tree_node_id() to pick which RenderFrameHostManager to
  // use when --site-per-process is used.
  if (entry.frame_tree_node_id() != -1 &&
      CommandLine::ForCurrentProcess()->HasSwitch(switches::kSitePerProcess)) {
    int64 frame_tree_node_id = entry.frame_tree_node_id();
    manager = render_frame_host->frame_tree_node()->frame_tree()->FindByID(
        frame_tree_node_id)->render_manager();
  }

  // TODO(creis): As a temporary hack, we currently do cross-process subframe
  // navigations in a top-level frame of the new process.  Thus, we don't yet
  // need to store the correct frame ID in FrameMsg_Navigate_Params.
  // When using --site-per-process, look up the FrameTreeNode ID that the
  // renderer-specific frame ID corresponds to.
  int64 frame_tree_node_id = frame_tree->root()->frame_tree_node_id();
    frame_tree_node_id =
        render_frame_host->frame_tree_node()->frame_tree_node_id();

    // TODO(creis): In the short term, cross-process subframe navigations are
    // happening in the pending RenderViewHost's top-level frame.  (We need to
    // both mirror the frame tree and get the navigation to occur in the correct
    // subframe to fix this.)  Until then, we should check whether we have a
    // pending NavigationEntry with a frame ID and if so, treat the
    // cross-process "main frame" navigation as a subframe navigation.  This
    // limits us to a single cross-process subframe per RVH, and it affects
    // NavigateToEntry, NavigatorImpl::DidStartProvisionalLoad, and
    // OnDidFinishLoad.
    int root_ftn_id = frame_tree->root()->frame_tree_node_id();
    if (pending_entry &&
        pending_entry->frame_tree_node_id() != -1 &&
        pending_entry->frame_tree_node_id() != root_ftn_id) {
      frame_tree_node_id = pending_entry->frame_tree_node_id();
    FrameTreeNode* frame = frame_tree->FindByID(frame_tree_node_id);
                                       bool main_frame,
      bool is_main_frame,
    bool is_main_frame,
      this, parent_routing_id, is_main_frame, url);
    bool is_main_frame,
      this, validated_url, is_main_frame, error_code,
      error_description);
                                         bool main_frame,
      bool is_main_frame,
  return frame_tree_.root()->navigator()->NavigateToPendingEntry(
      frame_tree_.GetMainFrame(), reload_type);
    bool is_main_frame,
  // --site-per-process mode has a short-term hack allowing cross-process
  // subframe pages to commit thinking they are top-level.  Correct it here to
  // avoid confusing the observers.
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSitePerProcess) &&
      render_frame_host != GetMainFrame()) {
    is_main_frame = false;
  }

                             params.is_main_frame,
    bool is_main_frame,
                                error_description, render_view_host));;
    const GURL& url,
    bool is_main_frame) {
  RenderFrameHostImpl* rfh =
      static_cast<RenderFrameHostImpl*>(render_frame_message_source_);

  // --site-per-process mode has a short-term hack allowing cross-process
  // subframe pages to commit thinking they are top-level.  Correct it here to
  // avoid confusing the observers.
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSitePerProcess) &&
      rfh != GetMainFrame()) {
    is_main_frame = false;
  }

      bool is_main_frame,
      bool is_main_frame,
  void OnDidFinishLoad(const GURL& url,
                       bool is_main_frame);
  contents()->TestDidFinishLoad(url_from_ipc, true);
      url_from_ipc, true, 1, base::string16());
  // True if this is the top-most frame.
  IPC_STRUCT_MEMBER(bool, is_main_frame)
IPC_MESSAGE_ROUTED3(FrameHostMsg_DidStartProvisionalLoadForFrame,
                    bool /* true if it is the main frame */,
IPC_MESSAGE_ROUTED4(FrameHostMsg_DidFailLoadWithError,
                    bool /* is_main_frame */,
IPC_MESSAGE_ROUTED2(FrameHostMsg_DidFinishLoad,
                    GURL /* validated_url */,
                    bool /* is_main_frame */)
       routing_id_, parent_routing_id,
       is_top_most, ds->request().url()));
  params.is_main_frame = !frame->parent();
                                             !frame->parent(),
                                      ds->request().url(),
                                      !frame->parent()));
  OnDidStartProvisionalLoadForFrame(-1, true, url_copy);
  OnDidStartProvisionalLoadForFrame(-1, true, url);
void TestWebContents::TestDidFinishLoad(const GURL& url,
                                        bool is_main_frame) {
  FrameHostMsg_DidFinishLoad msg(0, url, is_main_frame);
    bool is_main_frame,
      0, url, is_main_frame, error_code, error_description);
  void TestDidFinishLoad(const GURL& url, bool is_main_frame);
                                bool is_main_frame,
      extension_dispatcher_(extension_dispatcher) {
        callback_(context->isolate(), cb) {}
    return currentSpeechUtterance();
void SpeechSynthesis::startSpeakingImmediately()
    SpeechSynthesisUtterance* utterance = currentSpeechUtterance();
    ASSERT(utterance);

    // If the queue was empty, speak this immediately.
        startSpeakingImmediately();
    // Remove all the items from the utterance queue. The platform
    // may still have references to some of these utterances and may
    // fire events on them asynchronously.
    if (!currentSpeechUtterance())
    bool didJustFinishCurrentUtterance = false;
    // If the utterance that completed was the one we're currently speaking,
    // remove it from the queue and start speaking the next one.
    if (utterance == currentSpeechUtterance()) {
        m_utteranceQueue.removeFirst();
        didJustFinishCurrentUtterance = true;
    }

    // Always fire the event, because the platform may have asynchronously
    // sent an event on an utterance before it got the message that we
    // canceled it, and we should always report to the user what actually
    // happened.
    // Start the next utterance if we just finished one and one was pending.
    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
SpeechSynthesisUtterance* SpeechSynthesis::currentSpeechUtterance() const
{
    if (!m_utteranceQueue.isEmpty())
        return m_utteranceQueue.first().get();
    return nullptr;
}

    void startSpeakingImmediately();
    // Returns the utterance at the front of the queue.
    SpeechSynthesisUtterance* currentSpeechUtterance() const;

    , m_speakingErrorOccurredTimer(this, &PlatformSpeechSynthesizerMock::speakingErrorOccurred)
    m_speakingErrorOccurredTimer.stop();
void PlatformSpeechSynthesizerMock::speakingErrorOccurred(Timer<PlatformSpeechSynthesizerMock>*)
{
    ASSERT(m_utterance.get());
    client()->speakingErrorOccurred(m_utterance);
    m_utterance = nullptr;
}

    m_speakingErrorOccurredTimer.startOneShot(.1);
    void speakingErrorOccurred(Timer<PlatformSpeechSynthesizerMock>*);
    Timer<PlatformSpeechSynthesizerMock> m_speakingErrorOccurredTimer;
  SharedMemoryCreateOptions() : name(NULL), size(0), open_existing(false),
  const std::string* name;
  // shared memory must not exist.  This flag is meaningless unless name is
  // non-NULL.
  bool open_existing;
  bool CreateNamed(const std::string& name, bool open_existing, size_t size) {
    options.name = &name;
    options.open_existing = open_existing;
      options.name == NULL ? "" : options.name->c_str(),
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    if (!FilePathForMemoryName(*options.name, &path))
    if (fd == -1 && options.open_existing) {
    bool rv = memory.CreateNamed(s_test_name_, true, kDataSize);
      EXPECT_TRUE(memory1.CreateNamed("SharedMemoryMultipleLockThreadTest",
                                 true, kDataSize));
// CreateNamed(openExisting=true)
  rv = memory1.CreateNamed(test_name, false, kDataSize);
  // Open two handles to a memory segment and check that open_existing works
  // as expected.
  bool rv = memory1.CreateNamed(test_name, false, kDataSize);
  rv = memory2.CreateNamed(test_name, false, kDataSize2);
  rv = memory2.CreateNamed(test_name, true, kDataSize2);
  options.name = &shared_mem_name;
    bool rv = memory.CreateNamed(s_test_name_, true, kDataSize);
  name_ = ASCIIToWide(options.name == NULL ? "" : *options.name);
    if (!options.open_existing) {
  if (!shared_memory->CreateNamed(name, true, size))
  if (!shared_mem_service_data->CreateNamed(GetServiceProcessSharedMemName(),
                                            true, alloc_size))
    EXPECT_TRUE(shared_handle_.CreateNamed(kShmemSegmentName, false, 100));
    CHECK_LE(args.Length(), 2);
    bool check_value = args[0]->BooleanValue();
      error_message = "Error: " + std::string(*v8::String::AsciiValue(args[1]));
      error_message += "\n    <no stack trace>";
        error_message += base::StringPrintf("\n    at %s (%s:%d:%d)",
    DCHECK(check_value) << error_message;
    return v8::Undefined();
 private:
  source_map_.RegisterSource("contentSettings",
                             IDR_CONTENT_SETTINGS_CUSTOM_BINDINGS_JS);
  source_map_.RegisterSource("storage", IDR_STORAGE_CUSTOM_BINDINGS_JS);
  source_map_.RegisterSource("types", IDR_TYPES_CUSTOM_BINDINGS_JS);
        "    loadRefDependency: function(foo) { return {}; },"
DevToolsManager::DevToolsManager() : web_contents_listeners_(NULL) {
  DCHECK(!web_contents_listeners_.get()) <<
    Source<WebContents> src(source);
    const WebContents& web_contents) {
  const NavigationController& navigation_controller = web_contents.controller();
    WebContents& web_contents,
  DCHECK(!GetDevToolsClientHostFor(web_contents));
  NavigationController* navigation_controller = &web_contents.controller();
  SendAttachToAgent(web_contents, web_contents.render_view_host());
  WebContents* wc = tc->AsWebContents();
  if (!wc) {
    return;
  }
  RenderViewHost* target_host = wc->render_view_host();
  WebContents* wc = from.delegate()->GetAsWebContents();
void DevToolsManager::OpenDevToolsWindow(WebContents* wc) {
void DevToolsManager::InspectElement(WebContents* wc, int x, int y) {
  WebContents* web_contents = tab_contents->AsWebContents();
  if (!web_contents) {
    return;
  }
  SendDetachToAgent(*web_contents);
  if (!web_contents_listeners_.get()) {
    web_contents_listeners_.reset(new NotificationRegistrar);
    web_contents_listeners_->Add(
  DCHECK(web_contents_listeners_.get());
    web_contents_listeners_.reset();
void DevToolsManager::SendAttachToAgent(const WebContents& wc,
void DevToolsManager::SendDetachToAgent(const WebContents& wc) {
class WebContents;
  // Returns DevToolsClientHost registered for |web_contents| or NULL if
  // there is no alive DevToolsClientHost registered for |web_contents|.
  DevToolsClientHost* GetDevToolsClientHostFor(const WebContents& web_contents);
  // Registers new DevToolsClientHost for |web_contents|. There must be no
  // other DevToolsClientHosts registered for the WebContents at the moment.
  void RegisterDevToolsClientHostFor(WebContents& web_contents,
  void OpenDevToolsWindow(WebContents* wc);
  void InspectElement(WebContents* web_contents, int x, int y);
  // there is a DevToolsClientHost registered for the |web_contents|.
      const WebContents& web_contents,
  void SendDetachToAgent(const WebContents& web_contents);
  scoped_ptr<NotificationRegistrar> web_contents_listeners_;
  // Our benavior is just to report that the entry was committed.
  string16 default_title = WideToUTF16Hack(GetDefaultTitle());
  controller_.pending_entry()->set_title(default_title);
  controller_.CommitPendingEntry();
  virtual const string16& GetTitle() const = 0;
  virtual SiteInstance* GetSiteInstance() const = 0;
  virtual bool ShouldDisplayURL() = 0;
  virtual bool ShouldDisplayFavIcon() = 0;
  virtual std::wstring GetStatusText() const = 0;
  virtual void DidBecomeSelected() = 0;
  virtual void WasHidden() = 0;
  virtual bool NavigateToPendingEntry(bool reload) = 0;
  virtual void Stop() = 0;
  virtual void Cut() = 0;
  virtual void Copy() = 0;
  virtual void Paste() = 0;
  virtual void DisassociateFromPopupCount() = 0;
  virtual TabContents* Clone() = 0;
  virtual void PopupNotificationVisibilityChanged(bool visible) = 0;
  virtual gfx::NativeView GetContentNativeView() = 0;
  virtual gfx::NativeView GetNativeView() const = 0;
  virtual void GetContainerBounds(gfx::Rect *out) const = 0;
  virtual void Focus() = 0;
  virtual void SetInitialFocus(bool reverse) = 0;
  virtual bool IsBookmarkBarAlwaysVisible() = 0;
  virtual void SetDownloadShelfVisible(bool visible) = 0;
  virtual void SetIsLoading(bool is_loading,
                            LoadNotificationDetails* details) = 0;
const string16& WebContents::GetTitle() const {
  DOMUI* our_dom_ui = render_manager_.pending_dom_ui() ?
      render_manager_.pending_dom_ui() : render_manager_.dom_ui();
  if (our_dom_ui) {
    // Don't override the title in view source mode.
    NavigationEntry* entry = controller_.GetActiveEntry();
    if (!(entry && entry->IsViewSourceMode())) {
      // Give the DOM UI the chance to override our title.
      const string16& title = our_dom_ui->overridden_title();
      if (!title.empty())
        return title;
    }
  }

  // We use the title for the last committed entry rather than a pending
  // navigation entry. For example, when the user types in a URL, we want to
  // keep the old page's title until the new load has committed and we get a new
  // title.
  // The exception is with transient pages, for which we really want to use
  // their title, as they are not committed.
  NavigationEntry* entry = controller_.GetTransientEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);

  entry = controller_.GetLastCommittedEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);
  else if (controller_.LoadingURLLazily())
    return controller_.GetLazyTitle();
  return EmptyString16();
}

SiteInstance* WebContents::GetSiteInstance() const {
  return render_manager_.current_host()->site_instance();
}

bool WebContents::ShouldDisplayURL() {
  // Don't hide the url in view source mode.
  NavigationEntry* entry = controller_.GetActiveEntry();
  if (entry && entry->IsViewSourceMode())
    return true;
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->should_hide_url();
  return true;
}

bool WebContents::ShouldDisplayFavIcon() {
  // Always display a throbber during pending loads.
  if (controller_.GetLastCommittedEntry() && controller_.pending_entry())
    return true;

  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->hide_favicon();
  return true;
}

std::wstring WebContents::GetStatusText() const {
  if (!is_loading() || load_state_ == net::LOAD_STATE_IDLE)
    return std::wstring();

  switch (load_state_) {
    case net::LOAD_STATE_WAITING_FOR_CACHE:
      return l10n_util::GetString(IDS_LOAD_STATE_WAITING_FOR_CACHE);
    case net::LOAD_STATE_RESOLVING_PROXY_FOR_URL:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_PROXY_FOR_URL);
    case net::LOAD_STATE_RESOLVING_HOST:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_HOST);
    case net::LOAD_STATE_CONNECTING:
      return l10n_util::GetString(IDS_LOAD_STATE_CONNECTING);
    case net::LOAD_STATE_SENDING_REQUEST:
      return l10n_util::GetString(IDS_LOAD_STATE_SENDING_REQUEST);
    case net::LOAD_STATE_WAITING_FOR_RESPONSE:
      return l10n_util::GetStringF(IDS_LOAD_STATE_WAITING_FOR_RESPONSE,
                                   load_state_host_);
    // Ignore net::LOAD_STATE_READING_RESPONSE and net::LOAD_STATE_IDLE
    case net::LOAD_STATE_IDLE:
    case net::LOAD_STATE_READING_RESPONSE:
      break;
  }

  return std::wstring();
}

bool WebContents::NavigateToPendingEntry(bool reload) {
  const NavigationEntry& entry = *controller_.pending_entry();

  RenderViewHost* dest_render_view_host = render_manager_.Navigate(entry);
  if (!dest_render_view_host)
    return false;  // Unable to create the desired render view host.

  // Tell DevTools agent that it is attached prior to the navigation.
  DevToolsManager* dev_tools_manager = g_browser_process->devtools_manager();
  if (dev_tools_manager)  // NULL in unit tests.
    dev_tools_manager->SendAttachToAgent(*this, dest_render_view_host);

  // Used for page load time metrics.
  current_load_start_ = TimeTicks::Now();

  // Navigate in the desired RenderViewHost.
  dest_render_view_host->NavigateToEntry(entry, reload);

  if (entry.page_id() == -1) {
    // HACK!!  This code suppresses javascript: URLs from being added to
    // session history, which is what we want to do for javascript: URLs that
    // do not generate content.  What we really need is a message from the
    // renderer telling us that a new page was not created.  The same message
    // could be used for mailto: URLs and the like.
    if (entry.url().SchemeIs(chrome::kJavaScriptScheme))
      return false;
  }

  // Clear any provisional password saves - this stops password infobars
  // showing up on pages the user navigates to while the right page is
  // loading.
  GetPasswordManager()->ClearProvisionalSave();

  if (reload && !profile()->IsOffTheRecord()) {
    HistoryService* history =
        profile()->GetHistoryService(Profile::IMPLICIT_ACCESS);
    if (history)
      history->SetFavIconOutOfDateForPage(entry.url());
  }

  return true;
}

void WebContents::Stop() {
  render_manager_.Stop();
  printing_.Stop();
}

void WebContents::Cut() {
  render_view_host()->Cut();
}

void WebContents::Copy() {
  render_view_host()->Copy();
}

void WebContents::Paste() {
  render_view_host()->Paste();
}

void WebContents::DisassociateFromPopupCount() {
  render_view_host()->DisassociateFromPopupCount();
}

TabContents* WebContents::Clone() {
  // We create a new SiteInstance so that the new tab won't share processes
  // with the old one. This can be changed in the future if we need it to share
  // processes for some reason.
  TabContents* tc = new WebContents(profile(),
                                    SiteInstance::CreateSiteInstance(profile()),
                                    MSG_ROUTING_NONE, NULL);
  tc->controller().CopyStateFrom(controller_);
  return tc;
}

void WebContents::DidBecomeSelected() {
  controller_.SetActive(true);

  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // If pid() is -1, that means the RenderProcessHost still hasn't been
  // initialized.  It'll register with CacheManagerHost when it is.
  if (process()->pid() != -1)
    WebCacheManager::GetInstance()->ObserveActivity(process()->pid());
}

void WebContents::WasHidden() {
  if (!capturing_contents()) {
    // |render_view_host()| can be NULL if the user middle clicks a link to open
    // a tab in then background, then closes the tab before selecting it.  This
    // is because closing the tab calls WebContents::Destroy(), which removes
    // the |render_view_host()|; then when we actually destroy the window,
    // OnWindowPosChanged() notices and calls HideContents() (which calls us).
    if (render_widget_host_view())
      render_widget_host_view()->WasHidden();

    // Loop through children and send WasHidden to them, too.
    int count = static_cast<int>(child_windows_.size());
    for (int i = count - 1; i >= 0; --i) {
      ConstrainedWindow* window = child_windows_.at(i);
      window->WasHidden();
    }
  }

  NotificationService::current()->Notify(
      NotificationType::TAB_CONTENTS_HIDDEN,
      Source<TabContents>(this),
      NotificationService::NoDetails());
}

void WebContents::ShowContents() {
  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // Loop through children and send DidBecomeSelected to them, too.
  int count = static_cast<int>(child_windows_.size());
  for (int i = count - 1; i >= 0; --i) {
    ConstrainedWindow* window = child_windows_.at(i);
    window->DidBecomeSelected();
  }
}

void WebContents::HideContents() {
  // TODO(pkasting): http://b/1239839  Right now we purposefully don't call
  // our superclass HideContents(), because some callers want to be very picky
  // about the order in which these get called.  In addition to making the code
  // here practically impossible to understand, this also means we end up
  // calling TabContents::WasHidden() twice if callers call both versions of
  // HideContents() on a WebContents.
  WasHidden();
}

bool WebContents::IsBookmarkBarAlwaysVisible() {
  // See GetDOMUIForCurrentState() comment for more info. This case is very
  // similar, but for non-first loads, we want to use the committed entry. This
  // is so the bookmarks bar disappears at the same time the page does.
  if (controller_.GetLastCommittedEntry()) {
    // Not the first load, always use the committed DOM UI.
    if (render_manager_.dom_ui())
      return render_manager_.dom_ui()->force_bookmark_bar_visible();
    return false;  // Default.
  }

  // When it's the first load, we know either the pending one or the committed
  // one will have the DOM UI in it (see GetDOMUIForCurrentState), and only one
  // of them will be valid, so we can just check both.
  if (render_manager_.pending_dom_ui())
    return render_manager_.pending_dom_ui()->force_bookmark_bar_visible();
  if (render_manager_.dom_ui())
    return render_manager_.dom_ui()->force_bookmark_bar_visible();
  return false;  // Default.
}

void WebContents::SetDownloadShelfVisible(bool visible) {
  if (shelf_visible_ != visible) {
    if (visible) {
      // Invoke GetDownloadShelf to force the shelf to be created.
      GetDownloadShelf();
    }
    shelf_visible_ = visible;

    if (delegate_)
      delegate_->ContentsStateChanged(this);
  }

  // SetShelfVisible can force-close the shelf, so make sure we lay out
  // everything correctly, as if the animation had finished. This doesn't
  // matter for showing the shelf, as the show animation will do it.
  ToolbarSizeChanged(false);

  if (visible) {
    // Always set this value as it reflects the last time the download shelf
    // was made visible (even if it was already visible).
    last_download_shelf_show_ = TimeTicks::Now();
  }
}

void WebContents::PopupNotificationVisibilityChanged(bool visible) {
  render_view_host()->PopupNotificationVisibilityChanged(visible);
}

bool WebContents::FocusLocationBarByDefault() {
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return dom_ui->focus_location_bar_by_default();
  return false;
}

gfx::NativeView WebContents::GetNativeView() const {
  return view_->GetNativeView();
}

gfx::NativeView WebContents::GetContentNativeView() {
  return view_->GetContentNativeView();
}

void WebContents::GetContainerBounds(gfx::Rect *out) const {
  view_->GetContainerBounds(out);
}

void WebContents::Focus() {
  view_->Focus();
}

void WebContents::SetInitialFocus(bool reverse) {
  render_view_host()->SetInitialFocus(reverse);
}

// Notifies the RenderWidgetHost instance about the fact that the page is
// loading, or done loading and calls the base implementation.
void WebContents::SetIsLoading(bool is_loading,
                               LoadNotificationDetails* details) {
  if (is_loading == is_loading_)
    return;

  if (!is_loading) {
    load_state_ = net::LOAD_STATE_IDLE;
    load_state_host_.clear();
  }

  render_manager_.SetIsLoading(is_loading);

  is_loading_ = is_loading;
  waiting_for_response_ = is_loading;

  if (delegate_)
    delegate_->LoadingStateChanged(this);

  NotificationType type = is_loading ? NotificationType::LOAD_START :
      NotificationType::LOAD_STOP;
  NotificationDetails det = NotificationService::NoDetails();;
  if (details)
      det = Details<LoadNotificationDetails>(details);
  NotificationService::current()->Notify(type,
      Source<NavigationController>(&controller_),
      det);
}


DOMUI* WebContents::GetDOMUIForCurrentState() {
  // When there is a pending navigation entry, we want to use the pending DOMUI
  // that goes along with it to control the basic flags. For example, we want to
  // show the pending URL in the URL bar, so we want the display_url flag to
  // be from the pending entry.
  //
  // The confusion comes because there are multiple possibilities for the
  // initial load in a tab as a side effect of the way the RenderViewHostManager
  // works.
  //
  //  - For the very first tab the load looks "normal". The new tab DOM UI is
  //    the pending one, and we want it to apply here.
  //
  //  - For subsequent new tabs, they'll get a new SiteInstance which will then
  //    get switched to the one previously associated with the new tab pages.
  //    This switching will cause the manager to commit the RVH/DOMUI. So we'll
  //    have a committed DOM UI in this case.
  //
  // This condition handles all of these cases:
  //
  //  - First load in first tab: no committed nav entry + pending nav entry +
  //    pending dom ui:
  //    -> Use pending DOM UI if any.
  //
  //  - First load in second tab: no committed nav entry + pending nav entry +
  //    no pending DOM UI:
  //    -> Use the committed DOM UI if any.
  //
  //  - Second navigation in any tab: committed nav entry + pending nav entry:
  //    -> Use pending DOM UI if any.
  //
  //  - Normal state with no load: committed nav entry + no pending nav entry:
  //    -> Use committed DOM UI.
  if (controller_.pending_entry() &&
      (controller_.GetLastCommittedEntry() ||
       render_manager_.pending_dom_ui()))
    return render_manager_.pending_dom_ui();
  return render_manager_.dom_ui();
}
  // Returns true if the location bar should be focused by default rather than
  // the page contents. The view will call this function when the tab is
  // to see what it should do.
  bool FocusLocationBarByDefault();

  const string16& GetTitle() const;
  virtual SiteInstance* GetSiteInstance() const;
  virtual bool ShouldDisplayURL();
  virtual bool ShouldDisplayFavIcon();
  virtual std::wstring GetStatusText() const;
  virtual bool NavigateToPendingEntry(bool reload);
  virtual void Stop();
  virtual void Cut();
  virtual void Copy();
  virtual void Paste();
  virtual void DisassociateFromPopupCount();
  virtual TabContents* Clone();
  virtual void DidBecomeSelected();
  virtual void WasHidden();
  virtual void ShowContents();
  virtual void HideContents();
  virtual bool IsBookmarkBarAlwaysVisible();
  virtual void SetDownloadShelfVisible(bool visible);
  virtual void PopupNotificationVisibilityChanged(bool visible);
  virtual void Focus();

  // Retarded pass-throughs to the view.
  // TODO(brettw) fix this, tab contents shouldn't have these methods, probably
  // it should be killed altogether.
  virtual gfx::NativeView GetNativeView() const;
  virtual gfx::NativeView GetContentNativeView();
  virtual void GetContainerBounds(gfx::Rect *out) const;
  RenderWidgetHostView* render_widget_host_view() const {
    return render_manager_.current_view();
  }

  // TabContents (private overrides) -------------------------------------------

  virtual void SetInitialFocus(bool reverse);
  virtual void SetIsLoading(bool is_loading, LoadNotificationDetails* details);
  // Returns the DOMUI for the current state of the tab. This will either be
  // the pending DOMUI, the committed DOMUI, or NULL.
  DOMUI* GetDOMUIForCurrentState();

typedef HANDLE SharedMemoryLock;
// On POSIX, the lock is implemented as a lockf() on the mapped file,
// so no additional member (or definition of SharedMemoryLock) is
// needed.
  // calling Lock() to acquire the named mutex before either Create or Open
  // are called on Windows.
  // processes, not across threads.  The Lock method is not currently
  void Lock();

#if defined(OS_WIN)
  // A Lock() implementation with a timeout that also allows setting
  // security attributes on the mutex. sec_attr may be NULL.
  // Returns true if the Lock() has been acquired, false if the timeout was
  // reached.
  bool Lock(uint32 timeout_ms, SECURITY_ATTRIBUTES* sec_attr);
#endif
  void Unlock();
  SharedMemoryLock   lock_;
// the SharedMemoryAutoLock is in scope.
class SharedMemoryAutoLock {
  explicit SharedMemoryAutoLock(SharedMemory* shared_memory)
    shared_memory_->Lock();
  ~SharedMemoryAutoLock() {
    shared_memory_->Unlock();
  DISALLOW_COPY_AND_ASSIGN(SharedMemoryAutoLock);
void SharedMemory::Lock() {
void SharedMemory::Unlock() {
void SharedMemory::Lock() {
void SharedMemory::Unlock() {
      memory2.Lock();
      memory2.Unlock();
      memory.Lock();
      memory.Unlock();
void SharedMemory::Lock() {
  Lock(INFINITE, NULL);
}

bool SharedMemory::Lock(uint32 timeout_ms, SECURITY_ATTRIBUTES* sec_attr) {
    lock_ = CreateMutex(sec_attr, FALSE, name.c_str());
      return false;  // there is nothing good we can do here.
  DWORD result = WaitForSingleObject(lock_, timeout_ms);

  // Return false for WAIT_ABANDONED, WAIT_TIMEOUT or WAIT_FAILED.
  return (result == WAIT_OBJECT_0);
void SharedMemory::Unlock() {
    SharedMemoryAutoLock lock(internal_->shared_memory());
    SharedMemoryAutoLock lock(internal_->shared_memory());
#include "chrome/browser/extensions/extension_install_ui.h"
  ExtensionsService* service = profile_->GetExtensionsService();
  if (service) {
    CrxInstaller::Start(full_path,
                        service->install_directory(),
                        Extension::INTERNAL,
                        "",  // no expected id
                        true,  // please delete crx on completion
                        g_browser_process->file_thread()->message_loop(),
                        service,
                        new ExtensionInstallUI(profile_));
  }
namespace {
  // Helper function to delete files. This is used to avoid ugly casts which
  // would be necessary with PostMessage since file_util::Delete is overloaded.
  static void DeleteFileHelper(const FilePath& path, bool recursive) {
    file_util::Delete(path, recursive);
  }
}

void CrxInstaller::Start(const FilePath& crx_path,
                         const FilePath& install_directory,
                         Extension::Location install_source,
                         const std::string& expected_id,
                         bool delete_crx,
                         MessageLoop* file_loop,
                         ExtensionsService* frontend,
                         CrxInstallerClient* client) {
  // Note: We don't keep a reference because this object manages its own
  // lifetime.
  new CrxInstaller(crx_path, install_directory, install_source, expected_id,
                   delete_crx, file_loop, frontend, client);
}
                           ExtensionsService* frontend,
                           CrxInstallerClient* client)
      frontend_(frontend),
      client_(client),
  extensions_enabled_ = frontend_->extensions_enabled();

CrxInstaller::~CrxInstaller() {
  // Delete the temp directory and crx file as necessary. Note that the
  // destructor might be called on any thread, so we post a task to the file
  // thread to make sure the delete happens there.
  if (!temp_dir_.value().empty()) {
    file_loop_->PostTask(FROM_HERE, NewRunnableFunction(&DeleteFileHelper,
        temp_dir_, true));  // recursive delete
  }

  if (delete_crx_) {
    file_loop_->PostTask(FROM_HERE, NewRunnableFunction(&DeleteFileHelper,
        crx_path_, false));  // non-recursive delete
  }
}

  DCHECK(MessageLoop::current() == file_loop_);
  DCHECK(MessageLoop::current() == file_loop_);

    ReportFailureFromFileThread(StringPrintf(
        "ID in new extension manifest (%s) does not match expected id (%s)",
        extension->id().c_str(),
        expected_id_.c_str()));
  if (client_.get()) {
    ui_loop_->PostTask(FROM_HERE, NewRunnableMethod(this,
        &CrxInstaller::ConfirmInstall));
  } else {
    CompleteInstall();
void CrxInstaller::ConfirmInstall() {
  if (!client_->ConfirmInstall(extension_.get())) {
    // We're done. Since we don't post any more tasks to ourselves, our ref
    // count should go to zero and we die. The destructor will clean up the temp
    // dir.
    return;
  file_loop_->PostTask(FROM_HERE, NewRunnableMethod(this,
      &CrxInstaller::CompleteInstall));
  DCHECK(MessageLoop::current() == file_loop_);

  DCHECK(MessageLoop::current() == file_loop_);
  DCHECK(MessageLoop::current() == ui_loop_);

  // This isn't really necessary, it is only used because unit tests expect to
  // see errors get reported via this interface.
  //
  // TODO(aa): Need to go through unit tests and clean them up too, probably get
  // rid of this line.
  ExtensionErrorReporter::GetInstance()->ReportError(error, false);  // quiet

  if (client_)
    client_->OnInstallFailure(error);
  DCHECK(MessageLoop::current() == file_loop_);
  ui_loop_->PostTask(FROM_HERE, NewRunnableMethod(this,
      &CrxInstaller::ReportOverinstallFromUIThread));
}

void CrxInstaller::ReportOverinstallFromUIThread() {
  DCHECK(MessageLoop::current() == ui_loop_);

  if (client_.get())
    client_->OnOverinstallAttempted(extension_.get());

  frontend_->OnExtensionOverinstallAttempted(extension_->id());
  DCHECK(MessageLoop::current() == file_loop_);
  ui_loop_->PostTask(FROM_HERE, NewRunnableMethod(this,
      &CrxInstaller::ReportSuccessFromUIThread));
}

void CrxInstaller::ReportSuccessFromUIThread() {
  DCHECK(MessageLoop::current() == ui_loop_);

  // If there is a client, tell the client about installation.
  if (client_.get())
    client_->OnInstallSuccess(extension_.get());

  frontend_->OnExtensionInstalled(extension_.release());

  // We're done. We don't post any more tasks to ourselves so we are deleted
  // soon.
// Classes that want to know about install completion, or that want to have an
// opportunity to reject the unpacked extension before installation, should
// implement this interface.
class CrxInstallerClient
    : public base::RefCountedThreadSafe<CrxInstallerClient> {
 public:
  virtual ~CrxInstallerClient() {}

  // Return true to indicate that installation should proceed, false otherwise.
  virtual bool ConfirmInstall(Extension* extension) = 0;

  // Installation was successful.
  virtual void OnInstallSuccess(Extension* extension) = 0;

  // Intallation failed.
  virtual void OnInstallFailure(const std::string& error) = 0;

  // The install was rejected because the same extension/version is already
  // installed.
  virtual void OnOverinstallAttempted(Extension* extension) = 0;
};

  // Starts the installation of the crx file in |crx_path| into
  // |install_directory|.
  //
  // Other params:
  //  install_source: The source of the install (external, --load-extension, etc
  //  expected_id: Optional. If the caller knows what the ID of this extension
  //               should be after unpacking, it can be specified here as a
  //               sanity check.
  //  delete_crx: Whether the crx should be deleted on completion.
  //  file_loop: The message loop to do file IO on.
  //  frontend: The ExtensionsService to report the successfully installed
  //            extension to.
  //  client: Optional. If specified, will be used to confirm installation and
  //          also notified of success/fail. Note that we hold a reference to
  //          this, so it can outlive its creator (eg the UI).
  static void Start(const FilePath& crx_path,
                    const FilePath& install_directory,
                    Extension::Location install_source,
                    const std::string& expected_id,
                    bool delete_crx,
                    MessageLoop* file_loop,
                    ExtensionsService* frontend,
                    CrxInstallerClient* client);

 private:
               ExtensionsService* frontend,
               CrxInstallerClient* client);
  ~CrxInstaller();
  // Runs on the UI thread. Confirms with the user (via CrxInstallerClient) that
  // it is OK to install this extension.
  void ConfirmInstall();
  void ReportOverinstallFromUIThread();
  void ReportSuccessFromUIThread();
  // Whether manual extension installation is enabled. We can't just check this
  // before trying to install because themes are special-cased to always be
  // allowed.
  // The client we will work with to do the installation. This can be NULL, in
  // which case the install is silent.
  scoped_refptr<CrxInstallerClient> client_;

// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/extensions/extension_install_ui.h"

#include "app/l10n_util.h"
#include "grit/chromium_strings.h"
#include "chrome/browser/browser_list.h"
#include "chrome/browser/extensions/theme_preview_infobar_delegate.h"
#include "chrome/browser/profile.h"
#include "chrome/browser/tab_contents/tab_contents.h"

#if defined(OS_WIN)
#include "app/win_util.h"
#elif defined(OS_MACOSX)
#include "base/scoped_cftyperef.h"
#include "base/sys_string_conversions.h"
#include <CoreFoundation/CFUserNotification.h>
#endif

ExtensionInstallUI::ExtensionInstallUI(Profile* profile)
    : profile_(profile), ui_loop_(MessageLoop::current()) {
}

bool ExtensionInstallUI::ConfirmInstall(Extension* extension) {
  DCHECK(ui_loop_ == MessageLoop::current());

  // We special-case themes to not show any confirm UI. Instead they are
  // immediately installed, and then we show an infobar (see OnInstallSuccess)
  // to allow the user to revert if they don't like it.
  if (extension->IsTheme())
    return true;

#if defined(OS_WIN)
  if (win_util::MessageBox(GetForegroundWindow(),
          L"Are you sure you want to install this extension?\n\n"
          L"You should only install extensions from sources you trust.",
          l10n_util::GetString(IDS_PRODUCT_NAME).c_str(),
          MB_OKCANCEL) != IDOK) {
    return false;
  }
#elif defined(OS_MACOSX)
  // Using CoreFoundation to do this dialog is unimaginably lame but will do
  // until the UI is redone.
  scoped_cftyperef<CFStringRef> product_name(
      base::SysWideToCFStringRef(l10n_util::GetString(IDS_PRODUCT_NAME)));
  CFOptionFlags response;
  if (kCFUserNotificationAlternateResponse == CFUserNotificationDisplayAlert(
      0, kCFUserNotificationCautionAlertLevel, NULL, NULL, NULL,
      product_name,
      CFSTR("Are you sure you want to install this extension?\n\n"
           "This is a temporary message and it will be removed when "
           "extensions UI is finalized."),
      NULL, CFSTR("Cancel"), NULL, &response)) {
    return false;
  }
#else
  NOTREACHED();
#endif  // OS_*

  return true;
}

void ExtensionInstallUI::OnInstallSuccess(Extension* extension) {
  ShowThemeInfoBar(extension);
}

void ExtensionInstallUI::OnInstallFailure(const std::string& error) {
  DCHECK(ui_loop_ == MessageLoop::current());

#if defined(OS_WIN)
  win_util::MessageBox(NULL, UTF8ToWide(error), L"Extension Install Error",
      MB_OK | MB_SETFOREGROUND);
#elif defined(OS_MACOSX)
  // There must be a better way to do this, for all platforms.
  scoped_cftyperef<CFStringRef> message_cf(
      base::SysUTF8ToCFStringRef(error));
  CFOptionFlags response;
  CFUserNotificationDisplayAlert(
      0, kCFUserNotificationCautionAlertLevel, NULL, NULL, NULL,
      CFSTR("Extension Install Error"), message_cf,
      NULL, NULL, NULL, &response);
#else
  LOG(ERROR) << "Extension install failed: " << error.c_str();
  NOTREACHED();
#endif
}

void ExtensionInstallUI::OnOverinstallAttempted(Extension* extension) {
  ShowThemeInfoBar(extension);
}

void ExtensionInstallUI::ShowThemeInfoBar(Extension* extension) {
  if (!extension->IsTheme())
    return;

  Browser* browser = BrowserList::GetLastActiveWithProfile(profile_);
  if (!browser)
    return;

  TabContents* tab_contents = browser->GetSelectedTabContents();
  if (!tab_contents)
    return;

  // First remove any previous theme preview infobar.
  for (int i = 0; i < tab_contents->infobar_delegate_count(); ++i) {
    InfoBarDelegate* delegate = tab_contents->GetInfoBarDelegateAt(i);
    if (delegate->AsThemePreviewInfobarDelegate()) {
      tab_contents->RemoveInfoBar(delegate);
      break;
    }
  }

  // Now add the new one.
  tab_contents->AddInfoBar(new ThemePreviewInfobarDelegate(
      tab_contents, extension->name()));
}
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_EXTENSIONS_EXTENSION_INSTALL_UI_H_
#define CHROME_BROWSER_EXTENSIONS_EXTENSION_INSTALL_UI_H_

#include "base/file_path.h"
#include "base/gfx/native_widget_types.h"
#include "base/ref_counted.h"
#include "chrome/browser/extensions/crx_installer.h"

class ExtensionsService;
class MessageLoop;
class Profile;
class SandboxedExtensionUnpacker;

// Displays all the UI around extension installation.
//
// TODO(aa): This will become a view and move to browser/views/extensions in the
// future.
class ExtensionInstallUI : public CrxInstallerClient {
 public:
  ExtensionInstallUI(Profile* profile);

 private:
  // CrxInstallerClient
  virtual bool ConfirmInstall(Extension* extension);
  virtual void OnInstallSuccess(Extension* extension);
  virtual void OnInstallFailure(const std::string& error);
  virtual void OnOverinstallAttempted(Extension* extension);

  void ShowThemeInfoBar(Extension* extension);

  Profile* profile_;
  MessageLoop* ui_loop_;
};

#endif  // CHROME_BROWSER_EXTENSIONS_EXTENSION_INSTALL_UI_H_
/*
*/
const char* ExtensionsService::kGalleryDownloadURLPrefix =
    "http://www.corp.google.com/~glen/chrome/";
const char* ExtensionsService::kGalleryURLPrefix =
    "http://www.corp.google.com/~glen/chrome/";
  CrxInstaller::Start(extension_path, install_directory_, Extension::INTERNAL,
                      "",   // no expected id
                      false,  // don't delete crx when complete
                      backend_loop_,
                      this,
                      NULL);  // no client (silent install)
  CrxInstaller::Start(extension_path, install_directory_, Extension::INTERNAL,
                      id,
                      true,  // delete crx when complete
                      backend_loop_,
                      this,
                      NULL);  // no client (silent install)
  CrxInstaller::Start(path, install_directory_, location, id,
                      false,  // don't delete crx when complete
                      backend_loop_,
                      this,
                      NULL);  // no client (silent install)
  const FilePath& install_directory() const { return install_directory_; }

  // TODO(aa): This method can be removed. It is only used by the unit tests,
  // and they could use CrxInstaller directly instead.
  // TODO(aa): This method can be removed. ExtensionUpdater could use
  // CrxInstaller directly instead.
      : crx_path_(crx_path), file_loop_(NULL), rdh_(rdh), client_(client),
        got_response_(false) {
  // We assume that we are started on the thread that the client wants us to do
  // file IO on.
  file_loop_ = MessageLoop::current();

  UtilityProcessHost* host = new UtilityProcessHost(rdh_, this, file_loop_);
  DCHECK(file_loop_ == MessageLoop::current());
  DCHECK(file_loop_ == MessageLoop::current());
  MessageLoop* file_loop_;
  if (!listener_)
    return;
  if (chose_color)
    listener_->OnColorChosen(color);
  listener_->OnColorChooserDialogClosed();
  virtual void End() OVERRIDE {}
  IPC_SYNC_MESSAGE_ROUTED1_0(PluginMsg_DidFinishLoadWithReason,
                             int /* reason */)
                      std::string /* url */,
                      std::wstring /* result */,

  IPC_SYNC_MESSAGE_ROUTED3_0(PluginMsg_URLRequestRouted,
                             std::string /* url */,
                             bool /* notify_needed */,
                             intptr_t /* notify data */)
    IPC_MESSAGE_HANDLER(PluginMsg_URLRequestRouted, OnURLRequestRouted)
void WebPluginDelegateStub::OnDidFinishLoadWithReason(int reason) {
  delegate_->DidFinishLoadWithReason(reason);
void WebPluginDelegateStub::OnSendJavaScriptStream(const std::string& url,
                                                   const std::wstring& result,

void WebPluginDelegateStub::OnURLRequestRouted(const std::string& url,
                                               bool notify_needed,
                                               intptr_t notify_data) {
  delegate_->URLRequestRouted(url, notify_needed, notify_data);
}
  void OnDidFinishLoadWithReason(int reason);
  void OnSendJavaScriptStream(const std::string& url,
                              const std::wstring& result,
  void OnURLRequestRouted(const std::string& url, bool notify_needed,
                          intptr_t notify_data);

  WebFrame* sub1_frame = view_->webview()->GetFrameWithName(L"sub1");
void WebPluginDelegateProxy::SendJavaScriptStream(const std::string& url,
                                                  const std::wstring& result,
void WebPluginDelegateProxy::DidFinishLoadWithReason(NPReason reason) {
  Send(new PluginMsg_DidFinishLoadWithReason(instance_id_, reason));
void WebPluginDelegateProxy::URLRequestRouted(const std::string& url,
                                               bool notify_needed,
                                               intptr_t notify_data) {
  Send(new PluginMsg_URLRequestRouted(instance_id_, url, notify_needed,
                                      notify_data));
}

  virtual void DidFinishLoadWithReason(NPReason reason);
  virtual void SendJavaScriptStream(const std::string& url,
                                    const std::wstring& result,
  // Notifies the delegate about a Get/Post URL request getting routed
  virtual void URLRequestRouted(const std::string&url, bool notify_needed,
                                intptr_t notify_data);

#include "webkit/glue/webdatasource_impl.h"
      WebDataSource* ds = WebDataSourceImpl::FromLoader(dl);
  WebDataSource* ds = WebDataSourceImpl::FromLoader(dl);
  WebFrame* iframe = test_shell_->webView()->GetFrameWithName(L"ifr");
      get_notify_data_(NULL),
void PluginInstance::SetURLLoadData(const GURL& url,
                                    intptr_t notify_data) {
  get_url_ = url;
  get_notify_data_ = notify_data;
}

void PluginInstance::DidFinishLoadWithReason(NPReason reason) {
  if (!get_url_.is_empty()) {
    NPP_URLNotify(get_url_.spec().c_str(), reason,
        reinterpret_cast<void*>(get_notify_data_));
  }

  get_url_ = GURL();
  get_notify_data_ = NULL;
void PluginInstance::SendJavaScriptStream(const std::string& url,
                                          const std::wstring& result,
    stream->SendToPlugin(WideToUTF8(result), "text/html");
      this->NPP_URLNotify(url.c_str(), NPRES_DONE,
  virtual void DidFinishLoadWithReason(NPReason reason);

  // Helper method to set some persistent data for getURLNotify since
  // resource fetches happen async.
  void SetURLLoadData(const GURL& url, intptr_t notify_data);
  void SendJavaScriptStream(const std::string& url, const std::wstring& result,
    PluginInstance *instance,
    const std::string &url,
    void *notify_data)
    : PluginStream(instance, url.c_str(), notify_needed, notify_data) {
#ifndef WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H__
#define WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H__
  PluginStringStream(PluginInstance *instance,
                     const std::string &url,
                     void *notify_data);
  void SendToPlugin(const std::string &data,
                    const std::string &mime_type);

  DISALLOW_EVIL_CONSTRUCTORS(PluginStringStream);
#endif // WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H__
void WebPluginDelegateImpl::DidFinishLoadWithReason(NPReason reason) {
  instance()->DidFinishLoadWithReason(reason);
void WebPluginDelegateImpl::SendJavaScriptStream(const std::string& url,
                                                 const std::wstring& result,
  if (notify_needed) {
    instance()->SetURLLoadData(url, notify_data);
  }

void WebPluginDelegateImpl::URLRequestRouted(const std::string&url,
                                             bool notify_needed,
                                             intptr_t notify_data) {
  if (notify_needed) {
    instance()->SetURLLoadData(GURL(url.c_str()), notify_data);
  }
}
  virtual void DidFinishLoadWithReason(NPReason reason);
  virtual void SendJavaScriptStream(const std::string& url,
                                    const std::wstring& result,
  virtual void URLRequestRouted(const std::string&url, bool notify_needed,
                                intptr_t notify_data);

// Copyright (c) 2006-2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "config.h"
#include "webkit/glue/webdatasource_impl.h"

#include "webkit/api/public/WebURL.h"
#include "webkit/api/public/WebVector.h"
#include "webkit/glue/glue_util.h"

using WebCore::DocumentLoader;
using WebCore::ResourceRequest;
using WebCore::ResourceResponse;
using WebCore::SubstituteData;

using WebKit::WebDataSource;
using WebKit::WebNavigationType;
using WebKit::WebString;
using WebKit::WebURL;
using WebKit::WebURLRequest;
using WebKit::WebURLResponse;
using WebKit::WebVector;

// static
PassRefPtr<WebDataSourceImpl> WebDataSourceImpl::Create(
    const ResourceRequest& request,
    const SubstituteData& data) {
  return adoptRef(new WebDataSourceImpl(request, data));
}

WebDataSourceImpl::WebDataSourceImpl(const ResourceRequest& request,
                                     const SubstituteData& data)
    : DocumentLoader(request, data) {
}

WebDataSourceImpl::~WebDataSourceImpl() {
}

const WebURLRequest& WebDataSourceImpl::originalRequest() const {
  original_request_.bind(DocumentLoader::originalRequest());
  return original_request_;
}

const WebURLRequest& WebDataSourceImpl::request() const {
  request_.bind(DocumentLoader::request());
  return request_;
}

const WebURLResponse& WebDataSourceImpl::response() const {
  response_.bind(DocumentLoader::response());
  return response_;
}

bool WebDataSourceImpl::hasUnreachableURL() const {
  return !DocumentLoader::unreachableURL().isEmpty();
}

WebURL WebDataSourceImpl::unreachableURL() const {
  return webkit_glue::KURLToWebURL(DocumentLoader::unreachableURL());
}

void WebDataSourceImpl::redirectChain(WebVector<WebURL>& result) const {
  result.assign(redirect_chain_);
}

WebString WebDataSourceImpl::pageTitle() const {
  return webkit_glue::StringToWebString(title());
}

WebNavigationType WebDataSourceImpl::navigationType() const {
  return NavigationTypeToWebNavigationType(triggeringAction().type());
}

double WebDataSourceImpl::triggeringEventTime() const {
  if (!triggeringAction().event())
    return 0.0;

  // DOMTimeStamp uses units of milliseconds.
  return triggeringAction().event()->timeStamp() / 1000.0;
}

WebDataSource::ExtraData* WebDataSourceImpl::extraData() const {
  return extra_data_.get();
}

void WebDataSourceImpl::setExtraData(ExtraData* extra_data) {
  extra_data_.set(extra_data);
}

WebNavigationType WebDataSourceImpl::NavigationTypeToWebNavigationType(
    WebCore::NavigationType type) {
  switch (type) {
    case WebCore::NavigationTypeLinkClicked:
      return WebKit::WebNavigationTypeLinkClicked;
    case WebCore::NavigationTypeFormSubmitted:
      return WebKit::WebNavigationTypeFormSubmitted;
    case WebCore::NavigationTypeBackForward:
      return WebKit::WebNavigationTypeBackForward;
    case WebCore::NavigationTypeReload:
      return WebKit::WebNavigationTypeReload;
    case WebCore::NavigationTypeFormResubmitted:
      return WebKit::WebNavigationTypeFormResubmitted;
    case WebCore::NavigationTypeOther:
    default:
      return WebKit::WebNavigationTypeOther;
  }
}

GURL WebDataSourceImpl::GetEndOfRedirectChain() const {
  ASSERT(!redirect_chain_.isEmpty());
  return redirect_chain_.last();
}

void WebDataSourceImpl::ClearRedirectChain() {
  redirect_chain_.clear();
}

void WebDataSourceImpl::AppendRedirect(const GURL& url) {
  redirect_chain_.append(url);
}
// Copyright (c) 2006-2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef WEBKIT_GLUE_WEBDATASOURCE_IMPL_H_
#define WEBKIT_GLUE_WEBDATASOURCE_IMPL_H_

#include "DocumentLoader.h"
#include <wtf/Vector.h>
#include <wtf/OwnPtr.h>

#include "webkit/api/public/WebDataSource.h"
#include "webkit/api/src/WrappedResourceRequest.h"
#include "webkit/api/src/WrappedResourceResponse.h"

class GURL;
class WebFrameImpl;
class WebDocumentLoaderImpl;

class WebDataSourceImpl : public WebCore::DocumentLoader,
                          public WebKit::WebDataSource {
 public:
  static PassRefPtr<WebDataSourceImpl> Create(const WebCore::ResourceRequest&,
                                              const WebCore::SubstituteData&);

  static WebDataSourceImpl* FromLoader(WebCore::DocumentLoader* loader) {
    return static_cast<WebDataSourceImpl*>(loader);
  }

  // WebDataSource methods:
  virtual const WebKit::WebURLRequest& originalRequest() const;
  virtual const WebKit::WebURLRequest& request() const;
  virtual const WebKit::WebURLResponse& response() const;
  virtual bool hasUnreachableURL() const;
  virtual WebKit::WebURL unreachableURL() const;
  virtual void redirectChain(WebKit::WebVector<WebKit::WebURL>&) const;
  virtual WebKit::WebString pageTitle() const;
  virtual WebKit::WebNavigationType navigationType() const;
  virtual double triggeringEventTime() const;
  virtual ExtraData* extraData() const;
  virtual void setExtraData(ExtraData*);

  static WebKit::WebNavigationType NavigationTypeToWebNavigationType(
      WebCore::NavigationType type);

  bool HasRedirectChain() const { return !redirect_chain_.isEmpty(); }
  GURL GetEndOfRedirectChain() const;
  void ClearRedirectChain();
  void AppendRedirect(const GURL& url);

 private:
  WebDataSourceImpl(const WebCore::ResourceRequest&,
                    const WebCore::SubstituteData&);
  ~WebDataSourceImpl();

  // Mutable because the const getters will magically sync these to the
  // latest version from WebKit.
  mutable WebKit::WrappedResourceRequest original_request_;
  mutable WebKit::WrappedResourceRequest request_;
  mutable WebKit::WrappedResourceResponse response_;

  // Lists all intermediate URLs that have redirected for the current
  // provisional load. See WebFrameLoaderClient::
  // dispatchDidReceiveServerRedirectForProvisionalLoad for a description of
  // who modifies this when to keep it up to date.
  Vector<WebKit::WebURL> redirect_chain_;

  OwnPtr<ExtraData> extra_data_;

  DISALLOW_COPY_AND_ASSIGN(WebDataSourceImpl);
};

#endif  // WEBKIT_GLUE_WEBDATASOURCE_IMPL_H_
#include "webkit/glue/webdatasource_impl.h"
  return loader ? WebDataSourceImpl::FromLoader(loader) : NULL;
    plugin_delegate_(NULL),
class WebDataSourceImpl;
class WebPluginDelegate;
  // The plugin delegate is used to get notifications when downloads complete.
  // This is used by the NPAPI method getURLNotify.  plugin_delegate() may
  // return NULL.  TODO(darin): how come there is only one per frame?!?
  WebPluginDelegate* plugin_delegate() const {
    return plugin_delegate_;
  }
  void set_plugin_delegate(WebPluginDelegate* plugin_delegate) {
    plugin_delegate_ = plugin_delegate;
  }

  WebDataSourceImpl* GetDataSourceImpl() const;
  WebDataSourceImpl* GetProvisionalDataSourceImpl() const;
  // Plugins sometimes need to be notified when loads are complete so we keep
  // a pointer back to the appropriate plugin.
  WebPluginDelegate* plugin_delegate_;

#include "webkit/glue/webdatasource_impl.h"
      WebDataSourceImpl::FromLoader(documentLoader);
  DCHECK(ds->HasRedirectChain());
  ds->AppendRedirect(ds->request().url());
    GURL chain_end = ds->GetEndOfRedirectChain();
    ds->ClearRedirectChain();
      ds->AppendRedirect(chain_end);
    ds->AppendRedirect(url);
  DCHECK(!ds->HasRedirectChain());
    ds->AppendRedirect(expected_client_redirect_src_);
  ds->AppendRedirect(url);
  } else {
    webframe_->DidFail(error, true);
    WebPluginDelegate* plg_delegate = webframe_->plugin_delegate();
    if (plg_delegate)
      plg_delegate->DidFinishLoadWithReason(NPRES_NETWORK_ERR);

  WebPluginDelegate* plg_delegate = webframe_->plugin_delegate();
  if (plg_delegate)
    plg_delegate->DidFinishLoadWithReason(NPRES_NETWORK_ERR);
  DocumentLoader* documentLoader =
      webframe_->frame()->loader()->activeDocumentLoader();
  WebDataSourceImpl* dataSource =
      WebDataSourceImpl::FromLoader(documentLoader);
  WebPluginDelegate* plg_delegate = webframe_->plugin_delegate();
  if (plg_delegate)
    plg_delegate->DidFinishLoadWithReason(NPRES_DONE);
        bool is_redirect = ds->HasRedirectChain();
            WebDataSourceImpl::NavigationTypeToWebNavigationType(action.type());
  WebPluginDelegate* plg_delegate = webframe_->plugin_delegate();
  if (plg_delegate)
    plg_delegate->DidFinishLoadWithReason(NPRES_DONE);
  RefPtr<WebDataSourceImpl> ds = WebDataSourceImpl::Create(request, data);
  virtual WebCore::ObjectContentType objectContentType(const WebCore::KURL& url,
                                              const WebCore::String& mimeType);
#include "build/build_config.h"
  virtual void DidFinishLoadWithReason(NPReason reason) = 0;
  // The result of the script execution is returned via this function.
  virtual void SendJavaScriptStream(const std::string& url,
                                    const std::wstring& result,
  // Notifies the delegate about a Get/Post URL request getting routed.
  virtual void URLRequestRouted(const std::string&url, bool notify_needed,
                                intptr_t notify_data) = 0;

bool WebPluginImpl::ExecuteScript(const std::string& url,
                                  const std::wstring& script,
                                  bool notify_needed,
                                  intptr_t notify_data,
                                  bool popups_allowed) {
  // This could happen if the WebPluginContainer was already deleted.
  if (!frame())
    return false;

  // Pending resource fetches should also not trigger a callback.
  webframe_->set_plugin_delegate(NULL);

  WebCore::String script_str(webkit_glue::StdWStringToString(script));

  // Note: the call to executeScript might result in the frame being
  // deleted, so add an extra reference to it in this scope.
  // For KJS, keeping a pointer to the JSBridge is enough, but for V8
  // we also need to addref the frame.
  WTF::RefPtr<WebCore::Frame> cur_frame(frame());

  WebCore::ScriptValue result =
      frame()->loader()->executeScript(script_str, popups_allowed);
  WebCore::String script_result;
  std::wstring wresult;
  bool succ = false;
  if (result.getString(script_result)) {
    succ = true;
    wresult = webkit_glue::StringToStdWString(script_result);
  }

  // delegate_ could be NULL because executeScript caused the container to be
  // deleted.
  if (delegate_)
    delegate_->SendJavaScriptStream(url, wresult, succ, notify_needed,
                                    notify_data);

  return succ;
}

                                          bool notify, const char* url,
                                          GURL* unused) {
  if (!frame())
  WebCore::String str_target = target;
    WebCore::Frame *frameTarget = frame()->tree()->find(str_target);
    if (frameTarget != frame()) {
      // FIXME - might be good to log this into a security
      //         log somewhere.
  // TODO(darin): Eliminate these WebCore dependencies.

  WebCore::FrameLoadRequest load_request(
      *webkit_glue::WebURLRequestToResourceRequest(&request));
  load_request.setFrameName(str_target);
  WebCore::FrameLoader *loader = frame()->loader();
  // we actually don't know whether usergesture is true or false,
  // passing true since all we can do is assume it is okay.
  loader->loadFrameRequest(
      load_request,
      false,  // lock history
      false,  // lock back forward list
      0,      // event
      0);     // form state

  // loadFrameRequest() can cause the frame to go away.
  if (webframe_) {
    WebPluginDelegate* last_plugin = webframe_->plugin_delegate();
    if (last_plugin) {
      last_plugin->DidFinishLoadWithReason(NPRES_USER_BREAK);
      webframe_->set_plugin_delegate(NULL);
    }

    if (notify)
      webframe_->set_plugin_delegate(delegate_);
  }

                                    buf, is_file_data, notify, url,
                                    &complete_url);
  if (routing_status == ROUTED) {
    // The delegate could have gone away because of this call.
    if (delegate_)
      delegate_->URLRequestRouted(url, notify, notify_data);
  }
    std::string original_url = url;

    // Convert the javascript: URL to javascript by unescaping. WebCore uses
    // decode_string for this, so we do, too.
    std::string escaped_script = original_url.substr(strlen("javascript:"));
    WebCore::String script = WebCore::decodeURLEscapeSequences(
        WebCore::String(escaped_script.data(),
                                  static_cast<int>(escaped_script.length())));

    ExecuteScript(original_url, webkit_glue::StringToStdWString(script), notify,
                  notify_data, popups_allowed);
  webframe_->set_plugin_delegate(NULL);
  // plugin as is. This avoids having to track the notification arguments
  // in the plugin process.
                     bool notify_needed, intptr_t notify_data, bool popups_allowed);
  // Given a download request, check if we need to route the output
  // to a frame.  Returns ROUTED if the load is done and routed to
  // a frame, NOT_ROUTED or corresponding error codes otherwise.
  RoutingStatus RouteToFrame(const char *method, bool is_javascript_url,
                             const char* buf, bool is_file_data, bool notify,
  virtual WebKit::WebFrame* GetFrameWithName(const std::wstring& name) = 0;
WebFrame* WebViewImpl::GetFrameWithName(const std::wstring& name) {
  String name_str = webkit_glue::StdWStringToString(name);
  virtual WebKit::WebFrame* GetFrameWithName(const std::wstring& name);
#include "webkit/glue/webdatasource_impl.h"
    static_cast<WebDataSourceImpl*>(ds)->setDeferMainResourceDataLoad(false);
  if (!entry.GetTargetFrame().empty())
      frame = webView()->GetFrameWithName(entry.GetTargetFrame());
  if (!MakeCurrent())
  if (glGetError() != GL_NO_ERROR)
  if (!g_display)
  if (!eglInitialize(g_display, NULL, NULL) == EGL_TRUE)
  if (num_configs == 0)
  if (!UpdateSize())
    DLOG(ERROR) << "Error choosing pixel format.";
    DLOG(ERROR) << "Error creating context.";
    DLOG(ERROR) << "Error creating pbuffer.";
    DLOG(ERROR) << "Error attaching pbuffer to context.";
    DLOG(ERROR) << "Couldn't make context current for initialization.";
      DLOG(ERROR) << "Unable to make gl context current.";
  if (!context_)
        DLOG(ERROR) << "Unable to get the pixel format for GL context.";
        DLOG(ERROR) << "Unable to set the pixel format for GL context.";
      if (!BaseEGLContext::InitializeOneOff())
    DLOG(ERROR) << "Unable to set the pixel format for GL context.";
    DLOG(ERROR) << "Failed to create GL context.";
    DLOG(ERROR) << "Unable to make gl context current.";
    DLOG(ERROR) << "Unable to create pbuffer.";
    DLOG(ERROR) << "Unable to get pbuffer device context.";
    DLOG(ERROR) << "Failed to create GL context.";
      DLOG(ERROR) << "Could not share GL contexts.";
    DLOG(ERROR) << "Unable to make gl context current.";
      if (!PathService::Get(base::DIR_MODULE, &module_path))
        DLOG(INFO) << "libGL.so.1 not found.";
        DLOG(INFO) << "libEGL.so not found";
        DLOG(INFO) << "libGLESv2.so not found";
      if (!PathService::Get(base::DIR_MODULE, &module_path))
        LOG(INFO) << "libosmesa.so not found";
        LOG(INFO) << "OpenGL framework not found";
      if (!PathService::Get(base::DIR_MODULE, &module_path))
        LOG(INFO) << "osmesa.dll not found";
        LOG(INFO) << "libegl.dll not found.";
  if (ring_buffer_.get())
  if (size <= 0 || size > kMaxCommandBufferSize)
  if (max_vertex_attribs_ < kGLES2RequiredMinimumVertexAttribs)
  if (max_texture_units_ < kGLES2RequiredMinimumTextureUnits)
      DLOG(ERROR) << "Could not allocate offscreen buffer storage.";
        DLOG(ERROR) << "Could not initialize vertex shader translator.";
        DLOG(ERROR) << "Could not initialize fragment shader translator.";
    DLOG(ERROR) << last_error_;
    if (!UpdateOffscreenFrameBufferSize())
    if (!context_->SwapBuffers())
    // TODO(apatrick): need to do more than this on failure.
    if (!decoder_->MakeCurrent())
  if (!context.get())
    return currentSpeechUtterance();
void SpeechSynthesis::startSpeakingImmediately()
    SpeechSynthesisUtterance* utterance = currentSpeechUtterance();
    ASSERT(utterance);

    // If the queue was empty, speak this immediately.
        startSpeakingImmediately();
    // Remove all the items from the utterance queue. The platform
    // may still have references to some of these utterances and may
    // fire events on them asynchronously.
    if (!currentSpeechUtterance())
    bool didJustFinishCurrentUtterance = false;
    // If the utterance that completed was the one we're currently speaking,
    // remove it from the queue and start speaking the next one.
    if (utterance == currentSpeechUtterance()) {
        m_utteranceQueue.removeFirst();
        didJustFinishCurrentUtterance = true;
    }

    // Always fire the event, because the platform may have asynchronously
    // sent an event on an utterance before it got the message that we
    // canceled it, and we should always report to the user what actually
    // happened.
    // Start the next utterance if we just finished one and one was pending.
    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
SpeechSynthesisUtterance* SpeechSynthesis::currentSpeechUtterance() const
{
    if (!m_utteranceQueue.isEmpty())
        return m_utteranceQueue.first().get();
    return nullptr;
}

    void startSpeakingImmediately();
    // Returns the utterance at the front of the queue.
    SpeechSynthesisUtterance* currentSpeechUtterance() const;

    , m_speakingErrorOccurredTimer(this, &PlatformSpeechSynthesizerMock::speakingErrorOccurred)
    m_speakingErrorOccurredTimer.stop();
void PlatformSpeechSynthesizerMock::speakingErrorOccurred(Timer<PlatformSpeechSynthesizerMock>*)
{
    ASSERT(m_utterance.get());
    client()->speakingErrorOccurred(m_utterance);
    m_utterance = nullptr;
}

    m_speakingErrorOccurredTimer.startOneShot(.1);
    void speakingErrorOccurred(Timer<PlatformSpeechSynthesizerMock>*);
    Timer<PlatformSpeechSynthesizerMock> m_speakingErrorOccurredTimer;
  if (context_)
  context_.reset();
      url_(web_frame_ ? GetDataSourceURLForFrame(web_frame_) : GURL()) {
  gin::PerContextData::From(v8_context)->set_runner(this);
void ScriptContext::Run(const std::string& source,
                        const std::string& resource_name) {
  module_system_->RunString(source, resource_name);
}

v8::Handle<v8::Value> ScriptContext::Call(v8::Handle<v8::Function> function,
                                          v8::Handle<v8::Value> receiver,
                                          int argc,
                                          v8::Handle<v8::Value> argv[]) {
  return CallFunction(function, argc, argv);
}

gin::ContextHolder* ScriptContext::GetContextHolder() {
  v8::HandleScope handle_scope(isolate());
  return gin::PerContextData::From(v8_context())->context_holder();
}

class ScriptContext : public RequestSender::Source, public gin::Runner {
  // gin::Runner overrides.
  void Run(const std::string& source,
           const std::string& resource_name) override;
  v8::Handle<v8::Value> Call(v8::Handle<v8::Function> function,
                             v8::Handle<v8::Value> receiver,
                             int argc,
                             v8::Handle<v8::Value> argv[]) override;
  gin::ContextHolder* GetContextHolder() override;

                                      this);
  UpdateClearPluginLSOData();
void ClearBrowserDataHandler::Observe(NotificationType type,
                                      const NotificationSource& source,
                                      const NotificationDetails& details) {
  switch (type.value) {
    case NotificationType::PREF_CHANGED: {
      const std::string& pref_name = *Details<std::string>(details).ptr();
      if (pref_name == prefs::kClearPluginLSODataEnabled)
        UpdateClearPluginLSOData();
      else
        OptionsPageUIHandler::Observe(type, source, details);
      break;
    }

    default:
      OptionsPageUIHandler::Observe(type, source, details);
  }
}

    if (clear_plugin_lso_data_enabled_.GetValue())
void ClearBrowserDataHandler::UpdateClearPluginLSOData() {
  int label_id = clear_plugin_lso_data_enabled_.GetValue() ?
      IDS_DEL_COOKIES_FLASH_CHKBOX :
      IDS_DEL_COOKIES_CHKBOX;
  scoped_ptr<Value> label(
      Value::CreateStringValue(l10n_util::GetStringUTF16(label_id)));
  web_ui_->CallJavascriptFunction(
      "ClearBrowserDataOverlay.setClearLocalDataLabel", *label);
}

#include "chrome/browser/plugin_data_remover_helper.h"
  // NotificationObserver implementation.
  virtual void Observe(NotificationType type,
                       const NotificationSource& source,
                       const NotificationDetails& details);

  // Updates the UI to reflect whether clearing LSO data is supported.
  void UpdateClearPluginLSOData();

  // Used for asynchronously updating the preference stating whether clearing
  // LSO data is supported.
  PluginDataRemoverHelper clear_plugin_lso_data_enabled_;
  clear_plugin_lso_data_enabled_.Init(prefs::kClearPluginLSODataEnabled,
                                      g_browser_process->local_state(),
                                      this);
  UpdateClearPluginLSOData();

      else if (pref_name == prefs::kClearPluginLSODataEnabled)
        UpdateClearPluginLSOData();
void ContentSettingsHandler::UpdateClearPluginLSOData() {
  int label_id = clear_plugin_lso_data_enabled_.GetValue() ?
      IDS_COOKIES_LSO_CLEAR_WHEN_CLOSE_CHKBOX :
      IDS_COOKIES_CLEAR_WHEN_CLOSE_CHKBOX;
  scoped_ptr<Value> label(
      Value::CreateStringValue(l10n_util::GetStringUTF16(label_id)));
  web_ui_->CallJavascriptFunction(
      "ContentSettings.setClearLocalDataOnShutdownLabel", *label);
}

  // Updates the state of the "Clear plugin LSO data on exit" checkbox.
  void UpdateClearPluginLSOData();
  PluginDataRemoverHelper clear_plugin_lso_data_enabled_;
    return &mock_core_options_handler_;
  StrictMock<MockCoreOptionsHandler> mock_core_options_handler_;
  EXPECT_CALL(mock_core_options_handler_,
// Whether there is a Flash version installed that supports clearing LSO data.
const char kClearPluginLSODataEnabled[] = "browser.clear_lso_data_enabled";

extern const char kClearPluginLSODataEnabled[];
WebURL WebDataSourceImpl::endOfRedirectChain() const
void WebDataSourceImpl::appendRedirect(const WebURL& url)
        WebURL endOfRedirectChain() const;
        void appendRedirect(const WebURL& url);
        Vector<WebURL> m_redirectChain;
#include "googleurl/src/gurl.h"
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate) {
    delegate->setWindowRect(
  if (webview_->delegate()) {
    rect = webview_->delegate()->rootWindowRect();
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate) {
    delegate->didFocus();

    // If accessibility is enabled, we should notify assistive technology that
    // the active AccessibilityObject changed.
    const WebCore::Frame* frame = webview_->GetFocusedWebCoreFrame();
    if (!frame)
      return;
    WebCore::Document* doc = frame->document();
    if (doc && doc->axObjectCache()->accessibilityEnabled()) {
      WebCore::Node* focused_node = webview_->GetFocusedNode();
      if (!focused_node) {
        // Could not retrieve focused Node.
        return;
      }
      // Retrieve the focused AccessibilityObject.
      WebCore::AccessibilityObject* focused_acc_obj =
          doc->axObjectCache()->getOrCreate(focused_node->renderer());
      // Alert assistive technology that focus changed.
      if (focused_acc_obj)
        delegate->FocusAccessibilityObject(focused_acc_obj);
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate)
    delegate->didBlur();
  return webview_->delegate() != NULL;
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate)
    delegate->runModal();
  return webview_->delegate() != NULL;
  if (webview_->delegate()) {
        webview_->delegate()->windowResizerRect());
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate)
    delegate->didInvalidateRect(webkit_glue::IntRectToWebRect(paint_rect));
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate) {
    delegate->didScrollRect(
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate) {
    WebRect window_rect = delegate->windowRect();
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate)
    delegate->didChangeCursor(cursor);
#include <string>
#include <vector>

#include "base/basictypes.h"
#include "base/logging.h"
#include "base/string_util.h"
#include "webkit/glue/plugins/plugin_list.h"
#include "webkit/glue/webview_delegate.h"
using base::Time;
using base::TimeDelta;

    NOTREACHED() << "Got a server redirect when there is no provisional DS";
  DCHECK(ds->hasRedirectChain());
  ds->appendRedirect(ds->request().url());
    expected_client_redirect_src_ = GURL();
    expected_client_redirect_dest_ = GURL();
  expected_client_redirect_src_ = webframe_->url();
  expected_client_redirect_dest_ = webkit_glue::KURLToGURL(url);
  if (expected_client_redirect_dest_.SchemeIsFile() &&
     (expected_client_redirect_src_.SchemeIs("http") ||
      expected_client_redirect_src_.SchemeIsSecure())) {
    expected_client_redirect_src_ = GURL();
    expected_client_redirect_dest_ = GURL();
        expected_client_redirect_src_,
        expected_client_redirect_dest_,
  DCHECK(ds) << "DataSource NULL when navigating to reference fragment";
    GURL url = ds->request().url();
    GURL chain_end = ds->endOfRedirectChain();
      if (webframe_->client())
        webframe_->client()->didCompleteClientRedirect(webframe_, chain_end);
      expected_client_redirect_src_ = GURL();
      expected_client_redirect_dest_ = GURL();
    NOTREACHED() << "Attempting to provisional load but there isn't one";
  GURL url = ds->request().url();
  DCHECK(!ds->hasRedirectChain());
  if (expected_client_redirect_src_.is_valid()) {
    DCHECK(expected_client_redirect_dest_.SchemeIs("javascript") ||
          webframe_, expected_client_redirect_src_);
  DCHECK(next_navigation_policy_ != WebKit::WebNavigationPolicyIgnore);
  WebViewDelegate* d = webview->delegate();
  if (d)
    d->show(webview->initial_navigation_policy());
      GURL url = ds->request().url();
      if (url.SchemeIs(webkit_glue::kBackForwardNavigationScheme)) {
  NOTREACHED() << "Page cache should be disabled";
  NOTREACHED();
  DCHECK(plugin_widget_.get());
  String rv;
  return rv;
void WebFrameLoaderClient::HandleBackForwardNavigation(const GURL& url) {
  DCHECK(url.SchemeIs(webkit_glue::kBackForwardNavigationScheme));
  std::string offset_str = url.ExtractFileName();
  int offset;
  if (!StringToInt(offset_str, &offset))
#include "googleurl/src/gurl.h"
  void HandleBackForwardNavigation(const GURL&);
  GURL expected_client_redirect_src_;
  GURL expected_client_redirect_dest_;
  IPC_SYNC_MESSAGE_ROUTED1_0(PluginMsg_DidFinishLoadWithReason,
                             int /* reason */)
                      std::string /* url */,
                      std::wstring /* result */,

  IPC_SYNC_MESSAGE_ROUTED3_0(PluginMsg_URLRequestRouted,
                             std::string /* url */,
                             bool /* notify_needed */,
                             intptr_t /* notify data */)
    IPC_MESSAGE_HANDLER(PluginMsg_URLRequestRouted, OnURLRequestRouted)
void WebPluginDelegateStub::OnDidFinishLoadWithReason(int reason) {
  delegate_->DidFinishLoadWithReason(reason);
void WebPluginDelegateStub::OnSendJavaScriptStream(const std::string& url,
                                                   const std::wstring& result,

void WebPluginDelegateStub::OnURLRequestRouted(const std::string& url,
                                               bool notify_needed,
                                               intptr_t notify_data) {
  delegate_->URLRequestRouted(url, notify_needed, notify_data);
}
  void OnDidFinishLoadWithReason(int reason);
  void OnSendJavaScriptStream(const std::string& url,
                              const std::wstring& result,
  void OnURLRequestRouted(const std::string& url, bool notify_needed,
                          intptr_t notify_data);

  WebFrame* sub1_frame = view_->webview()->GetFrameWithName(L"sub1");
void WebPluginDelegateProxy::SendJavaScriptStream(const std::string& url,
                                                  const std::wstring& result,
void WebPluginDelegateProxy::DidFinishLoadWithReason(NPReason reason) {
  Send(new PluginMsg_DidFinishLoadWithReason(instance_id_, reason));
void WebPluginDelegateProxy::URLRequestRouted(const std::string& url,
                                               bool notify_needed,
                                               intptr_t notify_data) {
  Send(new PluginMsg_URLRequestRouted(instance_id_, url, notify_needed,
                                      notify_data));
}

  virtual void DidFinishLoadWithReason(NPReason reason);
  virtual void SendJavaScriptStream(const std::string& url,
                                    const std::wstring& result,
  // Notifies the delegate about a Get/Post URL request getting routed
  virtual void URLRequestRouted(const std::string&url, bool notify_needed,
                                intptr_t notify_data);

#include "webkit/glue/webdatasource_impl.h"
      WebDataSource* ds = WebDataSourceImpl::FromLoader(dl);
  WebDataSource* ds = WebDataSourceImpl::FromLoader(dl);
  WebFrame* iframe = test_shell_->webView()->GetFrameWithName(L"ifr");
      get_notify_data_(NULL),
void PluginInstance::SetURLLoadData(const GURL& url,
                                    intptr_t notify_data) {
  get_url_ = url;
  get_notify_data_ = notify_data;
}

void PluginInstance::DidFinishLoadWithReason(NPReason reason) {
  if (!get_url_.is_empty()) {
    NPP_URLNotify(get_url_.spec().c_str(), reason,
        reinterpret_cast<void*>(get_notify_data_));
  }

  get_url_ = GURL();
  get_notify_data_ = NULL;
void PluginInstance::SendJavaScriptStream(const std::string& url,
                                          const std::wstring& result,
    stream->SendToPlugin(WideToUTF8(result), "text/html");
      this->NPP_URLNotify(url.c_str(), NPRES_DONE,
  virtual void DidFinishLoadWithReason(NPReason reason);

  // Helper method to set some persistent data for getURLNotify since
  // resource fetches happen async.
  void SetURLLoadData(const GURL& url, intptr_t notify_data);
  void SendJavaScriptStream(const std::string& url, const std::wstring& result,
    PluginInstance *instance,
    const std::string &url,
    void *notify_data)
    : PluginStream(instance, url.c_str(), notify_needed, notify_data) {
#ifndef WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H__
#define WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H__
  PluginStringStream(PluginInstance *instance,
                     const std::string &url,
                     void *notify_data);
  void SendToPlugin(const std::string &data,
                    const std::string &mime_type);

  DISALLOW_EVIL_CONSTRUCTORS(PluginStringStream);
#endif // WEBKIT_GLUE_PLUGIN_PLUGIN_STRING_STREAM_H__
void WebPluginDelegateImpl::DidFinishLoadWithReason(NPReason reason) {
  instance()->DidFinishLoadWithReason(reason);
void WebPluginDelegateImpl::SendJavaScriptStream(const std::string& url,
                                                 const std::wstring& result,
  if (notify_needed) {
    instance()->SetURLLoadData(url, notify_data);
  }

void WebPluginDelegateImpl::URLRequestRouted(const std::string&url,
                                             bool notify_needed,
                                             intptr_t notify_data) {
  if (notify_needed) {
    instance()->SetURLLoadData(GURL(url.c_str()), notify_data);
  }
}
  virtual void DidFinishLoadWithReason(NPReason reason);
  virtual void SendJavaScriptStream(const std::string& url,
                                    const std::wstring& result,
  virtual void URLRequestRouted(const std::string&url, bool notify_needed,
                                intptr_t notify_data);

// Copyright (c) 2006-2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "config.h"
#include "webkit/glue/webdatasource_impl.h"

#include "webkit/api/public/WebURL.h"
#include "webkit/api/public/WebVector.h"
#include "webkit/glue/glue_util.h"

using WebCore::DocumentLoader;
using WebCore::ResourceRequest;
using WebCore::ResourceResponse;
using WebCore::SubstituteData;

using WebKit::WebDataSource;
using WebKit::WebNavigationType;
using WebKit::WebString;
using WebKit::WebURL;
using WebKit::WebURLRequest;
using WebKit::WebURLResponse;
using WebKit::WebVector;

// static
PassRefPtr<WebDataSourceImpl> WebDataSourceImpl::Create(
    const ResourceRequest& request,
    const SubstituteData& data) {
  return adoptRef(new WebDataSourceImpl(request, data));
}

WebDataSourceImpl::WebDataSourceImpl(const ResourceRequest& request,
                                     const SubstituteData& data)
    : DocumentLoader(request, data) {
}

WebDataSourceImpl::~WebDataSourceImpl() {
}

const WebURLRequest& WebDataSourceImpl::originalRequest() const {
  original_request_.bind(DocumentLoader::originalRequest());
  return original_request_;
}

const WebURLRequest& WebDataSourceImpl::request() const {
  request_.bind(DocumentLoader::request());
  return request_;
}

const WebURLResponse& WebDataSourceImpl::response() const {
  response_.bind(DocumentLoader::response());
  return response_;
}

bool WebDataSourceImpl::hasUnreachableURL() const {
  return !DocumentLoader::unreachableURL().isEmpty();
}

WebURL WebDataSourceImpl::unreachableURL() const {
  return webkit_glue::KURLToWebURL(DocumentLoader::unreachableURL());
}

void WebDataSourceImpl::redirectChain(WebVector<WebURL>& result) const {
  result.assign(redirect_chain_);
}

WebString WebDataSourceImpl::pageTitle() const {
  return webkit_glue::StringToWebString(title());
}

WebNavigationType WebDataSourceImpl::navigationType() const {
  return NavigationTypeToWebNavigationType(triggeringAction().type());
}

double WebDataSourceImpl::triggeringEventTime() const {
  if (!triggeringAction().event())
    return 0.0;

  // DOMTimeStamp uses units of milliseconds.
  return triggeringAction().event()->timeStamp() / 1000.0;
}

WebDataSource::ExtraData* WebDataSourceImpl::extraData() const {
  return extra_data_.get();
}

void WebDataSourceImpl::setExtraData(ExtraData* extra_data) {
  extra_data_.set(extra_data);
}

WebNavigationType WebDataSourceImpl::NavigationTypeToWebNavigationType(
    WebCore::NavigationType type) {
  switch (type) {
    case WebCore::NavigationTypeLinkClicked:
      return WebKit::WebNavigationTypeLinkClicked;
    case WebCore::NavigationTypeFormSubmitted:
      return WebKit::WebNavigationTypeFormSubmitted;
    case WebCore::NavigationTypeBackForward:
      return WebKit::WebNavigationTypeBackForward;
    case WebCore::NavigationTypeReload:
      return WebKit::WebNavigationTypeReload;
    case WebCore::NavigationTypeFormResubmitted:
      return WebKit::WebNavigationTypeFormResubmitted;
    case WebCore::NavigationTypeOther:
    default:
      return WebKit::WebNavigationTypeOther;
  }
}

GURL WebDataSourceImpl::GetEndOfRedirectChain() const {
  ASSERT(!redirect_chain_.isEmpty());
  return redirect_chain_.last();
}

void WebDataSourceImpl::ClearRedirectChain() {
  redirect_chain_.clear();
}

void WebDataSourceImpl::AppendRedirect(const GURL& url) {
  redirect_chain_.append(url);
}
// Copyright (c) 2006-2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef WEBKIT_GLUE_WEBDATASOURCE_IMPL_H_
#define WEBKIT_GLUE_WEBDATASOURCE_IMPL_H_

#include "DocumentLoader.h"
#include <wtf/Vector.h>
#include <wtf/OwnPtr.h>

#include "webkit/api/public/WebDataSource.h"
#include "webkit/api/src/WrappedResourceRequest.h"
#include "webkit/api/src/WrappedResourceResponse.h"

class GURL;
class WebFrameImpl;
class WebDocumentLoaderImpl;

class WebDataSourceImpl : public WebCore::DocumentLoader,
                          public WebKit::WebDataSource {
 public:
  static PassRefPtr<WebDataSourceImpl> Create(const WebCore::ResourceRequest&,
                                              const WebCore::SubstituteData&);

  static WebDataSourceImpl* FromLoader(WebCore::DocumentLoader* loader) {
    return static_cast<WebDataSourceImpl*>(loader);
  }

  // WebDataSource methods:
  virtual const WebKit::WebURLRequest& originalRequest() const;
  virtual const WebKit::WebURLRequest& request() const;
  virtual const WebKit::WebURLResponse& response() const;
  virtual bool hasUnreachableURL() const;
  virtual WebKit::WebURL unreachableURL() const;
  virtual void redirectChain(WebKit::WebVector<WebKit::WebURL>&) const;
  virtual WebKit::WebString pageTitle() const;
  virtual WebKit::WebNavigationType navigationType() const;
  virtual double triggeringEventTime() const;
  virtual ExtraData* extraData() const;
  virtual void setExtraData(ExtraData*);

  static WebKit::WebNavigationType NavigationTypeToWebNavigationType(
      WebCore::NavigationType type);

  bool HasRedirectChain() const { return !redirect_chain_.isEmpty(); }
  GURL GetEndOfRedirectChain() const;
  void ClearRedirectChain();
  void AppendRedirect(const GURL& url);

 private:
  WebDataSourceImpl(const WebCore::ResourceRequest&,
                    const WebCore::SubstituteData&);
  ~WebDataSourceImpl();

  // Mutable because the const getters will magically sync these to the
  // latest version from WebKit.
  mutable WebKit::WrappedResourceRequest original_request_;
  mutable WebKit::WrappedResourceRequest request_;
  mutable WebKit::WrappedResourceResponse response_;

  // Lists all intermediate URLs that have redirected for the current
  // provisional load. See WebFrameLoaderClient::
  // dispatchDidReceiveServerRedirectForProvisionalLoad for a description of
  // who modifies this when to keep it up to date.
  Vector<WebKit::WebURL> redirect_chain_;

  OwnPtr<ExtraData> extra_data_;

  DISALLOW_COPY_AND_ASSIGN(WebDataSourceImpl);
};

#endif  // WEBKIT_GLUE_WEBDATASOURCE_IMPL_H_
#include "webkit/glue/webdatasource_impl.h"
  return loader ? WebDataSourceImpl::FromLoader(loader) : NULL;
    plugin_delegate_(NULL),
class WebDataSourceImpl;
class WebPluginDelegate;
  // The plugin delegate is used to get notifications when downloads complete.
  // This is used by the NPAPI method getURLNotify.  plugin_delegate() may
  // return NULL.  TODO(darin): how come there is only one per frame?!?
  WebPluginDelegate* plugin_delegate() const {
    return plugin_delegate_;
  }
  void set_plugin_delegate(WebPluginDelegate* plugin_delegate) {
    plugin_delegate_ = plugin_delegate;
  }

  WebDataSourceImpl* GetDataSourceImpl() const;
  WebDataSourceImpl* GetProvisionalDataSourceImpl() const;
  // Plugins sometimes need to be notified when loads are complete so we keep
  // a pointer back to the appropriate plugin.
  WebPluginDelegate* plugin_delegate_;

#include "webkit/glue/webdatasource_impl.h"
      WebDataSourceImpl::FromLoader(documentLoader);
  DCHECK(ds->HasRedirectChain());
  ds->AppendRedirect(ds->request().url());
    GURL chain_end = ds->GetEndOfRedirectChain();
    ds->ClearRedirectChain();
      ds->AppendRedirect(chain_end);
    ds->AppendRedirect(url);
  DCHECK(!ds->HasRedirectChain());
    ds->AppendRedirect(expected_client_redirect_src_);
  ds->AppendRedirect(url);
  } else {
    webframe_->DidFail(error, true);
    WebPluginDelegate* plg_delegate = webframe_->plugin_delegate();
    if (plg_delegate)
      plg_delegate->DidFinishLoadWithReason(NPRES_NETWORK_ERR);

  WebPluginDelegate* plg_delegate = webframe_->plugin_delegate();
  if (plg_delegate)
    plg_delegate->DidFinishLoadWithReason(NPRES_NETWORK_ERR);
  DocumentLoader* documentLoader =
      webframe_->frame()->loader()->activeDocumentLoader();
  WebDataSourceImpl* dataSource =
      WebDataSourceImpl::FromLoader(documentLoader);
  WebPluginDelegate* plg_delegate = webframe_->plugin_delegate();
  if (plg_delegate)
    plg_delegate->DidFinishLoadWithReason(NPRES_DONE);
        bool is_redirect = ds->HasRedirectChain();
            WebDataSourceImpl::NavigationTypeToWebNavigationType(action.type());
  WebPluginDelegate* plg_delegate = webframe_->plugin_delegate();
  if (plg_delegate)
    plg_delegate->DidFinishLoadWithReason(NPRES_DONE);
  RefPtr<WebDataSourceImpl> ds = WebDataSourceImpl::Create(request, data);
  virtual WebCore::ObjectContentType objectContentType(const WebCore::KURL& url,
                                              const WebCore::String& mimeType);
#include "build/build_config.h"
  virtual void DidFinishLoadWithReason(NPReason reason) = 0;
  // The result of the script execution is returned via this function.
  virtual void SendJavaScriptStream(const std::string& url,
                                    const std::wstring& result,
  // Notifies the delegate about a Get/Post URL request getting routed.
  virtual void URLRequestRouted(const std::string&url, bool notify_needed,
                                intptr_t notify_data) = 0;

bool WebPluginImpl::ExecuteScript(const std::string& url,
                                  const std::wstring& script,
                                  bool notify_needed,
                                  intptr_t notify_data,
                                  bool popups_allowed) {
  // This could happen if the WebPluginContainer was already deleted.
  if (!frame())
    return false;

  // Pending resource fetches should also not trigger a callback.
  webframe_->set_plugin_delegate(NULL);

  WebCore::String script_str(webkit_glue::StdWStringToString(script));

  // Note: the call to executeScript might result in the frame being
  // deleted, so add an extra reference to it in this scope.
  // For KJS, keeping a pointer to the JSBridge is enough, but for V8
  // we also need to addref the frame.
  WTF::RefPtr<WebCore::Frame> cur_frame(frame());

  WebCore::ScriptValue result =
      frame()->loader()->executeScript(script_str, popups_allowed);
  WebCore::String script_result;
  std::wstring wresult;
  bool succ = false;
  if (result.getString(script_result)) {
    succ = true;
    wresult = webkit_glue::StringToStdWString(script_result);
  }

  // delegate_ could be NULL because executeScript caused the container to be
  // deleted.
  if (delegate_)
    delegate_->SendJavaScriptStream(url, wresult, succ, notify_needed,
                                    notify_data);

  return succ;
}

                                          bool notify, const char* url,
                                          GURL* unused) {
  if (!frame())
  WebCore::String str_target = target;
    WebCore::Frame *frameTarget = frame()->tree()->find(str_target);
    if (frameTarget != frame()) {
      // FIXME - might be good to log this into a security
      //         log somewhere.
  // TODO(darin): Eliminate these WebCore dependencies.

  WebCore::FrameLoadRequest load_request(
      *webkit_glue::WebURLRequestToResourceRequest(&request));
  load_request.setFrameName(str_target);
  WebCore::FrameLoader *loader = frame()->loader();
  // we actually don't know whether usergesture is true or false,
  // passing true since all we can do is assume it is okay.
  loader->loadFrameRequest(
      load_request,
      false,  // lock history
      false,  // lock back forward list
      0,      // event
      0);     // form state

  // loadFrameRequest() can cause the frame to go away.
  if (webframe_) {
    WebPluginDelegate* last_plugin = webframe_->plugin_delegate();
    if (last_plugin) {
      last_plugin->DidFinishLoadWithReason(NPRES_USER_BREAK);
      webframe_->set_plugin_delegate(NULL);
    }

    if (notify)
      webframe_->set_plugin_delegate(delegate_);
  }

                                    buf, is_file_data, notify, url,
                                    &complete_url);
  if (routing_status == ROUTED) {
    // The delegate could have gone away because of this call.
    if (delegate_)
      delegate_->URLRequestRouted(url, notify, notify_data);
  }
    std::string original_url = url;

    // Convert the javascript: URL to javascript by unescaping. WebCore uses
    // decode_string for this, so we do, too.
    std::string escaped_script = original_url.substr(strlen("javascript:"));
    WebCore::String script = WebCore::decodeURLEscapeSequences(
        WebCore::String(escaped_script.data(),
                                  static_cast<int>(escaped_script.length())));

    ExecuteScript(original_url, webkit_glue::StringToStdWString(script), notify,
                  notify_data, popups_allowed);
  webframe_->set_plugin_delegate(NULL);
  // plugin as is. This avoids having to track the notification arguments
  // in the plugin process.
                     bool notify_needed, intptr_t notify_data, bool popups_allowed);
  // Given a download request, check if we need to route the output
  // to a frame.  Returns ROUTED if the load is done and routed to
  // a frame, NOT_ROUTED or corresponding error codes otherwise.
  RoutingStatus RouteToFrame(const char *method, bool is_javascript_url,
                             const char* buf, bool is_file_data, bool notify,
  virtual WebKit::WebFrame* GetFrameWithName(const std::wstring& name) = 0;
WebFrame* WebViewImpl::GetFrameWithName(const std::wstring& name) {
  String name_str = webkit_glue::StdWStringToString(name);
  virtual WebKit::WebFrame* GetFrameWithName(const std::wstring& name);
#include "webkit/glue/webdatasource_impl.h"
    static_cast<WebDataSourceImpl*>(ds)->setDeferMainResourceDataLoad(false);
  if (!entry.GetTargetFrame().empty())
      frame = webView()->GetFrameWithName(entry.GetTargetFrame());
#include "chrome/browser/webui/options/options_managed_banner_handler.h"
#include "chrome/browser/webui/options/core_options_handler.h"
#include "chrome/browser/webui/options/language_options_handler.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/content_settings_handler.h"
#include "chrome/browser/webui/options/about_page_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#include "chrome/browser/webui/options/add_startup_page_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#include "chrome/browser/webui/options/advanced_options_handler.h"
#include "chrome/browser/webui/options/dom_options_util.h"
#include "chrome/browser/webui/options/options_managed_banner_handler.h"
#include "chrome/browser/webui/options/advanced_options_utils.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#include "chrome/browser/webui/options/advanced_options_utils.h"
#include "chrome/browser/webui/options/advanced_options_utils.h"
#include "chrome/browser/webui/options/autofill_options_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/browser_options_handler.h"
#include "chrome/browser/webui/options/dom_options_util.h"
#include "chrome/browser/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/certificate_manager_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/clear_browser_data_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#include "chrome/browser/webui/options/content_settings_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#include "chrome/browser/webui/options/cookies_view_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#include "chrome/browser/webui/options/core_options_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/dom_options_util.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#include "chrome/browser/webui/options/font_settings_handler.h"
#include "chrome/browser/webui/options/dom_options_util.h"
#include "chrome/browser/webui/options/font_settings_utils.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#include "chrome/browser/webui/options/font_settings_utils.h"
#include "chrome/browser/webui/options/font_settings_utils.h"
#include "chrome/browser/webui/options/import_data_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#include "chrome/browser/webui/options/language_options_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/language_options_handler_common.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/language_options_handler_common.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#include "chrome/browser/webui/options/language_options_handler.h"
#include "chrome/browser/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/about_page_handler.h"
#include "chrome/browser/webui/options/add_startup_page_handler.h"
#include "chrome/browser/webui/options/advanced_options_handler.h"
#include "chrome/browser/webui/options/autofill_options_handler.h"
#include "chrome/browser/webui/options/browser_options_handler.h"
#include "chrome/browser/webui/options/clear_browser_data_handler.h"
#include "chrome/browser/webui/options/content_settings_handler.h"
#include "chrome/browser/webui/options/cookies_view_handler.h"
#include "chrome/browser/webui/options/core_options_handler.h"
#include "chrome/browser/webui/options/dom_options_util.h"
#include "chrome/browser/webui/options/font_settings_handler.h"
#include "chrome/browser/webui/options/import_data_handler.h"
#include "chrome/browser/webui/options/language_options_handler.h"
#include "chrome/browser/webui/options/password_manager_handler.h"
#include "chrome/browser/webui/options/personal_options_handler.h"
#include "chrome/browser/webui/options/search_engine_manager_handler.h"
#include "chrome/browser/webui/options/stop_syncing_handler.h"
#include "chrome/browser/webui/options/certificate_manager_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_UI_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_UI_H_
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_UI_H_
#include "chrome/browser/webui/options/password_manager_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/personal_options_handler.h"
#include "chrome/browser/webui/options/dom_options_util.h"
#include "chrome/browser/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/search_engine_manager_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/stop_syncing_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#include "chrome/browser/webui/options/core_options_handler.h"
#include "chrome/browser/webui/options/options_ui.h"
  ASSERT_TRUE(shared_buf.Create(L"", false, true, bytes));
  if (!dib->shared_memory_.Create(L"", false /* read write */,
  if (!dib->shared_memory_.Create(L"", false /* read write */,
  bool Create(const std::wstring& name, bool read_only, bool open_existing,
  bool Delete(const std::wstring& name);
  bool Open(const std::wstring& name, bool read_only);
  bool CreateOrOpen(const std::wstring &name, int posix_flags, uint32 size);
  bool FilePathForMemoryName(const std::wstring& memname, FilePath* path);

bool SharedMemory::Create(const std::wstring &name, bool read_only,
bool SharedMemory::Delete(const std::wstring& name) {
bool SharedMemory::Open(const std::wstring &name, bool read_only) {
// For the given shmem named |memname|, return a filename to mmap()
bool SharedMemory::FilePathForMemoryName(const std::wstring& memname,
  DCHECK(memname.find_first_of(L"/") == std::string::npos);
  DCHECK(memname.find_first_of(L"\0") == std::string::npos);
  if (file_util::GetShmemTempDir(&temp_dir) == false)
  *path = temp_dir.AppendASCII("com.google.chrome.shmem." +
                               WideToUTF8(memname));
bool SharedMemory::CreateOrOpen(const std::wstring &name,
  if (name == L"") {
  static const wchar_t* const s_test_name_;
const wchar_t* const MultipleThreadMain::s_test_name_ =
    L"SharedMemoryOpenThreadTest";
      EXPECT_TRUE(memory1.Create(L"SharedMemoryMultipleLockThreadTest",
  std::wstring test_name = L"SharedMemoryOpenCloseTest";
    rv = memories[i].Create(L"", false, true, kDataSize);
  static const wchar_t* const s_test_name_;
const wchar_t* const SharedMemoryProcessTest::s_test_name_ = L"MPMem";
bool SharedMemory::Create(const std::wstring &name, bool read_only,
  name_ = name;
      name.empty() ? NULL : name.c_str());
bool SharedMemory::Delete(const std::wstring& name) {
bool SharedMemory::Open(const std::wstring &name, bool read_only) {
  name_ = name;
      name.empty() ? NULL : name.c_str());
  if (!priv->shared_memory_.Create(UTF8ToWide(name), false, true, size))
  void DeleteShmem(std::string name) {
    mem.Delete(UTF8ToWide(name));
  if (!shared_memory->Create(std::wstring(),  // anonymous
    if (shared_memory_.Create(std::wstring(), false, false, buffer_size_) &&
  if (!entry->shared_memory.Create(L"", false, false, hardware_packet_size) ||
    if (shm.Create(L"", false, false, shm_size))
  if (!shared_memory->Create(L"", false /* read write */,
  shared_buf.Create(L"", false, false, buffer_size);
  if (!shared_memory_->Create(std::wstring() /* anonymous */,
      EXPECT_TRUE(shared_mem.Create(std::wstring(),
          false, false, test_page_contents_len));
    EXPECT_EQ(true, shared_handle_.Create(L"DeferredResourceLoaderTest", false,
  if (!input_transfer_buffer_->Create(std::wstring(), false, false, size))
  if (!shared_buf->Create(std::wstring(), false, false, size)) {
    CHECK(shared_mem_.Create(L"", false, false, kSize));
  shared_buf.Create(L"", false, false, buffer_size);
    if (shared_buf.Create(L"", false, false, buf_size) &&
      L"", false /* read write */, true /* open existing */, buf_size);
  ASSERT_TRUE(shared_memory.Create(std::wstring(), false,
                                   false, body.size()));
  memory.Delete(UTF8ToWide(filename));
  if (ring_buffer_->Create(std::wstring(), false, false, size)) {
  if (!buffer->Create(std::wstring(), false, false, size))
    shared_memory_->Create(std::wstring(), false, false, kRingBufferSize);
  memory.Delete(UTF8ToWide(filename));
#ifndef CHROME_BROWSER_CERT_STORE_H__
#define CHROME_BROWSER_CERT_STORE_H__
#include "chrome/browser/render_process_host.h"
#endif  // CHROME_BROWSER_CERT_STORE_H__
#include "chrome/browser/page_load_tracker.h"

#ifndef CHROME_COMMON_CHROME_COUNTERS_H__
#define CHROME_COMMON_CHROME_COUNTERS_H__
#include "base/stats_counters.h"

#endif  // CHROME_COMMON_CHROME_COUNTERS_H__
#include <limits>

#include "base/gfx/platform_canvas.h"
  shader_scale.postTranslate(SkIntToScalar(dest_x - src_x), SkIntToScalar(dest_y - src_y));
#ifndef CHROME_COMMON_GFX_CHROME_CANVAS_H__
#define CHROME_COMMON_GFX_CHROME_CANVAS_H__
#include "chrome/common/gfx/chrome_font.h"
#include "chrome/common/l10n_util.h"
                     const SkColor& color, int x, int y, int w, int h) {
    DrawStringInt(text, font, color, x, y, w, h,
                  l10n_util::DefaultCanvasTextAlignment());
  }
   // aligned to the left, vertically centered, clipped to the region. If the
   // text is too big, it is truncated and '...' is added to the end.
#endif  // CHROME_COMMON_GFX_CHROME_CANVAS_H__

  l->append(StringPrintf(L"(%d, %d, %d, %d)", p.x(), p.y(), p.width(), p.height()));
struct WebCursor_Data {
  WebCursor::Type cursor_type;
  int hotspot_x;
  int hotspot_y;
  SkBitmap_Data bitmap_info;
};

#ifndef CHROME_COMMON_IPC_MESSAGE_UTILS_H__
#define CHROME_COMMON_IPC_MESSAGE_UTILS_H__
#include "skia/include/SkBitmap.h"
  MessageIterator(const Message& m) : msg_(m), iter_(NULL) {
    m->WriteData(reinterpret_cast<const char*>(&p), sizeof(double));
    if (result && data_size == sizeof(double)) {
      memcpy(r, data, sizeof(double));
    m->WriteData(reinterpret_cast<const char*>(&p), sizeof(wchar_t));
    if (result && data_size == sizeof(wchar_t)) {
      memcpy(r, data, sizeof(wchar_t));
struct SkBitmap_Data {
  // The configuration for the bitmap (bits per pixel, etc).
  SkBitmap::Config fConfig;

  // The width of the bitmap in pixels.
  uint32 fWidth;

  // The height of the bitmap in pixels.
  uint32 fHeight;

  // The number of bytes between subsequent rows of the bitmap.
  uint32 fRowBytes;

  void InitSkBitmapDataForTransfer(const SkBitmap& bitmap) {
    fConfig = bitmap.config();
    fWidth = bitmap.width();
    fHeight = bitmap.height();
    fRowBytes = bitmap.rowBytes();
  }

  void InitSkBitmapFromData(SkBitmap* bitmap, const char* pixels,
                            size_t total_pixels) const {
    if (total_pixels) {
      bitmap->setConfig(fConfig, fWidth, fHeight, fRowBytes);
      bitmap->allocPixels();
      memcpy(bitmap->getPixels(), pixels, total_pixels);
    }
  }
};

  static void Write(Message* m, const param_type& p) {
    size_t fixed_size = sizeof(SkBitmap_Data);
    SkBitmap_Data bmp_data;
    bmp_data.InitSkBitmapDataForTransfer(p);
    m->WriteData(reinterpret_cast<const char*>(&bmp_data),
                 static_cast<int>(fixed_size));
    size_t pixel_size = p.getSize();
    SkAutoLockPixels p_lock(p);
    m->WriteData(reinterpret_cast<const char*>(p.getPixels()),
                 static_cast<int>(pixel_size));
  }
  static bool Read(const Message* m, void** iter, param_type* r) {
    const char* fixed_data;
    int fixed_data_size = 0;
    if (!m->ReadData(iter, &fixed_data, &fixed_data_size) ||
       (fixed_data_size <= 0)) {
      NOTREACHED();
      return false;
    }
    if (fixed_data_size != sizeof(SkBitmap_Data))
      return false;  // Message is malformed.
    const char* variable_data;
    int variable_data_size = 0;
    if (!m->ReadData(iter, &variable_data, &variable_data_size) ||
       (variable_data_size < 0)) {
      NOTREACHED();
      return false;
    }
    const SkBitmap_Data* bmp_data =
        reinterpret_cast<const SkBitmap_Data*>(fixed_data);
    bmp_data->InitSkBitmapFromData(r, variable_data, variable_data_size);
    return true;
  }
  static void Log(const param_type& p, std::wstring* l) {
    l->append(StringPrintf(L"<SkBitmap>"));
  }
  int64 receive;  // Time before it was dispatched (i.e. before calling OnMessageReceived).
  int64 dispatch;  // Time after it was dispatched (i.e. after calling OnMessageReceived).
  ParamDeserializer(const RefTuple& out) : out_(out) { }
#endif  // CHROME_COMMON_IPC_MESSAGE_UTILS_H__
#include "chrome/common/stl_util-inl.h"
#ifndef CHROME_COMMON_SQLITE_COMPILED_STATEMENT__
#define CHROME_COMMON_SQLITE_COMPILED_STATEMENT__
#include "base/logging.h"
  SqliteStatementCache(sqlite3* db) : db_(db) {
  void set_db(sqlite3* db) {
    DCHECK(!db_) << "Setting the database twice";
    db_ = db;
  }
  SQLStatement& operator*() {
    DCHECK(statement_) << "Should check is_valid() before using the statement.";
    return *statement_;
  }
  SQLStatement* operator->() {
    DCHECK(statement_) << "Should check is_valid() before using the statement.";
    return statement_;
  }
  SQLStatement* statement() {
    DCHECK(statement_) << "Should check is_valid() before using the statement.";
    return statement_;
  }
#endif  // CHROME_COMMON_SQLITE_COMPILED_STATEMENT__
#ifndef CHROME_COMMON_SQLITEUTILS_H__
#define CHROME_COMMON_SQLITEUTILS_H__
#include "base/logging.h"
  SQLTransaction(sqlite3 *db) {
    db_ = db;
    began_ = false;
  }

  virtual ~SQLTransaction() {
    if (began_) {
      Rollback();
    }
  }
  virtual int BeginCommand(const char *command) {
    int rv = SQLITE_ERROR;
    if (!began_ && db_) {
      rv = sqlite3_exec(db_, command, NULL, NULL, NULL);
      began_ = (rv == SQLITE_OK);
    }
    return rv;
  }

  virtual int EndCommand(const char *command) {
    int rv = SQLITE_ERROR;
    if (began_ && db_) {
      rv = sqlite3_exec(db_, command, NULL, NULL, NULL);
      began_ = (rv != SQLITE_OK);
    }
    return rv;
  }
  sqlite3 *db_;
  DISALLOW_EVIL_CONSTRUCTORS(SQLTransaction);
  virtual ~SQLNestedTransactionSite() { DCHECK(!top_transaction_); }
  SQLNestedTransaction *GetTopTransaction() {
  void SetTopTransaction(SQLNestedTransaction *top) {
    DCHECK(!top || !top_transaction_);
    top_transaction_ = top;
  }
  SQLNestedTransaction *top_transaction_;
  SQLNestedTransaction(SQLNestedTransactionSite *site)
    : SQLTransaction(site->GetSqlite3DB()),
      needs_rollback_(false),
      site_(site) {
    DCHECK(site);
    if (site->GetTopTransaction() == NULL) {
      site->SetTopTransaction(this);
    }
  }

  virtual ~SQLNestedTransaction() {
    if (began_) {
      Rollback();
    }
    if (site_->GetTopTransaction() == this) {
      site_->SetTopTransaction(NULL);
    }
  }
  virtual int BeginCommand(const char *command) {
    DCHECK(db_);
    DCHECK(site_ && site_->GetTopTransaction());
    if (!db_ || began_) {
      return SQLITE_ERROR;
    }
    if (site_->GetTopTransaction() == this) {
      int rv = sqlite3_exec(db_, command, NULL, NULL, NULL);
      began_ = (rv == SQLITE_OK);
      if (began_) {
        site_->OnBegin();
      }
      return rv;
    } else {
      if (site_->GetTopTransaction()->needs_rollback_) {
        return SQLITE_ERROR;
      }
      began_ = true;
      return SQLITE_OK;
    }
  }

  virtual int EndCommand(const char *command) {
    DCHECK(db_);
    DCHECK(site_ && site_->GetTopTransaction());
    if (!db_ || !began_) {
      return SQLITE_ERROR;
    }
    if (site_->GetTopTransaction() == this) {
      if (needs_rollback_) {
        sqlite3_exec(db_, "ROLLBACK", NULL, NULL, NULL);
        began_ = false; // reset so we don't try to rollback or call
                        // OnRollback() again
        site_->OnRollback();
        return SQLITE_ERROR;
      } else {
        int rv = sqlite3_exec(db_, command, NULL, NULL, NULL);
        began_ = (rv != SQLITE_OK);
        if (strcmp(command, "ROLLBACK") == 0) {
          began_ = false; // reset so we don't try to rollbck or call
                          // OnRollback() again
          site_->OnRollback();
        } else {
          DCHECK(strcmp(command, "COMMIT") == 0);
          if (rv == SQLITE_OK) {
            site_->OnCommit();
          }
        }
        return rv;
      }
    } else {
      if (strcmp(command, "ROLLBACK") == 0) {
        site_->GetTopTransaction()->needs_rollback_ = true;
      }
      began_ = false;
      return SQLITE_OK;
    }
  }
  SQLNestedTransactionSite *site_;
  DISALLOW_EVIL_CONSTRUCTORS(SQLNestedTransaction);
  explicit scoped_sqlite3_stmt_ptr(sqlite3_stmt *stmt)
  sqlite3_stmt *get() const {
  void set(sqlite3_stmt *stmt) {
  sqlite3_stmt *release() {
    sqlite3_stmt *tmp = stmt_;
  sqlite3_stmt *stmt_;
  DISALLOW_EVIL_CONSTRUCTORS(scoped_sqlite3_stmt_ptr);
public:
  int prepare(sqlite3 *db, const char *sql) {
  int prepare(sqlite3 *db, const char *sql, int sql_len) {
    DCHECK(!stmt_);
    int rv = sqlite3_prepare_v2(db, sql, sql_len, &stmt_, NULL);
    if (rv != SQLITE_OK) {
      DLOG(ERROR) << "SQLStatement.prepare_v2 failed: " << sqlite3_errmsg(db);
    }
    return rv;
  }
  int prepare16(sqlite3 *db, const wchar_t *sql) {
  int prepare16(sqlite3 *db, const wchar_t *sql, int sql_len) {
    DCHECK(!stmt_);
    sql_len *= sizeof(wchar_t);
    int rv = sqlite3_prepare16_v2(db, sql, sql_len, &stmt_, NULL);
    if (rv != SQLITE_OK) {
      DLOG(ERROR) << "SQLStatement.prepare16_v2 failed: " << sqlite3_errmsg(db);
    }
    return rv;
  }

  int step() {
    DCHECK(stmt_);
    return sqlite3_step(stmt_);
  }

  int reset() {
    DCHECK(stmt_);
    return sqlite3_reset(stmt_);
  }

  sqlite_int64 last_insert_rowid() {
    DCHECK(stmt_);
    return sqlite3_last_insert_rowid(db_handle());
  }

  sqlite3 *db_handle() {
    DCHECK(stmt_);
    return sqlite3_db_handle(stmt_);
  }
  int bind_parameter_count() {
    DCHECK(stmt_);
    return sqlite3_bind_parameter_count(stmt_);
  }
  int bind_blob(int index, std::vector<unsigned char> *blob) {
    if (blob) {
      const void *value = &(*blob)[0];
      int len = static_cast<int>(blob->size());
      return bind_blob(index, value, len);
    } else {
      return bind_null(index);
    }
  }

  int bind_blob(int index, const void *value, int value_len) {
     return bind_blob(index, value, value_len, SQLITE_TRANSIENT);
  }

  int bind_blob(int index, const void *value, int value_len, Function dtor) {
    DCHECK(stmt_);
    return sqlite3_bind_blob(stmt_, index + 1, value, value_len, dtor);
  }

  int bind_double(int index, double value) {
    DCHECK(stmt_);
    return sqlite3_bind_double(stmt_, index + 1, value);
  }

  int bind_bool(int index, bool value) {
    DCHECK(stmt_);
    return sqlite3_bind_int(stmt_, index + 1, value);
  }

  int bind_int(int index, int value) {
    DCHECK(stmt_);
    return sqlite3_bind_int(stmt_, index + 1, value);
  }

  int bind_int64(int index, sqlite_int64 value) {
    DCHECK(stmt_);
    return sqlite3_bind_int64(stmt_, index + 1, value);
  }

  int bind_null(int index) {
    DCHECK(stmt_);
    return sqlite3_bind_null(stmt_, index + 1);
  }
  int bind_text(int index, const char *value) {
  int bind_text(int index, const char *value, int value_len) {
  int bind_text(int index, const char *value, int value_len,
                Function dtor) {
    DCHECK(stmt_);
    return sqlite3_bind_text(stmt_, index + 1, value, value_len, dtor);
  }
  int bind_text16(int index, const wchar_t *value) {
  int bind_text16(int index, const wchar_t *value, int value_len) {
  int bind_text16(int index, const wchar_t *value, int value_len,
                  Function dtor) {
    DCHECK(stmt_);
    value_len *= sizeof(wchar_t);
    return sqlite3_bind_text16(stmt_, index + 1, value, value_len, dtor);
  }
  int bind_value(int index, const sqlite3_value *value) {
    DCHECK(stmt_);
    return sqlite3_bind_value(stmt_, index + 1, value);
  }
  int column_count() {
    DCHECK(stmt_);
    return sqlite3_column_count(stmt_);
  }

  int column_type(int index) {
    DCHECK(stmt_);
    return sqlite3_column_type(stmt_, index);
  }

  const wchar_t *column_name16(int index) {
    DCHECK(stmt_);
    return static_cast<const wchar_t*>( sqlite3_column_name16(stmt_, index) );
  }

  const void *column_blob(int index) {
    DCHECK(stmt_);
    return sqlite3_column_blob(stmt_, index);
  }

  bool column_blob_as_vector(int index, std::vector<unsigned char> *blob) {
    DCHECK(stmt_);
    const void *p = column_blob(index);
    size_t len = column_bytes(index);
    blob->resize(len);
    if (blob->size() != len) {
      return false;
    }
    if (len > 0)
      memcpy(&(blob->front()), p, len);
    return true;
  }

  bool column_blob_as_string(int index, std::string* blob) {
    DCHECK(stmt_);
    const void *p = column_blob(index);
    size_t len = column_bytes(index);
    blob->resize(len);
    if (blob->size() != len) {
      return false;
    }
    blob->assign(reinterpret_cast<const char*>(p), len);
    return true;
  }

  int column_bytes(int index) {
    DCHECK(stmt_);
    return sqlite3_column_bytes(stmt_, index);
  }

  int column_bytes16(int index) {
    DCHECK(stmt_);
    return sqlite3_column_bytes16(stmt_, index);
  }
  double column_double(int index) {
    DCHECK(stmt_);
    return sqlite3_column_double(stmt_, index);
  }

  bool column_bool(int index) {
    DCHECK(stmt_);
    return sqlite3_column_int(stmt_, index) ? true : false;
  }

  int column_int(int index) {
    DCHECK(stmt_);
    return sqlite3_column_int(stmt_, index);
  }

  sqlite_int64 column_int64(int index) {
    DCHECK(stmt_);
    return sqlite3_column_int64(stmt_, index);
  }

  const char* column_text(int index) {
    DCHECK(stmt_);
    return reinterpret_cast<const char*>(sqlite3_column_text(stmt_, index));
  }

  bool column_string(int index, std::string *str) {
    DCHECK(stmt_);
    DCHECK(str);
    const char* s = column_text(index);
	str->assign(s ? s : std::string(""));
    return s != NULL;
  }

  std::string column_string(int index) {
    std::string str;
    column_string(index, &str);
    return str;
  }

  const wchar_t *column_text16(int index) {
    DCHECK(stmt_);
    return static_cast<const wchar_t*>( sqlite3_column_text16(stmt_, index) );
  }

  bool column_string16(int index, std::wstring *str) {
    DCHECK(stmt_);
    DCHECK(str);
    const wchar_t *s = column_text16(index);
    str->assign(s ? s : std::wstring(L""));
    return (s != NULL);
  }

  std::wstring column_string16(int index) {
    std::wstring wstr;
    column_string16(index, &wstr);
    return wstr;
  }
  DISALLOW_EVIL_CONSTRUCTORS(SQLStatement);
#endif  // CHROME_COMMON_SQLITEUTILS_H__
#include "chrome/common/gfx/chrome_canvas.h"
#include "base/gfx/skia_utils.h"
#include "border.h"
#include <windows.h>

// Chrome personal options page UI handler.
class ClearBrowserDataHandler : public OptionsPageUIHandler {
  size_t idx = param_values->GetSize();
  LOG(INFO) << "param_values->GetSize() = " << idx;
  size_t size = param_values->GetSize();
  LOG(INFO) << "Array size = " << size;
static int kValidOutputRates[] = {96000, 48000, 44100};
static int kValidOutputRates[] = {48000};
  audio_output_device_ = AudioDeviceFactory::NewOutputDevice();
  DCHECK(audio_output_device_);
int WebRtcAudioDeviceImpl::Render(
    media::AudioBus* audio_bus,
    int audio_delay_milliseconds) {
  DCHECK_LE(audio_bus->frames(), output_buffer_size());
  const int channels = audio_bus->channels();
  char* audio_byte_buffer = reinterpret_cast<char*>(output_buffer_.get());

  while (accumulated_audio_samples < audio_bus->frames()) {
                                                audio_byte_buffer,
    audio_byte_buffer += bytes_per_10_msec;

  // Deinterleave each channel and convert to 32-bit floating-point
  // with nominal range -1.0 -> +1.0 to match the callback format.
  audio_bus->FromInterleaved(output_buffer_.get(), audio_bus->frames(),
                             bytes_per_sample_);
  return audio_bus->frames();
void WebRtcAudioDeviceImpl::OnRenderError() {
  DCHECK_EQ(MessageLoop::current(), ChildProcess::current()->io_message_loop());
  // TODO(henrika): Implement error handling.
  LOG(ERROR) << "OnRenderError()";
  DCHECK(!output_buffer_.get());
  // Ask the browser for the default audio output hardware sample-rate.
  // This request is based on a synchronous IPC message.
  int out_sample_rate = GetAudioOutputSampleRate();
  DVLOG(1) << "Audio output hardware sample rate: " << out_sample_rate;
  AddHistogramSampleRate(kAudioOutput, out_sample_rate);

  // Verify that the reported output hardware sample rate is supported
  // on the current platform.
  if (std::find(&kValidOutputRates[0],
                &kValidOutputRates[0] + arraysize(kValidOutputRates),
                out_sample_rate) ==
      &kValidOutputRates[arraysize(kValidOutputRates)]) {
    DLOG(ERROR) << out_sample_rate << " is not a supported output rate.";
    return -1;
  }

  ChannelLayout out_channel_layout = media::CHANNEL_LAYOUT_MONO;
  int out_buffer_size = 0;
  // Always use stereo rendering on Windows.
  out_channel_layout = media::CHANNEL_LAYOUT_STEREO;

  // Render side: AUDIO_PCM_LOW_LATENCY is based on the Core Audio (WASAPI)
  // API which was introduced in Windows Vista. For lower Windows versions,
  // a callback-driven Wave implementation is used instead. An output buffer
  // size of 10ms works well for WASAPI but 30ms is needed for Wave.

  // Use different buffer sizes depending on the current hardware sample rate.
  if (out_sample_rate == 96000 || out_sample_rate == 48000) {
    out_buffer_size = (out_sample_rate / 100);
  } else {
    // We do run at 44.1kHz at the actual audio layer, but ask for frames
    // at 44.0kHz to ensure that we can feed them to the webrtc::VoiceEngine.
    // TODO(henrika): figure out why we seem to need 20ms here for glitch-
    // free audio.
    out_buffer_size = 2 * 440;
  }

  // Windows XP and lower can't cope with 10 ms output buffer size.
  // It must be extended to 30 ms (60 ms will be used internally by WaveOut).
  if (!media::IsWASAPISupported()) {
    out_buffer_size = 3 * out_buffer_size;
    DLOG(WARNING) << "Extending the output buffer size by a factor of three "
                  << "since Windows XP has been detected.";
  }

  out_channel_layout = media::CHANNEL_LAYOUT_MONO;

  // Render side: AUDIO_PCM_LOW_LATENCY on Mac OS X is based on a callback-
  // driven Core Audio implementation. Tests have shown that 10ms is a suitable
  // frame size to use, both for 48kHz and 44.1kHz.

  // Use different buffer sizes depending on the current hardware sample rate.
  if (out_sample_rate == 48000) {
    out_buffer_size = 480;
  } else {
    // We do run at 44.1kHz at the actual audio layer, but ask for frames
    // at 44.0kHz to ensure that we can feed them to the webrtc::VoiceEngine.
    out_buffer_size = 440;
  }
  out_channel_layout = media::CHANNEL_LAYOUT_MONO;
  out_buffer_size = 480;
  output_audio_parameters_.Reset(
      AudioParameters::AUDIO_PCM_LOW_LATENCY, out_channel_layout,
      out_sample_rate, 16, out_buffer_size);

  UMA_HISTOGRAM_ENUMERATION("WebRTC.AudioOutputChannelLayout",
                            out_channel_layout, media::CHANNEL_LAYOUT_MAX);
  AddHistogramFramesPerBuffer(kAudioOutput, out_buffer_size);
  // Configure the audio rendering client.
  audio_output_device_->Initialize(output_audio_parameters_, this);

  output_buffer_.reset(new int16[output_buffer_size() * output_channels()]);
  DCHECK(output_buffer_.get());
  DCHECK(output_buffer_.get());
  output_buffer_.reset();
  start_render_time_ = base::Time::Now();
  audio_output_device_->Start();
  audio_output_device_->Stop();
      NON_EXPORTED_BASE(public media::AudioRendererSink::RenderCallback),
      NON_EXPORTED_BASE(public media::AudioInputDevice::CaptureEventHandler) {
  // media::AudioRendererSink::RenderCallback implementation.
  virtual int Render(media::AudioBus* audio_bus,
                     int audio_delay_milliseconds) OVERRIDE;
  virtual void OnRenderError() OVERRIDE;
  // Provides access to the native audio output layer in the browser process.
  scoped_refptr<media::AudioRendererSink> audio_output_device_;
  scoped_array<int16> output_buffer_;
  // Protects |recording_|, |output_delay_ms_|, |input_delay_ms_|.



  if (video_frame_provider_) {
  if (video_frame_provider_ && paused_) {
  }
  paused_ = false;
  // TODO(wjia): add audio. See crbug.com/142988.
  // TODO(wjia): add audio. See crbug.com/142988.
  // TODO(wjia): set audio volume. See crbug.com/142988.
  NOTIMPLEMENTED();
  // TODO(wjia): add audio support. See crbug.com/142988.
  return false;
  if (web_contents) {
    Profile* profile =
        Profile::FromBrowserContext(web_contents->GetBrowserContext());
    Browser* browser = chrome::FindAnyBrowser(profile, include_incognito_);
    if (browser)
      return browser;
  }
void
ChromeContentRendererClient::DidInitializeServiceWorkerContextOnWorkerThread(
    v8::Local<v8::Context> context,
    const GURL& url) {
  extensions::Dispatcher::DidInitializeServiceWorkerContextOnWorkerThread(
      context, url);
  extensions::Dispatcher::WillDestroyServiceWorkerContextOnWorkerThread(context,
                                                                        url);
      ->DidInitializeServiceWorkerContextOnWorkerThread(context, script_url_);
      context, script_url_);
    // The renderer has done validation before sending extension api requests.
    // Therefore, we should never receive a request that is invalid in a way
    // that JSON validation in the renderer should have caught. It could be an
    // attacker trying to exploit the browser, so we crash the renderer instead.
    LOG(ERROR) <<
        "Terminating renderer because of malformed extension message.";
    if (content::RenderProcessHost::run_renderer_in_process()) {
      // In single process mode it is better if we don't suicide but just crash.
      CHECK(false);
    } else {
      KillBadMessageSender(peer_process, histogram_value);
    }
    content::RenderFrameHost* render_frame_host) {
  UIThreadResponseCallbackWrapperMap::const_iterator
      iter = ui_thread_response_callback_wrappers_.find(render_frame_host);
  UIThreadResponseCallbackWrapper* callback_wrapper = nullptr;
  if (iter == ui_thread_response_callback_wrappers_.end()) {
    callback_wrapper = new UIThreadResponseCallbackWrapper(AsWeakPtr(),
                                                           render_frame_host);
    ui_thread_response_callback_wrappers_[render_frame_host] = callback_wrapper;
    callback_wrapper = iter->second;

  DispatchWithCallbackInternal(
      params, render_frame_host,
      callback_wrapper->CreateCallback(params.request_id));
  DCHECK(render_frame_host);
  int process_id = render_frame_host->GetProcess()->GetID();
  scoped_refptr<ExtensionFunction> function(
      CreateExtensionFunction(params,
                              extension,
                              process_id,
                              *process_map,
                              ExtensionAPI::GetSharedInstance(),
                              browser_context_,
                              callback));
                content::RenderFrameHost* render_frame_host);
  dispatcher_.Dispatch(params, render_frame_host);
  EXPECT_EQ(6u, feature->contexts()->size());
  RegisterNativeHandlers(module_system, context);
// static
        if (context->IsAnyFeatureAvailableToContext(*map_entry.second.get()))
    case Feature::SERVICE_WORKER_CONTEXT:
      // Handled in DidInitializeServiceWorkerContextOnWorkerThread().
      NOTREACHED();
      break;
                                        ScriptContext* context) {
  RegisterNativeHandlers(module_system,
                         context,
                         this,
                         request_sender_.get(),
                         v8_schema_registry_.get());
  // Runs on a different thread and should not use any member variables.
  static void DidInitializeServiceWorkerContextOnWorkerThread(
                              ScriptContext* context);
  v8::Local<v8::Object> GetOrCreateObject(const v8::Local<v8::Object>& object,
                                          const std::string& field,
                                          v8::Isolate* isolate);
  v8::Local<v8::Object> GetOrCreateBindObjectIfAvailable(
      ScriptContextSet::GetContextByObject(object);
  if (!render_frame)
  ~RequestSender();
      api, extension(), context_type(), GetDataSourceURLForFrame(web_frame()));
        context = v8::Context::New(m_isolate, nullptr, globalTemplate);
    CHECK_LE(args.Length(), 2);
    bool check_value = args[0]->BooleanValue();
      error_message = "Error: " + std::string(*v8::String::AsciiValue(args[1]));
      error_message += "\n    <no stack trace>";
        error_message += base::StringPrintf("\n    at %s (%s:%d:%d)",
    DCHECK(check_value) << error_message;
    return v8::Undefined();
 private:
  source_map_.RegisterSource("contentSettings",
                             IDR_CONTENT_SETTINGS_CUSTOM_BINDINGS_JS);
  source_map_.RegisterSource("storage", IDR_STORAGE_CUSTOM_BINDINGS_JS);
  source_map_.RegisterSource("types", IDR_TYPES_CUSTOM_BINDINGS_JS);
        "    loadRefDependency: function(foo) { return {}; },"
    layer->scrollToOffset(toIntSize(point), RenderLayer::ScrollOffsetClamped);
                    innerLayer->scrollToOffset(scrollOffset, RenderLayer::ScrollOffsetClamped);
        layer()->scrollToXOffset(newLeft, RenderLayer::ScrollOffsetClamped);
        layer()->scrollToYOffset(newTop, RenderLayer::ScrollOffsetClamped);
#include "core/editing/FrameSelection.h"
#include "core/inspector/InspectorInstrumentation.h"
    , m_scrollDimensionsDirty(true)
        scrollToOffset(newScrollOffset, clamp);
IntSize RenderLayer::clampScrollOffset(const IntSize& scrollOffset) const
{
    RenderBox* box = renderBox();
    ASSERT(box);

    int maxX = scrollWidth() - box->pixelSnappedClientWidth();
    int maxY = scrollHeight() - box->pixelSnappedClientHeight();

    int x = max(min(scrollOffset.width(), maxX), 0);
    int y = max(min(scrollOffset.height(), maxY), 0);
    return IntSize(x, y);
}

    IntSize newScrollOffset = clamp == ScrollOffsetClamped ? clampScrollOffset(scrollOffset) : scrollOffset;
    if (newScrollOffset != adjustedScrollOffset())
        m_scrollableArea->scrollToOffsetWithoutAnimation(-scrollOrigin() + newScrollOffset);
}

void RenderLayer::setScrollOffset(const IntPoint& newScrollOffset)
{
    RenderBox* box = renderBox();
    if (!box)
        return;

    if (!box->isMarquee()) {
        // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (m_scrollableArea->scrollOffset() == toIntSize(newScrollOffset))
        return;
    m_scrollableArea->setScrollOffset(toIntSize(newScrollOffset));

    Frame* frame = renderer()->frame();
    InspectorInstrumentation::willScrollLayer(renderer());

    RenderView* view = renderer()->view();

    // We should have a RenderView if we're trying to scroll.
    ASSERT(view);

    // Update the positions of our child layers (if needed as only fixed layers should be impacted by a scroll).
    // We don't update compositing layers, because we need to do a deep update from the compositing ancestor.
    bool inLayout = view ? view->frameView()->isInLayout() : false;
    if (!inLayout) {
        // If we're in the middle of layout, we'll just update layers once layout has finished.
        updateLayerPositionsAfterOverflowScroll();
        if (view) {
            // Update regions, scrolling may change the clip of a particular region.
            view->frameView()->updateAnnotatedRegions();
            view->updateWidgetPositions();
        }

        updateCompositingLayersAfterScroll();
    }

    RenderLayerModelObject* repaintContainer = renderer()->containerForRepaint();
    if (frame) {
        // The caret rect needs to be invalidated after scrolling
        frame->selection().setCaretRectNeedsUpdate();

        FloatQuad quadForFakeMouseMoveEvent = FloatQuad(m_repaintRect);
        if (repaintContainer)
            quadForFakeMouseMoveEvent = repaintContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
        frame->eventHandler()->dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
    }

    bool requiresRepaint = true;

    if (compositor()->inCompositingMode() && usesCompositedScrolling())
        requiresRepaint = false;

    // Just schedule a full repaint of our object.
    if (view && requiresRepaint)
        renderer()->repaintUsingContainer(repaintContainer, pixelSnappedIntRect(m_repaintRect));

    // Schedule the scroll DOM event.
    if (renderer()->node())
        renderer()->node()->document().eventQueue()->enqueueOrDispatchScrollEvent(renderer()->node(), DocumentEventQueue::ScrollEventElementTarget);

    InspectorInstrumentation::didScrollLayer(renderer());
        IntSize clampedScrollOffset = clampScrollOffset(adjustedScrollOffset() + toIntSize(roundedIntRect(r).location()));
            scrollToOffset(clampedScrollOffset);
    IntSize scrollDimensions = maximumScrollPosition() - minimumScrollPosition();
IntPoint RenderLayer::minimumScrollPosition() const
{
    return -scrollOrigin();
}

IntPoint RenderLayer::maximumScrollPosition() const
{
    RenderBox* box = renderBox();
    if (!box || !box->hasOverflowClip())
        return -scrollOrigin();

    return -scrollOrigin() + enclosingIntRect(m_overflowRect).size() - enclosingIntRect(box->clientBoxRect()).size();
}

IntSize RenderLayer::contentsSize() const
{
    return IntSize(scrollWidth(), scrollHeight());
}

    ASSERT(renderBox());
    if (m_scrollDimensionsDirty)
        const_cast<RenderLayer*>(this)->computeScrollDimensions();
    return snapSizeToPixel(m_overflowRect.width(), renderBox()->clientLeft() + renderBox()->x());
    ASSERT(renderBox());
    if (m_scrollDimensionsDirty)
        const_cast<RenderLayer*>(this)->computeScrollDimensions();
    return snapSizeToPixel(m_overflowRect.height(), renderBox()->clientTop() + renderBox()->y());
}

void RenderLayer::computeScrollDimensions()
{
    RenderBox* box = renderBox();
    ASSERT(box);

    m_scrollDimensionsDirty = false;

    m_overflowRect = box->layoutOverflowRect();
    box->flipForWritingMode(m_overflowRect);

    int scrollableLeftOverflow = m_overflowRect.x() - box->borderLeft();
    int scrollableTopOverflow = m_overflowRect.y() - box->borderTop();
    m_scrollableArea->setScrollOrigin(IntPoint(-scrollableLeftOverflow, -scrollableTopOverflow));
}

bool RenderLayer::hasScrollableHorizontalOverflow() const
{
    return hasHorizontalOverflow() && renderBox()->scrollsOverflowX();
}

bool RenderLayer::hasScrollableVerticalOverflow() const
{
    return hasVerticalOverflow() && renderBox()->scrollsOverflowY();
}

bool RenderLayer::hasHorizontalOverflow() const
{
    ASSERT(!m_scrollDimensionsDirty);

    return scrollWidth() > renderBox()->pixelSnappedClientWidth();
}

bool RenderLayer::hasVerticalOverflow() const
{
    ASSERT(!m_scrollDimensionsDirty);

    return scrollHeight() > renderBox()->pixelSnappedClientHeight();
    bool hasHorizontalOverflow = this->hasHorizontalOverflow();
    bool hasVerticalOverflow = this->hasVerticalOverflow();
        m_hBar->setProportion(clientWidth, m_overflowRect.width());
        m_vBar->setProportion(clientHeight, m_overflowRect.height());
    updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
    m_scrollDimensionsDirty = true;
    IntSize originalScrollOffset = adjustedScrollOffset();

    computeScrollDimensions();

    if (!box->isMarquee()) {
        // Layout may cause us to be at an invalid scroll position. In this case we need
        // to pull our scroll offsets back to the max (or push them up to the min).
        IntSize clampedScrollOffset = clampScrollOffset(adjustedScrollOffset());
        if (clampedScrollOffset != adjustedScrollOffset())
            scrollToOffset(clampedScrollOffset);
    }

    if (originalScrollOffset != adjustedScrollOffset())
        scrollableArea()->scrollToOffsetWithoutAnimation(-scrollOrigin() + adjustedScrollOffset());

    if (!m_scrollDimensionsDirty)
        updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
            rect.append(m_overflowRect);
    enum ScrollOffsetClamping {
        ScrollOffsetUnclamped,
        ScrollOffsetClamped
    };


    IntSize clampScrollOffset(const IntSize&) const;

    void computeScrollDimensions();
    bool hasHorizontalOverflow() const;
    bool hasVerticalOverflow() const;
    bool hasScrollableHorizontalOverflow() const;
    bool hasScrollableVerticalOverflow() const;

    void setScrollOffset(const IntPoint&);
    IntPoint minimumScrollPosition() const;
    IntPoint maximumScrollPosition() const;
    IntSize contentsSize() const;
    unsigned m_scrollDimensionsDirty : 1;
    // The width/height of our scrolled area.
    LayoutRect m_overflowRect;

void RenderLayerScrollableArea::setScrollOffset(const IntPoint& offset)
    m_layer->setScrollOffset(offset);
    return m_layer->minimumScrollPosition();
    return m_layer->maximumScrollPosition();
    return m_layer->contentsSize();
    KHTMLAssert(needsLayout());
    KHTMLAssert(minMaxKnown());
    QRect oldBounds;
    bool checkForRepaint = checkForRepaintDuringLayout();
    if (checkForRepaint)
        oldBounds = getAbsoluteRepaintRect();
    
    if (m_widget)
    
    if (checkForRepaint)
        repaintAfterLayoutIfNeeded(oldBounds, oldBounds);
    QRect oldBounds;
    bool checkForRepaint = checkForRepaintDuringLayout();
    if (checkForRepaint)
        oldBounds = getAbsoluteRepaintRect();
    
    if (checkForRepaint)
        repaintAfterLayoutIfNeeded(oldBounds, oldBounds);

void RenderWidget::layout()
    KHTMLAssert(needsLayout());
    KHTMLAssert(minMaxKnown());

    if (m_widget) {
	resizeWidget(m_widget,
		      m_height-borderLeft()-borderRight()-paddingLeft()-paddingRight());
#include "content/public/browser/color_chooser.h"
  if (should_quit_if_last_browser && chrome::ShouldStartShutdown(this))
                                                 int color_chooser_id,
                                                 SkColor color) {
#if defined(OS_WIN)
  // On Windows, only create a color chooser if one doesn't exist, because we
  // can't close the old color chooser dialog.
  if (!color_chooser_.get())
    color_chooser_.reset(content::ColorChooser::Create(color_chooser_id,
                                                       web_contents,
                                                       color));
#else
  if (color_chooser_.get())
    color_chooser_->End();
  color_chooser_.reset(content::ColorChooser::Create(color_chooser_id,
                                                     web_contents,
                                                     color));
#endif
  return color_chooser_.get();
}

void Browser::DidEndColorChooser() {
  color_chooser_.reset();
      content::WebContents* web_contents,
      int color_chooser_id,
      SkColor color) OVERRIDE;
  virtual void DidEndColorChooser() OVERRIDE;
  // Currently open color chooser. Non-NULL after OpenColorChooser is called and
  // before DidEndColorChooser is called.
  scoped_ptr<content::ColorChooser> color_chooser_;


#include "content/public/browser/web_contents_observer.h"
class ColorChooserGtk : public content::ColorChooser,
                        public content::WebContentsObserver {
  ColorChooserGtk(
      int identifier, content::WebContents* tab, SkColor initial_color);
content::ColorChooser* content::ColorChooser::Create(
    int identifier, content::WebContents* tab, SkColor initial_color) {
  return new ColorChooserGtk(identifier, tab, initial_color);
ColorChooserGtk::ColorChooserGtk(
    int identifier, content::WebContents* tab, SkColor initial_color)
    : content::ColorChooser(identifier),
      content::WebContentsObserver(tab) {
  web_contents()->DidChooseColorInColorChooser(identifier(),
                                               gfx::GdkColorToSkColor(color));
  if (web_contents())
    web_contents()->DidEndColorChooser(identifier());
  ColorChooserAura(int identifier,
                   content::WebContents* tab,
                   SkColor initial_color);
  // The web contents invoking the color chooser.  No ownership because it will
  // outlive this class.
  content::WebContents* tab_;
ColorChooserAura::ColorChooserAura(int identifier,
                                   content::WebContents* tab,
    : ColorChooser(identifier),
      tab_(tab) {
  DCHECK(tab_);
      view_, tab->GetView()->GetNativeView());
  tab_->DidChooseColorInColorChooser(identifier(), color);
  tab_->DidEndColorChooser(identifier());
    tab_->DidEndColorChooser(identifier());
// static
content::ColorChooser* content::ColorChooser::Create(
    int identifier, content::WebContents* tab, SkColor initial_color) {
  return new ColorChooserAura(identifier, tab, initial_color);
#include "content/public/browser/web_contents_observer.h"
  ColorChooserWin(int identifier,
                  content::WebContents* tab,
  content::WebContents* tab_;
content::ColorChooser* content::ColorChooser::Create(int identifier,
                                                     content::WebContents* tab,
                                                     SkColor initial_color) {
  return new ColorChooserWin(identifier, tab, initial_color);
ColorChooserWin::ColorChooserWin(int identifier,
                                 content::WebContents* tab,
    : content::ColorChooser(identifier),
      tab_(tab) {
      tab_->GetRenderViewHost()->GetView()->GetNativeView());
  if (tab_)
    tab_->DidChooseColorInColorChooser(identifier(), color);
  if (tab_)
    tab_->DidEndColorChooser(identifier());
namespace content {

ColorChooser* ColorChooser::Create(
    int identifier, WebContents* tab, SkColor initial_color) {
  return new components::ColorChooserAndroid(identifier, tab, initial_color);
}

}  // namespace content

ColorChooserAndroid::ColorChooserAndroid(int identifier,
                                         content::WebContents* web_contents,
    : ColorChooser::ColorChooser(identifier),
      content::WebContentsObserver(web_contents) {
  web_contents()->DidChooseColorInColorChooser(identifier(), color);
  web_contents()->DidEndColorChooser(identifier());
#include "content/public/browser/web_contents_observer.h"
class ColorChooserAndroid : public content::ColorChooser,
                            public content::WebContentsObserver {
  ColorChooserAndroid(int identifier, content::WebContents* tab,
ColorChooser* WebContentsDelegateAndroid::OpenColorChooser(
    WebContents* source,
    int color_chooser_id,
    SkColor color)  {
  return ColorChooser::Create(color_chooser_id, source, color);

  virtual content::ColorChooser* OpenColorChooser(
      content::WebContents* source, int color_chooser_id,
      SkColor color) OVERRIDE;
      color_chooser_(NULL),
void WebContentsImpl::DidChooseColorInColorChooser(int color_chooser_id,
                                                   SkColor color) {
      GetRoutingID(), color_chooser_id, color));
void WebContentsImpl::DidEndColorChooser(int color_chooser_id) {
  Send(new ViewMsg_DidEndColorChooser(GetRoutingID(), color_chooser_id));
  if (delegate_)
    delegate_->DidEndColorChooser();
  color_chooser_ = NULL;
  color_chooser_ = delegate_ ?
      delegate_->OpenColorChooser(this, color_chooser_id, color) : NULL;
      color_chooser_id == color_chooser_->identifier())
      color_chooser_id == color_chooser_->identifier())
  virtual void DidChooseColorInColorChooser(int color_chooser_id,
                                            SkColor color) OVERRIDE;
  virtual void DidEndColorChooser(int color_chooser_id) OVERRIDE;
  ColorChooser* color_chooser_;
class WebContents;

// Abstraction object for color choosers for each platform.
  static ColorChooser* Create(int identifier,
                              WebContents* web_contents,
                              SkColor initial_color);

  explicit ColorChooser(int identifier) : identifier_(identifier) {}
  // Returns a unique identifier for this chooser.  Identifiers are unique
  // across a renderer process.  This avoids race conditions in synchronizing
  // the browser and renderer processes.  For example, if a renderer closes one
  // chooser and opens another, and simultaneously the user picks a color in the
  // first chooser, the IDs can be used to drop the "chose a color" message
  // rather than erroneously tell the renderer that the user picked a color in
  // the second chooser.
  int identifier() const { return identifier_; }


 private:
  int identifier_;
  virtual void DidChooseColorInColorChooser(int color_chooser_id,
                                            SkColor color) = 0;
  virtual void DidEndColorChooser(int color_chooser_id) = 0;
    WebContents* web_contents,
    int color_chooser_id,
    SkColor color) {
  virtual content::ColorChooser* OpenColorChooser(WebContents* web_contents,
                                                  int color_chooser_id,
                                                  SkColor color);

  virtual void DidEndColorChooser() {}
  if (context_)
  context_.reset();
      url_(web_frame_ ? GetDataSourceURLForFrame(web_frame_) : GURL()) {
  gin::PerContextData::From(v8_context)->set_runner(this);
void ScriptContext::Run(const std::string& source,
                        const std::string& resource_name) {
  module_system_->RunString(source, resource_name);
}

v8::Handle<v8::Value> ScriptContext::Call(v8::Handle<v8::Function> function,
                                          v8::Handle<v8::Value> receiver,
                                          int argc,
                                          v8::Handle<v8::Value> argv[]) {
  return CallFunction(function, argc, argv);
}

gin::ContextHolder* ScriptContext::GetContextHolder() {
  v8::HandleScope handle_scope(isolate());
  return gin::PerContextData::From(v8_context())->context_holder();
}

class ScriptContext : public RequestSender::Source, public gin::Runner {
  // gin::Runner overrides.
  void Run(const std::string& source,
           const std::string& resource_name) override;
  v8::Handle<v8::Value> Call(v8::Handle<v8::Function> function,
                             v8::Handle<v8::Value> receiver,
                             int argc,
                             v8::Handle<v8::Value> argv[]) override;
  gin::ContextHolder* GetContextHolder() override;

using blink::WebFrame;
  WebFrame* frame = context()->web_frame();
    WebFrame* frame,
#include "third_party/WebKit/public/web/WebFrame.h"
      blink::WebFrame* frame,
#include "extensions/common/extension.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "extensions/renderer/extension_groups.h"
const Extension* Dispatcher::GetExtensionFromFrameAndWorld(
    const blink::WebFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.

    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_.GetExtensionOrAppIDByURL(frame_url);
  }

  const Extension* extension = extensions_.GetByID(extension_id);
  if (!extension && !extension_id.empty()) {
    // There are conditions where despite a context being associated with an
    // extension, no extension actually gets found.  Ignore "invalid" because
    // CSP blocks extension page loading by switching the extension ID to
    // "invalid". This isn't interesting.
    if (extension_id != "invalid") {
      LOG(ERROR) << "Extension \"" << extension_id << "\" not found";
      RenderThread::Get()->RecordAction(
          UserMetricsAction("ExtensionNotFound_ED"));
    }
  }
  return extension;
}

  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());

  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  script_context_set_.Add(context);
  if (context_type == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(extension);
  switch (context_type) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  ScriptContext* context = script_context_set_.GetByV8Context(v8_context);
  script_context_set_.Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  if (IsSandboxedPage(ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_.ForEach(
  script_context_set_.ForEach(
  MessagingBindings::DeliverMessage(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(script_context_set_, port_id,
  ScriptContextSet::ContextSet removed_contexts =
      script_context_set_.OnExtensionUnloaded(id);
  for (ScriptContextSet::ContextSet::iterator it = removed_contexts.begin();
       it != removed_contexts.end(); ++it) {
    request_sender_->InvalidateSource(*it);
// TODO(kalman): This is checking for the wrong thing, it should be checking if
// the frame's security origin is unique. The extension sandbox directive is
// checked for in extensions/common/manifest_handlers/csp_info.cc.
bool Dispatcher::IsSandboxedPage(const GURL& url) const {
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions_.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

Feature::Context Dispatcher::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (IsSandboxedPage(url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && IsExtensionActive(extension->id())) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of IsSandboxedPage().
  if (!origin.isUnique() && extensions_.ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

class Extension;
    return script_context_set_;
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(const blink::WebFrame* frame,
                                                 int world_id,
                                                 bool use_effective_url);

  // Forwarded from the RenderFrameObserver events by ExtensionFrameHelper.
  bool IsSandboxedPage(const GURL& url) const;

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  ScriptContextSet script_context_set_;
  std::set<std::string> active_extension_ids_;
#include "third_party/WebKit/public/web/WebFrame.h"
#include "third_party/WebKit/public/web/WebFrame.h"
  if (blink::WebFrame* webframe = context->web_frame())
                             blink::WebFrame* web_frame,
  gin::PerContextData::From(v8_context)->set_runner(runner_.get());
                blink::WebFrame* frame,
  blink::WebFrame* web_frame() const { return web_frame_; }
  // The WebFrame associated with this context. This can be NULL because this
  // object can outlive is destroyed asynchronously.
  blink::WebFrame* web_frame_;
ScriptContextSet::ScriptContextSet() {
}
ScriptContextSet::~ScriptContextSet() {
int ScriptContextSet::size() const {
  return static_cast<int>(contexts_.size());
void ScriptContextSet::Add(ScriptContext* context) {
#if DCHECK_IS_ON()
  // It's OK to insert the same context twice, but we should only ever have
  // one ScriptContext per v8::Context.
  for (ContextSet::iterator iter = contexts_.begin(); iter != contexts_.end();
       ++iter) {
    ScriptContext* candidate = *iter;
    if (candidate != context)
      DCHECK(candidate->v8_context() != context->v8_context());
  }
#endif
  contexts_.insert(context);
ScriptContextSet::ContextSet ScriptContextSet::GetAll() const {
  return contexts_;
}

                              : NULL;
  return calling.IsEmpty() ? NULL : GetByV8Context(calling);
    v8::Handle<v8::Context> v8_context) const {
  for (ContextSet::const_iterator iter = contexts_.begin();
       iter != contexts_.end(); ++iter) {
    if ((*iter)->v8_context() == v8_context)
      return *iter;

  return NULL;
  ContextSet contexts = GetAll();

  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    ScriptContext* context = *it;
ScriptContextSet::ContextSet ScriptContextSet::OnExtensionUnloaded(
  ContextSet contexts = GetAll();
  ContextSet removed;

  // Clean up contexts belonging to the unloaded extension. This is done so
  // that content scripts (which remain injected into the page) don't continue
  // receiving events and sending messages.
  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    if ((*it)->extension() && (*it)->extension()->id() == extension_id) {
      (*it)->DispatchOnUnloadEvent();
      removed.insert(*it);
      Remove(*it);
    }
  return removed;
#include "base/basictypes.h"
#include "base/bind.h"
namespace content {
class RenderView;
namespace v8 {
class Context;
// A container of ExtensionBindingsContext. Since calling JavaScript within a
// context can cause any number of contexts to be created or destroyed, this
// has additional smarts to help with the set changing underneath callers.
  ScriptContextSet();
  int size() const;
  // Takes ownership of |context|.
  void Add(ScriptContext* context);
  // Returns a copy to protect against changes.
  typedef std::set<ScriptContext*> ContextSet;
  ContextSet GetAll() const;

  ScriptContext* GetByV8Context(v8::Handle<v8::Context> context) const;
  ContextSet OnExtensionUnloaded(const std::string& extension_id);
  ContextSet contexts_;
#include "third_party/WebKit/public/web/WebFrame.h"
TEST(ScriptContextSet, Lifecycle) {
  ScriptContextSet context_set;
  context_holder.SetContext(v8::Context::New(isolate));

  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  const Extension* extension = NULL;
  ScriptContext* context =
      new ScriptContext(context_holder.context(), frame, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT);
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  EXPECT_EQ(context, context_set.GetByV8Context(context->v8_context()));
  // Adding the same item multiple times should be OK and deduped.
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  // GetAll() returns a copy so removing from one should not remove from others.
  ScriptContextSet::ContextSet set_copy = context_set.GetAll();
  EXPECT_EQ(1u, set_copy.count(context));
  EXPECT_EQ(0, context_set.size());
  EXPECT_FALSE(context_set.GetByV8Context(context->v8_context()));
  EXPECT_EQ(1u, set_copy.size());
    const std::string target_path =
        to_path.value() + &ent->fts_path[from_path.value().size()];
        if (mkdir(target_path.c_str(), 0777) != 0) {
        // TODO(port): use a native file path rather than all these
        // conversions.
        if (!CopyFile(UTF8ToWide(ent->fts_path), UTF8ToWide(target_path)))
  // TODO(port): do something less racy here
  PlatformThread::Sleep(1000);
                                      this);
  UpdateClearPluginLSOData();
void ClearBrowserDataHandler::Observe(NotificationType type,
                                      const NotificationSource& source,
                                      const NotificationDetails& details) {
  switch (type.value) {
    case NotificationType::PREF_CHANGED: {
      const std::string& pref_name = *Details<std::string>(details).ptr();
      if (pref_name == prefs::kClearPluginLSODataEnabled)
        UpdateClearPluginLSOData();
      else
        OptionsPageUIHandler::Observe(type, source, details);
      break;
    }

    default:
      OptionsPageUIHandler::Observe(type, source, details);
  }
}

    if (clear_plugin_lso_data_enabled_.GetValue())
void ClearBrowserDataHandler::UpdateClearPluginLSOData() {
  int label_id = clear_plugin_lso_data_enabled_.GetValue() ?
      IDS_DEL_COOKIES_FLASH_CHKBOX :
      IDS_DEL_COOKIES_CHKBOX;
  scoped_ptr<Value> label(
      Value::CreateStringValue(l10n_util::GetStringUTF16(label_id)));
  web_ui_->CallJavascriptFunction(
      "ClearBrowserDataOverlay.setClearLocalDataLabel", *label);
}

#include "chrome/browser/plugin_data_remover_helper.h"
  // NotificationObserver implementation.
  virtual void Observe(NotificationType type,
                       const NotificationSource& source,
                       const NotificationDetails& details);

  // Updates the UI to reflect whether clearing LSO data is supported.
  void UpdateClearPluginLSOData();

  // Used for asynchronously updating the preference stating whether clearing
  // LSO data is supported.
  PluginDataRemoverHelper clear_plugin_lso_data_enabled_;
  clear_plugin_lso_data_enabled_.Init(prefs::kClearPluginLSODataEnabled,
                                      g_browser_process->local_state(),
                                      this);
  UpdateClearPluginLSOData();

      else if (pref_name == prefs::kClearPluginLSODataEnabled)
        UpdateClearPluginLSOData();
void ContentSettingsHandler::UpdateClearPluginLSOData() {
  int label_id = clear_plugin_lso_data_enabled_.GetValue() ?
      IDS_COOKIES_LSO_CLEAR_WHEN_CLOSE_CHKBOX :
      IDS_COOKIES_CLEAR_WHEN_CLOSE_CHKBOX;
  scoped_ptr<Value> label(
      Value::CreateStringValue(l10n_util::GetStringUTF16(label_id)));
  web_ui_->CallJavascriptFunction(
      "ContentSettings.setClearLocalDataOnShutdownLabel", *label);
}

  // Updates the state of the "Clear plugin LSO data on exit" checkbox.
  void UpdateClearPluginLSOData();
  PluginDataRemoverHelper clear_plugin_lso_data_enabled_;
    return &mock_core_options_handler_;
  StrictMock<MockCoreOptionsHandler> mock_core_options_handler_;
  EXPECT_CALL(mock_core_options_handler_,
// Whether there is a Flash version installed that supports clearing LSO data.
const char kClearPluginLSODataEnabled[] = "browser.clear_lso_data_enabled";

extern const char kClearPluginLSODataEnabled[];
      read_only_ ? PAGE_READONLY : PAGE_READWRITE, 0, static_cast<DWORD>(size),
      IPC_MESSAGE_HANDLER(ViewHostMsg_CreateWorker, OnCreateWorker)
void ResourceMessageFilter::OnCreateWorker(const GURL& url,
                                           bool is_shared,
                                           const string16& name,
                                           int render_view_route_id,
                                           int* route_id) {
  WorkerService::GetInstance()->CreateWorker(
      url, is_shared, name, id(), render_view_route_id, this, id(), *route_id);
  void OnCreateWorker(const GURL& url,
                      bool is_shared,
                      const string16& name,
                      int render_view_route_id,
                      int* route_id);
  Send(new WorkerProcessMsg_CreateWorker(instance.url,
                                         instance.is_shared,
                                         instance.name,
                                         instance.worker_route_id));
      IPC_MESSAGE_HANDLER(ViewHostMsg_CreateWorker, OnCreateWorker)
void WorkerProcessHost::OnCreateWorker(const GURL& url,
                                       bool is_shared,
                                       const string16& name,
                                       int render_view_route_id,
                                       int* route_id) {
  WorkerService::GetInstance()->CreateWorker(
      url, is_shared, name, instances_.front().renderer_id,
    bool is_shared;
    string16 name;
  void OnCreateWorker(const GURL& url,
                      bool is_shared,
                      const string16& name,
                      int render_view_route_id,
                      int* route_id);
bool WorkerService::CreateWorker(const GURL &url,
                                 bool is_shared,
                                 const string16& name,
                                 int renderer_id,
                                 int render_view_route_id,
                                 IPC::Message::Sender* sender,
                                 int sender_id,
                                 int sender_route_id) {
  instance.name = name;
  instance.is_shared = is_shared;
  bool CreateWorker(const GURL &url,
                    bool is_shared,
                    const string16& name,
                    int renderer_pid,
                    int render_view_route_id,
                    IPC::Message::Sender* sender,
                    int sender_id,
                    int sender_route_id);
  IPC_SYNC_MESSAGE_CONTROL4_1(ViewHostMsg_CreateWorker,
                              bool /* is_shared */,
  IPC_MESSAGE_CONTROL4(WorkerProcessMsg_CreateWorker,
                       bool /* is_shared */,
                       string16 /* name */,
#include "chrome/renderer/websharedworker_proxy.h"
WebSharedWorkerProxy::WebSharedWorkerProxy(ChildThread* child_thread,
    : WebWorkerBase(child_thread, route_id, render_view_route_id) {
bool WebSharedWorkerProxy::isStarted() {
void WebSharedWorkerProxy::startWorkerContext(
    const WebKit::WebString& name,
  CreateWorkerContext(script_url, true, name, user_agent, source_code);
void WebSharedWorkerProxy::connect(WebKit::WebMessagePortChannel* channel) {
void WebSharedWorkerProxy::OnMessageReceived(const IPC::Message& message) {
  IPC_BEGIN_MESSAGE_MAP(WebSharedWorkerProxy, message)
void WebSharedWorkerProxy::OnWorkerCreated() {
#ifndef CHROME_RENDERER_WEBSHAREDWORKER_PROXY_H_
#define CHROME_RENDERER_WEBSHAREDWORKER_PROXY_H_
class WebSharedWorkerProxy : public WebKit::WebSharedWorker,
                             private WebWorkerBase {
  WebSharedWorkerProxy(ChildThread* child_thread,
                                  const WebKit::WebString& name,
  // IPC::Channel::Listener proxyementation.
  DISALLOW_COPY_AND_ASSIGN(WebSharedWorkerProxy);
#endif  // CHROME_RENDERER_WEBSHAREDWORKER_PROXY_H_
void WebWorkerBase::CreateWorkerContext(const GURL& script_url,
                                        bool is_shared,
                                        const string16& name,
  IPC::Message* create_message = new ViewHostMsg_CreateWorker(
      script_url, is_shared, name, render_view_route_id_, &route_id_);
  void CreateWorkerContext(const GURL& script_url,
                           bool is_shared,
                           const string16& name,
using WebKit::WebCommonWorkerClient;
  CreateWorkerContext(script_url, false, string16(), user_agent, source_code);
                        static_cast<WebCommonWorkerClient*>(client_),
                        WebCommonWorkerClient::workerContextDestroyed)
  void OnWorkerContextDestroyed();
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/worker/websharedworker_stub.h"

#include "chrome/common/webmessageportchannel_impl.h"
#include "chrome/common/worker_messages.h"
#include "webkit/api/public/WebSharedWorker.h"
#include "webkit/api/public/WebString.h"
#include "webkit/api/public/WebURL.h"

WebSharedWorkerStub::WebSharedWorkerStub(
    const string16& name, int route_id)
    : WebWorkerStubBase(route_id),
      name_(name) {

  // TODO(atwilson): Add support for NaCl when they support MessagePorts.
  impl_ = WebKit::WebSharedWorker::create(client());

}

WebSharedWorkerStub::~WebSharedWorkerStub() {
  impl_->clientDestroyed();
}

void WebSharedWorkerStub::OnMessageReceived(const IPC::Message& message) {
  IPC_BEGIN_MESSAGE_MAP(WebSharedWorkerStub, message)
    IPC_MESSAGE_HANDLER(WorkerMsg_StartWorkerContext, OnStartWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_TerminateWorkerContext,
                        OnTerminateWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_Connect, OnConnect)
  IPC_END_MESSAGE_MAP()
}

void WebSharedWorkerStub::OnStartWorkerContext(
    const GURL& url, const string16& user_agent, const string16& source_code) {
  impl_->startWorkerContext(url, name_, user_agent, source_code);
}

void WebSharedWorkerStub::OnConnect(int sent_message_port_id, int routing_id) {
  WebKit::WebMessagePortChannel* channel =
      new WebMessagePortChannelImpl(routing_id, sent_message_port_id);
  impl_->connect(channel);
}

void WebSharedWorkerStub::OnTerminateWorkerContext() {
  impl_->terminateWorkerContext();

  // Call the client to make sure context exits.
  EnsureWorkerContextTerminates();
}
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_WORKER_WEB_SHARED_WORKER_STUB_H_
#define CHROME_WORKER_WEB_SHARED_WORKER_STUB_H_

#include "chrome/worker/webworker_stub_base.h"
#include "chrome/worker/webworkerclient_proxy.h"
#include "googleurl/src/gurl.h"

namespace WebKit {
class WebSharedWorker;
}

// This class creates a WebSharedWorker, and translates incoming IPCs to the
// appropriate WebSharedWorker APIs.
class WebSharedWorkerStub : public WebWorkerStubBase {
 public:
  WebSharedWorkerStub(const string16& name, int route_id);

  // IPC::Channel::Listener implementation.
  virtual void OnMessageReceived(const IPC::Message& message);

 private:
  virtual ~WebSharedWorkerStub();

  // Invoked when the WebWorkerClientProxy is shutting down.
  void OnConnect(int sent_message_port_id, int routing_id);
  void OnStartWorkerContext(
      const GURL& url, const string16& user_agent, const string16& source_code);
  void OnTerminateWorkerContext();

  WebKit::WebSharedWorker* impl_;
  string16 name_;

  DISALLOW_COPY_AND_ASSIGN(WebSharedWorkerStub);
};

#endif  // CHROME_WORKER_WEB_SHARED_WORKER_STUB_H_
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/worker/webworker_stub.h"

#include "base/command_line.h"
#include "chrome/common/chrome_switches.h"
#include "chrome/common/webmessageportchannel_impl.h"
#include "chrome/common/worker_messages.h"
#include "chrome/worker/nativewebworker_impl.h"
#include "webkit/api/public/WebString.h"
#include "webkit/api/public/WebURL.h"
#include "webkit/api/public/WebWorker.h"

using WebKit::WebWorker;

static bool UrlIsNativeWorker(const GURL& url) {
  // If the renderer was not passed the switch to enable native workers,
  // then the URL should be treated as a JavaScript worker.
  if (!CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableNativeWebWorkers)) {
    return false;
  }
  // Based on the suffix, decide whether the url should be considered
  // a NativeWebWorker (for .nexe) or a WebWorker (for anything else).
  const std::string kNativeSuffix(".nexe");
  std::string worker_url = url.path();
  // Compute the start index of the suffix.
  std::string::size_type suffix_index =
      worker_url.length() - kNativeSuffix.length();
  std::string::size_type pos = worker_url.find(kNativeSuffix, suffix_index);
  return (suffix_index == pos);
}

WebWorkerStub::WebWorkerStub(const GURL& url, int route_id)
    : WebWorkerStubBase(route_id) {
  if (UrlIsNativeWorker(url)) {
    // Launch a native worker.
    impl_ = NativeWebWorkerImpl::create(client());
  } else {
    // Launch a JavaScript worker.
    impl_ = WebKit::WebWorker::create(client());
  }
}

WebWorkerStub::~WebWorkerStub() {
  impl_->clientDestroyed();
}

void WebWorkerStub::OnMessageReceived(const IPC::Message& message) {
  if (!impl_)
    return;

  IPC_BEGIN_MESSAGE_MAP(WebWorkerStub, message)
    IPC_MESSAGE_FORWARD(WorkerMsg_StartWorkerContext, impl_,
                        WebWorker::startWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_TerminateWorkerContext,
                        OnTerminateWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_PostMessage, OnPostMessage)
    IPC_MESSAGE_FORWARD(WorkerMsg_WorkerObjectDestroyed, impl_,
                        WebWorker::workerObjectDestroyed)
  IPC_END_MESSAGE_MAP()
}

void WebWorkerStub::OnTerminateWorkerContext() {
  impl_->terminateWorkerContext();

  // Call the client to make sure context exits.
  EnsureWorkerContextTerminates();
}

void WebWorkerStub::OnPostMessage(
    const string16& message,
    const std::vector<int>& sent_message_port_ids,
    const std::vector<int>& new_routing_ids) {
  WebKit::WebMessagePortChannelArray channels(sent_message_port_ids.size());
  for (size_t i = 0; i < sent_message_port_ids.size(); i++) {
    channels[i] = new WebMessagePortChannelImpl(
        new_routing_ids[i], sent_message_port_ids[i]);
  }

  impl_->postMessageToWorkerContext(message, channels);
}
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_WORKER_WEB_WORKER_STUB_H_
#define CHROME_WORKER_WEB_WORKER_STUB_H_

#include "chrome/worker/webworker_stub_base.h"
#include "chrome/worker/webworkerclient_proxy.h"
#include "googleurl/src/gurl.h"

namespace WebKit {
class WebWorker;
}

// This class creates a WebWorker, and translates incoming IPCs to the
// appropriate WebWorker APIs.
class WebWorkerStub : public WebWorkerStubBase {
 public:
  WebWorkerStub(const GURL& url, int route_id);

  // IPC::Channel::Listener implementation.
  virtual void OnMessageReceived(const IPC::Message& message);

 private:
  virtual ~WebWorkerStub();

  void OnTerminateWorkerContext();
  void OnPostMessage(const string16& message,
                     const std::vector<int>& sent_message_port_ids,
                     const std::vector<int>& new_routing_ids);

  WebKit::WebWorker* impl_;

  DISALLOW_COPY_AND_ASSIGN(WebWorkerStub);
};

#endif  // CHROME_WORKER_WEB_WORKER_STUB_H_
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/worker/webworker_stub_base.h"

#include "base/compiler_specific.h"
#include "chrome/common/child_process.h"
#include "chrome/worker/worker_thread.h"

WebWorkerStubBase::WebWorkerStubBase(int route_id)
    : route_id_(route_id),
      ALLOW_THIS_IN_INITIALIZER_LIST(client_(route_id, this)) {

  // Start processing incoming IPCs for this worker.
  WorkerThread::current()->AddRoute(route_id_, this);
  ChildProcess::current()->AddRefProcess();
}

WebWorkerStubBase::~WebWorkerStubBase() {
  WorkerThread::current()->RemoveRoute(route_id_);
  ChildProcess::current()->ReleaseProcess();
}

void WebWorkerStubBase::Shutdown() {
  // The worker has exited - free ourselves and the client.
  delete this;
}

void WebWorkerStubBase::EnsureWorkerContextTerminates() {
  client_.EnsureWorkerContextTerminates();
}
// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_WORKER_WEB_WORKER_STUB_BASE_H_
#define CHROME_WORKER_WEB_WORKER_STUB_BASE_H_

#include "chrome/worker/webworkerclient_proxy.h"
#include "ipc/ipc_channel.h"

// This class is the common base class for both WebWorkerStub and
// WebSharedWorkerStub and contains common setup/teardown functionality.
class WebWorkerStubBase : public IPC::Channel::Listener {
 public:
  WebWorkerStubBase(int route_id);
  virtual ~WebWorkerStubBase();

  // Invoked when the WebWorkerClientProxy is shutting down.
  void Shutdown();

  // Called after terminating the worker context to make sure that the worker
  // actually terminates (is not stuck in an infinite loop).
  void EnsureWorkerContextTerminates();

  WebWorkerClientProxy* client() { return &client_; }

 private:
  int route_id_;

  // WebWorkerClient that responds to outgoing API calls from the worker object.
  WebWorkerClientProxy client_;

  DISALLOW_COPY_AND_ASSIGN(WebWorkerStubBase);
};

#endif  // CHROME_WORKER_WEB_WORKER_STUB_BASE_H_
#include "chrome/worker/webworker_stub_base.h"
WebWorkerClientProxy::WebWorkerClientProxy(int route_id,
                                           WebWorkerStubBase* stub)
    : route_id_(route_id),
      stub_(stub),
  // Tell the stub that the worker has shutdown - frees this object.
  if (stub_)
    stub_->Shutdown();
void WebWorkerClientProxy::EnsureWorkerContextTerminates() {
class WebWorkerStubBase;

class WebWorkerClientProxy : public WebKit::WebWorkerClient {
  WebWorkerClientProxy(int route_id, WebWorkerStubBase* stub);
  ~WebWorkerClientProxy();
  void EnsureWorkerContextTerminates();
  WebWorkerStubBase* stub_;
#include "chrome/worker/webworker_stub.h"
#include "chrome/worker/websharedworker_stub.h"
void WorkerThread::OnCreateWorker(const GURL& url,
                                  bool is_shared,
                                  const string16& name,
                                  int route_id) {
  // WebWorkerStub and WebSharedWorkerStub own themselves.
  if (is_shared)
    new WebSharedWorkerStub(name, route_id);
  else
    new WebWorkerStub(url, route_id);
  void OnCreateWorker(
      const GURL& url, bool is_shared, const string16& name, int route_id);
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef WebCommonWorkerClient_h
#define WebCommonWorkerClient_h

namespace WebKit {
    class WebNotificationPresenter;
    class WebString;
    class WebWorker;
    class WebWorkerClient;

    // Provides an interface back to the in-page script object for a worker.
    // This interface contains common APIs used by both shared and dedicated
    // workers.
    // All functions are expected to be called back on the thread that created
    // the Worker object, unless noted.
    class WebCommonWorkerClient {
    public:
        virtual void postExceptionToWorkerObject(
            const WebString& errorString, int lineNumber,
            const WebString& sourceURL) = 0;

        virtual void postConsoleMessageToWorkerObject(
            int destinationIdentifier,
            int sourceIdentifier,
            int messageType,
            int messageLevel,
            const WebString& message,
            int lineNumber,
            const WebString& sourceURL) = 0;

        virtual void workerContextDestroyed() = 0;

        // Returns the notification presenter for this worker context.  Pointer
        // is owned by the object implementing WebCommonWorkerClient.
        virtual WebNotificationPresenter* notificationPresenter() = 0;

        // This can be called on any thread to create a nested WebWorker.
        // WebSharedWorkers are not instantiated via this API - instead
        // they are created via the WebSharedWorkerRepository.
        virtual WebWorker* createWorker(WebWorkerClient* client) = 0;

    protected:
        ~WebCommonWorkerClient() { }
    };

} // namespace WebKit

#endif
    class WebCommonWorkerClient;
        // Invoked from the worker thread to instantiate a WebSharedWorker that interacts with the WebKit worker components.
        WEBKIT_API static WebSharedWorker* create(WebCommonWorkerClient*);

        virtual ~WebSharedWorker() {};
                                        const WebString& name,
        // Sends a connect event to the SharedWorker context.

        // Invoked to shutdown the worker when there are no more associated documents.
        virtual void terminateWorkerContext() = 0;

        // Notification when the WebCommonWorkerClient is destroyed.
        virtual void clientDestroyed() = 0;
#include "WebCommonWorkerClient.h"
    class WebWorkerClient : public WebCommonWorkerClient {
  SharedWorkerScriptLoader(PassRefPtr<SharedWorker> worker, const KURL& url, const String& name, PassOwnPtr<MessagePortChannel> port, PassOwnPtr<WebSharedWorker> webWorker)
      : m_worker(worker),
        m_url(url),
        m_name(name),
        m_webWorker(webWorker),
        m_port(port)
    void load();
    KURL m_url;
    String m_name;
void SharedWorkerScriptLoader::load()
    m_scriptLoader.loadAsynchronously(m_worker->scriptExecutionContext(), m_url, DenyCrossOriginRequests, this);
        m_webWorker->startWorkerContext(m_url, m_name, m_worker->scriptExecutionContext()->userAgent(m_url), m_scriptLoader.script());
        SharedWorkerScriptLoader* loader = new SharedWorkerScriptLoader(worker, url, name, port.release(), webWorker.release());
        loader->load();
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "WebSharedWorkerImpl.h"

using namespace WebCore;

namespace WebKit {

#if ENABLE(SHARED_WORKERS)

WebSharedWorker* WebSharedWorker::create(WebCommonWorkerClient* client)
{
    // FIXME: Return an instance of WebSharedWorkerImpl once the implementation is complete.
    ASSERT_NOT_REACHED();
    return NULL;
}

#endif // ENABLE(SHARED_WORKERS)

} // namespace WebKit
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef WebSharedWorkerImpl_h
#define WebSharedWorkerImpl_h

#include "WebSharedWorker.h"

#if ENABLE(SHARED_WORKERS)

#include "ScriptExecutionContext.h"
#include "WorkerLoaderProxy.h"
#include "WorkerObjectProxy.h"
#include <wtf/PassOwnPtr.h>
#include <wtf/RefPtr.h>

namespace WebCore {
class SharedWorkerThread;
}

namespace WebKit {
class WebView;

// This class is used by the worker process code to talk to the WebCore::SharedWorker implementation.
// It can't use it directly since it uses WebKit types, so this class converts the data types.
// When the WebCore::SharedWorker object wants to call WebCore::WorkerReportingProxy, this class will
// convert to Chrome data types first and then call the supplied WebCommonWorkerClient.
class WebSharedWorkerImpl : public WebCore::WorkerLoaderProxy {
public:
    explicit WebSharedWorkerImpl(WebCommonWorkerClient* client);

    // WebSharedWorker methods:
    virtual bool isStarted();
    virtual void startWorkerContext(const WebURL&, const WebString& name, const WebString& userAgent, const WebString& sourceCode);
    virtual void connect(WebMessagePortChannel*);

    WebCommonWorkerClient* client() { return m_client; }

private:
    virtual ~WebSharedWorkerImpl();

    WebCommonWorkerClient* m_client;

    RefPtr<WebCore::SharedWorkerThread> m_workerThread;
};

} // namespace WebKit

#endif // ENABLE(SHARED_WORKERS)

#endif
using v8_helpers::IsEmptyOrUndefined;
  if (!IsEmptyOrUndefined(retval)) {
  if (IsEmptyOrUndefined(has_port))
  context_holder_->SetContext(v8::Context::New(isolate));
#include "extensions/renderer/v8_helpers.h"
using namespace v8_helpers;

  if (IsEmptyOrUndefined(handler_function_value)) {
  v8::Local<v8::Context> v8_context = context_->v8_context();
  v8::Context::Scope context_scope(v8_context);
  SetProperty(
      v8_context, data, kHandlerFunction,

  // TODO(kalman): Cache these. See https://crbug.com/478744.
  v8::Local<v8::Context> v8_context = context_->v8_context();
  v8::Context::Scope context_scope(v8_context);
        GetPropertyUnsafe(v8_context, data, kHandlerFunction);
    DeletePropertyUnsafe(v8_context, data, kHandlerFunction);
#include "base/bind.h"
#include "base/bind_helpers.h"
#include "base/lazy_instance.h"
#include "base/synchronization/lock.h"
#include "extensions/renderer/object_backed_native_handler.h"
#include "third_party/WebKit/public/web/WebScopedMicrotaskSuppression.h"
// Preface:
//
// This is the documentation for makeCallback() function in the JavaScript, out
// here to reduce the amount of effort that the v8 parser needs to do:
//
// Returns a new object with every function on |obj| configured to call()
// itself with the given arguments.
//
// E.g. given
//    var result = makeCallable(Function.prototype)
//
// |result| will be an object including 'bind' such that
//    result.bind(foo, 1, 2, 3);
//
// is equivalent to Function.prototype.bind.call(foo, 1, 2, 3), and so on.
// This is a convenient way to save functions that user scripts may clobber.
// This is the source of a script which evaluates to a function, which should
// then be executed to save the bindings. This function is passed references
// to ScriptRunner::Apply and ScriptRunner::Save via the |natives| argument.
    "(function(natives) {\n"
    "      return natives.Apply(\n"
    "  natives.Save(builtin.name, safe);\n"
    "natives.Save('JSON', {\n"
    "});\n";
// Holds a compiled instance of |kScript| so that every instance of
// SafeBuiltins doesn't need to recompile it. Thread-safe.
// TODO(kalman): It would benefit to cache ModuleSystem's native handlers in
// this way as well.
class CompiledScript {
 public:
  CompiledScript() {}

  // Returns a handle to the instance of the compiled script, bound to the
  // current context (assumed to be |context|).
  v8::Local<v8::Script> GetForCurrentContext(v8::Local<v8::Context> context) {
    v8::Isolate* isolate = context->GetIsolate();
    DCHECK(v8::Isolate::GetCurrent() == isolate &&
           isolate->GetCurrentContext() == context);
    v8::EscapableHandleScope handle_scope(isolate);

    v8::Local<v8::Script> compiled_script;
    base::AutoLock lock_scope(lock_);
    if (unbound_compiled_script_.IsEmpty()) {
      compiled_script =
          v8::Script::Compile(context, ToV8StringUnsafe(isolate, kScript))
              .ToLocalChecked();
      unbound_compiled_script_.Reset(isolate,
                                     compiled_script->GetUnboundScript());
    } else {
      compiled_script =
          v8::Local<v8::UnboundScript>::New(isolate, unbound_compiled_script_)
              ->BindToCurrentContext();
    }
    return handle_scope.Escape(compiled_script);
  }

 private:
  // CompiledScript needs to be accessed on multiple threads - the main
  // RenderThread, plus worker threads. Singletons are thread-safe, but
  // access to |unbound_compiled_script_| must be locked.
  base::Lock lock_;

  // Use a v8::Persistent not a v8::Global because Globals attempt to reset the
  // handle on destruction, and by the time CompiledScript is destroyed the
  // renderer will be shutting down, and accessing into v8 will crash.
  v8::Persistent<v8::UnboundScript> unbound_compiled_script_;

  DISALLOW_COPY_AND_ASSIGN(CompiledScript);
};

base::LazyInstance<CompiledScript> g_compiled_script =
    LAZY_INSTANCE_INITIALIZER;

// Returns a unique key to use as a hidden value in an object without a
// namespace collision.
                          base::StringPrintf("safe_builtins::%s", name));
class ScriptNativeHandler : public ObjectBackedNativeHandler {
 public:
  explicit ScriptNativeHandler(ScriptContext* context)
      : ObjectBackedNativeHandler(context) {
    RouteFunction("Apply", base::Bind(&ScriptNativeHandler::Apply,
                                      base::Unretained(this)));
    RouteFunction(
        "Save", base::Bind(&ScriptNativeHandler::Save, base::Unretained(this)));
  }
  ~ScriptNativeHandler() override { Invalidate(); }
  // Takes 5 arguments:
  //  |function| The function that the arguments are being applied to.
  //  |recv| The receiver of the function call (i.e. the "this" value).
  //  |args| The arguments to the function call. This is actually an Arguments
  //    object but that isn't exposed in a convenient way in the v8 API, so we
  //    just use an Object and pass in |args_length| explicitly.
  //  |first_arg_index| The index of the first argument within |args|.
  //    This is 1 for prototype methods where the first argument to the
  //    function is the receiver. It's 0 for static methods which don't have a
  //    receiver.
  //  |args_length| The length of the argument list. This is needed because
  //    |args| is an Object which doesn't have a reliable concept of a length.
  void Apply(const v8::FunctionCallbackInfo<v8::Value>& info) {
    CHECK(info.Length() == 5 && info[0]->IsFunction() && info[2]->IsObject() &&
          info[3]->IsInt32() && info[4]->IsInt32());
    v8::Local<v8::Value> recv = info[1];
    v8::Local<v8::Object> args = info[2].As<v8::Object>();
    v8::Local<v8::Context> v8_context = context()->v8_context();

      CHECK(IsTrue(args->Has(v8_context, i + first_arg_index)));
      if (!GetProperty(v8_context, args, i + first_arg_index, &argv[i]))
    if (function->Call(v8_context, recv, argc, argv.get())
            .ToLocal(&return_value))
  void Save(const v8::FunctionCallbackInfo<v8::Value>& info) {
    v8::Local<v8::Object> object = info[1].As<v8::Object>();
    context()->v8_context()->Global()->SetHiddenValue(
        MakeKey(*v8::String::Utf8Value(info[0]), GetIsolate()), object);

  DISALLOW_COPY_AND_ASSIGN(ScriptNativeHandler);
void DeleteScriptHandler(scoped_ptr<ScriptNativeHandler> script_handler) {
  // |script_handler| is a scoped_ptr so will delete itself.
}

SafeBuiltins::~SafeBuiltins() {}

scoped_ptr<SafeBuiltins> SafeBuiltins::Install(ScriptContext* context) {
  v8::Isolate* isolate = context->isolate();
  v8::HandleScope handle_scope(isolate);
  v8::Handle<v8::Context> v8_context = context->v8_context();
  v8::Context::Scope context_scope(v8_context);
  blink::WebScopedMicrotaskSuppression microtask_suppression;

  // Run the script to return a new function bound to this context.
  v8::Local<v8::Script> script =
      g_compiled_script.Get().GetForCurrentContext(v8_context);
  v8::Local<v8::Value> return_value = script->Run();
  CHECK(return_value->IsFunction());
  v8::Local<v8::Function> script_function = return_value.As<v8::Function>();

  // Call the script function to save builtins.
  scoped_ptr<ScriptNativeHandler> script_handler(
      new ScriptNativeHandler(context));
  v8::Local<v8::Value> args[] = {script_handler->NewInstance()};
  CHECK(!script_function->Call(v8_context, v8_context->Global(),
                               arraysize(args), args)
             .IsEmpty());
  // Bind the lifetime of |script_handler| to |context|.
  context->AddInvalidationObserver(
      base::Bind(&DeleteScriptHandler, base::Passed(&script_handler)));
  // The SafeBuiltins instance itself is just a thin wrapper around accessing
  // the hidden properties that were just installed on |context|.
  return make_scoped_ptr(new SafeBuiltins(context));
}
  return Load("Array");
  return Load("Function");
  return Load("JSON");
  return Load("Object");
  return Load("RegExp");
  return Load("String");
  return Load("Error");
}

SafeBuiltins::SafeBuiltins(ScriptContext* context) : context_(context) {}

v8::Local<v8::Object> SafeBuiltins::Load(const char* name) const {
  v8::Local<v8::Value> value = context_->v8_context()->Global()->GetHiddenValue(
      MakeKey(name, context_->isolate()));
  CHECK(!IsEmptyOrUndefined(value));
  CHECK(value->IsObject()) << name;
  return v8::Local<v8::Object>::Cast(value);
#include "base/macros.h"
#include "base/memory/scoped_ptr.h"
// Saves a subset of the JavaScript builtin types, so that they can be used
// later without extensions tampering with them.
  ~SafeBuiltins();
  // Creates and immediately installs a SafeBuiltins instance in |context|.
  static scoped_ptr<SafeBuiltins> Install(ScriptContext* context);
  explicit SafeBuiltins(ScriptContext* context);

  v8::Local<v8::Object> Load(const char* name) const;


  DISALLOW_COPY_AND_ASSIGN(SafeBuiltins);
#include "extensions/renderer/safe_builtins.h"
  safe_builtins_ = SafeBuiltins::Install(this);
class SafeBuiltins;
  SafeBuiltins* safe_builtins() { return safe_builtins_.get(); }
  const SafeBuiltins* safe_builtins() const { return safe_builtins_.get(); }
  scoped_ptr<SafeBuiltins> safe_builtins_;
#include "extensions/renderer/safe_builtins.h"
inline bool IsEmptyOrUndefined(v8::Local<v8::Value> value) {
// DeletePropertyUnsafe() family wraps v8::Object::Delete(). They crash when an
// exception is thrown.
inline bool DeletePropertyUnsafe(v8::Local<v8::Context> context,
                                 v8::Local<v8::Object> object,
                                 v8::Local<v8::Value> key) {
  return object->Delete(context, key).FromJust();
}

inline bool DeletePropertyUnsafe(
    v8::Local<v8::Context> context,
    v8::Local<v8::Object> object,
    const char* key,
    v8::NewStringType string_type = v8::NewStringType::kNormal) {
  return object->Delete(context, ToV8StringUnsafe(context->GetIsolate(), key,
                                                  string_type))
      .FromJust();
}

      shelf_visible_(false),
      capturing_contents_(false),
      is_being_destroyed_(false) {
  // Data ----------------------------------------------------------------------
  bool is_crashed_;  // true if the tab is considered crashed.
  // The download shelf view (view at the bottom of the page).
  scoped_ptr<DownloadShelf> download_shelf_;

  // Whether the shelf view is visible.
  bool shelf_visible_;

  // See capturing_contents() above.
  bool capturing_contents_;
  // popups. This pointer alsog goes in |child_windows_| for ownership,
class WebContents::GearsCreateShortcutCallbackFunctor {
 public:
  explicit GearsCreateShortcutCallbackFunctor(WebContents* contents)
     : contents_(contents) {}

  void Run(const GearsShortcutData2& shortcut_data, bool success) {
    if (contents_)
      contents_->OnGearsCreateShortcutDone(shortcut_data, success);
    delete this;
  }
  void Cancel() {
    contents_ = NULL;
  }

 private:
  WebContents* contents_;
};

// static
int WebContents::find_request_id_counter_ = -1;

    : TabContents(profile),
      view_(TabContentsView::Create(this)),
      ALLOW_THIS_IN_INITIALIZER_LIST(render_manager_(this, this)),
      printing_(*this),
      notify_disconnection_(false),
      received_page_title_(false),
      is_starred_(false),
#if defined(OS_WIN)
      message_box_active_(CreateEvent(NULL, TRUE, FALSE, NULL)),
#endif
      ALLOW_THIS_IN_INITIALIZER_LIST(fav_icon_helper_(this)),
      suppress_javascript_messages_(false),
      load_state_(net::LOAD_STATE_IDLE),
      find_ui_active_(false),
      find_op_aborted_(false),
      current_find_request_id_(find_request_id_counter_++),
      find_prepopulate_text_(NULL) {
void WebContents::OnGearsCreateShortcutDone(
    const GearsShortcutData2& shortcut_data, bool success) {
  NavigationEntry* current_entry = controller_.GetLastCommittedEntry();
  bool same_page =
      current_entry && pending_install_.page_id == current_entry->page_id();

  if (success && same_page) {
    // Only switch to app mode if the user chose to create a shortcut and
    // we're still on the same page that it corresponded to.
    if (delegate())
      delegate()->ConvertContentsToApplication(this);
  }

  // Reset the page id to indicate no requests are pending.
  pending_install_.page_id = 0;
  pending_install_.callback_functor = NULL;
}

#include "base/basictypes.h"
#include "chrome/browser/cancelable_request.h"
#include "chrome/browser/download/save_package.h"
#include "chrome/browser/fav_icon_helper.h"
#include "chrome/browser/find_notification_details.h"
#include "chrome/browser/renderer_host/render_view_host_delegate.h"
#include "chrome/browser/shell_dialogs.h"
#include "chrome/browser/tab_contents/navigation_controller.h"
#include "chrome/browser/tab_contents/render_view_host_manager.h"
#include "chrome/common/gears_api.h"
#include "net/base/load_states.h"
#include "webkit/glue/password_form.h"
#include "webkit/glue/webpreferences.h"

#if defined(OS_MACOSX) || defined(OS_LINUX)
// Remove when we've finished porting the supporting classes.
#include "chrome/common/temp_scaffolding_stubs.h"
#elif defined(OS_WIN)
#include "chrome/browser/printing/print_view_manager.h"
#endif
class AutofillManager;
class PasswordManager;
class PluginInstaller;
class TabContentsView;
  // When CreateShortcut is invoked RenderViewHost::GetApplicationInfo is
  // invoked. CreateShortcut caches the state of the page needed to create the
  // shortcut in PendingInstall. When OnDidGetApplicationInfo is invoked, it
  // uses the information from PendingInstall and the WebApplicationInfo
  // to create the shortcut.
  class GearsCreateShortcutCallbackFunctor;
  struct PendingInstall {
    int32 page_id;
    SkBitmap icon;
    std::wstring title;
    GURL url;
    // This object receives the GearsCreateShortcutCallback and routes the
    // message back to the WebContents, if we haven't been deleted.
    GearsCreateShortcutCallbackFunctor* callback_functor;
  };

  // Called when the user dismisses the shortcut creation dialog.  'success' is
  // true if the shortcut was created.
  void OnGearsCreateShortcutDone(const GearsShortcutData2& shortcut_data,
                                 bool success);

  // Data ----------------------------------------------------------------------

  // The corresponding view.
  scoped_ptr<TabContentsView> view_;

  // Manages creation and swapping of render views.
  RenderViewHostManager render_manager_;

  // Handles print preview and print job for this contents.
  printing::PrintViewManager printing_;

  // Indicates whether we should notify about disconnection of this
  // WebContents. This is used to ensure disconnection notifications only
  // happen if a connection notification has happened and that they happen only
  // once.
  bool notify_disconnection_;

  // Maps from handle to page_id.
  typedef std::map<HistoryService::Handle, int32> HistoryRequestMap;
  HistoryRequestMap history_requests_;

  // System time at which the current load was started.
  base::TimeTicks current_load_start_;

  // Whether we have a (non-empty) title for the current page.
  // Used to prevent subsequent title updates from affecting history. This
  // prevents some weirdness because some AJAXy apps use titles for status
  // messages.
  bool received_page_title_;

  // SavePackage, lazily created.
  scoped_refptr<SavePackage> save_package_;

  // Tracks our pending CancelableRequests. This maps pending requests to
  // page IDs so that we know whether a given callback still applies. The
  // page ID -1 means no page ID was set.
  CancelableRequestConsumerT<int32, -1> cancelable_consumer_;

  // Whether the current URL is starred
  bool is_starred_;

#if defined(OS_WIN)
  // Handle to an event that's set when the page is showing a message box (or
  // equivalent constrained window).  Plugin processes check this to know if
  // they should pump messages then.
  ScopedHandle message_box_active_;
#endif

  // AutofillManager, lazily created.
  scoped_ptr<AutofillManager> autofill_manager_;

  // PasswordManager, lazily created.
  scoped_ptr<PasswordManager> password_manager_;

  // PluginInstaller, lazily created.
  scoped_ptr<PluginInstaller> plugin_installer_;

  // Handles downloading favicons.
  FavIconHelper fav_icon_helper_;

  // Dialog box used for choosing files to upload from file form fields.
  scoped_refptr<SelectFileDialog> select_file_dialog_;

  // The time that the last javascript message was dismissed.
  base::TimeTicks last_javascript_message_dismissal_;

  // True if the user has decided to block future javascript messages. This is
  // reset on navigations to false on navigations.
  bool suppress_javascript_messages_;

  // When a navigation occurs, we record its contents MIME type. It can be
  // used to check whether we can do something for some special contents.
  std::string contents_mime_type_;

  // Character encoding. TODO(jungshik) : convert to std::string
  std::wstring encoding_;

  PendingInstall pending_install_;

  // The last time that the download shelf was made visible.
  base::TimeTicks last_download_shelf_show_;

  // The current load state and the URL associated with it.
  net::LoadState load_state_;
  std::wstring load_state_host_;

  // True if the Find UI is active for this Tab.
  bool find_ui_active_;

  // True if a Find operation was aborted. This can happen if the Find box is
  // closed or if the search term inside the Find box is erased while a search
  // is in progress. This can also be set if a page has been reloaded, and will
  // on FindNext result in a full Find operation so that the highlighting for
  // inactive matches can be repainted.
  bool find_op_aborted_;

  // Each time a search request comes in we assign it an id before passing it
  // over the IPC so that when the results come in we can evaluate whether we
  // still care about the results of the search (in some cases we don't because
  // the user has issued a new search).
  static int find_request_id_counter_;

  // This variable keeps track of what the most recent request id is.
  int current_find_request_id_;

  // The last string we searched for. This is used to figure out if this is a
  // Find or a FindNext operation (FindNext should not increase the request id).
  string16 find_text_;

  // Keeps track of the last search string that was used to search in any tab.
  string16* find_prepopulate_text_;

  // The last find result. This object contains details about the number of
  // matches, the find selection rectangle, etc. The UI can access this
  // information to build its presentation.
  FindNotificationDetails find_result_;

    // ========

        FrameNavigationDisabler navigationDisabler(m_frame);
FrameNavigationDisabler::FrameNavigationDisabler(LocalFrame* frame)
    : m_navigationScheduler(&frame->navigationScheduler())
{
    m_navigationScheduler->disableFrameNavigation();
}

FrameNavigationDisabler::~FrameNavigationDisabler()
{
    m_navigationScheduler->enableFrameNavigation();
}

    , m_navigationDisableCount(0)
    return m_frame->page() && isFrameNavigationAllowed() && NavigationDisablerForBeforeUnload::isNavigationAllowed();
    return m_frame->page() && isFrameNavigationAllowed() && (protocolIsJavaScript(url) || NavigationDisablerForBeforeUnload::isNavigationAllowed());
    friend class FrameNavigationDisabler;
    void disableFrameNavigation() { ++m_navigationDisableCount; }
    void enableFrameNavigation() { --m_navigationDisableCount; }
    bool isFrameNavigationAllowed() const { return !m_navigationDisableCount; }

    int m_navigationDisableCount;
class FrameNavigationDisabler {
    WTF_MAKE_NONCOPYABLE(FrameNavigationDisabler);
    STACK_ALLOCATED();
public:
    explicit FrameNavigationDisabler(LocalFrame*);
    ~FrameNavigationDisabler();

private:
    RawPtrWillBeMember<NavigationScheduler> m_navigationScheduler;
};

  if (web_contents) {
    Profile* profile =
        Profile::FromBrowserContext(web_contents->GetBrowserContext());
    Browser* browser = chrome::FindAnyBrowser(profile, include_incognito_);
    if (browser)
      return browser;
  }
void
ChromeContentRendererClient::DidInitializeServiceWorkerContextOnWorkerThread(
    v8::Local<v8::Context> context,
    const GURL& url) {
  extensions::Dispatcher::DidInitializeServiceWorkerContextOnWorkerThread(
      context, url);
  extensions::Dispatcher::WillDestroyServiceWorkerContextOnWorkerThread(context,
                                                                        url);
      ->DidInitializeServiceWorkerContextOnWorkerThread(context, script_url_);
      context, script_url_);
    // The renderer has done validation before sending extension api requests.
    // Therefore, we should never receive a request that is invalid in a way
    // that JSON validation in the renderer should have caught. It could be an
    // attacker trying to exploit the browser, so we crash the renderer instead.
    LOG(ERROR) <<
        "Terminating renderer because of malformed extension message.";
    if (content::RenderProcessHost::run_renderer_in_process()) {
      // In single process mode it is better if we don't suicide but just crash.
      CHECK(false);
    } else {
      KillBadMessageSender(peer_process, histogram_value);
    }
    content::RenderFrameHost* render_frame_host) {
  UIThreadResponseCallbackWrapperMap::const_iterator
      iter = ui_thread_response_callback_wrappers_.find(render_frame_host);
  UIThreadResponseCallbackWrapper* callback_wrapper = nullptr;
  if (iter == ui_thread_response_callback_wrappers_.end()) {
    callback_wrapper = new UIThreadResponseCallbackWrapper(AsWeakPtr(),
                                                           render_frame_host);
    ui_thread_response_callback_wrappers_[render_frame_host] = callback_wrapper;
    callback_wrapper = iter->second;

  DispatchWithCallbackInternal(
      params, render_frame_host,
      callback_wrapper->CreateCallback(params.request_id));
  DCHECK(render_frame_host);
  int process_id = render_frame_host->GetProcess()->GetID();
  scoped_refptr<ExtensionFunction> function(
      CreateExtensionFunction(params,
                              extension,
                              process_id,
                              *process_map,
                              ExtensionAPI::GetSharedInstance(),
                              browser_context_,
                              callback));
                content::RenderFrameHost* render_frame_host);
  dispatcher_.Dispatch(params, render_frame_host);
  EXPECT_EQ(6u, feature->contexts()->size());
  RegisterNativeHandlers(module_system, context);
// static
        if (context->IsAnyFeatureAvailableToContext(*map_entry.second.get()))
    case Feature::SERVICE_WORKER_CONTEXT:
      // Handled in DidInitializeServiceWorkerContextOnWorkerThread().
      NOTREACHED();
      break;
                                        ScriptContext* context) {
  RegisterNativeHandlers(module_system,
                         context,
                         this,
                         request_sender_.get(),
                         v8_schema_registry_.get());
  // Runs on a different thread and should not use any member variables.
  static void DidInitializeServiceWorkerContextOnWorkerThread(
                              ScriptContext* context);
  v8::Local<v8::Object> GetOrCreateObject(const v8::Local<v8::Object>& object,
                                          const std::string& field,
                                          v8::Isolate* isolate);
  v8::Local<v8::Object> GetOrCreateBindObjectIfAvailable(
      ScriptContextSet::GetContextByObject(object);
  if (!render_frame)
  ~RequestSender();
      api, extension(), context_type(), GetDataSourceURLForFrame(web_frame()));
        context = v8::Context::New(m_isolate, nullptr, globalTemplate);
WebURL WebDataSourceImpl::endOfRedirectChain() const
void WebDataSourceImpl::appendRedirect(const WebURL& url)
        WebURL endOfRedirectChain() const;
        void appendRedirect(const WebURL& url);
        Vector<WebURL> m_redirectChain;
#include "googleurl/src/gurl.h"
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate) {
    delegate->setWindowRect(
  if (webview_->delegate()) {
    rect = webview_->delegate()->rootWindowRect();
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate) {
    delegate->didFocus();

    // If accessibility is enabled, we should notify assistive technology that
    // the active AccessibilityObject changed.
    const WebCore::Frame* frame = webview_->GetFocusedWebCoreFrame();
    if (!frame)
      return;
    WebCore::Document* doc = frame->document();
    if (doc && doc->axObjectCache()->accessibilityEnabled()) {
      WebCore::Node* focused_node = webview_->GetFocusedNode();
      if (!focused_node) {
        // Could not retrieve focused Node.
        return;
      }
      // Retrieve the focused AccessibilityObject.
      WebCore::AccessibilityObject* focused_acc_obj =
          doc->axObjectCache()->getOrCreate(focused_node->renderer());
      // Alert assistive technology that focus changed.
      if (focused_acc_obj)
        delegate->FocusAccessibilityObject(focused_acc_obj);
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate)
    delegate->didBlur();
  return webview_->delegate() != NULL;
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate)
    delegate->runModal();
  return webview_->delegate() != NULL;
  if (webview_->delegate()) {
        webview_->delegate()->windowResizerRect());
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate)
    delegate->didInvalidateRect(webkit_glue::IntRectToWebRect(paint_rect));
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate) {
    delegate->didScrollRect(
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate) {
    WebRect window_rect = delegate->windowRect();
  WebViewDelegate* delegate = webview_->delegate();
  if (delegate)
    delegate->didChangeCursor(cursor);
#include <string>
#include <vector>

#include "base/basictypes.h"
#include "base/logging.h"
#include "base/string_util.h"
#include "webkit/glue/plugins/plugin_list.h"
#include "webkit/glue/webview_delegate.h"
using base::Time;
using base::TimeDelta;

    NOTREACHED() << "Got a server redirect when there is no provisional DS";
  DCHECK(ds->hasRedirectChain());
  ds->appendRedirect(ds->request().url());
    expected_client_redirect_src_ = GURL();
    expected_client_redirect_dest_ = GURL();
  expected_client_redirect_src_ = webframe_->url();
  expected_client_redirect_dest_ = webkit_glue::KURLToGURL(url);
  if (expected_client_redirect_dest_.SchemeIsFile() &&
     (expected_client_redirect_src_.SchemeIs("http") ||
      expected_client_redirect_src_.SchemeIsSecure())) {
    expected_client_redirect_src_ = GURL();
    expected_client_redirect_dest_ = GURL();
        expected_client_redirect_src_,
        expected_client_redirect_dest_,
  DCHECK(ds) << "DataSource NULL when navigating to reference fragment";
    GURL url = ds->request().url();
    GURL chain_end = ds->endOfRedirectChain();
      if (webframe_->client())
        webframe_->client()->didCompleteClientRedirect(webframe_, chain_end);
      expected_client_redirect_src_ = GURL();
      expected_client_redirect_dest_ = GURL();
    NOTREACHED() << "Attempting to provisional load but there isn't one";
  GURL url = ds->request().url();
  DCHECK(!ds->hasRedirectChain());
  if (expected_client_redirect_src_.is_valid()) {
    DCHECK(expected_client_redirect_dest_.SchemeIs("javascript") ||
          webframe_, expected_client_redirect_src_);
  DCHECK(next_navigation_policy_ != WebKit::WebNavigationPolicyIgnore);
  WebViewDelegate* d = webview->delegate();
  if (d)
    d->show(webview->initial_navigation_policy());
      GURL url = ds->request().url();
      if (url.SchemeIs(webkit_glue::kBackForwardNavigationScheme)) {
  NOTREACHED() << "Page cache should be disabled";
  NOTREACHED();
  DCHECK(plugin_widget_.get());
  String rv;
  return rv;
void WebFrameLoaderClient::HandleBackForwardNavigation(const GURL& url) {
  DCHECK(url.SchemeIs(webkit_glue::kBackForwardNavigationScheme));
  std::string offset_str = url.ExtractFileName();
  int offset;
  if (!StringToInt(offset_str, &offset))
#include "googleurl/src/gurl.h"
  void HandleBackForwardNavigation(const GURL&);
  GURL expected_client_redirect_src_;
  GURL expected_client_redirect_dest_;
    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
TEST_F(FileUtilTest, CopyDirectoryWithTrailingSeparators) {
  // Create a directory.
  FilePath dir_name_from =
      temp_dir_.path().Append(FILE_PATH_LITERAL("Copy_From_Subdir"));
  file_util::CreateDirectory(dir_name_from);
  ASSERT_TRUE(file_util::PathExists(dir_name_from));

  // Create a file under the directory.
  FilePath file_name_from =
      dir_name_from.Append(FILE_PATH_LITERAL("Copy_Test_File.txt"));
  CreateTextFile(file_name_from, L"Gooooooooooooooooooooogle");
  ASSERT_TRUE(file_util::PathExists(file_name_from));

  // Copy the directory recursively.
  FilePath dir_name_to =
      temp_dir_.path().Append(FILE_PATH_LITERAL("Destination"));
  FilePath file_name_to =
      dir_name_to.Append(FILE_PATH_LITERAL("Copy_Test_File.txt"));

  // Create from path with trailing separators.
#if defined(OS_WIN)
  FilePath from_path =
      temp_dir_.path().Append(FILE_PATH_LITERAL("Copy_From_Subdir\\\\\\"));
#elif defined(OS_POSIX)
  FilePath from_path =
      temp_dir_.path().Append(FILE_PATH_LITERAL("Copy_From_Subdir///"));
#endif

  EXPECT_TRUE(file_util::CopyDirectory(from_path, dir_name_to, true));

  // Check everything has been copied.
  EXPECT_TRUE(file_util::PathExists(dir_name_from));
  EXPECT_TRUE(file_util::PathExists(file_name_from));
  EXPECT_TRUE(file_util::PathExists(dir_name_to));
  EXPECT_TRUE(file_util::PathExists(file_name_to));
}

  PLATFORM_FILE_TRUNCATE = 4096
  if ((descriptor < 0) && (flags & PLATFORM_FILE_DELETE_ON_CLOSE)) {
  if ((descriptor < 0) && error_code) {
    switch (errno) {
      case EACCES:
      case EISDIR:
      case EROFS:
      case EPERM:
        *error_code = PLATFORM_FILE_ERROR_ACCESS_DENIED;
        break;
      case ETXTBSY:
        *error_code = PLATFORM_FILE_ERROR_IN_USE;
        break;
      case EEXIST:
        *error_code = PLATFORM_FILE_ERROR_EXISTS;
        break;
      case ENOENT:
        *error_code = PLATFORM_FILE_ERROR_NOT_FOUND;
        break;
      case EMFILE:
        *error_code = PLATFORM_FILE_ERROR_TOO_MANY_OPENED;
        break;
      case ENOMEM:
        *error_code = PLATFORM_FILE_ERROR_NO_MEMORY;
        break;
      case ENOSPC:
        *error_code = PLATFORM_FILE_ERROR_NO_SPACE;
        break;
      case ENOTDIR:
        *error_code = PLATFORM_FILE_ERROR_NOT_A_DIRECTORY;
        break;
      default:
        *error_code = PLATFORM_FILE_ERROR_FAILED;
  return close(file);
  if ((flags & PLATFORM_FILE_OPEN_ALWAYS) && created &&
      INVALID_HANDLE_VALUE != file) {
    *created = (ERROR_ALREADY_EXISTS != GetLastError());
  if ((file == kInvalidPlatformFileValue) && error_code) {
    DWORD last_error = GetLastError();
    switch (last_error) {
      case ERROR_SHARING_VIOLATION:
        *error_code = PLATFORM_FILE_ERROR_IN_USE;
        break;
      case ERROR_FILE_EXISTS:
        *error_code = PLATFORM_FILE_ERROR_EXISTS;
        break;
      case ERROR_FILE_NOT_FOUND:
        *error_code = PLATFORM_FILE_ERROR_NOT_FOUND;
        break;
      case ERROR_ACCESS_DENIED:
        *error_code = PLATFORM_FILE_ERROR_ACCESS_DENIED;
        break;
      default:
        *error_code = PLATFORM_FILE_ERROR_FAILED;
  return (CloseHandle(file) == 0);
  static Time FromLargeInteger(LARGE_INTEGER li);
  virtual void StartPageScaleAnimation(gfx::Vector2d target_offset,
void Layer::SetScrollOffsetFromImplSide(gfx::Vector2d scroll_offset) {

  void SetScrollOffsetFromImplSide(gfx::Vector2d scroll_offset);

void LayerImpl::SetSentScrollDelta(gfx::Vector2d sent_scroll_delta) {
void LayerImpl::SetScrollOffset(gfx::Vector2d scroll_offset) {
void LayerImpl::SetScrollOffsetAndDelta(gfx::Vector2d scroll_offset,

  void SetScrollOffset(gfx::Vector2d scroll_offset);
  void SetScrollOffsetAndDelta(gfx::Vector2d scroll_offset,

  void SetSentScrollDelta(gfx::Vector2d sent_scroll_delta);
gfx::Rect ExpandRectByDelta(const gfx::Rect& rect, gfx::Vector2d delta) {
    gfx::Vector2d amount) {
  void SetEnlargePassTextureAmountForTesting(gfx::Vector2d amount);
void SoftwareOutputDevice::Scroll(
    gfx::Vector2d delta, const gfx::Rect& clip_rect) {
  virtual void Scroll(gfx::Vector2d delta,
                      const gfx::Rect& clip_rect);
void BitmapContentLayerUpdater::Resource::Update(ResourceUpdateQueue* queue,
                                                 const gfx::Rect& source_rect,
                                                 gfx::Vector2d dest_offset,
                                                 bool partial_update) {
                                              gfx::Vector2d dest_offset,
                        gfx::Vector2d dest_offset,
                     gfx::Vector2d dest_offset,
    gfx::Vector2d dest_offset,
                        gfx::Vector2d dest_offset,
                                         gfx::Vector2d dest_offset,
                                      gfx::Vector2d dest_offset,
                        gfx::Vector2d dest_offset,
                     gfx::Vector2d dest_offset,
                        gfx::Vector2d dest_offset,
                                    gfx::Vector2d dest_offset) {
                 gfx::Vector2d dest_offset);
                                 gfx::Vector2d dest_offset) {
                 gfx::Vector2d dest_offset);
                                      gfx::Vector2d dest_offset) {
                               gfx::Vector2d dest_offset);
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta, float scale) {}
void PixelTest::ForceViewportOffset(gfx::Vector2d viewport_offset) {
  void ForceViewportOffset(gfx::Vector2d viewport_offset);
                                        gfx::Vector2d dest_offset,
                        gfx::Vector2d dest_offset,
void LayerTreeHost::StartPageScaleAnimation(gfx::Vector2d target_offset,
  void StartPageScaleAnimation(gfx::Vector2d target_offset,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
void LayerTreeHostImpl::StartPageScaleAnimation(gfx::Vector2d target_offset,
                                                bool anchor_point,
                                                float page_scale,
                                                base::TimeDelta duration) {
  virtual void StartPageScaleAnimation(gfx::Vector2d target_offset,
                             gfx::Vector2d scroll_delta) {

  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
void RenderWidgetCompositor::ApplyScrollAndScale(gfx::Vector2d scroll_delta,
                                                 float page_scale) {
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void StartPageScaleAnimation(gfx::Vector2d target_offset,
    gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta, float page_scale)
      OVERRIDE;
void CompositorHost::ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
  virtual void ApplyScrollAndScale(gfx::Vector2d scroll_delta,
// Chrome personal options page UI handler.
class ClearBrowserDataHandler : public OptionsPageUIHandler {
  size_t idx = param_values->GetSize();
  LOG(INFO) << "param_values->GetSize() = " << idx;
  size_t size = param_values->GetSize();
  LOG(INFO) << "Array size = " << size;
using blink::WebFrame;
  WebFrame* frame = context()->web_frame();
    WebFrame* frame,
#include "third_party/WebKit/public/web/WebFrame.h"
      blink::WebFrame* frame,
#include "extensions/common/extension.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "extensions/renderer/extension_groups.h"
const Extension* Dispatcher::GetExtensionFromFrameAndWorld(
    const blink::WebFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.

    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_.GetExtensionOrAppIDByURL(frame_url);
  }

  const Extension* extension = extensions_.GetByID(extension_id);
  if (!extension && !extension_id.empty()) {
    // There are conditions where despite a context being associated with an
    // extension, no extension actually gets found.  Ignore "invalid" because
    // CSP blocks extension page loading by switching the extension ID to
    // "invalid". This isn't interesting.
    if (extension_id != "invalid") {
      LOG(ERROR) << "Extension \"" << extension_id << "\" not found";
      RenderThread::Get()->RecordAction(
          UserMetricsAction("ExtensionNotFound_ED"));
    }
  }
  return extension;
}

  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());

  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  script_context_set_.Add(context);
  if (context_type == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(extension);
  switch (context_type) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  ScriptContext* context = script_context_set_.GetByV8Context(v8_context);
  script_context_set_.Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  if (IsSandboxedPage(ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_.ForEach(
  script_context_set_.ForEach(
  MessagingBindings::DeliverMessage(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(script_context_set_, port_id,
  ScriptContextSet::ContextSet removed_contexts =
      script_context_set_.OnExtensionUnloaded(id);
  for (ScriptContextSet::ContextSet::iterator it = removed_contexts.begin();
       it != removed_contexts.end(); ++it) {
    request_sender_->InvalidateSource(*it);
// TODO(kalman): This is checking for the wrong thing, it should be checking if
// the frame's security origin is unique. The extension sandbox directive is
// checked for in extensions/common/manifest_handlers/csp_info.cc.
bool Dispatcher::IsSandboxedPage(const GURL& url) const {
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions_.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

Feature::Context Dispatcher::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (IsSandboxedPage(url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && IsExtensionActive(extension->id())) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of IsSandboxedPage().
  if (!origin.isUnique() && extensions_.ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

class Extension;
    return script_context_set_;
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(const blink::WebFrame* frame,
                                                 int world_id,
                                                 bool use_effective_url);

  // Forwarded from the RenderFrameObserver events by ExtensionFrameHelper.
  bool IsSandboxedPage(const GURL& url) const;

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  ScriptContextSet script_context_set_;
  std::set<std::string> active_extension_ids_;
#include "third_party/WebKit/public/web/WebFrame.h"
#include "third_party/WebKit/public/web/WebFrame.h"
  if (blink::WebFrame* webframe = context->web_frame())
                             blink::WebFrame* web_frame,
  gin::PerContextData::From(v8_context)->set_runner(runner_.get());
                blink::WebFrame* frame,
  blink::WebFrame* web_frame() const { return web_frame_; }
  // The WebFrame associated with this context. This can be NULL because this
  // object can outlive is destroyed asynchronously.
  blink::WebFrame* web_frame_;
ScriptContextSet::ScriptContextSet() {
}
ScriptContextSet::~ScriptContextSet() {
int ScriptContextSet::size() const {
  return static_cast<int>(contexts_.size());
void ScriptContextSet::Add(ScriptContext* context) {
#if DCHECK_IS_ON()
  // It's OK to insert the same context twice, but we should only ever have
  // one ScriptContext per v8::Context.
  for (ContextSet::iterator iter = contexts_.begin(); iter != contexts_.end();
       ++iter) {
    ScriptContext* candidate = *iter;
    if (candidate != context)
      DCHECK(candidate->v8_context() != context->v8_context());
  }
#endif
  contexts_.insert(context);
ScriptContextSet::ContextSet ScriptContextSet::GetAll() const {
  return contexts_;
}

                              : NULL;
  return calling.IsEmpty() ? NULL : GetByV8Context(calling);
    v8::Handle<v8::Context> v8_context) const {
  for (ContextSet::const_iterator iter = contexts_.begin();
       iter != contexts_.end(); ++iter) {
    if ((*iter)->v8_context() == v8_context)
      return *iter;

  return NULL;
  ContextSet contexts = GetAll();

  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    ScriptContext* context = *it;
ScriptContextSet::ContextSet ScriptContextSet::OnExtensionUnloaded(
  ContextSet contexts = GetAll();
  ContextSet removed;

  // Clean up contexts belonging to the unloaded extension. This is done so
  // that content scripts (which remain injected into the page) don't continue
  // receiving events and sending messages.
  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    if ((*it)->extension() && (*it)->extension()->id() == extension_id) {
      (*it)->DispatchOnUnloadEvent();
      removed.insert(*it);
      Remove(*it);
    }
  return removed;
#include "base/basictypes.h"
#include "base/bind.h"
namespace content {
class RenderView;
namespace v8 {
class Context;
// A container of ExtensionBindingsContext. Since calling JavaScript within a
// context can cause any number of contexts to be created or destroyed, this
// has additional smarts to help with the set changing underneath callers.
  ScriptContextSet();
  int size() const;
  // Takes ownership of |context|.
  void Add(ScriptContext* context);
  // Returns a copy to protect against changes.
  typedef std::set<ScriptContext*> ContextSet;
  ContextSet GetAll() const;

  ScriptContext* GetByV8Context(v8::Handle<v8::Context> context) const;
  ContextSet OnExtensionUnloaded(const std::string& extension_id);
  ContextSet contexts_;
#include "third_party/WebKit/public/web/WebFrame.h"
TEST(ScriptContextSet, Lifecycle) {
  ScriptContextSet context_set;
  context_holder.SetContext(v8::Context::New(isolate));

  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  const Extension* extension = NULL;
  ScriptContext* context =
      new ScriptContext(context_holder.context(), frame, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT);
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  EXPECT_EQ(context, context_set.GetByV8Context(context->v8_context()));
  // Adding the same item multiple times should be OK and deduped.
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  // GetAll() returns a copy so removing from one should not remove from others.
  ScriptContextSet::ContextSet set_copy = context_set.GetAll();
  EXPECT_EQ(1u, set_copy.count(context));
  EXPECT_EQ(0, context_set.size());
  EXPECT_FALSE(context_set.GetByV8Context(context->v8_context()));
  EXPECT_EQ(1u, set_copy.size());
    std::wstring* url, std::wstring* title) {
  if (SUCCEEDED(data_object->GetData(GetFilenameWFormat(), &store))) {
    bool success = false;
    {
      // filename using unicode
      ScopedHGlobal<wchar_t> data(store.hGlobal);
      if (data.get() && data.get()[0] &&
          (PathFileExists(data.get()) || PathIsUNC(data.get()))) {
        wchar_t file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathW(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(file_url);
          title->assign(file_url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }

  if (SUCCEEDED(data_object->GetData(GetFilenameFormat(), &store))) {
    bool success = false;
    {
      // filename using ascii
      ScopedHGlobal<char> data(store.hGlobal);
      if (data.get() && data.get()[0] && (PathFileExistsA(data.get()) ||
                                          PathIsUNCA(data.get()))) {
        char file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathA(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(UTF8ToWide(file_url));
          title->assign(*url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;

  return false;
  return GetUrl(data_object, plain_text, &title);
      std::wstring* url, std::wstring* title);
  bool success = ClipboardUtil::GetUrl(source_object_, &url_str, title);
      ClipboardUtil::GetUrl(data_object, &url, &title);
  if (ClipboardUtil::GetUrl(data_object, &url_str, &drop_data->url_title)) {
// A base class for shell dialogs.
class BaseShellDialog {
 public:
  // Returns true if a shell dialog box is currently being shown modally
  // to the specified owner.
  virtual bool IsRunning(gfx::NativeWindow owning_window) const = 0;

  // Notifies the dialog box that the listener has been destroyed and it should
  // no longer be sent notifications.
  virtual void ListenerDestroyed() = 0;

 protected:
  virtual ~BaseShellDialog() {}
};

// Helpers to show certain types of Windows shell dialogs in a way that doesn't
// block the UI of the entire app.

class ShellDialogThread : public base::Thread {
 public:
  ShellDialogThread() : base::Thread("Chrome_ShellDialogThread") { }
  ~ShellDialogThread() {
    Stop();
  }

 protected:
  void Init() {
    // Initializes the COM library on the current thread.
    CoInitialize(NULL);
  }

  void CleanUp() {
    // Closes the COM library on the current thread. CoInitialize must
    // be balanced by a corresponding call to CoUninitialize.
    CoUninitialize();
  }

 private:
  DISALLOW_COPY_AND_ASSIGN(ShellDialogThread);
};

///////////////////////////////////////////////////////////////////////////////
// A base class for all shell dialog implementations that handles showing a
// shell dialog modally on its own thread.
class BaseShellDialogImpl {
 public:
  BaseShellDialogImpl();
  virtual ~BaseShellDialogImpl();

 protected:
  // Represents a run of a dialog.
  struct RunState {
    // Owning HWND, may be null.
    HWND owner;

    // Thread dialog is run on.
    base::Thread* dialog_thread;
  };

  // Called at the beginning of a modal dialog run. Disables the owner window
  // and tracks it. Returns the message loop of the thread that the dialog will
  // be run on.
  RunState BeginRun(HWND owner);

  // Cleans up after a dialog run. If the run_state has a valid HWND this makes
  // sure that the window is enabled. This is essential because BeginRun
  // aggressively guards against multiple modal dialogs per HWND. Must be called
  // on the UI thread after the result of the dialog has been determined.
  //
  // In addition this deletes the Thread in RunState.
  void EndRun(RunState run_state);

  // Returns true if a modal shell dialog is currently active for the specified
  // owner. Must be called on the UI thread.
  bool IsRunningDialogForOwner(HWND owner) const;

  // Disables the window |owner|. Can be run from either the ui or the dialog
  // thread. Can be called on either the UI or the dialog thread. This function
  // is called on the dialog thread after the modal Windows Common dialog
  // functions return because Windows automatically re-enables the owning
  // window when those functions return, but we don't actually want them to be
  // re-enabled until the response of the dialog propagates back to the UI
  // thread, so we disable the owner manually after the Common dialog function
  // returns.
  void DisableOwner(HWND owner);

 private:
  // Creates a thread to run a shell dialog on. Each dialog requires its own
  // thread otherwise in some situations where a singleton owns a single
  // instance of this object we can have a situation where a modal dialog in
  // one window blocks the appearance of a modal dialog in another.
  static base::Thread* CreateDialogThread();

  // Enables the window |owner_|. Can only be run from the ui thread.
  void EnableOwner(HWND owner);

  // A list of windows that currently own active shell dialogs for this
  // instance. For example, if the DownloadManager owns an instance of this
  // object and there are two browser windows open both with Save As dialog
  // boxes active, this list will consist of the two browser windows' HWNDs.
  // The derived class must call EndRun once the dialog is done showing to
  // remove the owning HWND from this list.
  // This object is static since it is maintained for all instances of this
  // object - i.e. you can't have two file pickers open for the
  // same owner, even though they might be represented by different instances
  // of this object.
  // This set only contains non-null HWNDs. NULL hwnds are not added to this
  // list.
  typedef std::set<HWND> Owners;
  static Owners owners_;
  static int instance_count_;

  DISALLOW_COPY_AND_ASSIGN(BaseShellDialogImpl);
};

// static
BaseShellDialogImpl::Owners BaseShellDialogImpl::owners_;
int BaseShellDialogImpl::instance_count_ = 0;

BaseShellDialogImpl::BaseShellDialogImpl() {
  ++instance_count_;
}

BaseShellDialogImpl::~BaseShellDialogImpl() {
  // All runs should be complete by the time this is called!
  if (--instance_count_ == 0)
    DCHECK(owners_.empty());
}

BaseShellDialogImpl::RunState BaseShellDialogImpl::BeginRun(HWND owner) {
  // Cannot run a modal shell dialog if one is already running for this owner.
  DCHECK(!IsRunningDialogForOwner(owner));
  // The owner must be a top level window, otherwise we could end up with two
  // entries in our map for the same top level window.
  DCHECK(!owner || owner == GetAncestor(owner, GA_ROOT));
  RunState run_state;
  run_state.dialog_thread = CreateDialogThread();
  run_state.owner = owner;
  if (owner) {
    owners_.insert(owner);
    DisableOwner(owner);
  }
  return run_state;
}

void BaseShellDialogImpl::EndRun(RunState run_state) {
  if (run_state.owner) {
    DCHECK(IsRunningDialogForOwner(run_state.owner));
    EnableOwner(run_state.owner);
    DCHECK(owners_.find(run_state.owner) != owners_.end());
    owners_.erase(run_state.owner);
  }
  DCHECK(run_state.dialog_thread);
  delete run_state.dialog_thread;
}

bool BaseShellDialogImpl::IsRunningDialogForOwner(HWND owner) const {
  return (owner && owners_.find(owner) != owners_.end());
}

void BaseShellDialogImpl::DisableOwner(HWND owner) {
  if (IsWindow(owner))
    EnableWindow(owner, FALSE);
}

// static
base::Thread* BaseShellDialogImpl::CreateDialogThread() {
  base::Thread* thread = new ShellDialogThread;
  bool started = thread->Start();
  DCHECK(started);
  return thread;
}

void BaseShellDialogImpl::EnableOwner(HWND owner) {
  if (IsWindow(owner))
    EnableWindow(owner, TRUE);
}

      has_opener_(false) {
bool RenderView::canHandleRequest(const WebKit::WebURLRequest& request) {
WebKit::WebURLError RenderView::cannotShowURLError(
    const WebKit::WebURLRequest& request) {
  // No need to set fields of WebURLError.  It is passed to
  // unableToImplementPolicyWithError() below.
  return WebKit::WebURLError();
    WebFrame*, const WebKit::WebURLError&) {
  // We don't need to do anything here.
  // The implementations of this method in WebKit/mac WebKit/win are
  // just to log some information of the parameters.
void RenderView::didDisplayInsecureContent(WebKit::WebFrame* frame) {
void RenderView::OnFind(int request_id,
                        const string16& search_text,
                        const WebKit::WebFindOptions& options) {
  WebKit::WebVector<WebKit::WebString> ws_file_names(file_names.size());
  virtual bool canHandleRequest(const WebKit::WebURLRequest& request);
  virtual WebKit::WebURLError cannotShowURLError(
      const WebKit::WebURLRequest& request);
        virtual bool canHandleRequest(const WebURLRequest& request) = 0;
        // Called if canHandledRequest() returns false.
        virtual WebURLError cannotShowURLError(
            const WebURLRequest& request) = 0;
}  // namespace webkit_glue
  virtual bool canHandleRequest(const WebKit::WebURLRequest&) { return true; }
  virtual WebKit::WebURLError cannotShowURLError(
      const WebKit::WebURLRequest& request) { return WebKit::WebURLError(); }
#include "net/base/net_errors.h"
  return ResourceError(net::kErrorDomain, net::ERR_ABORTED,
                       request.url().string(), String());
      webframe_->client()->cannotShowURLError(WrappedResourceRequest(request)));
  return error.errorCode() != net::ERR_ABORTED;
  return webframe_->client()->canHandleRequest(WrappedResourceRequest(request));
bool TestWebViewDelegate::canHandleRequest(const WebURLRequest& request) {
WebURLError TestWebViewDelegate::cannotShowURLError(
    const WebURLRequest& request) {
  virtual bool canHandleRequest(const WebKit::WebURLRequest&);
  virtual WebKit::WebURLError cannotShowURLError(
      const WebKit::WebURLRequest& request);
      return sizeof(GLint) * 1;            // NOLINT
    case GL_BOOL_VEC3:
    case GL_BOOL_VEC4:
  void DoUniform1iv(GLint location, GLsizei count, const GLint *value);
      error::Error* error, GLuint* service_id, void** result);
void GLES2DecoderImpl::DoUniform1i(GLint location, GLint v0) {
    // The program does not exist.
    SetGLError(GL_INVALID_OPERATION, "glUniform1i: no program in use");
  if (!current_program_ || current_program_->IsDeleted()) {
    // The program does not exist.
    SetGLError(GL_INVALID_OPERATION, "glUniform1iv: no program in use");
  if (!current_program_ || current_program_->IsDeleted()) {
    error::Error* error, GLuint* service_id, void** result_pointer) {
      &error, &service_id, &result)) {
  void* result;
      &error, &service_id, &result)) {
    glGetUniformfv(
        service_id,
        location,
        static_cast<gles2::GetUniformfv::Result*>(result)->GetData());
  glUniform1f(location, x);
  glUniform1fv(location, count, v);
  glUniform1fv(location, count, v);
  glUniform2f(location, x, y);
  glUniform2fv(location, count, v);
  glUniform2fv(location, count, v);
  glUniform3f(location, x, y, z);
  glUniform3fv(location, count, v);
  glUniform3fv(location, count, v);
  glUniform4f(location, x, y, z, w);
  glUniform4fv(location, count, v);
  glUniform4fv(location, count, v);
  EXPECT_CALL(*gl_, Uniform1f(1, 2));
  EXPECT_CALL(*gl_, Uniform2f(1, 2, 3));
  EXPECT_CALL(*gl_, Uniform3f(1, 2, 3, 4));
  EXPECT_CALL(*gl_, Uniform4f(1, 2, 3, 4, 5));
void GLES2DecoderWithShaderTestBase::SetupShader(
    GLES2DecoderWithShaderTestBase::AttribInfo* attribs, size_t num_attribs,
    GLES2DecoderWithShaderTestBase::UniformInfo* uniforms, size_t num_uniforms,
        .WillOnce(SetArgumentPointee<2>(kMaxAttribLength))
          GetActiveAttrib(service_id, ii,
                          kMaxAttribLength, _, _, _, _))
        .WillOnce(SetArgumentPointee<2>(kMaxUniformLength))
          GetActiveUniform(service_id, ii,
                           kMaxUniformLength, _, _, _, _))
  struct AttribInfo {
    const char* name;
    GLint size;
    GLenum type;
    GLint location;
  };

  struct UniformInfo {
    const char* name;
    GLint size;
    GLenum type;
    GLint location;
  };

  void SetupShader(AttribInfo* attribs, size_t num_attribs,
                   UniformInfo* uniforms, size_t num_uniforms,
                   GLuint client_id, GLuint service_id);

#include "chrome/browser/extensions/extensions_service.h"
  ExtensionsService::ExtensionHeader header;
  memcpy(&header.magic, ExtensionsService::kExtensionHeaderMagic,
         ExtensionsService::kExtensionHeaderMagicSize);
  header.version = ExtensionsService::kCurrentVersion;
  fwrite(&header, sizeof(ExtensionsService::ExtensionHeader), 1,
#include "base/crypto/signature_verifier.h"
#include "base/gfx/png_encoder.h"
#include "base/scoped_handle.h"
#include "base/third_party/nss/blapi.h"
#include "base/third_party/nss/sha256.h"
#include "base/thread.h"
#include "chrome/browser/extensions/extension_creator.h"
#include "chrome/browser/utility_process_host.h"
#include "chrome/common/extensions/extension_unpacker.h"
#include "chrome/common/zip.h"
#include "net/base/base64.h"
#include "third_party/skia/include/core/SkBitmap.h"
const char ExtensionsService::kExtensionHeaderMagic[] = "Cr24";

const char* ExtensionsServiceBackend::kTempExtensionName = "TEMP_INSTALL";

namespace {

// A temporary subdirectory where we unpack extensions.
const char* kUnpackExtensionDir = "TEMP_UNPACK";

// Unpacking errors
const char* kBadMagicNumberError = "Bad magic number";
const char* kBadHeaderSizeError = "Excessively large key or signature";
const char* kBadVersionNumberError = "Bad version number";
const char* kInvalidExtensionHeaderError = "Invalid extension header";
const char* kInvalidPublicKeyError = "Invalid public key";
const char* kInvalidSignatureError = "Invalid signature";
const char* kSignatureVerificationFailed = "Signature verification failed";
const char* kSignatureVerificationInitFailed =
    "Signature verification initialization failed. This is most likely "
    "caused by a public key in the wrong format (should encode algorithm).";

}

// This class coordinates an extension unpack task which is run in a separate
// process.  Results are sent back to this class, which we route to the
// ExtensionServiceBackend.
    : public UtilityProcessHost::Client {
                 const std::string& public_key,
      public_key_(public_key), expected_id_(expected_id), got_response_(false),
      silent_(silent), from_gallery_(from_gallery) {
  }

  // Starts the unpack task.  We call back to the backend when the task is done,
  // or a problem occurs.
  void Start() {
    AddRef();  // balanced in OnUnpackExtensionReply()

    // TODO(mpcomplete): handle multiple installs
    FilePath temp_dir = backend_->install_directory_.AppendASCII(
        kUnpackExtensionDir);
    if (!file_util::CreateDirectory(temp_dir)) {
      backend_->ReportExtensionInstallError(extension_path_,
          "Failed to create temporary directory.");
      return;
    }

    temp_extension_path_ = temp_dir.Append(extension_path_.BaseName());
    if (!file_util::CopyFile(extension_path_, temp_extension_path_)) {
      backend_->ReportExtensionInstallError(extension_path_,
          "Failed to copy extension file to temporary directory.");
      return;
    }

    if (backend_->resource_dispatcher_host_) {
      ChromeThread::GetMessageLoop(ChromeThread::IO)->PostTask(FROM_HERE,
          NewRunnableMethod(this, &UnpackerClient::StartProcessOnIOThread,
                            backend_->resource_dispatcher_host_,
                            MessageLoop::current()));
    } else {
      // Cheesy... but if we don't have a ResourceDispatcherHost, assume we're
      // in a unit test and run the unpacker directly in-process.
      ExtensionUnpacker unpacker(temp_extension_path_);
      if (unpacker.Run()) {
        OnUnpackExtensionSucceededImpl(*unpacker.parsed_manifest(),
                                       unpacker.decoded_images());
      } else {
        OnUnpackExtensionFailed(unpacker.error_message());
      }
    }
  // UtilityProcessHost::Client
  virtual void OnProcessCrashed() {
    // Don't report crashes if they happen after we got a response.
    if (got_response_)
      return;

    OnUnpackExtensionFailed("Chrome crashed while trying to install.");
  virtual void OnUnpackExtensionSucceeded(const DictionaryValue& manifest) {
     ExtensionUnpacker::DecodedImages images;
     if (!ExtensionUnpacker::ReadImagesFromFile(temp_extension_path_,
                                                &images)) {
       OnUnpackExtensionFailed("Couldn't read image data from disk.");
     } else {
       OnUnpackExtensionSucceededImpl(manifest, images);
     }
  }

  void OnUnpackExtensionSucceededImpl(
      const DictionaryValue& manifest,
      const ExtensionUnpacker::DecodedImages& images) {
    // Add our public key into the parsed manifest. We want it to be saved so
    // that we can later refer to it (eg for generating ids, validating
    // signatures, etc).
    // The const_cast is hacky, but seems like the right thing here, rather than
    // making a full copy just to make this change.
    const_cast<DictionaryValue*>(&manifest)->SetString(
        extension_manifest_keys::kPublicKey, public_key_);

    // The extension was unpacked to the temp dir inside our unpacking dir.
    FilePath extension_dir = temp_extension_path_.DirName().AppendASCII(
        ExtensionsServiceBackend::kTempExtensionName);
    backend_->OnExtensionUnpacked(extension_path_, extension_dir,
                                  expected_id_, manifest, images, silent_,
                                  from_gallery_);
    Cleanup();
  }

  virtual void OnUnpackExtensionFailed(const std::string& error_message) {
    Cleanup();
  }

  // Cleans up our temp directory.
  void Cleanup() {
    if (got_response_)
      return;

    got_response_ = true;
    file_util::Delete(temp_extension_path_.DirName(), true);
    Release();  // balanced in Run()
  // Starts the utility process that unpacks our extension.
  void StartProcessOnIOThread(ResourceDispatcherHost* rdh,
                              MessageLoop* file_loop) {
    UtilityProcessHost* host = new UtilityProcessHost(rdh, this, file_loop);
    host->StartExtensionUnpacker(temp_extension_path_);
  }
  // The public key of the extension we're installing.
  std::string public_key_;

  // True if we got a response from the utility process and have cleaned up
  // already.
  bool got_response_;

    // The utility process might be in the middle of unpacking an extension, so
    // ignore the temp unpacking directory.
    if (extension_id == kUnpackExtensionDir)
      continue;

  std::string actual_public_key;
  if (!ValidateSignature(extension_path, &actual_public_key))
    return;  // Failures reported within ValidateSignature().

  UnpackerClient* client = new UnpackerClient(
      this, extension_path, actual_public_key, expected_id, silent,
      from_gallery);
  client->Start();
}

bool ExtensionsServiceBackend::ValidateSignature(const FilePath& extension_path,
                                                 std::string* key_out) {
  ScopedStdioHandle file(file_util::OpenFile(extension_path, "rb"));
  if (!file.get()) {
    ReportExtensionInstallError(extension_path, "Could not open file.");
    return NULL;
  }

  // Read and verify the header.
  ExtensionsService::ExtensionHeader header;
  size_t len;

  // TODO(erikkay): Yuck.  I'm not a big fan of this kind of code, but it
  // appears that we don't have any endian/alignment aware serialization
  // code in the code base.  So for now, this assumes that we're running
  // on a little endian machine with 4 byte alignment.
  len = fread(&header, 1, sizeof(ExtensionsService::ExtensionHeader),
      file.get());
  if (len < sizeof(ExtensionsService::ExtensionHeader)) {
    ReportExtensionInstallError(extension_path, kInvalidExtensionHeaderError);
    return false;
  }
  if (strncmp(ExtensionsService::kExtensionHeaderMagic, header.magic,
      sizeof(header.magic))) {
    ReportExtensionInstallError(extension_path, kBadMagicNumberError);
    return false;
  }
  if (header.version != ExtensionsService::kCurrentVersion) {
    ReportExtensionInstallError(extension_path, kBadVersionNumberError);
    return false;
  }
  if (header.key_size > ExtensionsService::kMaxPublicKeySize ||
      header.signature_size > ExtensionsService::kMaxSignatureSize) {
    ReportExtensionInstallError(extension_path, kBadHeaderSizeError);
    return false;
  }

  std::vector<uint8> key;
  key.resize(header.key_size);
  len = fread(&key.front(), sizeof(uint8), header.key_size, file.get());
  if (len < header.key_size) {
    ReportExtensionInstallError(extension_path, kInvalidPublicKeyError);
    return false;
  }

  std::vector<uint8> signature;
  signature.resize(header.signature_size);
  len = fread(&signature.front(), sizeof(uint8), header.signature_size,
      file.get());
  if (len < header.signature_size) {
    ReportExtensionInstallError(extension_path, kInvalidSignatureError);
    return false;
  }

  // Note: this structure is an ASN.1 which encodes the algorithm used
  // with its parameters. This is defined in PKCS #1 v2.1 (RFC 3447).
  // It is encoding: { OID sha1WithRSAEncryption      PARAMETERS NULL }
  // TODO(aa): This needs to be factored away someplace common.
  const uint8 signature_algorithm[15] = {
    0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
    0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00
  };

  base::SignatureVerifier verifier;
  if (!verifier.VerifyInit(signature_algorithm,
                           sizeof(signature_algorithm),
                           &signature.front(),
                           signature.size(),
                           &key.front(),
                           key.size())) {
    ReportExtensionInstallError(extension_path,
        kSignatureVerificationInitFailed);
    return false;
  }

  unsigned char buf[1 << 12];
  while ((len = fread(buf, 1, sizeof(buf), file.get())) > 0)
    verifier.VerifyUpdate(buf, len);

  if (!verifier.VerifyFinal()) {
    ReportExtensionInstallError(extension_path, kSignatureVerificationFailed);
    return false;
  }

  net::Base64Encode(std::string(reinterpret_cast<char*>(&key.front()),
      key.size()), key_out);
  return true;
    const FilePath& extension_path,
    const FilePath& temp_extension_dir,
    const std::string& expected_id,
    const DictionaryValue& manifest,
    const std::vector< Tuple2<SkBitmap, FilePath> >& images,
    bool silent, bool from_gallery) {
  Extension extension;
  std::string error;
  if (!extension.InitFromValue(manifest,
                               true,  // require ID
                               &error)) {
    ReportExtensionInstallError(extension_path, "Invalid extension manifest.");
    return;
  }
  LookupExternalExtension(extension.id(), NULL, &location);
  if (extension.IsTheme())
    ReportExtensionInstallError(extension_path,
        "Extensions are not enabled.");
  if (extension.IsTheme())
      ReportExtensionInstallError(extension_path,
  if (!expected_id.empty() && expected_id != extension.id()) {
    error_msg += extension.id();
    ReportExtensionInstallError(extension_path, error_msg);
  FilePath dest_dir = install_directory_.AppendASCII(extension.id());
  std::string version = extension.VersionString();
      CompareToInstalledVersion(extension.id(), version, &current_version);
    ReportExtensionInstallError(extension_path,
    if (NeedsReinstall(extension.id(), current_version)) {
      ReportExtensionOverinstallAttempted(extension.id(), extension_path);
      return;
    }
  }

  // Write our parsed manifest back to disk, to ensure it doesn't contain an
  // exploitable bug that can be used to compromise the browser.
  std::string manifest_json;
  JSONStringValueSerializer serializer(&manifest_json);
  serializer.set_pretty_print(true);
  if (!serializer.Serialize(manifest)) {
    ReportExtensionInstallError(extension_path,
                                "Error serializing manifest.json.");
    return;
  }

  FilePath manifest_path =
      temp_extension_dir.AppendASCII(Extension::kManifestFilename);
  if (!file_util::WriteFile(manifest_path,
                            manifest_json.data(), manifest_json.size())) {
    ReportExtensionInstallError(extension_path, "Error saving manifest.json.");
    return;
  }

  // Delete any images that may be used by the browser.  We're going to write
  // out our own versions of the parsed images, and we want to make sure the
  // originals are gone for good.
  std::set<FilePath> image_paths = extension.GetBrowserImages();
  if (image_paths.size() != images.size()) {
    ReportExtensionInstallError(extension_path,
        "Decoded images don't match what's in the manifest.");
    return;
  }

  for (std::set<FilePath>::iterator it = image_paths.begin();
       it != image_paths.end(); ++it) {
    if (!file_util::Delete(temp_extension_dir.Append(*it), false)) {
      ReportExtensionInstallError(extension_path,
                                  "Error removing old image file.");
      return;
    }
  }

  // Write our parsed images back to disk as well.
  for (size_t i = 0; i < images.size(); ++i) {
    const SkBitmap& image = images[i].a;
    FilePath path = temp_extension_dir.Append(images[i].b);

    std::vector<unsigned char> image_data;
    // TODO(mpcomplete): It's lame that we're encoding all images as PNG, even
    // though they may originally be .jpg, etc.  Figure something out.
    // http://code.google.com/p/chromium/issues/detail?id=12459
    if (!PNGEncoder::EncodeBGRASkBitmap(image, false, &image_data)) {
      ReportExtensionInstallError(extension_path,
                                  "Error re-encoding theme image.");
      return;
    }

    // Note: we're overwriting existing files that the utility process wrote,
    // so we can be sure the directory exists.
    const char* image_data_ptr = reinterpret_cast<const char*>(&image_data[0]);
    if (!file_util::WriteFile(path, image_data_ptr, image_data.size())) {
      ReportExtensionInstallError(extension_path, "Error saving theme image.");
  if (!InstallDirSafely(temp_extension_dir, version_dir))
  Extension* loaded = LoadExtension(version_dir,
                                    location,
                                    true);  // require id
  CHECK(loaded);

      frontend_, &ExtensionsService::OnExtensionInstalled, extension_path,
      loaded, install_type));
  scoped_ptr<ExtensionList> extensions(new ExtensionList);
  extensions->push_back(loaded);
  // Hand off ownership of the loaded extensions to the frontend.
  ReportExtensionsLoaded(extensions.release());
class SkBitmap;
  // TODO(port): Move Crx package definitions to ExtentionCreator. They are
  // currently here because ExtensionCreator is excluded on linux & mac.

  // The size of the magic character sequence at the beginning of each crx
  // file, in bytes. This should be a multiple of 4.
  static const size_t kExtensionHeaderMagicSize = 4;

  // This header is the first data at the beginning of an extension. Its
  // contents are purposely 32-bit aligned so that it can just be slurped into
  // a struct without manual parsing.
  struct ExtensionHeader {
    char magic[kExtensionHeaderMagicSize];
    uint32 version;
    size_t key_size;  // The size of the public key, in bytes.
    size_t signature_size;  // The size of the signature, in bytes.
    // An ASN.1-encoded PublicKeyInfo structure follows.
    // The signature follows.
  };

  // The maximum size the crx parser will tolerate for a public key.
  static const size_t kMaxPublicKeySize = 1 << 16;

  // The maximum size the crx parser will tolerate for a signature.
  static const size_t kMaxSignatureSize = 1 << 16;

  // The magic character sequence at the beginning of each crx file.
  static const char kExtensionHeaderMagic[];

  // The current version of the crx format.
  static const uint32 kCurrentVersion = 2;

  // Validates the signature of the extension in |extension_path|. Returns true
  // and the public key (in |key|) if the signature validates, false otherwise.
  bool ValidateSignature(const FilePath& extension_path, std::string* key_out);

  // Finish installing an extension after it has been unpacked to
  // |temp_extension_dir| by our utility process.  If |expected_id| is not
  // empty, it's verified against the extension's manifest before installation.
  // |manifest| and |images| are parsed information from the extension that
  // we want to write to disk in the browser process. If |silent| is true, there
  // will be no install confirmation dialog.
      const FilePath& extension_path,
      const FilePath& temp_extension_dir,
      const std::string& expected_id,
      const DictionaryValue& manifest,
      const std::vector< Tuple2<SkBitmap, FilePath> >& images,
 
  FilePath path = extension_path.DirName().AppendASCII(kDecodedImagesFilename);
    enableApplicationCache(enable);
    enableDatabase(enable);
    enableDeviceOrientation(enable);
    enableDirectoryUpload(enable);
    enableEncryptedMedia(enable);
    enableFileSystem(enable);
    enableFullscreen(enable);
    enableGamepad(enable);
    enableGeolocation(enable);
    enableIndexedDB(enable);
    enableInputTypeWeek(enable);
    enableJavaScriptI18NAPI(enable);
    enableLocalStorage(enable);
    enableMediaSource(enable);
    enableMediaStream(enable);
    enableNotifications(enable);
    enablePeerConnection(enable);
    enableQuota(enable);
    enableScriptedSpeech(enable);
    enableSessionStorage(enable);
    enableSpeechInput(enable);
    enableTouch(enable);
    enableVideoTrack(enable);
    enableWebAudio(enable);
    enableCSSCompositing(enable);
    enableCSSExclusions(enable);
    enableCSSRegions(enable);
    enableCustomDOMElements(enable);
    enableDialogElement(enable);
    enableExperimentalContentSecurityPolicyFeatures(enable);
    enableFontLoadEvents(enable);
    enableSeamlessIFrames(enable);
    enableStyleScoped(enable);
    // This method should be used by ContentShell
    // to enable features which should be enabled for
    // the layout tests but are not yet "experimental".
    enableCanvasPath(enable);
    enableExperimentalCanvasFeatures(enable);
    enableExperimentalShadowDOM(enable);
    enableInputTypeDateTime(enable);
    enableRequestAutocomplete(enable);
    enableWebMIDI(enable);
    "            ['indexOf', 'slice', 'split', 'substr']);\n"

        if (!SubresourceIntegrity::CheckSubresourceIntegrity(*m_element, sourceCode.source(), sourceCode.resource()->url(), sourceCode.resource()->mimeType()))
            return;
bool Resource::passesAccessControlCheck(ExecutionContext* context, SecurityOrigin* securityOrigin)
bool Resource::passesAccessControlCheck(ExecutionContext* context, SecurityOrigin* securityOrigin, String& errorDescription)
    bool passesAccessControlCheck(ExecutionContext*, SecurityOrigin*);
    bool passesAccessControlCheck(ExecutionContext*, SecurityOrigin*, String& errorDescription);
bool ResourceFetcher::canAccessResource(Resource* resource, SecurityOrigin* sourceOrigin, const KURL& url) const
        if (!forPreload && frame() && frame()->document()) {
    virtual bool canAccessResource(Resource*, SecurityOrigin*, const KURL&) const override;
            if (!m_host->canAccessResource(resource, m_options.securityOrigin.get(), response.url())) {
    virtual bool canAccessResource(Resource*, SecurityOrigin* sourceOrigin, const KURL&) const = 0;
bool SubresourceIntegrity::CheckSubresourceIntegrity(const Element& element, const String& source, const KURL& resourceUrl, const String& resourceType)
    static bool CheckSubresourceIntegrity(const Element&, const WTF::String& content, const KURL& resourceUrl, const WTF::String& mimeType);
    void expectIntegrity(const char* integrity, const char* script, const KURL& url, const String& mimeType = String())
        EXPECT_TRUE(SubresourceIntegrity::CheckSubresourceIntegrity(*scriptElement, script, url, mimeType));
    void expectIntegrityFailure(const char* integrity, const char* script, const KURL& url, const String& mimeType = String())
        EXPECT_FALSE(SubresourceIntegrity::CheckSubresourceIntegrity(*scriptElement, script, url, mimeType));
    expectIntegrity(kSha256Integrity, kBasicScript, secureURL);
    expectIntegrity(kSha384Integrity, kBasicScript, secureURL);
    expectIntegrity(kSha512Integrity, kBasicScript, secureURL);
    expectIntegrityFailure(kSha384IntegrityLabeledAs256, kBasicScript, secureURL);
    expectIntegrityFailure(kUnsupportedHashFunctionIntegrity, kBasicScript, secureURL);
    // The same checks as CheckSubresourceIntegrityInSecureOrigin should pass here.
    expectIntegrity(kSha256Integrity, kBasicScript, secureURL);
    expectIntegrity(kSha384Integrity, kBasicScript, secureURL);
    expectIntegrity(kSha512Integrity, kBasicScript, secureURL);
    expectIntegrityFailure(kSha384IntegrityLabeledAs256, kBasicScript, secureURL);
    expectIntegrityFailure(kUnsupportedHashFunctionIntegrity, kBasicScript, secureURL);
    if (!SubresourceIntegrity::CheckSubresourceIntegrity(*m_owner, cachedStyleSheet->sheetText(), KURL(KURL(), href), cachedStyleSheet->mimeType())) {
    file_permissions_.erase(file.StripTrailingSeparators());
  // Determine whether permission has been granted to request url.
  // Schemes that have not been granted default to being denied.
    if (judgment == scheme_policy_.end())
      return false;  // Unmentioned schemes are disallowed.

    return judgment->second;
    // If the child process has been commanded to request a scheme, then we
    // grant it the capability to request URLs of that scheme.
  // request the URL.
    policy->GrantRequestURL(renderer_id, net::FilePathToFileURL(path));
  GURL file_url = GURL("file:///etc/passwd");
  dropped_data.url = file_url;
                             WebKit::WebDragOperationNone, 0);
  EXPECT_FALSE(ChildProcessSecurityPolicyImpl::GetInstance()->CanRequestURL(
      process()->GetID(), file_url));
    int cumulative_bindings =
        RenderProcess::current()->GetEnabledBindings();
        bool is_initial_navigation = page_id_ == -1;
  // Use the frame's original request's URL rather than the document's URL for
  // this check.  For a popup, the document's URL may become the opener window's
  // URL if the opener has called document.write.  See http://crbug.com/93517.
  GURL old_url(frame->dataSource()->request().url());

      shelf_visible_(false),
      capturing_contents_(false),
      is_being_destroyed_(false) {
  // Data ----------------------------------------------------------------------
  bool is_crashed_;  // true if the tab is considered crashed.
  // The download shelf view (view at the bottom of the page).
  scoped_ptr<DownloadShelf> download_shelf_;

  // Whether the shelf view is visible.
  bool shelf_visible_;

  // See capturing_contents() above.
  bool capturing_contents_;
  // popups. This pointer alsog goes in |child_windows_| for ownership,
class WebContents::GearsCreateShortcutCallbackFunctor {
 public:
  explicit GearsCreateShortcutCallbackFunctor(WebContents* contents)
     : contents_(contents) {}

  void Run(const GearsShortcutData2& shortcut_data, bool success) {
    if (contents_)
      contents_->OnGearsCreateShortcutDone(shortcut_data, success);
    delete this;
  }
  void Cancel() {
    contents_ = NULL;
  }

 private:
  WebContents* contents_;
};

// static
int WebContents::find_request_id_counter_ = -1;

    : TabContents(profile),
      view_(TabContentsView::Create(this)),
      ALLOW_THIS_IN_INITIALIZER_LIST(render_manager_(this, this)),
      printing_(*this),
      notify_disconnection_(false),
      received_page_title_(false),
      is_starred_(false),
#if defined(OS_WIN)
      message_box_active_(CreateEvent(NULL, TRUE, FALSE, NULL)),
#endif
      ALLOW_THIS_IN_INITIALIZER_LIST(fav_icon_helper_(this)),
      suppress_javascript_messages_(false),
      load_state_(net::LOAD_STATE_IDLE),
      find_ui_active_(false),
      find_op_aborted_(false),
      current_find_request_id_(find_request_id_counter_++),
      find_prepopulate_text_(NULL) {
void WebContents::OnGearsCreateShortcutDone(
    const GearsShortcutData2& shortcut_data, bool success) {
  NavigationEntry* current_entry = controller_.GetLastCommittedEntry();
  bool same_page =
      current_entry && pending_install_.page_id == current_entry->page_id();

  if (success && same_page) {
    // Only switch to app mode if the user chose to create a shortcut and
    // we're still on the same page that it corresponded to.
    if (delegate())
      delegate()->ConvertContentsToApplication(this);
  }

  // Reset the page id to indicate no requests are pending.
  pending_install_.page_id = 0;
  pending_install_.callback_functor = NULL;
}

#include "base/basictypes.h"
#include "chrome/browser/cancelable_request.h"
#include "chrome/browser/download/save_package.h"
#include "chrome/browser/fav_icon_helper.h"
#include "chrome/browser/find_notification_details.h"
#include "chrome/browser/renderer_host/render_view_host_delegate.h"
#include "chrome/browser/shell_dialogs.h"
#include "chrome/browser/tab_contents/navigation_controller.h"
#include "chrome/browser/tab_contents/render_view_host_manager.h"
#include "chrome/common/gears_api.h"
#include "net/base/load_states.h"
#include "webkit/glue/password_form.h"
#include "webkit/glue/webpreferences.h"

#if defined(OS_MACOSX) || defined(OS_LINUX)
// Remove when we've finished porting the supporting classes.
#include "chrome/common/temp_scaffolding_stubs.h"
#elif defined(OS_WIN)
#include "chrome/browser/printing/print_view_manager.h"
#endif
class AutofillManager;
class PasswordManager;
class PluginInstaller;
class TabContentsView;
  // When CreateShortcut is invoked RenderViewHost::GetApplicationInfo is
  // invoked. CreateShortcut caches the state of the page needed to create the
  // shortcut in PendingInstall. When OnDidGetApplicationInfo is invoked, it
  // uses the information from PendingInstall and the WebApplicationInfo
  // to create the shortcut.
  class GearsCreateShortcutCallbackFunctor;
  struct PendingInstall {
    int32 page_id;
    SkBitmap icon;
    std::wstring title;
    GURL url;
    // This object receives the GearsCreateShortcutCallback and routes the
    // message back to the WebContents, if we haven't been deleted.
    GearsCreateShortcutCallbackFunctor* callback_functor;
  };

  // Called when the user dismisses the shortcut creation dialog.  'success' is
  // true if the shortcut was created.
  void OnGearsCreateShortcutDone(const GearsShortcutData2& shortcut_data,
                                 bool success);

  // Data ----------------------------------------------------------------------

  // The corresponding view.
  scoped_ptr<TabContentsView> view_;

  // Manages creation and swapping of render views.
  RenderViewHostManager render_manager_;

  // Handles print preview and print job for this contents.
  printing::PrintViewManager printing_;

  // Indicates whether we should notify about disconnection of this
  // WebContents. This is used to ensure disconnection notifications only
  // happen if a connection notification has happened and that they happen only
  // once.
  bool notify_disconnection_;

  // Maps from handle to page_id.
  typedef std::map<HistoryService::Handle, int32> HistoryRequestMap;
  HistoryRequestMap history_requests_;

  // System time at which the current load was started.
  base::TimeTicks current_load_start_;

  // Whether we have a (non-empty) title for the current page.
  // Used to prevent subsequent title updates from affecting history. This
  // prevents some weirdness because some AJAXy apps use titles for status
  // messages.
  bool received_page_title_;

  // SavePackage, lazily created.
  scoped_refptr<SavePackage> save_package_;

  // Tracks our pending CancelableRequests. This maps pending requests to
  // page IDs so that we know whether a given callback still applies. The
  // page ID -1 means no page ID was set.
  CancelableRequestConsumerT<int32, -1> cancelable_consumer_;

  // Whether the current URL is starred
  bool is_starred_;

#if defined(OS_WIN)
  // Handle to an event that's set when the page is showing a message box (or
  // equivalent constrained window).  Plugin processes check this to know if
  // they should pump messages then.
  ScopedHandle message_box_active_;
#endif

  // AutofillManager, lazily created.
  scoped_ptr<AutofillManager> autofill_manager_;

  // PasswordManager, lazily created.
  scoped_ptr<PasswordManager> password_manager_;

  // PluginInstaller, lazily created.
  scoped_ptr<PluginInstaller> plugin_installer_;

  // Handles downloading favicons.
  FavIconHelper fav_icon_helper_;

  // Dialog box used for choosing files to upload from file form fields.
  scoped_refptr<SelectFileDialog> select_file_dialog_;

  // The time that the last javascript message was dismissed.
  base::TimeTicks last_javascript_message_dismissal_;

  // True if the user has decided to block future javascript messages. This is
  // reset on navigations to false on navigations.
  bool suppress_javascript_messages_;

  // When a navigation occurs, we record its contents MIME type. It can be
  // used to check whether we can do something for some special contents.
  std::string contents_mime_type_;

  // Character encoding. TODO(jungshik) : convert to std::string
  std::wstring encoding_;

  PendingInstall pending_install_;

  // The last time that the download shelf was made visible.
  base::TimeTicks last_download_shelf_show_;

  // The current load state and the URL associated with it.
  net::LoadState load_state_;
  std::wstring load_state_host_;

  // True if the Find UI is active for this Tab.
  bool find_ui_active_;

  // True if a Find operation was aborted. This can happen if the Find box is
  // closed or if the search term inside the Find box is erased while a search
  // is in progress. This can also be set if a page has been reloaded, and will
  // on FindNext result in a full Find operation so that the highlighting for
  // inactive matches can be repainted.
  bool find_op_aborted_;

  // Each time a search request comes in we assign it an id before passing it
  // over the IPC so that when the results come in we can evaluate whether we
  // still care about the results of the search (in some cases we don't because
  // the user has issued a new search).
  static int find_request_id_counter_;

  // This variable keeps track of what the most recent request id is.
  int current_find_request_id_;

  // The last string we searched for. This is used to figure out if this is a
  // Find or a FindNext operation (FindNext should not increase the request id).
  string16 find_text_;

  // Keeps track of the last search string that was used to search in any tab.
  string16* find_prepopulate_text_;

  // The last find result. This object contains details about the number of
  // matches, the find selection rectangle, etc. The UI can access this
  // information to build its presentation.
  FindNotificationDetails find_result_;

    v8::Handle<v8::Object> holder = V8DOMWrapper::lookupDOMWrapper(V8ClassIndex::DOMWINDOW, info.This());
    if (holder.IsEmpty())
        return;

    DOMWindow* imp = V8DOMWrapper::convertToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, holder);
    v8::Handle<v8::Object> holder = V8DOMWrapper::lookupDOMWrapper(V8ClassIndex::DOMWINDOW, info.This());
    if (holder.IsEmpty())
        return notHandledByInterceptor();
    DOMWindow* window = V8DOMWrapper::convertToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, holder);
    v8::Handle<v8::Object> holder = V8DOMWrapper::lookupDOMWrapper(V8ClassIndex::DOMWINDOW, info.This());
    if (holder.IsEmpty())
        return notHandledByInterceptor();

    DOMWindow* window = V8DOMWrapper::convertToNativeObject<DOMWindow>(V8ClassIndex::DOMWINDOW, holder);
    v8::Handle<v8::Value> result = holder->GetRealNamedPropertyInPrototypeChain(name);
DevToolsManager::DevToolsManager() : web_contents_listeners_(NULL) {
  DCHECK(!web_contents_listeners_.get()) <<
    Source<WebContents> src(source);
    const WebContents& web_contents) {
  const NavigationController& navigation_controller = web_contents.controller();
    WebContents& web_contents,
  DCHECK(!GetDevToolsClientHostFor(web_contents));
  NavigationController* navigation_controller = &web_contents.controller();
  SendAttachToAgent(web_contents, web_contents.render_view_host());
  WebContents* wc = tc->AsWebContents();
  if (!wc) {
    return;
  }
  RenderViewHost* target_host = wc->render_view_host();
  WebContents* wc = from.delegate()->GetAsWebContents();
void DevToolsManager::OpenDevToolsWindow(WebContents* wc) {
void DevToolsManager::InspectElement(WebContents* wc, int x, int y) {
  WebContents* web_contents = tab_contents->AsWebContents();
  if (!web_contents) {
    return;
  }
  SendDetachToAgent(*web_contents);
  if (!web_contents_listeners_.get()) {
    web_contents_listeners_.reset(new NotificationRegistrar);
    web_contents_listeners_->Add(
  DCHECK(web_contents_listeners_.get());
    web_contents_listeners_.reset();
void DevToolsManager::SendAttachToAgent(const WebContents& wc,
void DevToolsManager::SendDetachToAgent(const WebContents& wc) {
class WebContents;
  // Returns DevToolsClientHost registered for |web_contents| or NULL if
  // there is no alive DevToolsClientHost registered for |web_contents|.
  DevToolsClientHost* GetDevToolsClientHostFor(const WebContents& web_contents);
  // Registers new DevToolsClientHost for |web_contents|. There must be no
  // other DevToolsClientHosts registered for the WebContents at the moment.
  void RegisterDevToolsClientHostFor(WebContents& web_contents,
  void OpenDevToolsWindow(WebContents* wc);
  void InspectElement(WebContents* web_contents, int x, int y);
  // there is a DevToolsClientHost registered for the |web_contents|.
      const WebContents& web_contents,
  void SendDetachToAgent(const WebContents& web_contents);
  scoped_ptr<NotificationRegistrar> web_contents_listeners_;
  // Our benavior is just to report that the entry was committed.
  string16 default_title = WideToUTF16Hack(GetDefaultTitle());
  controller_.pending_entry()->set_title(default_title);
  controller_.CommitPendingEntry();
  virtual const string16& GetTitle() const = 0;
  virtual SiteInstance* GetSiteInstance() const = 0;
  virtual bool ShouldDisplayURL() = 0;
  virtual bool ShouldDisplayFavIcon() = 0;
  virtual std::wstring GetStatusText() const = 0;
  virtual void DidBecomeSelected() = 0;
  virtual void WasHidden() = 0;
  virtual bool NavigateToPendingEntry(bool reload) = 0;
  virtual void Stop() = 0;
  virtual void Cut() = 0;
  virtual void Copy() = 0;
  virtual void Paste() = 0;
  virtual void DisassociateFromPopupCount() = 0;
  virtual TabContents* Clone() = 0;
  virtual void PopupNotificationVisibilityChanged(bool visible) = 0;
  virtual gfx::NativeView GetContentNativeView() = 0;
  virtual gfx::NativeView GetNativeView() const = 0;
  virtual void GetContainerBounds(gfx::Rect *out) const = 0;
  virtual void Focus() = 0;
  virtual void SetInitialFocus(bool reverse) = 0;
  virtual bool IsBookmarkBarAlwaysVisible() = 0;
  virtual void SetDownloadShelfVisible(bool visible) = 0;
  virtual void SetIsLoading(bool is_loading,
                            LoadNotificationDetails* details) = 0;
const string16& WebContents::GetTitle() const {
  DOMUI* our_dom_ui = render_manager_.pending_dom_ui() ?
      render_manager_.pending_dom_ui() : render_manager_.dom_ui();
  if (our_dom_ui) {
    // Don't override the title in view source mode.
    NavigationEntry* entry = controller_.GetActiveEntry();
    if (!(entry && entry->IsViewSourceMode())) {
      // Give the DOM UI the chance to override our title.
      const string16& title = our_dom_ui->overridden_title();
      if (!title.empty())
        return title;
    }
  }

  // We use the title for the last committed entry rather than a pending
  // navigation entry. For example, when the user types in a URL, we want to
  // keep the old page's title until the new load has committed and we get a new
  // title.
  // The exception is with transient pages, for which we really want to use
  // their title, as they are not committed.
  NavigationEntry* entry = controller_.GetTransientEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);

  entry = controller_.GetLastCommittedEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);
  else if (controller_.LoadingURLLazily())
    return controller_.GetLazyTitle();
  return EmptyString16();
}

SiteInstance* WebContents::GetSiteInstance() const {
  return render_manager_.current_host()->site_instance();
}

bool WebContents::ShouldDisplayURL() {
  // Don't hide the url in view source mode.
  NavigationEntry* entry = controller_.GetActiveEntry();
  if (entry && entry->IsViewSourceMode())
    return true;
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->should_hide_url();
  return true;
}

bool WebContents::ShouldDisplayFavIcon() {
  // Always display a throbber during pending loads.
  if (controller_.GetLastCommittedEntry() && controller_.pending_entry())
    return true;

  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->hide_favicon();
  return true;
}

std::wstring WebContents::GetStatusText() const {
  if (!is_loading() || load_state_ == net::LOAD_STATE_IDLE)
    return std::wstring();

  switch (load_state_) {
    case net::LOAD_STATE_WAITING_FOR_CACHE:
      return l10n_util::GetString(IDS_LOAD_STATE_WAITING_FOR_CACHE);
    case net::LOAD_STATE_RESOLVING_PROXY_FOR_URL:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_PROXY_FOR_URL);
    case net::LOAD_STATE_RESOLVING_HOST:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_HOST);
    case net::LOAD_STATE_CONNECTING:
      return l10n_util::GetString(IDS_LOAD_STATE_CONNECTING);
    case net::LOAD_STATE_SENDING_REQUEST:
      return l10n_util::GetString(IDS_LOAD_STATE_SENDING_REQUEST);
    case net::LOAD_STATE_WAITING_FOR_RESPONSE:
      return l10n_util::GetStringF(IDS_LOAD_STATE_WAITING_FOR_RESPONSE,
                                   load_state_host_);
    // Ignore net::LOAD_STATE_READING_RESPONSE and net::LOAD_STATE_IDLE
    case net::LOAD_STATE_IDLE:
    case net::LOAD_STATE_READING_RESPONSE:
      break;
  }

  return std::wstring();
}

bool WebContents::NavigateToPendingEntry(bool reload) {
  const NavigationEntry& entry = *controller_.pending_entry();

  RenderViewHost* dest_render_view_host = render_manager_.Navigate(entry);
  if (!dest_render_view_host)
    return false;  // Unable to create the desired render view host.

  // Tell DevTools agent that it is attached prior to the navigation.
  DevToolsManager* dev_tools_manager = g_browser_process->devtools_manager();
  if (dev_tools_manager)  // NULL in unit tests.
    dev_tools_manager->SendAttachToAgent(*this, dest_render_view_host);

  // Used for page load time metrics.
  current_load_start_ = TimeTicks::Now();

  // Navigate in the desired RenderViewHost.
  dest_render_view_host->NavigateToEntry(entry, reload);

  if (entry.page_id() == -1) {
    // HACK!!  This code suppresses javascript: URLs from being added to
    // session history, which is what we want to do for javascript: URLs that
    // do not generate content.  What we really need is a message from the
    // renderer telling us that a new page was not created.  The same message
    // could be used for mailto: URLs and the like.
    if (entry.url().SchemeIs(chrome::kJavaScriptScheme))
      return false;
  }

  // Clear any provisional password saves - this stops password infobars
  // showing up on pages the user navigates to while the right page is
  // loading.
  GetPasswordManager()->ClearProvisionalSave();

  if (reload && !profile()->IsOffTheRecord()) {
    HistoryService* history =
        profile()->GetHistoryService(Profile::IMPLICIT_ACCESS);
    if (history)
      history->SetFavIconOutOfDateForPage(entry.url());
  }

  return true;
}

void WebContents::Stop() {
  render_manager_.Stop();
  printing_.Stop();
}

void WebContents::Cut() {
  render_view_host()->Cut();
}

void WebContents::Copy() {
  render_view_host()->Copy();
}

void WebContents::Paste() {
  render_view_host()->Paste();
}

void WebContents::DisassociateFromPopupCount() {
  render_view_host()->DisassociateFromPopupCount();
}

TabContents* WebContents::Clone() {
  // We create a new SiteInstance so that the new tab won't share processes
  // with the old one. This can be changed in the future if we need it to share
  // processes for some reason.
  TabContents* tc = new WebContents(profile(),
                                    SiteInstance::CreateSiteInstance(profile()),
                                    MSG_ROUTING_NONE, NULL);
  tc->controller().CopyStateFrom(controller_);
  return tc;
}

void WebContents::DidBecomeSelected() {
  controller_.SetActive(true);

  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // If pid() is -1, that means the RenderProcessHost still hasn't been
  // initialized.  It'll register with CacheManagerHost when it is.
  if (process()->pid() != -1)
    WebCacheManager::GetInstance()->ObserveActivity(process()->pid());
}

void WebContents::WasHidden() {
  if (!capturing_contents()) {
    // |render_view_host()| can be NULL if the user middle clicks a link to open
    // a tab in then background, then closes the tab before selecting it.  This
    // is because closing the tab calls WebContents::Destroy(), which removes
    // the |render_view_host()|; then when we actually destroy the window,
    // OnWindowPosChanged() notices and calls HideContents() (which calls us).
    if (render_widget_host_view())
      render_widget_host_view()->WasHidden();

    // Loop through children and send WasHidden to them, too.
    int count = static_cast<int>(child_windows_.size());
    for (int i = count - 1; i >= 0; --i) {
      ConstrainedWindow* window = child_windows_.at(i);
      window->WasHidden();
    }
  }

  NotificationService::current()->Notify(
      NotificationType::TAB_CONTENTS_HIDDEN,
      Source<TabContents>(this),
      NotificationService::NoDetails());
}

void WebContents::ShowContents() {
  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // Loop through children and send DidBecomeSelected to them, too.
  int count = static_cast<int>(child_windows_.size());
  for (int i = count - 1; i >= 0; --i) {
    ConstrainedWindow* window = child_windows_.at(i);
    window->DidBecomeSelected();
  }
}

void WebContents::HideContents() {
  // TODO(pkasting): http://b/1239839  Right now we purposefully don't call
  // our superclass HideContents(), because some callers want to be very picky
  // about the order in which these get called.  In addition to making the code
  // here practically impossible to understand, this also means we end up
  // calling TabContents::WasHidden() twice if callers call both versions of
  // HideContents() on a WebContents.
  WasHidden();
}

bool WebContents::IsBookmarkBarAlwaysVisible() {
  // See GetDOMUIForCurrentState() comment for more info. This case is very
  // similar, but for non-first loads, we want to use the committed entry. This
  // is so the bookmarks bar disappears at the same time the page does.
  if (controller_.GetLastCommittedEntry()) {
    // Not the first load, always use the committed DOM UI.
    if (render_manager_.dom_ui())
      return render_manager_.dom_ui()->force_bookmark_bar_visible();
    return false;  // Default.
  }

  // When it's the first load, we know either the pending one or the committed
  // one will have the DOM UI in it (see GetDOMUIForCurrentState), and only one
  // of them will be valid, so we can just check both.
  if (render_manager_.pending_dom_ui())
    return render_manager_.pending_dom_ui()->force_bookmark_bar_visible();
  if (render_manager_.dom_ui())
    return render_manager_.dom_ui()->force_bookmark_bar_visible();
  return false;  // Default.
}

void WebContents::SetDownloadShelfVisible(bool visible) {
  if (shelf_visible_ != visible) {
    if (visible) {
      // Invoke GetDownloadShelf to force the shelf to be created.
      GetDownloadShelf();
    }
    shelf_visible_ = visible;

    if (delegate_)
      delegate_->ContentsStateChanged(this);
  }

  // SetShelfVisible can force-close the shelf, so make sure we lay out
  // everything correctly, as if the animation had finished. This doesn't
  // matter for showing the shelf, as the show animation will do it.
  ToolbarSizeChanged(false);

  if (visible) {
    // Always set this value as it reflects the last time the download shelf
    // was made visible (even if it was already visible).
    last_download_shelf_show_ = TimeTicks::Now();
  }
}

void WebContents::PopupNotificationVisibilityChanged(bool visible) {
  render_view_host()->PopupNotificationVisibilityChanged(visible);
}

bool WebContents::FocusLocationBarByDefault() {
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return dom_ui->focus_location_bar_by_default();
  return false;
}

gfx::NativeView WebContents::GetNativeView() const {
  return view_->GetNativeView();
}

gfx::NativeView WebContents::GetContentNativeView() {
  return view_->GetContentNativeView();
}

void WebContents::GetContainerBounds(gfx::Rect *out) const {
  view_->GetContainerBounds(out);
}

void WebContents::Focus() {
  view_->Focus();
}

void WebContents::SetInitialFocus(bool reverse) {
  render_view_host()->SetInitialFocus(reverse);
}

// Notifies the RenderWidgetHost instance about the fact that the page is
// loading, or done loading and calls the base implementation.
void WebContents::SetIsLoading(bool is_loading,
                               LoadNotificationDetails* details) {
  if (is_loading == is_loading_)
    return;

  if (!is_loading) {
    load_state_ = net::LOAD_STATE_IDLE;
    load_state_host_.clear();
  }

  render_manager_.SetIsLoading(is_loading);

  is_loading_ = is_loading;
  waiting_for_response_ = is_loading;

  if (delegate_)
    delegate_->LoadingStateChanged(this);

  NotificationType type = is_loading ? NotificationType::LOAD_START :
      NotificationType::LOAD_STOP;
  NotificationDetails det = NotificationService::NoDetails();;
  if (details)
      det = Details<LoadNotificationDetails>(details);
  NotificationService::current()->Notify(type,
      Source<NavigationController>(&controller_),
      det);
}


DOMUI* WebContents::GetDOMUIForCurrentState() {
  // When there is a pending navigation entry, we want to use the pending DOMUI
  // that goes along with it to control the basic flags. For example, we want to
  // show the pending URL in the URL bar, so we want the display_url flag to
  // be from the pending entry.
  //
  // The confusion comes because there are multiple possibilities for the
  // initial load in a tab as a side effect of the way the RenderViewHostManager
  // works.
  //
  //  - For the very first tab the load looks "normal". The new tab DOM UI is
  //    the pending one, and we want it to apply here.
  //
  //  - For subsequent new tabs, they'll get a new SiteInstance which will then
  //    get switched to the one previously associated with the new tab pages.
  //    This switching will cause the manager to commit the RVH/DOMUI. So we'll
  //    have a committed DOM UI in this case.
  //
  // This condition handles all of these cases:
  //
  //  - First load in first tab: no committed nav entry + pending nav entry +
  //    pending dom ui:
  //    -> Use pending DOM UI if any.
  //
  //  - First load in second tab: no committed nav entry + pending nav entry +
  //    no pending DOM UI:
  //    -> Use the committed DOM UI if any.
  //
  //  - Second navigation in any tab: committed nav entry + pending nav entry:
  //    -> Use pending DOM UI if any.
  //
  //  - Normal state with no load: committed nav entry + no pending nav entry:
  //    -> Use committed DOM UI.
  if (controller_.pending_entry() &&
      (controller_.GetLastCommittedEntry() ||
       render_manager_.pending_dom_ui()))
    return render_manager_.pending_dom_ui();
  return render_manager_.dom_ui();
}
  // Returns true if the location bar should be focused by default rather than
  // the page contents. The view will call this function when the tab is
  // to see what it should do.
  bool FocusLocationBarByDefault();

  const string16& GetTitle() const;
  virtual SiteInstance* GetSiteInstance() const;
  virtual bool ShouldDisplayURL();
  virtual bool ShouldDisplayFavIcon();
  virtual std::wstring GetStatusText() const;
  virtual bool NavigateToPendingEntry(bool reload);
  virtual void Stop();
  virtual void Cut();
  virtual void Copy();
  virtual void Paste();
  virtual void DisassociateFromPopupCount();
  virtual TabContents* Clone();
  virtual void DidBecomeSelected();
  virtual void WasHidden();
  virtual void ShowContents();
  virtual void HideContents();
  virtual bool IsBookmarkBarAlwaysVisible();
  virtual void SetDownloadShelfVisible(bool visible);
  virtual void PopupNotificationVisibilityChanged(bool visible);
  virtual void Focus();

  // Retarded pass-throughs to the view.
  // TODO(brettw) fix this, tab contents shouldn't have these methods, probably
  // it should be killed altogether.
  virtual gfx::NativeView GetNativeView() const;
  virtual gfx::NativeView GetContentNativeView();
  virtual void GetContainerBounds(gfx::Rect *out) const;
  RenderWidgetHostView* render_widget_host_view() const {
    return render_manager_.current_view();
  }

  // TabContents (private overrides) -------------------------------------------

  virtual void SetInitialFocus(bool reverse);
  virtual void SetIsLoading(bool is_loading, LoadNotificationDetails* details);
  // Returns the DOMUI for the current state of the tab. This will either be
  // the pending DOMUI, the committed DOMUI, or NULL.
  DOMUI* GetDOMUIForCurrentState();

void BrowserProcessImpl::SetApplicationLocale(const std::string& locale) {
  locale_ = locale;
  extension_l10n_util::SetProcessLocale(locale);
}

void BrowserProcessImpl::CheckForInspectorFiles() {
  file_thread()->message_loop()->PostTask
      (FROM_HERE,
       NewRunnableMethod(this, &BrowserProcessImpl::DoInspectorFilesCheck));
}

#if (defined(OS_WIN) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
void BrowserProcessImpl::StartAutoupdateTimer() {
  autoupdate_timer_.Start(
      base::TimeDelta::FromHours(kUpdateCheckIntervalHours),
      this,
      &BrowserProcessImpl::OnAutoupdateTimer);
}
#endif

#include "chrome/browser/automation/automation_provider_list.h"
  virtual ResourceDispatcherHost* resource_dispatcher_host() {
    DCHECK(CalledOnValidThread());
    if (!created_resource_dispatcher_host_)
      CreateResourceDispatcherHost();
    return resource_dispatcher_host_.get();
  }

  virtual MetricsService* metrics_service() {
    DCHECK(CalledOnValidThread());
    if (!created_metrics_service_)
      CreateMetricsService();
    return metrics_service_.get();
  }

  virtual IOThread* io_thread() {
    DCHECK(CalledOnValidThread());
    if (!created_io_thread_)
      CreateIOThread();
    return io_thread_.get();
  }

  virtual base::Thread* file_thread() {
    DCHECK(CalledOnValidThread());
    if (!created_file_thread_)
      CreateFileThread();
    return file_thread_.get();
  }

  virtual base::Thread* db_thread() {
    DCHECK(CalledOnValidThread());
    if (!created_db_thread_)
      CreateDBThread();
    return db_thread_.get();
  }

  virtual base::Thread* process_launcher_thread() {
    DCHECK(CalledOnValidThread());
    if (!created_process_launcher_thread_)
      CreateProcessLauncherThread();
    return process_launcher_thread_.get();
  }

  virtual base::Thread* cache_thread() {
    DCHECK(CalledOnValidThread());
    if (!created_cache_thread_)
      CreateCacheThread();
    return cache_thread_.get();
  }

  virtual base::Thread* background_x11_thread() {
    DCHECK(CalledOnValidThread());
    // The BACKGROUND_X11 thread is created when the IO thread is created.
    if (!created_io_thread_)
      CreateIOThread();
    return background_x11_thread_.get();
  }

  virtual ProfileManager* profile_manager() {
    DCHECK(CalledOnValidThread());
    if (!created_profile_manager_)
      CreateProfileManager();
    return profile_manager_.get();
  }

  virtual PrefService* local_state() {
    DCHECK(CalledOnValidThread());
    if (!created_local_state_)
      CreateLocalState();
    return local_state_.get();
  }

  virtual DevToolsManager* devtools_manager() {
    DCHECK(CalledOnValidThread());
    if (!created_devtools_manager_)
      CreateDevToolsManager();
    return devtools_manager_.get();
  }

  virtual Clipboard* clipboard() {
    DCHECK(CalledOnValidThread());
    return clipboard_.get();
  }

  virtual NotificationUIManager* notification_ui_manager() {
    DCHECK(CalledOnValidThread());
    if (!created_notification_ui_manager_)
      CreateNotificationUIManager();
    return notification_ui_manager_.get();
  }

  virtual StatusTrayManager* status_tray_manager() {
    DCHECK(CalledOnValidThread());
    if (!status_tray_manager_.get())
      CreateStatusTrayManager();
    return status_tray_manager_.get();
  }

  virtual IconManager* icon_manager() {
    DCHECK(CalledOnValidThread());
    if (!created_icon_manager_)
      CreateIconManager();
    return icon_manager_.get();
  }

  virtual ThumbnailGenerator* GetThumbnailGenerator() {
    return &thumbnail_generator_;
  }

  virtual AutomationProviderList* InitAutomationProviderList() {
    DCHECK(CalledOnValidThread());
    if (automation_provider_list_.get() == NULL) {
      automation_provider_list_.reset(AutomationProviderList::GetInstance());
    }
    return automation_provider_list_.get();
  }

  virtual void InitDebuggerWrapper(int port, bool useHttp) {
    DCHECK(CalledOnValidThread());
    if (!created_debugger_wrapper_)
      CreateDebuggerWrapper(port, useHttp);
  }



  virtual bool IsShuttingDown() {
    DCHECK(CalledOnValidThread());
    return did_start_ && 0 == module_ref_count_;
  }


  virtual GoogleURLTracker* google_url_tracker() {
    DCHECK(CalledOnValidThread());
    if (!google_url_tracker_.get())
      CreateGoogleURLTracker();
    return google_url_tracker_.get();
  }

  virtual IntranetRedirectDetector* intranet_redirect_detector() {
    DCHECK(CalledOnValidThread());
    if (!intranet_redirect_detector_.get())
      CreateIntranetRedirectDetector();
    return intranet_redirect_detector_.get();
  }

  virtual const std::string& GetApplicationLocale() {
    DCHECK(!locale_.empty());
    return locale_;
  }

  virtual base::WaitableEvent* shutdown_event() {
    return shutdown_event_.get();
  }

  virtual TabCloseableStateWatcher* tab_closeable_state_watcher() {
    DCHECK(CalledOnValidThread());
    if (!tab_closeable_state_watcher_.get())
      CreateTabCloseableStateWatcher();
    return tab_closeable_state_watcher_.get();
  }

  virtual bool have_inspector_files() const {
    return have_inspector_files_;
  }
#include "chrome/browser/browser_process.h"
#include <string>
#include "base/logging.h"
#include "googleurl/src/gurl.h"
  bool IsVisited(const GURL& url) const {
    return IsVisited(url.spec().data(), url.spec().size());
  }
#include "chrome/common/dom_storage_common.h"
#include "chrome/common/extensions/extension_extent.h"
#include "chrome/renderer/gpu_channel_host.h"
#include "chrome/renderer/renderer_histogram_snapshots.h"
  // Contains extension-related data that the renderer needs to know about.
  // TODO(mpcomplete): this doesn't feel like it belongs here. Find a better
  // place.
  struct ExtensionInfo {
    std::string extension_id;
    ExtensionExtent web_extent;
    ExtensionExtent browse_extent;
  };

            if (RenderView* renderView = this->renderView())
                renderView->updateWidgetPositions();
        if (RenderView* renderView = this->renderView()) {
            renderView->updateWidgetPositions();
        }
    RenderView* renderView = this->renderView();
    if (renderView)
        renderView->updateWidgetPositions();
    InspectorInstrumentation::willScrollLayer(m_box);
    RenderView* view = m_box->view();
    // We should have a RenderView if we're trying to scroll.
    ASSERT(view);
    bool inLayout = view ? view->frameView()->isInLayout() : false;
    if (!inLayout) {
        if (view) {
            // Update regions, scrolling may change the clip of a particular region.
            view->frameView()->updateAnnotatedRegions();
            view->updateWidgetPositions();
        }

    if (frame) {
        // The caret rect needs to be invalidated after scrolling
        frame->selection().setCaretRectNeedsUpdate();

        FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->repainter().repaintRect());
        if (repaintContainer)
            quadForFakeMouseMoveEvent = repaintContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
        frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
    }
    if (view && requiresRepaint)
#include "core/rendering/RenderWidget.h"
size_t RenderView::getRetainedWidgets(Vector<RenderWidget*>& renderWidgets)
{
    size_t size = m_widgets.size();

    renderWidgets.reserveCapacity(size);

    RenderWidgetSet::const_iterator end = m_widgets.end();
    for (RenderWidgetSet::const_iterator it = m_widgets.begin(); it != end; ++it) {
        renderWidgets.uncheckedAppend(*it);
        (*it)->ref();
    }

    return size;
}

void RenderView::releaseWidgets(Vector<RenderWidget*>& renderWidgets)
{
    size_t size = renderWidgets.size();

    for (size_t i = 0; i < size; ++i)
        renderWidgets[i]->deref();
}

void RenderView::updateWidgetPositions()
{
    // updateWidgetPosition() can possibly cause layout to be re-entered (via plug-ins running
    // scripts in response to NPP_SetWindow, for example), so we need to keep the Widgets
    // alive during enumeration.

    Vector<RenderWidget*> renderWidgets;
    size_t size = getRetainedWidgets(renderWidgets);

    for (size_t i = 0; i < size; ++i)
        renderWidgets[i]->updateWidgetPosition();

    for (size_t i = 0; i < size; ++i)
        renderWidgets[i]->widgetPositionsUpdated();

    releaseWidgets(renderWidgets);
}

void RenderView::addWidget(RenderWidget* o)
{
    m_widgets.add(o);
}

void RenderView::removeWidget(RenderWidget* o)
{
    m_widgets.remove(o);
}

class RenderWidget;
    void updateWidgetPositions();
    void addWidget(RenderWidget*);
    void removeWidget(RenderWidget*);

    size_t getRetainedWidgets(Vector<RenderWidget*>&);
    void releaseWidgets(Vector<RenderWidget*>&);

    typedef HashSet<RenderWidget*> RenderWidgetSet;
    RenderWidgetSet m_widgets;

#include "platform/graphics/GraphicsContext.h"
    , m_frameView(element->document().view())
    view()->addWidget(this);
    if (RenderView* v = view())
        v->removeWidget(this);
        moveWidgetToParentSoon(m_widget.get(), m_frameView);
    if (!m_frameView || paintInfo.phase != PaintPhaseForeground)
    FrameView* m_frameView;
    FrameView* view = mainFrameImpl()->frameView();
    FrameView* view = frame->view();
    if (!m_terminationRequested)
    file_permissions_.erase(file.StripTrailingSeparators());
  // Determine whether permission has been granted to request url.
  // Schemes that have not been granted default to being denied.
    if (judgment == scheme_policy_.end())
      return false;  // Unmentioned schemes are disallowed.

    return judgment->second;
    // If the child process has been commanded to request a scheme, then we
    // grant it the capability to request URLs of that scheme.
  // request the URL.
    policy->GrantRequestURL(renderer_id, net::FilePathToFileURL(path));
  GURL file_url = GURL("file:///etc/passwd");
  dropped_data.url = file_url;
                             WebKit::WebDragOperationNone, 0);
  EXPECT_FALSE(ChildProcessSecurityPolicyImpl::GetInstance()->CanRequestURL(
      process()->GetID(), file_url));
    int cumulative_bindings =
        RenderProcess::current()->GetEnabledBindings();
        bool is_initial_navigation = page_id_ == -1;
  // Use the frame's original request's URL rather than the document's URL for
  // this check.  For a popup, the document's URL may become the opener window's
  // URL if the opener has called document.write.  See http://crbug.com/93517.
  GURL old_url(frame->dataSource()->request().url());

void BrowserProcessImpl::SetApplicationLocale(const std::string& locale) {
  locale_ = locale;
  extension_l10n_util::SetProcessLocale(locale);
}

void BrowserProcessImpl::CheckForInspectorFiles() {
  file_thread()->message_loop()->PostTask
      (FROM_HERE,
       NewRunnableMethod(this, &BrowserProcessImpl::DoInspectorFilesCheck));
}

#if (defined(OS_WIN) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
void BrowserProcessImpl::StartAutoupdateTimer() {
  autoupdate_timer_.Start(
      base::TimeDelta::FromHours(kUpdateCheckIntervalHours),
      this,
      &BrowserProcessImpl::OnAutoupdateTimer);
}
#endif

#include "chrome/browser/automation/automation_provider_list.h"
  virtual ResourceDispatcherHost* resource_dispatcher_host() {
    DCHECK(CalledOnValidThread());
    if (!created_resource_dispatcher_host_)
      CreateResourceDispatcherHost();
    return resource_dispatcher_host_.get();
  }

  virtual MetricsService* metrics_service() {
    DCHECK(CalledOnValidThread());
    if (!created_metrics_service_)
      CreateMetricsService();
    return metrics_service_.get();
  }

  virtual IOThread* io_thread() {
    DCHECK(CalledOnValidThread());
    if (!created_io_thread_)
      CreateIOThread();
    return io_thread_.get();
  }

  virtual base::Thread* file_thread() {
    DCHECK(CalledOnValidThread());
    if (!created_file_thread_)
      CreateFileThread();
    return file_thread_.get();
  }

  virtual base::Thread* db_thread() {
    DCHECK(CalledOnValidThread());
    if (!created_db_thread_)
      CreateDBThread();
    return db_thread_.get();
  }

  virtual base::Thread* process_launcher_thread() {
    DCHECK(CalledOnValidThread());
    if (!created_process_launcher_thread_)
      CreateProcessLauncherThread();
    return process_launcher_thread_.get();
  }

  virtual base::Thread* cache_thread() {
    DCHECK(CalledOnValidThread());
    if (!created_cache_thread_)
      CreateCacheThread();
    return cache_thread_.get();
  }

  virtual base::Thread* background_x11_thread() {
    DCHECK(CalledOnValidThread());
    // The BACKGROUND_X11 thread is created when the IO thread is created.
    if (!created_io_thread_)
      CreateIOThread();
    return background_x11_thread_.get();
  }

  virtual ProfileManager* profile_manager() {
    DCHECK(CalledOnValidThread());
    if (!created_profile_manager_)
      CreateProfileManager();
    return profile_manager_.get();
  }

  virtual PrefService* local_state() {
    DCHECK(CalledOnValidThread());
    if (!created_local_state_)
      CreateLocalState();
    return local_state_.get();
  }

  virtual DevToolsManager* devtools_manager() {
    DCHECK(CalledOnValidThread());
    if (!created_devtools_manager_)
      CreateDevToolsManager();
    return devtools_manager_.get();
  }

  virtual Clipboard* clipboard() {
    DCHECK(CalledOnValidThread());
    return clipboard_.get();
  }

  virtual NotificationUIManager* notification_ui_manager() {
    DCHECK(CalledOnValidThread());
    if (!created_notification_ui_manager_)
      CreateNotificationUIManager();
    return notification_ui_manager_.get();
  }

  virtual StatusTrayManager* status_tray_manager() {
    DCHECK(CalledOnValidThread());
    if (!status_tray_manager_.get())
      CreateStatusTrayManager();
    return status_tray_manager_.get();
  }

  virtual IconManager* icon_manager() {
    DCHECK(CalledOnValidThread());
    if (!created_icon_manager_)
      CreateIconManager();
    return icon_manager_.get();
  }

  virtual ThumbnailGenerator* GetThumbnailGenerator() {
    return &thumbnail_generator_;
  }

  virtual AutomationProviderList* InitAutomationProviderList() {
    DCHECK(CalledOnValidThread());
    if (automation_provider_list_.get() == NULL) {
      automation_provider_list_.reset(AutomationProviderList::GetInstance());
    }
    return automation_provider_list_.get();
  }

  virtual void InitDebuggerWrapper(int port, bool useHttp) {
    DCHECK(CalledOnValidThread());
    if (!created_debugger_wrapper_)
      CreateDebuggerWrapper(port, useHttp);
  }



  virtual bool IsShuttingDown() {
    DCHECK(CalledOnValidThread());
    return did_start_ && 0 == module_ref_count_;
  }


  virtual GoogleURLTracker* google_url_tracker() {
    DCHECK(CalledOnValidThread());
    if (!google_url_tracker_.get())
      CreateGoogleURLTracker();
    return google_url_tracker_.get();
  }

  virtual IntranetRedirectDetector* intranet_redirect_detector() {
    DCHECK(CalledOnValidThread());
    if (!intranet_redirect_detector_.get())
      CreateIntranetRedirectDetector();
    return intranet_redirect_detector_.get();
  }

  virtual const std::string& GetApplicationLocale() {
    DCHECK(!locale_.empty());
    return locale_;
  }

  virtual base::WaitableEvent* shutdown_event() {
    return shutdown_event_.get();
  }

  virtual TabCloseableStateWatcher* tab_closeable_state_watcher() {
    DCHECK(CalledOnValidThread());
    if (!tab_closeable_state_watcher_.get())
      CreateTabCloseableStateWatcher();
    return tab_closeable_state_watcher_.get();
  }

  virtual bool have_inspector_files() const {
    return have_inspector_files_;
  }
#include "chrome/browser/browser_process.h"
#include <string>
#include "base/logging.h"
#include "googleurl/src/gurl.h"
  bool IsVisited(const GURL& url) const {
    return IsVisited(url.spec().data(), url.spec().size());
  }
#include "chrome/common/dom_storage_common.h"
#include "chrome/common/extensions/extension_extent.h"
#include "chrome/renderer/gpu_channel_host.h"
#include "chrome/renderer/renderer_histogram_snapshots.h"
  // Contains extension-related data that the renderer needs to know about.
  // TODO(mpcomplete): this doesn't feel like it belongs here. Find a better
  // place.
  struct ExtensionInfo {
    std::string extension_id;
    ExtensionExtent web_extent;
    ExtensionExtent browse_extent;
  };

  if (current_color_chooser_)
    return current_color_chooser_;
  return new ColorChooserWin(web_contents, initial_color);
    file_permissions_.erase(file.StripTrailingSeparators());
  // Determine whether permission has been granted to request url.
  // Schemes that have not been granted default to being denied.
    if (judgment == scheme_policy_.end())
      return false;  // Unmentioned schemes are disallowed.

    return judgment->second;
    // If the child process has been commanded to request a scheme, then we
    // grant it the capability to request URLs of that scheme.
  // request the URL.
    policy->GrantRequestURL(renderer_id, net::FilePathToFileURL(path));
  GURL file_url = GURL("file:///etc/passwd");
  dropped_data.url = file_url;
                             WebKit::WebDragOperationNone, 0);
  EXPECT_FALSE(ChildProcessSecurityPolicyImpl::GetInstance()->CanRequestURL(
      process()->GetID(), file_url));
    int cumulative_bindings =
        RenderProcess::current()->GetEnabledBindings();
        bool is_initial_navigation = page_id_ == -1;
  // Use the frame's original request's URL rather than the document's URL for
  // this check.  For a popup, the document's URL may become the opener window's
  // URL if the opener has called document.write.  See http://crbug.com/93517.
  GURL old_url(frame->dataSource()->request().url());

    EXPECT_FALSE(sourceList.matches(KURL(base, "https://foo.test/")));
    EXPECT_FALSE(sourceList.matches(KURL(base, "https://example1.com/foo/"), ContentSecurityPolicy::DidRedirect));
    EXPECT_FALSE(source.matches(KURL(base, "https://example.com:8000/foo"), ContentSecurityPolicy::DidRedirect));
    ((static_cast<uint8>(a) << 24u) | (static_cast<uint8>(b) << 16u) | \
     (static_cast<uint8>(c) << 8u) | (static_cast<uint8>(d)))
    enableApplicationCache(enable);
    enableDatabase(enable);
    enableDeviceOrientation(enable);
    enableDirectoryUpload(enable);
    enableEncryptedMedia(enable);
    enableFileSystem(enable);
    enableFullscreen(enable);
    enableGamepad(enable);
    enableGeolocation(enable);
    enableIndexedDB(enable);
    enableInputTypeWeek(enable);
    enableJavaScriptI18NAPI(enable);
    enableLocalStorage(enable);
    enableMediaSource(enable);
    enableMediaStream(enable);
    enableNotifications(enable);
    enablePeerConnection(enable);
    enableQuota(enable);
    enableScriptedSpeech(enable);
    enableSessionStorage(enable);
    enableSpeechInput(enable);
    enableTouch(enable);
    enableVideoTrack(enable);
    enableWebAudio(enable);
    enableCSSCompositing(enable);
    enableCSSExclusions(enable);
    enableCSSRegions(enable);
    enableCustomDOMElements(enable);
    enableDialogElement(enable);
    enableExperimentalContentSecurityPolicyFeatures(enable);
    enableFontLoadEvents(enable);
    enableSeamlessIFrames(enable);
    enableStyleScoped(enable);
    // This method should be used by ContentShell
    // to enable features which should be enabled for
    // the layout tests but are not yet "experimental".
    enableCanvasPath(enable);
    enableExperimentalCanvasFeatures(enable);
    enableExperimentalShadowDOM(enable);
    enableInputTypeDateTime(enable);
    enableRequestAutocomplete(enable);
    enableWebMIDI(enable);
    , m_currentSpeechUtterance(nullptr)
    return m_currentSpeechUtterance;
void SpeechSynthesis::startSpeakingImmediately(SpeechSynthesisUtterance* utterance)
    ASSERT(!m_currentSpeechUtterance);
    m_currentSpeechUtterance = utterance;
    // If the queue was empty, speak this immediately and add it to the queue.
        startSpeakingImmediately(utterance);
    // Remove all the items from the utterance queue.
    // Hold on to the current utterance so the platform synthesizer can have a chance to clean up.
    RefPtrWillBeMember<SpeechSynthesisUtterance> current = m_currentSpeechUtterance;
    current = nullptr;

    // The platform should have called back immediately and cleared the current utterance.
    ASSERT(!m_currentSpeechUtterance);
    if (!m_currentSpeechUtterance)
    ASSERT(m_currentSpeechUtterance);
    m_currentSpeechUtterance = nullptr;
    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());
    if (m_utteranceQueue.size()) {
        RefPtrWillBeMember<SpeechSynthesisUtterance> firstUtterance = m_utteranceQueue.first();
        ASSERT(firstUtterance == utterance);
        if (firstUtterance == utterance)
            m_utteranceQueue.removeFirst();
        // Start the next job if there is one pending.
        if (!m_utteranceQueue.isEmpty())
            startSpeakingImmediately(m_utteranceQueue.first().get());
    }
    visitor->trace(m_currentSpeechUtterance);
    void startSpeakingImmediately(SpeechSynthesisUtterance*);
    RawPtrWillBeMember<SpeechSynthesisUtterance> m_currentSpeechUtterance;
    client()->speakingErrorOccurred(m_utterance);
    m_utterance = nullptr;
  AppWindow* app_window =
      registry->GetAppWindowForRenderViewHost(contents->GetRenderViewHost());
          ->GetAppWindowForRenderViewHost(web_contents->GetRenderViewHost());
RenderFrameImpl* RenderFrameImpl::FromRoutingID(int32 routing_id) {
#include "content/public/browser/render_view_host.h"
        AppWindow* window = AppWindowRegistry::Get(browser_context())
                                ->GetAppWindowForAppAndKey(
                                    extension_id(), create_params.window_key);
        if (window) {
          content::RenderViewHost* created_view =
              window->web_contents()->GetRenderViewHost();
          int view_id = MSG_ROUTING_NONE;
              created_view->GetProcess()->GetID()) {
            view_id = created_view->GetRoutingID();
              window->Show(AppWindow::SHOW_INACTIVE);
              window->Show(AppWindow::SHOW_ACTIVE);
          result->Set("viewId", new base::FundamentalValue(view_id));
          window->GetSerializedState(result);
  content::RenderViewHost* created_view =
      app_window->web_contents()->GetRenderViewHost();
  int view_id = MSG_ROUTING_NONE;
  if (create_params.creator_process_id == created_view->GetProcess()->GetID())
    view_id = created_view->GetRoutingID();
  result->Set("viewId", new base::FundamentalValue(view_id));
          ->HadDevToolsAttached(created_view)) {
  if (web_contents_->GetRenderViewHost()->GetProcess()->GetID() ==
    SuspendRenderViewHost(web_contents_->GetRenderViewHost());
            << web_contents_->GetRenderViewHost()->GetProcess()->GetID()
void AppWindowContentsImpl::SuspendRenderViewHost(
    content::RenderViewHost* rvh) {
  DCHECK(rvh);
                 rvh->GetProcess()->GetID(), rvh->GetRoutingID()));
#include "content/public/browser/notification_observer.h"
  void SuspendRenderViewHost(content::RenderViewHost* rvh);
#include "content/public/browser/render_view_host.h"
namespace {

// Create a key that identifies a AppWindow in a RenderViewHost across App
// reloads. If the window was given an id in CreateParams, the key is the
// extension id, a colon separator, and the AppWindow's |id|. If there is no
// |id|, the chrome-extension://extension-id/page.html URL will be used. If the
// RenderViewHost is not for a AppWindow, return an empty string.
std::string GetWindowKeyForRenderViewHost(
    const AppWindowRegistry* registry,
    content::RenderViewHost* render_view_host) {
  AppWindow* app_window =
      registry->GetAppWindowForRenderViewHost(render_view_host);
  if (!app_window)
    return std::string();  // Not a AppWindow.

  if (app_window->window_key().empty())
    return app_window->web_contents()->GetURL().possibly_invalid_spec();

  std::string key = app_window->extension_id();
  key += ':';
  key += app_window->window_key();
  return key;
}

}  // namespace

    content::WebContents* web_contents) const {
AppWindow* AppWindowRegistry::GetAppWindowForRenderViewHost(
    content::RenderViewHost* render_view_host) const {
  return GetAppWindowForWebContents(
      content::WebContents::FromRenderViewHost(render_view_host));
}

    content::RenderViewHost* render_view_host) const {
  std::string key = GetWindowKeyForRenderViewHost(this, render_view_host);
  std::string key =
      GetWindowKeyForRenderViewHost(this, web_contents->GetRenderViewHost());
class RenderViewHost;
      content::WebContents* web_contents) const;
  // TODO(devlin): Remove this when callers have been updated to use the
  // above.
  AppWindow* GetAppWindowForRenderViewHost(
      content::RenderViewHost* render_view_host) const;
  // newly created |render_view_host|.
  bool HadDevToolsAttached(content::RenderViewHost* render_view_host) const;
#include "content/public/renderer/render_view_observer.h"
#include "content/public/renderer/render_view_visitor.h"
#include "extensions/renderer/dispatcher.h"
class DidCreateDocumentElementObserver : public content::RenderViewObserver {
  DidCreateDocumentElementObserver(content::RenderView* view,
                                   Dispatcher* dispatcher)
      : content::RenderViewObserver(view), dispatcher_(dispatcher) {}
  void DidCreateDocumentElement(blink::WebLocalFrame* frame) override {
    DCHECK(frame);
    DCHECK(dispatcher_);
    if (frame->parent())
    ScriptContext* script_context =
        dispatcher_->script_context_set().GetByV8Context(
            frame->mainWorldScriptContext());
  Dispatcher* dispatcher_;
AppWindowCustomBindings::AppWindowCustomBindings(Dispatcher* dispatcher,
                                                 ScriptContext* context)
    : ObjectBackedNativeHandler(context), dispatcher_(dispatcher) {
  RouteFunction("GetView",
      base::Bind(&AppWindowCustomBindings::GetView,
                 base::Unretained(this)));
void AppWindowCustomBindings::GetView(
  int view_id = args[0]->Int32Value();
  if (view_id == MSG_ROUTING_NONE)
  content::RenderView* view = content::RenderView::FromRoutingID(view_id);
  if (!view)
  if (inject_titlebar)
    new DidCreateDocumentElementObserver(view, dispatcher_);

  content::RenderFrame* render_frame = context()->GetRenderFrame();
  content::RenderView* render_view =
      render_frame ? render_frame->GetRenderView() : nullptr;
  if (!render_view)
  blink::WebFrame* opener = render_view->GetWebView()->mainFrame();
  blink::WebFrame* frame = view->GetWebView()->mainFrame();
  frame->setOpener(opener);
      new ExtensionHostMsg_ResumeRequests(view->GetRoutingID()));
  v8::Local<v8::Value> window = frame->mainWorldScriptContext()->Global();
class Dispatcher;
  AppWindowCustomBindings(Dispatcher* dispatcher, ScriptContext* context);
  void GetView(const v8::FunctionCallbackInfo<v8::Value>& args);
  // Dispatcher handle. Not owned.
  Dispatcher* dispatcher_;
#include "extensions/renderer/render_view_observer_natives.h"
      "renderViewObserverNatives",
      scoped_ptr<NativeHandler>(new RenderViewObserverNatives(context)));
      scoped_ptr<NativeHandler>(
          new AppWindowCustomBindings(dispatcher, context)));
#ifndef EXTENSIONS_RENDERER_RENDER_VIEW_OBSERVER_NATIVES_H_
#define EXTENSIONS_RENDERER_RENDER_VIEW_OBSERVER_NATIVES_H_
// Native functions for JS to run callbacks upon RenderView events.
class RenderViewObserverNatives : public ObjectBackedNativeHandler {
  RenderViewObserverNatives(ScriptContext* context);
  // Runs a callback upon creation of new document element inside a render view
  DISALLOW_COPY_AND_ASSIGN(RenderViewObserverNatives);
#endif  // EXTENSIONS_RENDERER_RENDER_VIEW_OBSERVER_NATIVES_H_
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "extensions/renderer/render_view_observer_natives.h"

#include "content/public/renderer/render_view.h"
#include "content/public/renderer/render_view_observer.h"
#include "extensions/common/extension_api.h"
#include "extensions/renderer/script_context.h"
#include "third_party/WebKit/public/web/WebFrame.h"
#include "third_party/WebKit/public/web/WebScopedMicrotaskSuppression.h"

namespace extensions {

namespace {

// Deletes itself when done.
class LoadWatcher : public content::RenderViewObserver {
 public:
  LoadWatcher(ScriptContext* context,
              content::RenderView* view,
              v8::Local<v8::Function> cb)
      : content::RenderViewObserver(view),
        context_(context),
        callback_(context->isolate(), cb) {}

  void DidCreateDocumentElement(blink::WebLocalFrame* frame) override {
    CallbackAndDie(true);
  }

  void DidFailProvisionalLoad(blink::WebLocalFrame* frame,
                              const blink::WebURLError& error) override {
    CallbackAndDie(false);
  }

 private:
  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
    delete this;
  }

  ScriptContext* context_;
  v8::Global<v8::Function> callback_;
  DISALLOW_COPY_AND_ASSIGN(LoadWatcher);
};
}  // namespace

RenderViewObserverNatives::RenderViewObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
  RouteFunction("OnDocumentElementCreated",
                base::Bind(&RenderViewObserverNatives::OnDocumentElementCreated,
                           base::Unretained(this)));
}

void RenderViewObserverNatives::OnDocumentElementCreated(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK(args.Length() == 2);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsFunction());

  int view_id = args[0]->Int32Value();

  content::RenderView* view = content::RenderView::FromRoutingID(view_id);
  if (!view) {
    LOG(WARNING) << "No render view found to register LoadWatcher.";
    return;
  }

  new LoadWatcher(context(), view, args[1].As<v8::Function>());

  args.GetReturnValue().Set(true);
}

}  // namespace extensions
      DCHECK(suffix[0] == '/');
        LOG(WARNING) << "CopyDirectory() skipping symbolic link.";
        LOG(WARNING) << "CopyDirectory() skipping weird file.";
      DCHECK(suffix[0] == '/');
        LOG(WARNING) << "skipping symbolic link.";
        LOG(WARNING) << "skipping weird file.";
  GetUserMediaRequestFailed(&request_info->request, result);
    GetUserMediaRequestTrackStartedFailed(&request->request,
                                          result,
                                          result_name);
    MediaStreamRequestResult result) {
      break;
      break;
      break;
      break;
      break;
      break;
      break;
      break;
      break;
    default:
      NOTREACHED();
      request_info->requestFailed();
      break;
  }
}

void UserMediaClientImpl::GetUserMediaRequestTrackStartedFailed(
    blink::WebUserMediaRequest* request_info,
    MediaStreamRequestResult result,
    const blink::WebString& result_name) {
  switch (result) {
      break;
      break;
    default:
      NOTREACHED();
      request_info->requestFailed();
      break;
      blink::WebUserMediaRequest* request_info,
      MediaStreamRequestResult result);
  virtual void GetUserMediaRequestTrackStartedFailed(
      content::MediaStreamRequestResult result) override {
    last_generated_stream_.reset();
    state_ = REQUEST_FAILED;
    result_ = result;
  }

  void GetUserMediaRequestTrackStartedFailed(
      blink::WebUserMediaRequest* request_info,
      MediaStreamRequestResult result,
  // TODO(joth): Release GL resources. crbug.com/231986.
  if (!success) {
    context3d_.reset();
    callbacks_.reset();
  }
class FakeOutputSurfaceClient : public OutputSurfaceClient {
 public:
  FakeOutputSurfaceClient()
      : begin_frame_count_(0),
        deferred_initialize_result_(true),
        deferred_initialize_called_(false),
        did_lose_output_surface_called_(false),
        memory_policy_(0),
        discard_backbuffer_when_not_visible_(false) {}

  virtual bool DeferredInitialize(
      scoped_refptr<ContextProvider> offscreen_context_provider) OVERRIDE {
    deferred_initialize_called_ = true;
    return deferred_initialize_result_;
  }
  virtual void SetNeedsRedrawRect(gfx::Rect damage_rect) OVERRIDE {}
  virtual void BeginFrame(const BeginFrameArgs& args) OVERRIDE {
    begin_frame_count_++;
  }
  virtual void OnSwapBuffersComplete(const CompositorFrameAck* ack) OVERRIDE {}
  virtual void DidLoseOutputSurface() OVERRIDE {
    did_lose_output_surface_called_ = true;
  }
  virtual void SetExternalDrawConstraints(const gfx::Transform& transform,
                                          gfx::Rect viewport) OVERRIDE {}
  virtual void SetMemoryPolicy(
      const ManagedMemoryPolicy& policy,
      bool discard_backbuffer_when_not_visible) OVERRIDE {
    memory_policy_ = policy;
    discard_backbuffer_when_not_visible_ = discard_backbuffer_when_not_visible;
  }

  int begin_frame_count() {
    return begin_frame_count_;
  }

  void set_deferred_initialize_result(bool result) {
    deferred_initialize_result_ = result;
  }

  bool deferred_initialize_called() {
    return deferred_initialize_called_;
  }

  bool did_lose_output_surface_called() {
    return did_lose_output_surface_called_;
  }

  const ManagedMemoryPolicy& memory_policy() const { return memory_policy_; }

  bool discard_backbuffer_when_not_visible() const {
    return discard_backbuffer_when_not_visible_;
  }

 private:
  int begin_frame_count_;
  bool deferred_initialize_result_;
  bool deferred_initialize_called_;
  bool did_lose_output_surface_called_;
  ManagedMemoryPolicy memory_policy_;
  bool discard_backbuffer_when_not_visible_;
};

      new ResourceProvider(output_surface));
  if (!resource_provider->Initialize(highp_threshold_min))
  WebGraphicsContext3D* context3d = output_surface_->context3d();
  if (!context3d || !context3d->makeContextCurrent())
    return;
  texture_uploader_.reset();
ResourceProvider::ResourceProvider(OutputSurface* output_surface)
      default_resource_type_(GLTexture),
      best_texture_format_(0) {
bool ResourceProvider::Initialize(int highp_threshold_min) {
  if (!context3d) {
    default_resource_type_ = Bitmap;
    max_texture_size_ = INT_MAX / 2;
    best_texture_format_ = GL_RGBA;
    return true;
  }
bool ResourceProvider::Reinitialize(int highp_threshold_min) {
  DCHECK(thread_checker_.CalledOnValidThread());

  // Only supports reinitializing from software mode.
  DCHECK(!texture_uploader_);
  return Initialize(highp_threshold_min);
  bool Reinitialize(int highp_threshold_min);
  void set_default_resource_type(ResourceType type) {
    default_resource_type_ = type;
  }
  explicit ResourceProvider(OutputSurface* output_surface);
  bool Initialize(int highp_threshold_min);
      : shared_data_(ContextSharedData::Create()),
        output_surface_(FakeOutputSurface::Create3d(
            ResourceProviderContext::Create(shared_data_.get())
                .PassAs<WebKit::WebGraphicsContext3D>())),
        resource_provider_(ResourceProvider::Create(output_surface_.get(), 0)) {
    resource_provider_->set_default_resource_type(GetParam());
  void GetResourcePixels(ResourceProvider::ResourceId id,
                         gfx::Size size,
                         WGC3Denum format,
                         uint8_t* pixels) {
    if (GetParam() == ResourceProvider::GLTexture) {
      ResourceProvider::ScopedReadLockGL lock_gl(resource_provider_.get(), id);
      ASSERT_NE(0U, lock_gl.texture_id());
      context()->bindTexture(GL_TEXTURE_2D, lock_gl.texture_id());
      context()->GetPixels(size, format, pixels);
    } else if (GetParam() == ResourceProvider::Bitmap) {
      ResourceProvider::ScopedReadLockSoftware lock_software(
          resource_provider_.get(), id);
      memcpy(pixels,
             lock_software.sk_bitmap()->getPixels(),
             lock_software.sk_bitmap()->getSize());
    }
  }

TEST_P(ResourceProviderTest, Basic) {
  ResourceProvider::ResourceId id = resource_provider_->CreateResource(
  EXPECT_EQ(1, static_cast<int>(resource_provider_->num_resources()));
  if (GetParam() == ResourceProvider::GLTexture)
    EXPECT_EQ(0, context()->texture_count());
  resource_provider_->SetPixels(id, data, rect, rect, gfx::Vector2d());
  if (GetParam() == ResourceProvider::GLTexture)
    EXPECT_EQ(1, context()->texture_count());
  GetResourcePixels(id, size, format, result);
  resource_provider_->DeleteResource(id);
  EXPECT_EQ(0, static_cast<int>(resource_provider_->num_resources()));
  if (GetParam() == ResourceProvider::GLTexture)
    EXPECT_EQ(0, context()->texture_count());
    GetResourcePixels(id, size, format, result);
    GetResourcePixels(id, size, format, result);
    GetResourcePixels(id, size, format, result);
    GetResourcePixels(id, size, format, result);
  GetResourcePixels(mapped_id1, size, format, result);
  GetResourcePixels(mapped_id2, size, format, result);
    ResourceProvider* resource_provider) {
  } else if (output_surface->context3d()) {
  CreateAndSetRenderer(output_surface.get(), resource_provider.get());
    bool using_map_image = GetRendererCapabilities().using_map_image;
    tile_manager_ = TileManager::Create(this,
                                        resource_provider.get(),
                                        settings_.num_raster_threads,
                                        rendering_stats_instrumentation_,
                                        using_map_image);
    UpdateTileManagerMemoryPolicy(ActualManagedMemoryPolicy());
  resource_provider_->Reinitialize(settings_.highp_threshold_min);
  CreateAndSetRenderer(output_surface_.get(), resource_provider_.get());
                            ResourceProvider* resource_provider);
    initialized_gl_ = false;
    num_draws_ = 0;
    if (!initialized_gl_) {
      ImplThreadTaskRunner()->PostTask(FROM_HERE, base::Bind(
          &LayerTreeHostTestDeferredInitialize::DeferredInitializeAndRedraw,
          base::Unretained(this),
          base::Unretained(host_impl)));
    } else {
      if (!num_draws_) {
        EXPECT_EQ(2u, layer_impl->append_quads_count());
        EndTest();
      }
      num_draws_++;
    initialized_gl_ = true;

    // Force redraw again.
    host_impl->SetNeedsRedrawRect(gfx::Rect(1, 1));
    // If we didn't swap this begin frame, we need to request another one.
    host_impl->SetNeedsBeginFrame(true);
    EXPECT_TRUE(initialized_gl_);
  bool initialized_gl_;
  int num_draws_;
  // One-time synchronously initialize compositor for hardware draw.
  // It is invalid to DemandDrawHw before this returns true.
      read_only_ ? PAGE_READONLY : PAGE_READWRITE, 0, static_cast<DWORD>(size),
    enableApplicationCache(enable);
    enableDatabase(enable);
    enableDeviceOrientation(enable);
    enableDirectoryUpload(enable);
    enableEncryptedMedia(enable);
    enableFileSystem(enable);
    enableFullscreen(enable);
    enableGamepad(enable);
    enableGeolocation(enable);
    enableIndexedDB(enable);
    enableInputTypeWeek(enable);
    enableJavaScriptI18NAPI(enable);
    enableLocalStorage(enable);
    enableMediaSource(enable);
    enableMediaStream(enable);
    enableNotifications(enable);
    enablePeerConnection(enable);
    enableQuota(enable);
    enableScriptedSpeech(enable);
    enableSessionStorage(enable);
    enableSpeechInput(enable);
    enableTouch(enable);
    enableVideoTrack(enable);
    enableWebAudio(enable);
    enableCSSCompositing(enable);
    enableCSSExclusions(enable);
    enableCSSRegions(enable);
    enableCustomDOMElements(enable);
    enableDialogElement(enable);
    enableExperimentalContentSecurityPolicyFeatures(enable);
    enableFontLoadEvents(enable);
    enableSeamlessIFrames(enable);
    enableStyleScoped(enable);
    // This method should be used by ContentShell
    // to enable features which should be enabled for
    // the layout tests but are not yet "experimental".
    enableCanvasPath(enable);
    enableExperimentalCanvasFeatures(enable);
    enableExperimentalShadowDOM(enable);
    enableInputTypeDateTime(enable);
    enableRequestAutocomplete(enable);
    enableWebMIDI(enable);
#include "grit/extensions_renderer_resources.h"
#include "grit/extensions_renderer_resources.h"
#include "grit/extensions_renderer_resources.h"
#include "grit/extensions_renderer_resources.h"
#include "grit/extensions_renderer_resources.h"
      IPC_MESSAGE_HANDLER(ViewHostMsg_CreateDedicatedWorker,
                          OnCreateDedicatedWorker)
void ResourceMessageFilter::OnCreateDedicatedWorker(const GURL& url,
                                                    int render_view_route_id,
                                                    int* route_id) {
  WorkerService::GetInstance()->CreateDedicatedWorker(
      url, id(), render_view_route_id, this, id(), *route_id);
  void OnCreateDedicatedWorker(const GURL& url,
                               int render_view_route_id,
                               int* route_id);
  Send(new WorkerProcessMsg_CreateWorker(
      instance.url, instance.worker_route_id));
      IPC_MESSAGE_HANDLER(ViewHostMsg_CreateDedicatedWorker,
                          OnCreateDedicatedWorker)
void WorkerProcessHost::OnCreateDedicatedWorker(const GURL& url,
                                                int render_view_route_id,
                                                int* route_id) {
  WorkerService::GetInstance()->CreateDedicatedWorker(
      url, instances_.front().renderer_id,
  void OnCreateDedicatedWorker(const GURL& url,
                               int render_view_route_id,
                               int* route_id);
bool WorkerService::CreateDedicatedWorker(const GURL &url,
                                          int renderer_id,
                                          int render_view_route_id,
                                          IPC::Message::Sender* sender,
                                          int sender_id,
                                          int sender_route_id) {
  bool CreateDedicatedWorker(const GURL &url,
                             int renderer_pid,
                             int render_view_route_id,
                             IPC::Message::Sender* sender,
                             int sender_id,
                             int sender_route_id);
  IPC_SYNC_MESSAGE_CONTROL2_1(ViewHostMsg_CreateDedicatedWorker,
                              GURL /* url */,
                              int /* render_view_route_id */,
                              int /* route_id */)

  // A renderer sends this to the browser process when it wants to create a
  // shared worker.  The browser will create the worker process if necessary,
  // and will return the route id on success.  On error returns
  // MSG_ROUTING_NONE.
  IPC_SYNC_MESSAGE_CONTROL3_1(ViewHostMsg_CreateSharedWorker,
  IPC_MESSAGE_CONTROL2(WorkerProcessMsg_CreateWorker,
#include "chrome/renderer/websharedworker_impl.h"
WebSharedWorkerImpl::WebSharedWorkerImpl(const GURL& url,
                                         const string16& name,
                                         ChildThread* child_thread,
    : WebWorkerBase(child_thread, route_id, render_view_route_id),
      url_(url),
      name_(name) {
bool WebSharedWorkerImpl::isStarted() {
void WebSharedWorkerImpl::startWorkerContext(
  DCHECK(url_ == script_url);
  IPC::Message* create_message = new ViewHostMsg_CreateSharedWorker(
      url_, name_, render_view_route_id_, &route_id_);
  CreateWorkerContext(create_message, script_url, user_agent, source_code);
void WebSharedWorkerImpl::connect(WebKit::WebMessagePortChannel* channel) {
void WebSharedWorkerImpl::OnMessageReceived(const IPC::Message& message) {
  IPC_BEGIN_MESSAGE_MAP(WebSharedWorkerImpl, message)
void WebSharedWorkerImpl::OnWorkerCreated() {
#ifndef CHROME_RENDERER_WEBSHAREDWORKER_IMPL_H_
#define CHROME_RENDERER_WEBSHAREDWORKER_IMPL_H_
class WebSharedWorkerImpl : public WebKit::WebSharedWorker,
                            private WebWorkerBase {
  WebSharedWorkerImpl(const GURL& url,
                      const string16& name,
                      ChildThread* child_thread,
  // IPC::Channel::Listener implementation.
  // The name and URL that uniquely identify this worker.
  GURL url_;
  string16 name_;

  DISALLOW_COPY_AND_ASSIGN(WebSharedWorkerImpl);
#endif  // CHROME_RENDERER_WEBSHAREDWORKER_IMPL_H_
void WebWorkerBase::CreateWorkerContext(IPC::Message* create_message,
                                        const GURL& script_url,
  // create_message is a sync message that sets route_id_
  void CreateWorkerContext(IPC::Message* create_message,
                           const GURL& script_url,
  IPC::Message* create_message = new ViewHostMsg_CreateDedicatedWorker(
      script_url, render_view_route_id_, &route_id_);
  CreateWorkerContext(create_message, script_url, user_agent, source_code);
                        client_,
                        WebWorkerClient::workerContextDestroyed)
#include "chrome/common/child_process.h"
#include "chrome/worker/nativewebworker_impl.h"
static bool UrlIsNativeWorker(const GURL& url) {
  // If the renderer was not passed the switch to enable native workers,
  // then the URL should be treated as a JavaScript worker.
  if (!CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableNativeWebWorkers)) {
    return false;
  }
  // Based on the suffix, decide whether the url should be considered
  // a NativeWebWorker (for .nexe) or a WebWorker (for anything else).
  const std::string kNativeSuffix(".nexe");
  std::string worker_url = url.path();
  // Compute the start index of the suffix.
  std::string::size_type suffix_index =
      worker_url.length() - kNativeSuffix.length();
  std::string::size_type pos = worker_url.find(kNativeSuffix, suffix_index);
  return (suffix_index == pos);
}

WebWorkerClientProxy::WebWorkerClientProxy(const GURL& url, int route_id)
    : url_(url),
      route_id_(route_id),
  if (UrlIsNativeWorker(url)) {
    // Launch a native worker.
    impl_ = NativeWebWorkerImpl::create(this);
  } else {
    // Launch a JavaScript worker.
    impl_ = WebWorker::create(this);
  }
  WorkerThread::current()->AddRoute(route_id_, this);
  ChildProcess::current()->AddRefProcess();
  impl_->clientDestroyed();
  WorkerThread::current()->RemoveRoute(route_id_);
  ChildProcess::current()->ReleaseProcess();

  delete this;
void WebWorkerClientProxy::OnMessageReceived(const IPC::Message& message) {
  if (!impl_)
    return;

  IPC_BEGIN_MESSAGE_MAP(WebWorkerClientProxy, message)
    IPC_MESSAGE_FORWARD(WorkerMsg_StartWorkerContext, impl_,
                        WebWorker::startWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_TerminateWorkerContext,
                        OnTerminateWorkerContext)
    IPC_MESSAGE_HANDLER(WorkerMsg_PostMessage, OnPostMessage)
    IPC_MESSAGE_FORWARD(WorkerMsg_WorkerObjectDestroyed, impl_,
                        WebWorker::workerObjectDestroyed)
  IPC_END_MESSAGE_MAP()
}

void WebWorkerClientProxy::OnTerminateWorkerContext() {
  impl_->terminateWorkerContext();

void WebWorkerClientProxy::OnPostMessage(
    const string16& message,
    const std::vector<int>& sent_message_port_ids,
    const std::vector<int>& new_routing_ids) {
  WebMessagePortChannelArray channels(sent_message_port_ids.size());
  for (size_t i = 0; i < sent_message_port_ids.size(); i++) {
    channels[i] = new WebMessagePortChannelImpl(
        new_routing_ids[i], sent_message_port_ids[i]);
  }

  impl_->postMessageToWorkerContext(message, channels);
}
#include "googleurl/src/gurl.h"
class WebWorkerClientProxy : public WebKit::WebWorkerClient,
                             public IPC::Channel::Listener {
  WebWorkerClientProxy(const GURL& url, int route_id);
  // IPC::Channel::Listener implementation.
  virtual void OnMessageReceived(const IPC::Message& message);
  ~WebWorkerClientProxy();

  void OnTerminateWorkerContext();
  void OnPostMessage(const string16& message,
                     const std::vector<int>& sent_message_port_ids,
                     const std::vector<int>& new_routing_ids);

  // The source url for this worker.
  GURL url_;


  WebKit::WebWorker* impl_;

#include "chrome/worker/webworkerclient_proxy.h"
void WorkerThread::OnCreateWorker(const GURL& url, int route_id) {
  // WebWorkerClientProxy owns itself.
  new WebWorkerClientProxy(url, route_id);
  void OnCreateWorker(const GURL& url, int route_id);
        virtual ~WebSharedWorker() {}
        // Sends a connect event to the SharedWorker thread.
    class WebWorkerClient {
        virtual void postExceptionToWorkerObject(
            const WebString& errorString, int lineNumber,
            const WebString& sourceURL) = 0;

        virtual void postConsoleMessageToWorkerObject(
            int destinationIdentifier,
            int sourceIdentifier,
            int messageType,
            int messageLevel,
            const WebString& message,
            int lineNumber,
            const WebString& sourceURL) = 0;

        virtual void workerContextDestroyed() = 0;

        // Returns the notification presenter for this worker context.  Pointer
        // is owned by the object implementing WebWorkerClient.
        virtual WebNotificationPresenter* notificationPresenter() = 0;

        // This can be called on any thread to create a nested worker.
        virtual WebWorker* createWorker(WebWorkerClient* client) = 0;

    SharedWorkerScriptLoader(PassRefPtr<SharedWorker> worker, PassOwnPtr<MessagePortChannel> port, PassOwnPtr<WebSharedWorker> webWorker)
        : m_worker(worker)
        , m_webWorker(webWorker)
        , m_port(port)
    void load(const KURL&);
void SharedWorkerScriptLoader::load(const KURL& url)
    m_scriptLoader.loadAsynchronously(m_worker->scriptExecutionContext(), url, DenyCrossOriginRequests, this);
        m_webWorker->startWorkerContext(m_scriptLoader.url(), m_worker->scriptExecutionContext()->userAgent(m_scriptLoader.url()), m_scriptLoader.script());
        SharedWorkerScriptLoader* loader = new SharedWorkerScriptLoader(worker, port.release(), webWorker.release());
        loader->load(url);
#include "third_party/WebKit/public/web/WebLocalFrame.h"
  blink::WebLocalFrame* frame = context()->web_frame();
    blink::WebLocalFrame* frame,

namespace blink {
class WebLocalFrame;
}
      blink::WebLocalFrame* frame,
  script_context_set_.reset(
      new ScriptContextSet(&extensions_, &active_extension_ids_));
  ScriptContext* context = script_context_set_->Register(
      frame, v8_context, extension_group, world_id);
  if (context->context_type() == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(context->extension());
  switch (context->context_type()) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  ScriptContext* context = script_context_set_->GetByV8Context(v8_context);
  script_context_set_->Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  if (ScriptContext::IsSandboxedPage(
          extensions_, ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_->ForEach(
  script_context_set_->ForEach(
  MessagingBindings::DeliverMessage(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(*script_context_set_, port_id,
  std::set<ScriptContext*> removed_contexts =
      script_context_set_->OnExtensionUnloaded(id);
  for (ScriptContext* context : removed_contexts) {
    request_sender_->InvalidateSource(context);
#include "base/memory/scoped_ptr.h"
#include "extensions/common/extension.h"
    return *script_context_set_;
  scoped_ptr<ScriptContextSet> script_context_set_;
  ExtensionIdSet active_extension_ids_;
#include "third_party/WebKit/public/web/WebLocalFrame.h"
class CloseChannelSender {
 public:
  CloseChannelSender(int target_port_id)
      : port_created_(false), target_port_id_(target_port_id) {}

  void notify_port_created() { port_created_ = true; }

  ~CloseChannelSender() {
    if (!port_created_) {
      // If we didn't create a port, notify the other end of the channel (treat
      // it as a disconnect).
      content::RenderThread::Get()->Send(new ExtensionHostMsg_CloseChannel(
          target_port_id_, kReceivingEndDoesntExistError));
    }
  }

 private:
  bool port_created_;
  int target_port_id_;

  DISALLOW_COPY_AND_ASSIGN(CloseChannelSender);
};

    CloseChannelSender* close_channel_sender,
    if (retval->BooleanValue())
      close_channel_sender->notify_port_created();
                                   bool user_gesture,
  scoped_ptr<blink::WebScopedUserGesture> web_user_gesture;
  scoped_ptr<blink::WebScopedWindowFocusAllowedIndicator> allow_window_focus;
  if (user_gesture) {
    web_user_gesture.reset(new blink::WebScopedUserGesture);
    allow_window_focus.reset(new blink::WebScopedWindowFocusAllowedIndicator);
  }

  scoped_ptr<ExtensionMsg_TabConnectionInfo> source_copy(
      new ExtensionMsg_TabConnectionInfo());
  source_copy->tab.Swap(source.tab.DeepCopy());
  source_copy->frame_id = source.frame_id;
  context_set.RequestRunForEach(
      info.target_id, restrict_to_render_frame,
                 channel_name, base::Owned(source_copy.release()), info,
                 tls_channel_id,
                 base::Owned(new CloseChannelSender(target_port_id))));
  context_set.RequestRunForEach(
      restrict_to_render_frame,
      base::Bind(&DeliverMessageToScriptContext, message.data,
                 message.user_gesture, target_port_id));
  context_set.RequestRunForEach(
      restrict_to_render_frame,
#include "third_party/WebKit/public/web/WebLocalFrame.h"
  if (blink::WebLocalFrame* webframe = context->web_frame())
#include "extensions/common/constants.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
                             blink::WebLocalFrame* web_frame,
  gin::PerContextData* gin_data = gin::PerContextData::From(v8_context);
  CHECK(gin_data);  // may fail if the v8::Context hasn't been registered yet
  gin_data->set_runner(runner_.get());
// static
bool ScriptContext::IsSandboxedPage(const ExtensionSet& extensions,
                                    const GURL& url) {
  // TODO(kalman): This is checking for the wrong thing, it should be checking
  // if the frame's security origin is unique. The extension sandbox directive
  // is checked for in extensions/common/manifest_handlers/csp_info.cc.
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

class WebLocalFrame;
class ExtensionSet;
                blink::WebLocalFrame* frame,
  // Returns whether |url| is sandboxed (as declared in any Extension in
  // |extension_set| as sandboxed).
  //
  // Declared in ScriptContext for lack of a better place, but this should
  // become unnecessary at some point as crbug.com/466373 is worked on.
  static bool IsSandboxedPage(const ExtensionSet& extension_set,
                              const GURL& url);

  blink::WebLocalFrame* web_frame() const { return web_frame_; }
  //
  // TODO(kalman): Remove this and replace with a GetOrigin() call which reads
  // of WebDocument::securityOrigin():
  //  - The URL can change (e.g. pushState) but the origin cannot. Luckily it
  //    appears as though callers don't make security decisions based on the
  //    result of GetURL() so it's not a problem... yet.
  //  - Origin is the correct check to be making.
  //  - It might let us remove the about:blank resolving?
  // The WebLocalFrame associated with this context. This can be NULL because
  // this object can outlive is destroyed asynchronously.
  blink::WebLocalFrame* web_frame_;
#include "content/public/common/url_constants.h"
#include "content/public/renderer/render_frame.h"
#include "content/public/renderer/render_frame_observer.h"
#include "extensions/renderer/extension_groups.h"
#include "extensions/renderer/script_injection.h"
#include "third_party/WebKit/public/platform/WebSuspendableTask.h"
#include "third_party/WebKit/public/web/WebDocument.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
namespace {

// This class inherits content::RenderFrameObserver for tracking when render
// frame goes away.
class BlinkTaskRunner : public blink::WebSuspendableTask,
                        public content::RenderFrameObserver {
 public:
  BlinkTaskRunner(content::RenderFrame* render_frame,
                  ScriptContext* context,
                  const base::Callback<void(ScriptContext*)>& callback)
      : RenderFrameObserver(render_frame),
        context_(context),
        callback_(callback) {}

  void run() override {
    if (render_frame() && context_->is_valid())
      callback_.Run(context_);
  }

 private:
  ScriptContext* context_;
  base::Callback<void(ScriptContext*)> callback_;

  // Overriden to avoid being destroyed when RenderFrame goes away.
  // BlinkTaskRunner objects are owned by WebLocalFrame.
  void OnDestruct() override {}

  DISALLOW_COPY_AND_ASSIGN(BlinkTaskRunner);
};

// This class deletes ScriptContext on run or on contextDestoyed.
// It allows us to pass ScriptContext as raw pointer to BlinkTaskRunner.
// In ScriptContextSet::Remove method we mark the context as invalid, but
// don't delete the object until all scheduled tasks are finished.
class ScriptContextDeleter : public blink::WebSuspendableTask {
 public:
  explicit ScriptContextDeleter(ScriptContext* context) : context_(context) {}

  void run() override { delete context_; }
  void contextDestroyed() override { delete context_; }

 private:
  ScriptContext* context_;

  DISALLOW_COPY_AND_ASSIGN(ScriptContextDeleter);
};

}  // namespace

ScriptContextSet::ScriptContextSet(ExtensionSet* extensions,
                                   ExtensionIdSet* active_extension_ids)
    : extensions_(extensions), active_extension_ids_(active_extension_ids) {

ScriptContext* ScriptContextSet::Register(
    blink::WebLocalFrame* frame,
    const v8::Handle<v8::Context>& v8_context,
    int extension_group,
    int world_id) {
  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());
  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  contexts_.insert(context);  // takes ownership
  return context;
    content::RenderFrame* context_render_frame = context->GetRenderFrame();
    blink::WebLocalFrame* web_local_frame =
        context_render_frame ? context_render_frame->GetWebFrame() : nullptr;


    if (!web_local_frame)
      base::MessageLoop::current()->DeleteSoon(FROM_HERE, context);
    else
      web_local_frame->requestRunTask(new ScriptContextDeleter(context));
                              : nullptr;
  return calling.IsEmpty() ? nullptr : GetByV8Context(calling);
    const v8::Handle<v8::Context>& v8_context) const {
  for (ScriptContext* script_context : contexts_) {
    if (script_context->v8_context() == v8_context)
      return script_context;
  return nullptr;
}
void ScriptContextSet::ForEach(
    const std::string& extension_id,
    content::RenderView* restrict_to_render_view,
    const base::Callback<void(ScriptContext*)>& callback) const {
  ForEachImpl(extension_id, restrict_to_render_view, callback, false);
void ScriptContextSet::RequestRunForEach(
    content::RenderFrame* restrict_to_render_frame,
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  ForEachImpl(extension_id, restrict_to_render_view, callback, true);
}

std::set<ScriptContext*> ScriptContextSet::OnExtensionUnloaded(
    const std::string& extension_id) {
  std::set<ScriptContext*> removed;
  ForEach(extension_id,
          base::Bind(&ScriptContextSet::DispatchOnUnloadEventAndRemove,
                     base::Unretained(this), &removed));
  return removed;
}

const Extension* ScriptContextSet::GetExtensionFromFrameAndWorld(
    const blink::WebLocalFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.
    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_->GetExtensionOrAppIDByURL(frame_url);
  }

  // There are conditions where despite a context being associated with an
  // extension, no extension actually gets found. Ignore "invalid" because CSP
  // blocks extension page loading by switching the extension ID to "invalid".
  const Extension* extension = extensions_->GetByID(extension_id);
  if (!extension && !extension_id.empty() && extension_id != "invalid") {
    // TODO(kalman): Do something here?
  }
  return extension;
}

Feature::Context ScriptContextSet::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (ScriptContext::IsSandboxedPage(*extensions_, url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && active_extension_ids_->count(extension->id()) > 0) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of ScriptContext::IsSandboxedPage().
  if (!origin.isUnique() && extensions_->ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

void ScriptContextSet::DispatchOnUnloadEventAndRemove(
    std::set<ScriptContext*>* out,
    ScriptContext* context) {
  context->DispatchOnUnloadEvent();
  Remove(context);  // deleted asynchronously
  out->insert(context);
}

void ScriptContextSet::ForEachImpl(
    const std::string& extension_id,
    content::RenderView* restrict_to_render_view,
    const base::Callback<void(ScriptContext*)>& callback,
    bool run_asynchronously) const {
  std::set<ScriptContext*> contexts_copy = contexts_;
  for (ScriptContext* context : contexts_copy) {
    if (restrict_to_render_view &&
        restrict_to_render_view != context_render_view)
    content::RenderFrame* context_render_frame = context->GetRenderFrame();
    if (!context_render_frame)
      continue;
    if (run_asynchronously) {
      blink::WebLocalFrame* web_local_frame =
          context_render_frame->GetWebFrame();
      if (!web_local_frame)
        continue;
      // WebLocalFrame takes BlinkTaskRunner ownership.
      web_local_frame->requestRunTask(
          new BlinkTaskRunner(context_render_frame, context, callback));
    } else {
      callback.Run(context);
#include "base/macros.h"
#include "base/memory/weak_ptr.h"
#include "extensions/common/extension.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/features/feature.h"
#include "url/gurl.h"
namespace blink {
class WebLocalFrame;
class WebSecurityOrigin;
}

class RenderFrame;
// A container of ScriptContexts, responsible for both creating and managing
// them.
//
// Since calling JavaScript within a context can cause any number of contexts
// to be created or destroyed, this has additional smarts to help with the set
// changing underneath callers.
  ScriptContextSet(
      ExtensionSet* extensions,
      // Set of the IDs of extensions that are active in this process.
      // Must outlive this. TODO(kalman): Combine this and |extensions|.
      ExtensionIdSet* active_extension_ids);

  // Returns the number of contexts being tracked by this set.
  // This may also include invalid contexts. TODO(kalman): Useful?
  size_t size() const { return contexts_.size(); }
  // Creates and starts managing a new ScriptContext. Ownership is held.
  // Returns a weak reference to the new ScriptContext.
  ScriptContext* Register(blink::WebLocalFrame* frame,
                          const v8::Handle<v8::Context>& v8_context,
                          int extension_group,
                          int world_id);
  ScriptContext* GetByV8Context(const v8::Handle<v8::Context>& context) const;
  // |extension_id| in |restrict_to_render_view|.
  // An empty |extension_id| will match all extensions, and a NULL
  // |restrict_to_render_view| will match all render views, but try to use the
  // inline variants of these methods instead.
               content::RenderView* restrict_to_render_view,
  void ForEach(content::RenderView* restrict_to_render_view,
    ForEach("", restrict_to_render_view, callback);
  // Asynchronously runs |callback| with each ScriptContext that belongs to
  // |extension_id| in |restrict_to_render_frame|.
  // Running may be postponed if context is suspended.
  // If context or render frame is destroyed before context resumed then
  // |callback| won't be run.
  void RequestRunForEach(
      const std::string& extension_id,
      content::RenderFrame* restrict_to_render_frame,
      const base::Callback<void(ScriptContext*)>& callback) const;
  // RequestRunForEach matches all extensions.
  void RequestRunForEach(
      content::RenderFrame* restrict_to_render_frame,
      const base::Callback<void(ScriptContext*)>& callback) const {
    RequestRunForEach("", restrict_to_render_frame, callback);
  }
  // RequestRunForEach matches all render frames.
  void RequestRunForEach(
      const std::string& extension_id,
      const base::Callback<void(ScriptContext*)>& callback) const {
    RequestRunForEach(extension_id, nullptr, callback);
  }

  std::set<ScriptContext*> OnExtensionUnloaded(const std::string& extension_id);
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(
      const blink::WebLocalFrame* frame,
      int world_id,
      bool use_effective_url);

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  // Calls Remove on |context| then appends |context| to |out|.
  // This is a helper designed to be used by OnExtensionUnloaded with ForEach.
  void DispatchOnUnloadEventAndRemove(std::set<ScriptContext*>* out,
                                      ScriptContext* context);

  // Common implementation of ForEach methods.
  void ForEachImpl(const std::string& extension_id,
                   content::RenderView* restrict_to_render_view,
                   const base::Callback<void(ScriptContext*)>& callback,
                   bool run_asynchronously) const;

  // Weak reference to all installed Extensions.
  ExtensionSet* extensions_;

  // Weak reference to all installed Extensions that are also active in this
  // process.
  ExtensionIdSet* active_extension_ids_;

  // The set of all ScriptContexts we own.
  std::set<ScriptContext*> contexts_;
#include <vector>

#include "extensions/common/extension_set.h"
TEST(ScriptContextSetTest, Lifecycle) {
  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebLocalFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  // Do this after construction of the webview, since it may construct the
  // Isolate.

  v8::Local<v8::Context> v8_context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(v8_context);
  // ScriptContext relies on gin, it just doesn't look like it from here.
  context_holder.SetContext(v8_context);
  ExtensionSet extensions;
  ExtensionIdSet active_extensions;
  ScriptContextSet context_set(&extensions, &active_extensions);
  ScriptContext* context = context_set.Register(
      frame, v8_context, 0, 0);  // no extension group or world ID
  // Context is valid and resembles correctness.
  EXPECT_TRUE(context->is_valid());
  EXPECT_EQ(frame, context->web_frame());
  EXPECT_EQ(v8_context, context->v8_context());
  // Context has been correctly added.
  EXPECT_EQ(1u, context_set.size());
  EXPECT_EQ(context, context_set.GetByV8Context(v8_context));
  // Test context is correctly removed.
  EXPECT_EQ(0u, context_set.size());
  EXPECT_EQ(nullptr, context_set.GetByV8Context(v8_context));
  // After removal, the context should be invalid.
  EXPECT_FALSE(context->is_valid());
  EXPECT_EQ(nullptr, context->web_frame());
using blink::WebFrame;
  WebFrame* frame = context()->web_frame();
    WebFrame* frame,
#include "third_party/WebKit/public/web/WebFrame.h"
      blink::WebFrame* frame,
#include "extensions/common/extension.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "extensions/renderer/extension_groups.h"
const Extension* Dispatcher::GetExtensionFromFrameAndWorld(
    const blink::WebFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.

    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_.GetExtensionOrAppIDByURL(frame_url);
  }

  const Extension* extension = extensions_.GetByID(extension_id);
  if (!extension && !extension_id.empty()) {
    // There are conditions where despite a context being associated with an
    // extension, no extension actually gets found.  Ignore "invalid" because
    // CSP blocks extension page loading by switching the extension ID to
    // "invalid". This isn't interesting.
    if (extension_id != "invalid") {
      LOG(ERROR) << "Extension \"" << extension_id << "\" not found";
      RenderThread::Get()->RecordAction(
          UserMetricsAction("ExtensionNotFound_ED"));
    }
  }
  return extension;
}

  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());

  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  script_context_set_.Add(context);
  if (context_type == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(extension);
  switch (context_type) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  ScriptContext* context = script_context_set_.GetByV8Context(v8_context);
  script_context_set_.Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_.size();
  if (IsSandboxedPage(ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_.ForEach(
  script_context_set_.ForEach(
  MessagingBindings::DeliverMessage(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(script_context_set_, port_id,
  ScriptContextSet::ContextSet removed_contexts =
      script_context_set_.OnExtensionUnloaded(id);
  for (ScriptContextSet::ContextSet::iterator it = removed_contexts.begin();
       it != removed_contexts.end(); ++it) {
    request_sender_->InvalidateSource(*it);
// TODO(kalman): This is checking for the wrong thing, it should be checking if
// the frame's security origin is unique. The extension sandbox directive is
// checked for in extensions/common/manifest_handlers/csp_info.cc.
bool Dispatcher::IsSandboxedPage(const GURL& url) const {
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions_.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

Feature::Context Dispatcher::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (IsSandboxedPage(url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && IsExtensionActive(extension->id())) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of IsSandboxedPage().
  if (!origin.isUnique() && extensions_.ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

class Extension;
    return script_context_set_;
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(const blink::WebFrame* frame,
                                                 int world_id,
                                                 bool use_effective_url);

  // Forwarded from the RenderFrameObserver events by ExtensionFrameHelper.
  bool IsSandboxedPage(const GURL& url) const;

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  ScriptContextSet script_context_set_;
  std::set<std::string> active_extension_ids_;
#include "third_party/WebKit/public/web/WebFrame.h"
#include "third_party/WebKit/public/web/WebFrame.h"
  if (blink::WebFrame* webframe = context->web_frame())
                             blink::WebFrame* web_frame,
  gin::PerContextData::From(v8_context)->set_runner(runner_.get());
                blink::WebFrame* frame,
  blink::WebFrame* web_frame() const { return web_frame_; }
  // The WebFrame associated with this context. This can be NULL because this
  // object can outlive is destroyed asynchronously.
  blink::WebFrame* web_frame_;
ScriptContextSet::ScriptContextSet() {
}
ScriptContextSet::~ScriptContextSet() {
int ScriptContextSet::size() const {
  return static_cast<int>(contexts_.size());
void ScriptContextSet::Add(ScriptContext* context) {
#if DCHECK_IS_ON()
  // It's OK to insert the same context twice, but we should only ever have
  // one ScriptContext per v8::Context.
  for (ContextSet::iterator iter = contexts_.begin(); iter != contexts_.end();
       ++iter) {
    ScriptContext* candidate = *iter;
    if (candidate != context)
      DCHECK(candidate->v8_context() != context->v8_context());
  }
#endif
  contexts_.insert(context);
ScriptContextSet::ContextSet ScriptContextSet::GetAll() const {
  return contexts_;
}

                              : NULL;
  return calling.IsEmpty() ? NULL : GetByV8Context(calling);
    v8::Handle<v8::Context> v8_context) const {
  for (ContextSet::const_iterator iter = contexts_.begin();
       iter != contexts_.end(); ++iter) {
    if ((*iter)->v8_context() == v8_context)
      return *iter;

  return NULL;
  ContextSet contexts = GetAll();

  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    ScriptContext* context = *it;
ScriptContextSet::ContextSet ScriptContextSet::OnExtensionUnloaded(
  ContextSet contexts = GetAll();
  ContextSet removed;

  // Clean up contexts belonging to the unloaded extension. This is done so
  // that content scripts (which remain injected into the page) don't continue
  // receiving events and sending messages.
  for (ContextSet::iterator it = contexts.begin(); it != contexts.end(); ++it) {
    if ((*it)->extension() && (*it)->extension()->id() == extension_id) {
      (*it)->DispatchOnUnloadEvent();
      removed.insert(*it);
      Remove(*it);
    }
  return removed;
#include "base/basictypes.h"
#include "base/bind.h"
namespace content {
class RenderView;
namespace v8 {
class Context;
// A container of ExtensionBindingsContext. Since calling JavaScript within a
// context can cause any number of contexts to be created or destroyed, this
// has additional smarts to help with the set changing underneath callers.
  ScriptContextSet();
  int size() const;
  // Takes ownership of |context|.
  void Add(ScriptContext* context);
  // Returns a copy to protect against changes.
  typedef std::set<ScriptContext*> ContextSet;
  ContextSet GetAll() const;

  ScriptContext* GetByV8Context(v8::Handle<v8::Context> context) const;
  ContextSet OnExtensionUnloaded(const std::string& extension_id);
  ContextSet contexts_;
#include "third_party/WebKit/public/web/WebFrame.h"
TEST(ScriptContextSet, Lifecycle) {
  ScriptContextSet context_set;
  context_holder.SetContext(v8::Context::New(isolate));

  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  const Extension* extension = NULL;
  ScriptContext* context =
      new ScriptContext(context_holder.context(), frame, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT, extension,
                        Feature::BLESSED_EXTENSION_CONTEXT);
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  EXPECT_EQ(context, context_set.GetByV8Context(context->v8_context()));
  // Adding the same item multiple times should be OK and deduped.
  context_set.Add(context);
  EXPECT_EQ(1u, context_set.GetAll().count(context));
  // GetAll() returns a copy so removing from one should not remove from others.
  ScriptContextSet::ContextSet set_copy = context_set.GetAll();
  EXPECT_EQ(1u, set_copy.count(context));
  EXPECT_EQ(0, context_set.size());
  EXPECT_FALSE(context_set.GetByV8Context(context->v8_context()));
  EXPECT_EQ(1u, set_copy.size());
  base::PlatformFile file =
      base::CreatePlatformFile(path,
                               base::PLATFORM_FILE_OPEN |
                               base::PLATFORM_FILE_WRITE_ATTRIBUTES,
                               NULL, NULL);
#ifndef OS_WIN
    // TODO(nhiroki): Support Windows (http://crbug.com/137807).
#endif
static bool schemeRequiresAuthority(const String& scheme)
    DEFINE_STATIC_LOCAL(URLSchemesMap, schemes, ());
    if (schemes.isEmpty()) {
        schemes.add("http");
        schemes.add("https");
        schemes.add("ftp");
    return schemes.contains(scheme);
SecurityOrigin::SecurityOrigin(const KURL& url, bool forceUnique)
    , m_isUnique(forceUnique || SchemeRegistry::shouldTreatURLSchemeAsNoAccess(m_protocol))
    , m_needsStorageIdentifierQuirkForFiles(false)
#if ENABLE(BLOB) || ENABLE(FILE_SYSTEM)
    bool isBlobOrFileSystemProtocol = false;
#if ENABLE(BLOB)
    if (m_protocol == BlobURL::blobProtocol())
        isBlobOrFileSystemProtocol = true;
#endif
#if ENABLE(FILE_SYSTEM)
    if (m_protocol == "filesystem")
        isBlobOrFileSystemProtocol = true;
#endif
    if (isBlobOrFileSystemProtocol) {
        KURL originURL(ParsedURLString, decodeURLEscapeSequences(url.path()));
        if (originURL.isValid()) {
            m_protocol = originURL.protocol().lower();
            m_host = originURL.host().lower();
            m_port = originURL.port();
        } else
            m_isUnique = true;
    }
#endif

    // For edge case URLs that were probably misparsed, make sure that the origin is unique.
    if (schemeRequiresAuthority(m_protocol) && m_host.isEmpty())
        m_isUnique = true;

    if (m_protocol.isEmpty())
        m_isUnique = true;
    // By default, only local SecurityOrigins can load local resources.
    m_canLoadLocalResources = isLocal();
    if (m_canLoadLocalResources) {
        // Directories should never be readable.
        // Note that we do not do this check for blob or filesystem url because its origin is file:/// when it is created from local file urls.
#if ENABLE(BLOB) || ENABLE(FILE_SYSTEM)
        bool doDirectoryCheck = !isBlobOrFileSystemProtocol;
#else
        bool doDirectoryCheck = true;
#endif
        if (doDirectoryCheck && (!url.hasPath() || url.path().endsWith("/")))
            m_isUnique = true;
        // Store the path in case we are doing per-file origin checking.
        m_filePath = url.path();
    }

    if (m_protocol == "file")
        m_needsStorageIdentifierQuirkForFiles = true;
    // Don't leak details from URLs into unique origins.
    if (m_isUnique) {
        m_protocol = "";
        m_host = "";
        m_port = InvalidPort;
    }
    , m_needsStorageIdentifierQuirkForFiles(other->m_needsStorageIdentifierQuirkForFiles)
    if (!url.isValid())
        return adoptRef(new SecurityOrigin(blankURL(), forceUnique));
    return adoptRef(new SecurityOrigin(url, forceUnique));
    RefPtr<SecurityOrigin> origin = create(KURL());
    if (m_needsStorageIdentifierQuirkForFiles)
    explicit SecurityOrigin(const KURL&, bool forceUnique);
    bool m_needsStorageIdentifierQuirkForFiles;
    if (m_documentLoader)
    return m_frame->page() && NavigationDisablerForBeforeUnload::isNavigationAllowed();
    return m_frame->page() && (protocolIsJavaScript(url) || NavigationDisablerForBeforeUnload::isNavigationAllowed());

// The maximum volume for a PCM device on windows. Volume is logarithmic so the
// perceived volume increase sounds linear.
const double kMaxVolumeLevel = 65535.0;

      buffer_size_(0) {
    QueueNextPacket(buffer);
                                            double right_level) {
  uint16 left = static_cast<uint16>(left_level * kMaxVolumeLevel);
  uint16 right = static_cast<uint16>(right_level * kMaxVolumeLevel);
  DWORD volume_packed = MAKELONG(left, right);
  MMRESULT res = ::waveOutSetVolume(waveout_, volume_packed);
  if (res != MMSYSERR_NOERROR) {
    HandleError(res);
    return;
  }
  DWORD volume_packed = 0;
  MMRESULT res = ::waveOutGetVolume(waveout_, &volume_packed);
  if (res != MMSYSERR_NOERROR) {
    HandleError(res);
    return;
  }
  *left_level = static_cast<double>(LOWORD(volume_packed)) / kMaxVolumeLevel;
  *right_level = static_cast<double>(HIWORD(volume_packed)) / kMaxVolumeLevel;
#ifndef MEDIA_AUDIO_WAVEOUT_OUTPUT_WIN_H_
#define MEDIA_AUDIO_WAVEOUT_OUTPUT_WIN_H_
#endif  // MEDIA_AUDIO_WAVEOUT_OUTPUT_WIN_H_
  base::strlcpy(top_dir, utf8_path, sizeof(top_dir));
bool CopyTree(const std::wstring& from_path, const std::wstring& to_path) {
  // TODO(erikkay): implement
  return false;
// TODO(erikkay): implement
#if defined(OS_WIN)
#endif
    std::wstring* url, std::wstring* title) {
  if (SUCCEEDED(data_object->GetData(GetFilenameWFormat(), &store))) {
    bool success = false;
    {
      // filename using unicode
      ScopedHGlobal<wchar_t> data(store.hGlobal);
      if (data.get() && data.get()[0] &&
          (PathFileExists(data.get()) || PathIsUNC(data.get()))) {
        wchar_t file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathW(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(file_url);
          title->assign(file_url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }

  if (SUCCEEDED(data_object->GetData(GetFilenameFormat(), &store))) {
    bool success = false;
    {
      // filename using ascii
      ScopedHGlobal<char> data(store.hGlobal);
      if (data.get() && data.get()[0] && (PathFileExistsA(data.get()) ||
                                          PathIsUNCA(data.get()))) {
        char file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathA(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(UTF8ToWide(file_url));
          title->assign(*url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;

  return false;
  return GetUrl(data_object, plain_text, &title);
      std::wstring* url, std::wstring* title);
  bool success = ClipboardUtil::GetUrl(source_object_, &url_str, title);
      ClipboardUtil::GetUrl(data_object, &url, &title);
  if (ClipboardUtil::GetUrl(data_object, &url_str, &drop_data->url_title)) {
    std::wstring* url, std::wstring* title) {
  if (SUCCEEDED(data_object->GetData(GetFilenameWFormat(), &store))) {
    bool success = false;
    {
      // filename using unicode
      ScopedHGlobal<wchar_t> data(store.hGlobal);
      if (data.get() && data.get()[0] &&
          (PathFileExists(data.get()) || PathIsUNC(data.get()))) {
        wchar_t file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathW(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(file_url);
          title->assign(file_url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }

  if (SUCCEEDED(data_object->GetData(GetFilenameFormat(), &store))) {
    bool success = false;
    {
      // filename using ascii
      ScopedHGlobal<char> data(store.hGlobal);
      if (data.get() && data.get()[0] && (PathFileExistsA(data.get()) ||
                                          PathIsUNCA(data.get()))) {
        char file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathA(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(UTF8ToWide(file_url));
          title->assign(*url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;

  return false;
  return GetUrl(data_object, plain_text, &title);
      std::wstring* url, std::wstring* title);
  bool success = ClipboardUtil::GetUrl(source_object_, &url_str, title);
      ClipboardUtil::GetUrl(data_object, &url, &title);
  if (ClipboardUtil::GetUrl(data_object, &url_str, &drop_data->url_title)) {
#include "chrome/browser/webui/options/options_managed_banner_handler.h"
#include "chrome/browser/webui/options/core_options_handler.h"
#include "chrome/browser/webui/options/language_options_handler.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/content_settings_handler.h"
#include "chrome/browser/webui/options/about_page_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_ABOUT_PAGE_HANDLER_H_
#include "chrome/browser/webui/options/add_startup_page_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_ADD_STARTUP_PAGE_HANDLER_H_
#include "chrome/browser/webui/options/advanced_options_handler.h"
#include "chrome/browser/webui/options/dom_options_util.h"
#include "chrome/browser/webui/options/options_managed_banner_handler.h"
#include "chrome/browser/webui/options/advanced_options_utils.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_HANDLER_H_
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_ADVANCED_OPTIONS_UTILS_H_
#include "chrome/browser/webui/options/advanced_options_utils.h"
#include "chrome/browser/webui/options/advanced_options_utils.h"
#include "chrome/browser/webui/options/autofill_options_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_AUTOFILL_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/browser_options_handler.h"
#include "chrome/browser/webui/options/dom_options_util.h"
#include "chrome/browser/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_BROWSER_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/certificate_manager_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_CERTIFICATE_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/clear_browser_data_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_CLEAR_BROWSER_DATA_HANDLER_H_
#include "chrome/browser/webui/options/content_settings_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_CONTENT_SETTINGS_HANDLER_H_
#include "chrome/browser/webui/options/cookies_view_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_COOKIES_VIEW_HANDLER_H_
#include "chrome/browser/webui/options/core_options_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_CORE_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/dom_options_util.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_DOM_OPTIONS_UTIL_H_
#include "chrome/browser/webui/options/font_settings_handler.h"
#include "chrome/browser/webui/options/dom_options_util.h"
#include "chrome/browser/webui/options/font_settings_utils.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_HANDLER_H_
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_FONT_SETTINGS_UTILS_H_
#include "chrome/browser/webui/options/font_settings_utils.h"
#include "chrome/browser/webui/options/font_settings_utils.h"
#include "chrome/browser/webui/options/import_data_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_IMPORT_DATA_HANDLER_H_
#include "chrome/browser/webui/options/language_options_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/language_options_handler_common.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/language_options_handler_common.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_LANGUAGE_OPTIONS_HANDLER_COMMON_H_
#include "chrome/browser/webui/options/language_options_handler.h"
#include "chrome/browser/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_MANAGED_BANNER_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#include "chrome/browser/webui/options/about_page_handler.h"
#include "chrome/browser/webui/options/add_startup_page_handler.h"
#include "chrome/browser/webui/options/advanced_options_handler.h"
#include "chrome/browser/webui/options/autofill_options_handler.h"
#include "chrome/browser/webui/options/browser_options_handler.h"
#include "chrome/browser/webui/options/clear_browser_data_handler.h"
#include "chrome/browser/webui/options/content_settings_handler.h"
#include "chrome/browser/webui/options/cookies_view_handler.h"
#include "chrome/browser/webui/options/core_options_handler.h"
#include "chrome/browser/webui/options/dom_options_util.h"
#include "chrome/browser/webui/options/font_settings_handler.h"
#include "chrome/browser/webui/options/import_data_handler.h"
#include "chrome/browser/webui/options/language_options_handler.h"
#include "chrome/browser/webui/options/password_manager_handler.h"
#include "chrome/browser/webui/options/personal_options_handler.h"
#include "chrome/browser/webui/options/search_engine_manager_handler.h"
#include "chrome/browser/webui/options/stop_syncing_handler.h"
#include "chrome/browser/webui/options/certificate_manager_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_UI_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_UI_H_
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_OPTIONS_UI_H_
#include "chrome/browser/webui/options/password_manager_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_PASSWORD_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/personal_options_handler.h"
#include "chrome/browser/webui/options/dom_options_util.h"
#include "chrome/browser/webui/options/options_managed_banner_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_PERSONAL_OPTIONS_HANDLER_H_
#include "chrome/browser/webui/options/search_engine_manager_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_SEARCH_ENGINE_MANAGER_HANDLER_H_
#include "chrome/browser/webui/options/stop_syncing_handler.h"
#ifndef CHROME_BROWSER_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#define CHROME_BROWSER_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#include "chrome/browser/webui/options/options_ui.h"
#endif  // CHROME_BROWSER_WEBUI_OPTIONS_STOP_SYNCING_HANDLER_H_
#include "chrome/browser/webui/options/core_options_handler.h"
#include "chrome/browser/webui/options/options_ui.h"
// static
uint64 SpdyIOBuffer::order_ = 0;
SpdyIOBuffer::SpdyIOBuffer(
    IOBuffer* buffer, int size, RequestPriority priority, SpdyStream* stream)
  : buffer_(new DrainableIOBuffer(buffer, size)),
    priority_(priority),
    position_(++order_),
    stream_(stream) {}

SpdyIOBuffer::SpdyIOBuffer() : priority_(HIGHEST), position_(0), stream_(NULL) {
}
  priority_ = rhs.priority_;
  position_ = rhs.position_;
  priority_ = rhs.priority_;
  position_ = rhs.position_;
void SpdyIOBuffer::release() {
#include "net/base/request_priority.h"
// A class for managing SPDY IO buffers.  These buffers need to be prioritized
// so that the SpdySession sends them in the right order.  Further, they need
// to track the SpdyStream which they are associated with so that incremental
// completion of the IO can notify the appropriate stream of completion.
  // |priority| is the priority of this buffer.
  // |stream| is a pointer to the stream which is managing this buffer.
  SpdyIOBuffer(IOBuffer* buffer, int size, RequestPriority priority,
               SpdyStream* stream);
  SpdyIOBuffer();
  size_t size() const { return buffer_->size(); }
  void release();
  RequestPriority priority() const { return priority_; }
  // Comparison operator to support sorting.
  bool operator<(const SpdyIOBuffer& other) const {
    if (priority_ != other.priority_)
      return priority_ < other.priority_;
    return position_ > other.position_;
  }

  RequestPriority priority_;
  uint64 position_;
  static uint64 order_;  // Maintains a FIFO order for equal priorities.
// static
void SpdySession::SpdyIOBufferProducer::ActivateStream(
    SpdySession* spdy_session,
    SpdyStream* spdy_stream) {
  spdy_session->ActivateStream(spdy_stream);
}

// static
SpdyIOBuffer* SpdySession::SpdyIOBufferProducer::CreateIOBuffer(
    SpdyFrame* frame,
    RequestPriority priority,
    SpdyStream* stream) {
  size_t size = frame->size();
  DCHECK_GT(size, 0u);

  // TODO(mbelshe): We have too much copying of data here.
  IOBufferWithSize* buffer = new IOBufferWithSize(size);
  memcpy(buffer->data(), frame->data(), size);

  return new SpdyIOBuffer(buffer, size, priority, stream);
}

  for (int i = NUM_PRIORITIES - 1; i >= MINIMUM_PRIORITY; --i) {
void SpdySession::SetStreamHasWriteAvailable(SpdyStream* stream,
                                             SpdyIOBufferProducer* producer) {
  write_queue_.push(producer);
  stream_producers_[producer] = stream;
  WriteSocketLater();
}

SpdyFrame* SpdySession::CreateSynStream(
  return syn_frame.release();
SpdyFrame* SpdySession::CreateCredentialFrame(
    RequestPriority priority) {
  DCHECK_EQ(OK, rv);
    return NULL;
  scoped_ptr<SpdyFrame> credential_frame(
  return credential_frame.release();
SpdyFrame* SpdySession::CreateHeadersFrame(
  return frame.release();
SpdyFrame* SpdySession::CreateDataFrame(SpdyStreamId stream_id,
                                        net::IOBuffer* data, int len,
                                        SpdyDataFlags flags) {
    return NULL;
      return NULL;
        return NULL;
  return frame.release();
  QueueFrame(rst_frame.release(), priority);
  DCHECK(in_flight_write_.size());
  scoped_refptr<SpdyStream> stream = in_flight_write_.stream();

  if (result >= 0) {
    // It should not be possible to have written more bytes than our
    // in_flight_write_.
    DCHECK_LE(result, in_flight_write_.buffer()->BytesRemaining());

    in_flight_write_.buffer()->DidConsume(result);

    // We only notify the stream when we've fully written the pending frame.
    if (!in_flight_write_.buffer()->BytesRemaining()) {
      if (stream) {
        // Report the number of bytes written to the caller, but exclude the
        // frame size overhead.  NOTE: if this frame was compressed the
        // reported bytes written is the compressed size, not the original
        // size.
        if (result > 0) {
          result = in_flight_write_.buffer()->size();
          DCHECK_GE(result,
                    static_cast<int>(
                        buffered_spdy_framer_->GetControlFrameHeaderSize()));
          result -= buffered_spdy_framer_->GetControlFrameHeaderSize();
        }

        // It is possible that the stream was cancelled while we were writing
        // to the socket.
        if (!stream->cancelled())
          stream->OnWriteComplete(result);
      }
      // Cleanup the write which just completed.
      in_flight_write_.release();
    }
    // Write more data.  We're already in a continuation, so we can
    // go ahead and write it immediately (without going back to the
    // message loop).
    WriteSocketLater();
  } else {
    in_flight_write_.release();
    // The stream is now errored.  Close it down.
    CloseSessionOnError(
        static_cast<net::Error>(result), true, "The stream has errored.");
  while (in_flight_write_.buffer() || !write_queue_.empty()) {
    if (!in_flight_write_.buffer()) {
      // Grab the next SpdyBuffer to send.
      scoped_ptr<SpdyIOBufferProducer> producer(write_queue_.top());
      write_queue_.pop();
      scoped_ptr<SpdyIOBuffer> buffer(producer->ProduceNextBuffer(this));
      stream_producers_.erase(producer.get());
      if (buffer == NULL)
      in_flight_write_ = *buffer;
    } else {
      DCHECK(in_flight_write_.buffer()->BytesRemaining());
  // We also need to drain the queue.
  while (!write_queue_.empty()) {
    scoped_ptr<SpdyIOBufferProducer> producer(write_queue_.top());
    write_queue_.pop();
    stream_producers_.erase(producer.get());
  }
class SimpleSpdyIOBufferProducer : public SpdySession::SpdyIOBufferProducer {
 public:
  SimpleSpdyIOBufferProducer(SpdyFrame* frame,
                             RequestPriority priority)
      : frame_(frame),
        priority_(priority) {
  }

  virtual RequestPriority GetPriority() const OVERRIDE {
    return priority_;
  }

  virtual SpdyIOBuffer* ProduceNextBuffer(SpdySession* session) OVERRIDE {
    return SpdySession::SpdyIOBufferProducer::CreateIOBuffer(
        frame_.get(), priority_, NULL);
  }

 private:
  scoped_ptr<SpdyFrame> frame_;
  RequestPriority priority_;
};
void SpdySession::QueueFrame(SpdyFrame* frame,
                             RequestPriority priority) {
  SimpleSpdyIOBufferProducer* producer =
      new SimpleSpdyIOBufferProducer(frame, priority);
  write_queue_.push(producer);
    PushedStreamMap::iterator it;
    for (it = unclaimed_pushed_streams_.begin();
  ActiveStreamMap::iterator it2 = active_streams_.find(id);
  if (it2 == active_streams_.end())
  // Possibly remove from the write queue.
  WriteQueue old = write_queue_;
  write_queue_ = WriteQueue();
  while (!old.empty()) {
    scoped_ptr<SpdyIOBufferProducer> producer(old.top());
    old.pop();
    StreamProducerMap::iterator it = stream_producers_.find(producer.get());
    if (it == stream_producers_.end() || it->second->stream_id() != id) {
      write_queue_.push(producer.release());
    } else {
      stream_producers_.erase(producer.get());
      producer.reset(NULL);
    }
  }
  const scoped_refptr<SpdyStream> stream(it2->second);
  active_streams_.erase(it2);
  DCHECK(stream);
  QueueFrame(settings_frame.release(), HIGHEST);
  QueueFrame(window_update_frame.release(), priority);
  QueueFrame(ping_frame.release(), HIGHEST);
#include <list>
#include <queue>
  // Defines an interface for producing SpdyIOBuffers.
  class NET_EXPORT_PRIVATE SpdyIOBufferProducer {
   public:
    SpdyIOBufferProducer() {}

    // Returns a newly created SpdyIOBuffer, owned by the caller, or NULL
    // if not buffer is ready to be produced.
    virtual SpdyIOBuffer* ProduceNextBuffer(SpdySession* session) = 0;

    virtual RequestPriority GetPriority() const = 0;

    virtual ~SpdyIOBufferProducer() {}

   protected:
    // Activates |spdy_stream| in |spdy_session|.
    static void ActivateStream(SpdySession* spdy_session,
                               SpdyStream* spdy_stream);

    static SpdyIOBuffer* CreateIOBuffer(SpdyFrame* frame,
                                        RequestPriority priority,
                                        SpdyStream* spdy_stream);
  };

  // Records that |stream| has a write available from |producer|.
  // |producer| will be owned by this SpdySession.
  void SetStreamHasWriteAvailable(SpdyStream* stream,
                                  SpdyIOBufferProducer* producer);
  // Send the SYN frame for |stream_id|. This also sends PING message to check
  // the status of the connection.
  SpdyFrame* CreateSynStream(
  // Write a CREDENTIAL frame to the session.
  SpdyFrame* CreateCredentialFrame(const std::string& origin,
                                   SSLClientCertType type,
                                   const std::string& key,
                                   const std::string& cert,
                                   RequestPriority priority);

  // Write a HEADERS frame to the stream.
  SpdyFrame* CreateHeadersFrame(SpdyStreamId stream_id,
                                const SpdyHeaderBlock& headers,
                                SpdyControlFlags flags);

  // Write a data frame to the stream.
  // Used to create and queue a data frame for the given stream.
  SpdyFrame* CreateDataFrame(SpdyStreamId stream_id,
                             net::IOBuffer* data, int len,
                             SpdyDataFlags flags);
  typedef std::map<SpdyIOBufferProducer*, SpdyStream*> StreamProducerMap;

  class SpdyIOBufferProducerCompare {
   public:
    bool operator() (const SpdyIOBufferProducer* lhs,
                     const SpdyIOBufferProducer* rhs) const {
      return lhs->GetPriority() < rhs->GetPriority();
    }
  };

  typedef std::priority_queue<SpdyIOBufferProducer*,
                              std::vector<SpdyIOBufferProducer*>,
                              SpdyIOBufferProducerCompare> WriteQueue;
  // Queue a frame for sending.
  // |frame| is the frame to send.
  // |priority| is the priority for insertion into the queue.
  void QueueFrame(SpdyFrame* frame, RequestPriority priority);
  // As streams have data to be sent, we put them into the write queue.
  WriteQueue write_queue_;

  // Mapping from SpdyIOBufferProducers to their corresponding SpdyStream
  // so that when a stream is destroyed, we can remove the corresponding
  // producer from |write_queue_|.
  StreamProducerMap stream_producers_;
// Test the SpdyIOBuffer class.
TEST_F(SpdySessionSpdy2Test, SpdyIOBuffer) {
  std::priority_queue<SpdyIOBuffer> queue_;
  const size_t kQueueSize = 100;

  // Insert items with random priority and increasing buffer size.
  for (size_t index = 0; index < kQueueSize; ++index) {
    queue_.push(SpdyIOBuffer(
        new IOBufferWithSize(index + 1),
        index + 1,
        static_cast<RequestPriority>(rand() % NUM_PRIORITIES),
        NULL));
  }

  EXPECT_EQ(kQueueSize, queue_.size());

  // Verify items come out with decreasing priority or FIFO order.
  RequestPriority last_priority = NUM_PRIORITIES;
  size_t last_size = 0;
  for (size_t index = 0; index < kQueueSize; ++index) {
    SpdyIOBuffer buffer = queue_.top();
    EXPECT_LE(buffer.priority(), last_priority);
    if (buffer.priority() < last_priority)
      last_size = 0;
    EXPECT_LT(last_size, buffer.size());
    last_priority = buffer.priority();
    last_size = buffer.size();
    queue_.pop();
  }

  EXPECT_EQ(0u, queue_.size());
}

// Test the SpdyIOBuffer class.
TEST_F(SpdySessionSpdy3Test, SpdyIOBuffer) {
  std::priority_queue<SpdyIOBuffer> queue_;
  const size_t kQueueSize = 100;

  // Insert items with random priority and increasing buffer size.
  for (size_t index = 0; index < kQueueSize; ++index) {
    queue_.push(SpdyIOBuffer(
        new IOBufferWithSize(index + 1),
        index + 1,
        static_cast<RequestPriority>(rand() % NUM_PRIORITIES),
        NULL));
  }

  EXPECT_EQ(kQueueSize, queue_.size());

  // Verify items come out with decreasing priority or FIFO order.
  RequestPriority last_priority = NUM_PRIORITIES;
  size_t last_size = 0;
  for (size_t index = 0; index < kQueueSize; ++index) {
    SpdyIOBuffer buffer = queue_.top();
    EXPECT_LE(buffer.priority(), last_priority);
    if (buffer.priority() < last_priority)
      last_size = 0;
    EXPECT_LT(last_size, buffer.size());
    last_priority = buffer.priority();
    last_size = buffer.size();
    queue_.pop();
  }

  EXPECT_EQ(0u, queue_.size());
}

class SpdyStream::SpdyStreamIOBufferProducer
    : public SpdySession::SpdyIOBufferProducer {
 public:
  SpdyStreamIOBufferProducer(SpdyStream* stream) : stream_(stream) {}

  // SpdyFrameProducer
  virtual RequestPriority GetPriority() const OVERRIDE {
    return stream_->priority();
  }

  virtual SpdyIOBuffer* ProduceNextBuffer(SpdySession* session) OVERRIDE {
    if (stream_->cancelled())
      return NULL;
    if (stream_->stream_id() == 0)
      SpdySession::SpdyIOBufferProducer::ActivateStream(session, stream_);
    frame_ = stream_->ProduceNextFrame();
    return frame_ == NULL ? NULL :
        SpdySession::SpdyIOBufferProducer::CreateIOBuffer(
            frame_.get(), GetPriority(), stream_);
  }

 private:
  scoped_refptr<SpdyStream> stream_;
  scoped_ptr<SpdyFrame> frame_;
};

void SpdyStream::SetHasWriteAvailable() {
  session_->SetStreamHasWriteAvailable(this,
                                       new SpdyStreamIOBufferProducer(this));
}

scoped_ptr<SpdyFrame> SpdyStream::ProduceNextFrame() {
  if (io_state_ == STATE_SEND_DOMAIN_BOUND_CERT_COMPLETE) {
    CHECK(request_.get());
    CHECK_GT(stream_id_, 0u);

    std::string origin = GetUrl().GetOrigin().spec();
    DCHECK(origin[origin.length() - 1] == '/');
    origin.erase(origin.length() - 1);  // Trim trailing slash.
    scoped_ptr<SpdyFrame> frame(session_->CreateCredentialFrame(
        origin, domain_bound_cert_type_, domain_bound_private_key_,
        domain_bound_cert_, priority_));
    return frame.Pass();
  } else if (io_state_ == STATE_SEND_HEADERS_COMPLETE) {
    CHECK(request_.get());
    CHECK_GT(stream_id_, 0u);

    SpdyControlFlags flags =
        has_upload_data_ ? CONTROL_FLAG_NONE : CONTROL_FLAG_FIN;
    scoped_ptr<SpdyFrame> frame(session_->CreateSynStream(
        stream_id_, priority_, slot_, flags, *request_));
    send_time_ = base::TimeTicks::Now();
    return frame.Pass();
  } else {
    CHECK(!cancelled());
    // We must need to write stream data.
    // Until the headers have been completely sent, we can not be sure
    // that our stream_id is correct.
    DCHECK_GT(io_state_, STATE_SEND_HEADERS_COMPLETE);
    DCHECK_GT(stream_id_, 0u);
    DCHECK(!pending_frames_.empty());

    PendingFrame frame = pending_frames_.front();
    pending_frames_.pop_front();

    waiting_completions_.push_back(frame.type);

    if (frame.type == TYPE_DATA) {
      // Send queued data frame.
      return scoped_ptr<SpdyFrame>(frame.data_frame);
    } else {
      DCHECK(frame.type == TYPE_HEADERS);
      // Create actual HEADERS frame just in time because it depends on
      // compression context and should not be reordered after the creation.
      scoped_ptr<SpdyFrame> header_frame(session_->CreateHeadersFrame(
          stream_id_, *frame.header_block, SpdyControlFlags()));
      delete frame.header_block;
      return header_frame.Pass();
    }
  }
  NOTREACHED();
}

  while (!pending_frames_.empty()) {
    PendingFrame frame = pending_frames_.back();
    pending_frames_.pop_back();
    if (frame.type == TYPE_DATA)
      delete frame.data_frame;
    else
      delete frame.header_block;
  }
  PendingFrame frame;
  frame.type = TYPE_HEADERS;
  // |frame.header_block| is deleted by either ProduceNextFrame() or
  // the destructor.
  frame.header_block = headers.release();
  pending_frames_.push_back(frame);
  SetHasWriteAvailable();
  PendingFrame frame;
  frame.type = TYPE_DATA;
  // |frame.data_frame| is either returned by ProduceNextFrame() or
  // deleted in the destructor.
  frame.data_frame = data_frame.release();
  pending_frames_.push_back(frame);
  SetHasWriteAvailable();
      // OnDataReceived, OnClose and OnWriteCompelte can be called.
  SetHasWriteAvailable();

  SetHasWriteAvailable();
#include <list>
  // Structure to contains pending frame information.
  typedef struct {
    FrameType type;
    union {
      SpdyHeaderBlock* header_block;
      SpdyFrame* data_frame;
    };
  } PendingFrame;

  class SpdyStreamIOBufferProducer;
  // Informs the SpdySession that this stream has a write available.
  void SetHasWriteAvailable();
  // Returns a newly created SPDY frame owned by the called that contains
  // the next frame to be sent by this frame.  May return NULL if this
  // stream has become stalled on flow control.
  scoped_ptr<SpdyFrame> ProduceNextFrame();
  // An in order list of pending frame data that are going to be sent. HEADERS
  // frames are queued as SpdyHeaderBlock structures because these must be
  // compressed just before sending. Data frames are queued as SpdyDataFrame.
  std::list<PendingFrame> pending_frames_;

  // An in order list of sending frame types. It will be used to know which type
  // of frame is sent and which callback should be invoked in OnOpen().
  std::list<FrameType> waiting_completions_;
template<class Collection> static v8::Handle<v8::Array> nodeCollectionIndexedPropertyEnumerator(const v8::AccessorInfo& info)
    return properties;
v8::Handle<v8::Value> npObjectNamedPropertyGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
    return npObjectGetProperty(info.Holder(), identifier, name, info.GetIsolate());
v8::Handle<v8::Value> npObjectIndexedPropertyGetter(uint32_t index, const v8::AccessorInfo& info)
    return npObjectGetProperty(info.Holder(), identifier, v8::Number::New(index), info.GetIsolate());
v8::Handle<v8::Value> npObjectGetNamedProperty(v8::Local<v8::Object> self, v8::Local<v8::String> name, const v8::AccessorInfo& info)
    return npObjectGetProperty(self, identifier, name, info.GetIsolate());
v8::Handle<v8::Value> npObjectGetIndexedProperty(v8::Local<v8::Object> self, uint32_t index, const v8::AccessorInfo& info)
    return npObjectGetProperty(self, identifier, v8::Number::New(index), info.GetIsolate());
v8::Handle<v8::Integer> npObjectQueryProperty(v8::Local<v8::String> name, const v8::AccessorInfo& info)
    return npObjectGetProperty(info.Holder(), identifier, name, info.GetIsolate()).IsEmpty() ? v8::Handle<v8::Integer>() : v8Integer(0, info.GetIsolate());
v8::Handle<v8::Value> npObjectNamedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
    return npObjectSetProperty(info.Holder(), identifier, value, info.GetIsolate());
v8::Handle<v8::Value> npObjectIndexedPropertySetter(uint32_t index, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
    return npObjectSetProperty(info.Holder(), identifier, value, info.GetIsolate());
v8::Handle<v8::Value> npObjectSetNamedProperty(v8::Local<v8::Object> self, v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
    return npObjectSetProperty(self, identifier, value, info.GetIsolate());
v8::Handle<v8::Value> npObjectSetIndexedProperty(v8::Local<v8::Object> self, uint32_t index, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
    return npObjectSetProperty(self, identifier, value, info.GetIsolate());
v8::Handle<v8::Array> npObjectPropertyEnumerator(const v8::AccessorInfo& info, bool namedProperty)
            return properties;

    return v8::Handle<v8::Array>();
v8::Handle<v8::Array> npObjectNamedPropertyEnumerator(const v8::AccessorInfo& info)
    return npObjectPropertyEnumerator(info, true);
v8::Handle<v8::Array> npObjectIndexedPropertyEnumerator(const v8::AccessorInfo& info)
    return npObjectPropertyEnumerator(info, false);
v8::Handle<v8::Value> npObjectNamedPropertyGetter(v8::Local<v8::String> name, const v8::AccessorInfo&);
v8::Handle<v8::Value> npObjectIndexedPropertyGetter(uint32_t index, const v8::AccessorInfo&);
v8::Handle<v8::Value> npObjectGetNamedProperty(v8::Local<v8::Object> self, v8::Local<v8::String> name, const v8::AccessorInfo&);
v8::Handle<v8::Value> npObjectGetIndexedProperty(v8::Local<v8::Object> self, uint32_t index, const v8::AccessorInfo&);
v8::Handle<v8::Value> npObjectNamedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value>, const v8::AccessorInfo&);
v8::Handle<v8::Value> npObjectIndexedPropertySetter(uint32_t index, const v8::AccessorInfo&);
v8::Handle<v8::Value> npObjectSetNamedProperty(v8::Local<v8::Object> self, v8::Local<v8::String> name, v8::Local<v8::Value>, const v8::AccessorInfo&);
v8::Handle<v8::Value> npObjectSetIndexedProperty(v8::Local<v8::Object> self, uint32_t index, v8::Local<v8::Value>, const v8::AccessorInfo&);
v8::Handle<v8::Array> V8CSSStyleDeclaration::namedPropertyEnumerator(const v8::AccessorInfo& info)
    return properties;
v8::Handle<v8::Integer> V8CSSStyleDeclaration::namedPropertyQuery(v8::Local<v8::String> v8Name, const v8::AccessorInfo& info)
    if (cssPropertyInfo(v8Name))
        return v8Integer(0, info.GetIsolate());

    return v8::Handle<v8::Integer>();
v8::Handle<v8::Value> V8CSSStyleDeclaration::namedPropertyGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
        return v8Undefined();
        return v8Undefined();
        return v8Undefined();
        return v8Undefined();
            return v8::Number::New(static_cast<CSSPrimitiveValue*>(
        return v8StringOrNull(cssValue->cssText(), info.GetIsolate());
    return v8String(result, info.GetIsolate());
v8::Handle<v8::Value> V8CSSStyleDeclaration::namedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
        return v8Undefined();
        return v8Undefined();
        return v8Undefined();
        return v8Undefined();
    if (ec)
    return value;
v8::Handle<v8::Integer> V8DOMStringMap::namedPropertyQuery(v8::Local<v8::String> name, const v8::AccessorInfo& info)
        return v8Integer(0, info.GetIsolate());
    return v8::Handle<v8::Integer>();
v8::Handle<v8::Value> V8DOMWindow::namedPropertyGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
        return v8Undefined();
        return v8Undefined();
    if (child)
        return toV8Fast(child->document()->domWindow(), info, window);
        return v8Undefined();
                if (items->hasExactlyOneItem())
                    return toV8Fast(items->item(0), info, window);
                return toV8Fast(items.release(), info, window);

    return v8Undefined();
static v8::Handle<v8::Value> npObjectNamedGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
        return v8Undefined();
        return v8Undefined();
    return npObjectGetNamedProperty(instance, name, info);
static v8::Handle<v8::Value> npObjectNamedSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
        return v8Undefined();
        return v8Undefined();
    return npObjectSetNamedProperty(instance, name, value, info);
v8::Handle<v8::Value> V8HTMLAppletElement::namedPropertyGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
    return npObjectNamedGetter<V8HTMLAppletElement>(name, info);
v8::Handle<v8::Value> V8HTMLEmbedElement::namedPropertyGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
    return npObjectNamedGetter<V8HTMLEmbedElement>(name, info);
v8::Handle<v8::Value> V8HTMLObjectElement::namedPropertyGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
    return npObjectNamedGetter<V8HTMLObjectElement>(name, info);
v8::Handle<v8::Value> V8HTMLAppletElement::namedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
    return npObjectNamedSetter<V8HTMLAppletElement>(name, value, info);
v8::Handle<v8::Value> V8HTMLEmbedElement::namedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
    return npObjectNamedSetter<V8HTMLEmbedElement>(name, value, info);
v8::Handle<v8::Value> V8HTMLObjectElement::namedPropertySetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
v8::Handle<v8::Value> npObjectIndexedGetter(uint32_t index, const v8::AccessorInfo& info)
        return v8Undefined();
        return v8Undefined();
    return npObjectGetIndexedProperty(instance, index, info);
v8::Handle<v8::Value> npObjectIndexedSetter(uint32_t index, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
        return v8Undefined();
        return v8Undefined();
    return npObjectSetIndexedProperty(instance, index, value, info);
v8::Handle<v8::Value> V8HTMLAppletElement::indexedPropertyGetter(uint32_t index, const v8::AccessorInfo& info)
    return npObjectIndexedGetter<V8HTMLAppletElement>(index, info);
v8::Handle<v8::Value> V8HTMLEmbedElement::indexedPropertyGetter(uint32_t index, const v8::AccessorInfo& info)
    return npObjectIndexedGetter<V8HTMLEmbedElement>(index, info);
v8::Handle<v8::Value> V8HTMLObjectElement::indexedPropertyGetter(uint32_t index, const v8::AccessorInfo& info)
    return npObjectIndexedGetter<V8HTMLObjectElement>(index, info);
v8::Handle<v8::Value> V8HTMLAppletElement::indexedPropertySetter(uint32_t index, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
    return npObjectIndexedSetter<V8HTMLAppletElement>(index, value, info);
v8::Handle<v8::Value> V8HTMLEmbedElement::indexedPropertySetter(uint32_t index, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
    return npObjectIndexedSetter<V8HTMLEmbedElement>(index, value, info);
v8::Handle<v8::Value> V8HTMLObjectElement::indexedPropertySetter(uint32_t index, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
    return npObjectIndexedSetter<V8HTMLObjectElement>(index, value, info);
template<class T>
static v8::Handle<T> setDOMException(ExceptionCode ec, const v8::AccessorInfo& info)
{
    setDOMException(ec, info.GetIsolate());
    return v8::Handle<T>();
}

v8::Handle<v8::Integer> V8Storage::namedPropertyQuery(v8::Local<v8::String> v8Name, const v8::AccessorInfo& info)
        return v8::Handle<v8::Integer>();
    if (ec)
        return setDOMException<v8::Integer>(ec, info);
        return v8::Handle<v8::Integer>();
    return v8Integer(0, info.GetIsolate());
  SharedMemoryCreateOptions() : name(NULL), size(0), open_existing(false),
  const std::string* name;
  // shared memory must not exist.  This flag is meaningless unless name is
  // non-NULL.
  bool open_existing;
  bool CreateNamed(const std::string& name, bool open_existing, size_t size) {
    options.name = &name;
    options.open_existing = open_existing;
      options.name == NULL ? "" : options.name->c_str(),
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    if (!FilePathForMemoryName(*options.name, &path))
    if (fd == -1 && options.open_existing) {
    bool rv = memory.CreateNamed(s_test_name_, true, kDataSize);
      EXPECT_TRUE(memory1.CreateNamed("SharedMemoryMultipleLockThreadTest",
                                 true, kDataSize));
// CreateNamed(openExisting=true)
  rv = memory1.CreateNamed(test_name, false, kDataSize);
  // Open two handles to a memory segment and check that open_existing works
  // as expected.
  bool rv = memory1.CreateNamed(test_name, false, kDataSize);
  rv = memory2.CreateNamed(test_name, false, kDataSize2);
  rv = memory2.CreateNamed(test_name, true, kDataSize2);
  options.name = &shared_mem_name;
    bool rv = memory.CreateNamed(s_test_name_, true, kDataSize);
  name_ = ASCIIToWide(options.name == NULL ? "" : *options.name);
    if (!options.open_existing) {
  if (!shared_memory->CreateNamed(name, true, size))
  if (!shared_mem_service_data->CreateNamed(GetServiceProcessSharedMemName(),
                                            true, alloc_size))
    EXPECT_TRUE(shared_handle_.CreateNamed(kShmemSegmentName, false, 100));
    if (m_isExternalScript && m_resource && !m_resource->mimeTypeAllowedByNosniff()) {
        contextDocument->addConsoleMessage(SecurityMessageSource, ErrorMessageLevel, "Refused to execute script from '" + m_resource->url().elidedString() + "' because its MIME type ('" + m_resource->mimeType() + "') is not executable, and strict MIME type checking is enabled.");
        return;
                ownerNode->notifyLoadedSheetAndAllCriticalSubresources(m_didLoadErrorOccur);
    virtual void notifyLoadedSheetAndAllCriticalSubresources(bool /* error loading subresource */) { }
        if (!executeScript(ScriptSourceCode(scriptContent(), scriptURL, position)))
    if (!m_isExternalScript && (!shouldBypassMainWorldCSP && !csp->allowInlineScript(elementDocument->url(), m_startLineNumber, sourceCode.source())))
        return true;
            return true;
            return true;
void StyleElement::processStyleSheet(Document& document, Element* element)
        return;
    process(element);
void StyleElement::childrenChanged(Element* element)
        return;
    process(element);
void StyleElement::finishParsingChildren(Element* element)
    process(element);
void StyleElement::process(Element* element)
        return;
    createSheet(element, element->textFromChildren());
void StyleElement::createSheet(Element* e, const String& text)
    void processStyleSheet(Document&, Element*);
    void childrenChanged(Element*);
    void finishParsingChildren(Element*);
    void createSheet(Element*, const String& text = String());
    void process(Element*);
void HTMLLinkElement::notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred)
    linkStyle()->notifyLoadedSheetAndAllCriticalSubresources(errorOccurred);
        notifyLoadedSheetAndAllCriticalSubresources(true);
void LinkStyle::notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred)
    m_loadedSheet = !errorOccurred;
            // The request may have been denied if (for example) the stylesheet is local and the document is remote.
    void notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred);
    virtual void notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred) override;
    StyleElement::finishParsingChildren(this);
    StyleElement::processStyleSheet(document(), this);
    StyleElement::childrenChanged(this);
void HTMLStyleElement::notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred)
    m_loadedSheet = !errorOccurred;
    virtual void notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred) override;
typedef HANDLE SharedMemoryLock;
// On POSIX, the lock is implemented as a lockf() on the mapped file,
// so no additional member (or definition of SharedMemoryLock) is
// needed.
  // calling Lock() to acquire the named mutex before either Create or Open
  // are called on Windows.
  // processes, not across threads.  The Lock method is not currently
  void Lock();

#if defined(OS_WIN)
  // A Lock() implementation with a timeout that also allows setting
  // security attributes on the mutex. sec_attr may be NULL.
  // Returns true if the Lock() has been acquired, false if the timeout was
  // reached.
  bool Lock(uint32 timeout_ms, SECURITY_ATTRIBUTES* sec_attr);
#endif
  void Unlock();
  SharedMemoryLock   lock_;
// the SharedMemoryAutoLock is in scope.
class SharedMemoryAutoLock {
  explicit SharedMemoryAutoLock(SharedMemory* shared_memory)
    shared_memory_->Lock();
  ~SharedMemoryAutoLock() {
    shared_memory_->Unlock();
  DISALLOW_COPY_AND_ASSIGN(SharedMemoryAutoLock);
void SharedMemory::Lock() {
void SharedMemory::Unlock() {
void SharedMemory::Lock() {
void SharedMemory::Unlock() {
      memory2.Lock();
      memory2.Unlock();
      memory.Lock();
      memory.Unlock();
void SharedMemory::Lock() {
  Lock(INFINITE, NULL);
}

bool SharedMemory::Lock(uint32 timeout_ms, SECURITY_ATTRIBUTES* sec_attr) {
    lock_ = CreateMutex(sec_attr, FALSE, name.c_str());
      return false;  // there is nothing good we can do here.
  DWORD result = WaitForSingleObject(lock_, timeout_ms);

  // Return false for WAIT_ABANDONED, WAIT_TIMEOUT or WAIT_FAILED.
  return (result == WAIT_OBJECT_0);
void SharedMemory::Unlock() {
    SharedMemoryAutoLock lock(internal_->shared_memory());
    SharedMemoryAutoLock lock(internal_->shared_memory());
static bool schemeRequiresAuthority(const String& scheme)
    DEFINE_STATIC_LOCAL(URLSchemesMap, schemes, ());
    if (schemes.isEmpty()) {
        schemes.add("http");
        schemes.add("https");
        schemes.add("ftp");
    return schemes.contains(scheme);
SecurityOrigin::SecurityOrigin(const KURL& url, bool forceUnique)
    , m_isUnique(forceUnique || SchemeRegistry::shouldTreatURLSchemeAsNoAccess(m_protocol))
    , m_needsStorageIdentifierQuirkForFiles(false)
#if ENABLE(BLOB) || ENABLE(FILE_SYSTEM)
    bool isBlobOrFileSystemProtocol = false;
#if ENABLE(BLOB)
    if (m_protocol == BlobURL::blobProtocol())
        isBlobOrFileSystemProtocol = true;
#endif
#if ENABLE(FILE_SYSTEM)
    if (m_protocol == "filesystem")
        isBlobOrFileSystemProtocol = true;
#endif
    if (isBlobOrFileSystemProtocol) {
        KURL originURL(ParsedURLString, decodeURLEscapeSequences(url.path()));
        if (originURL.isValid()) {
            m_protocol = originURL.protocol().lower();
            m_host = originURL.host().lower();
            m_port = originURL.port();
        } else
            m_isUnique = true;
    }
#endif

    // For edge case URLs that were probably misparsed, make sure that the origin is unique.
    if (schemeRequiresAuthority(m_protocol) && m_host.isEmpty())
        m_isUnique = true;

    if (m_protocol.isEmpty())
        m_isUnique = true;
    // By default, only local SecurityOrigins can load local resources.
    m_canLoadLocalResources = isLocal();
    if (m_canLoadLocalResources) {
        // Directories should never be readable.
        // Note that we do not do this check for blob or filesystem url because its origin is file:/// when it is created from local file urls.
#if ENABLE(BLOB) || ENABLE(FILE_SYSTEM)
        bool doDirectoryCheck = !isBlobOrFileSystemProtocol;
#else
        bool doDirectoryCheck = true;
#endif
        if (doDirectoryCheck && (!url.hasPath() || url.path().endsWith("/")))
            m_isUnique = true;
        // Store the path in case we are doing per-file origin checking.
        m_filePath = url.path();
    }

    if (m_protocol == "file")
        m_needsStorageIdentifierQuirkForFiles = true;
    // Don't leak details from URLs into unique origins.
    if (m_isUnique) {
        m_protocol = "";
        m_host = "";
        m_port = InvalidPort;
    }
    , m_needsStorageIdentifierQuirkForFiles(other->m_needsStorageIdentifierQuirkForFiles)
    if (!url.isValid())
        return adoptRef(new SecurityOrigin(blankURL(), forceUnique));
    return adoptRef(new SecurityOrigin(url, forceUnique));
    RefPtr<SecurityOrigin> origin = create(KURL());
    if (m_needsStorageIdentifierQuirkForFiles)
    explicit SecurityOrigin(const KURL&, bool forceUnique);
    bool m_needsStorageIdentifierQuirkForFiles;
    wstring explanation = l10n_util::GetStringF(IDS_LOGIN_DIALOG_DESCRIPTION,
                                                auth_info_->host,
                                                auth_info_->realm);
      off_the_record_(profile->IsOffTheRecord()) {
bool ResourceMessageFilter::OnMessageReceived(const IPC::Message& message) {
  bool handled = resource_dispatcher_host_->OnMessageReceived(
                                                message, this, &msg_is_ok) ||
                 app_cache_dispatcher_host_->OnMessageReceived(
                                                 message, &msg_is_ok) ||
                 dom_storage_dispatcher_host_->OnMessageReceived(
                                                   message, &msg_is_ok) ||
                 audio_renderer_host_->OnMessageReceived(
                                           message, &msg_is_ok) ||
                 db_dispatcher_host_->OnMessageReceived(message, &msg_is_ok);
    IPC_BEGIN_MESSAGE_MAP_EX(ResourceMessageFilter, message, msg_is_ok)
          OnReceiveContextMenuMsg(message))
          render_widget_helper_->DidReceivePaintMsg(message))


      IPC_MESSAGE_HANDLER(ViewHostMsg_OpenChannelToTab,
                          OnOpenChannelToTab)
      IPC_MESSAGE_HANDLER(ViewHostMsg_SetCacheMode,
                          OnSetCacheMode)
      IPC_MESSAGE_HANDLER_DELAY_REPLY(ViewHostMsg_GetFileSize,
                                      OnGetFileSize)
    BrowserRenderProcessHost::BadMessageTerminateProcess(message.type(),
                                                         handle());
  WorkerService::GetInstance()->OnSenderShutdown(this);
  WorkerService::GetInstance()->OnWorkerProcessDestroyed(this);
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(WorkerProcessHost, message)
    IPC_MESSAGE_HANDLER(ViewHostMsg_CreateDedicatedWorker,
                        OnCreateDedicatedWorker)
    IPC_MESSAGE_HANDLER(ViewHostMsg_CancelCreateDedicatedWorker,
                        OnCancelCreateDedicatedWorker)
    IPC_MESSAGE_HANDLER(ViewHostMsg_ForwardToWorker,
                        OnForwardToWorker)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP_EX()
#include "chrome/browser/worker_host/worker_process_host.h"
  // Receive a notification if the message filter is deleted.
  DCHECK(type.value == NotificationType::RESOURCE_MESSAGE_FILTER_SHUTDOWN);
  ResourceMessageFilter* filter = Source<ResourceMessageFilter>(source).ptr();
  OnSenderShutdown(filter);
void WorkerService::OnSenderShutdown(IPC::Message::Sender* sender) {
void WorkerService::OnWorkerProcessDestroyed(WorkerProcessHost* process) {
#ifndef CHROME_BROWSER_WORKER_HOST__WORKER_SERVICE_H_
#define CHROME_BROWSER_WORKER_HOST__WORKER_SERVICE_H_
  // NotificationObserver interface.
  void Observe(NotificationType type,
               const NotificationSource& source,
               const NotificationDetails& details);

  // Notifies us that a process that's talking to a worker has shut down.
  void OnSenderShutdown(IPC::Message::Sender* sender);

  // Notifies us that a worker process has closed.
  void OnWorkerProcessDestroyed(WorkerProcessHost* process);

#endif  // CHROME_BROWSER_WORKER_HOST__WORKER_SERVICE_H_
// No messages being sent in this direction for now.
//IPC_BEGIN_MESSAGES(WorkerProcessHost)
//IPC_END_MESSAGES(WorkerProcessHost)
      volume_(1) {
    buffer->dwBufferLength = used;
    media::AdjustVolume(buffer->lpData, buffer->dwBufferLength,
                        format_.nChannels, format_.wBitsPerSample >> 3,
                        volume_);
bool RenderView::canHandleRequest(const WebKit::WebURLRequest& request) {
WebKit::WebURLError RenderView::cannotShowURLError(
    const WebKit::WebURLRequest& request) {
  // No need to set fields of WebURLError.  It is passed to
  // unableToImplementPolicyWithError() below.
  return WebKit::WebURLError();
    WebFrame*, const WebKit::WebURLError&) {
  // We don't need to do anything here.
  // The implementations of this method in WebKit/mac WebKit/win are
  // just to log some information of the parameters.
void RenderView::didDisplayInsecureContent(WebKit::WebFrame* frame) {
void RenderView::OnFind(int request_id,
                        const string16& search_text,
                        const WebKit::WebFindOptions& options) {
  WebKit::WebVector<WebKit::WebString> ws_file_names(file_names.size());
  virtual bool canHandleRequest(const WebKit::WebURLRequest& request);
  virtual WebKit::WebURLError cannotShowURLError(
      const WebKit::WebURLRequest& request);
        virtual bool canHandleRequest(const WebURLRequest& request) = 0;
        // Called if canHandledRequest() returns false.
        virtual WebURLError cannotShowURLError(
            const WebURLRequest& request) = 0;
}  // namespace webkit_glue
  virtual bool canHandleRequest(const WebKit::WebURLRequest&) { return true; }
  virtual WebKit::WebURLError cannotShowURLError(
      const WebKit::WebURLRequest& request) { return WebKit::WebURLError(); }
#include "net/base/net_errors.h"
  return ResourceError(net::kErrorDomain, net::ERR_ABORTED,
                       request.url().string(), String());
      webframe_->client()->cannotShowURLError(WrappedResourceRequest(request)));
  return error.errorCode() != net::ERR_ABORTED;
  return webframe_->client()->canHandleRequest(WrappedResourceRequest(request));
bool TestWebViewDelegate::canHandleRequest(const WebURLRequest& request) {
WebURLError TestWebViewDelegate::cannotShowURLError(
    const WebURLRequest& request) {
  virtual bool canHandleRequest(const WebKit::WebURLRequest&);
  virtual WebKit::WebURLError cannotShowURLError(
      const WebKit::WebURLRequest& request);
  params.is_main_frame = true;
  params.is_main_frame = true;
  fail_load_params.is_main_frame = true;
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, true, url1);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, true, url2);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, true, url1);
      main_test_rfh(), -1, true, GURL(kUnreachableWebDataURL));
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, true, url1);
  navigator->DidStartProvisionalLoad(main_test_rfh(), -1, true, url2);
                                       bool main_frame,
      bool is_main_frame,
      bool is_main_frame,
      bool is_main_frame,
    bool is_main_frame,
  // TODO(creis): This is a hack for now, until we mirror the frame tree and do
  // cross-process subframe navigations in actual subframes.  As a result, we
  // can currently only support a single cross-process subframe per RVH.
  if (pending_entry &&
      pending_entry->frame_tree_node_id() != -1 &&
      CommandLine::ForCurrentProcess()->HasSwitch(switches::kSitePerProcess))
    is_main_frame = false;

        render_frame_host, parent_routing_id, is_main_frame,
          << ", is_main_frame: " << params.is_main_frame
    bool is_main_frame,
        render_frame_host, url, is_main_frame, error_code,
  // Use entry->frame_tree_node_id() to pick which RenderFrameHostManager to
  // use when --site-per-process is used.
  if (entry.frame_tree_node_id() != -1 &&
      CommandLine::ForCurrentProcess()->HasSwitch(switches::kSitePerProcess)) {
    int64 frame_tree_node_id = entry.frame_tree_node_id();
    manager = render_frame_host->frame_tree_node()->frame_tree()->FindByID(
        frame_tree_node_id)->render_manager();
  }

  // TODO(creis): As a temporary hack, we currently do cross-process subframe
  // navigations in a top-level frame of the new process.  Thus, we don't yet
  // need to store the correct frame ID in FrameMsg_Navigate_Params.
  // When using --site-per-process, look up the FrameTreeNode ID that the
  // renderer-specific frame ID corresponds to.
  int64 frame_tree_node_id = frame_tree->root()->frame_tree_node_id();
    frame_tree_node_id =
        render_frame_host->frame_tree_node()->frame_tree_node_id();

    // TODO(creis): In the short term, cross-process subframe navigations are
    // happening in the pending RenderViewHost's top-level frame.  (We need to
    // both mirror the frame tree and get the navigation to occur in the correct
    // subframe to fix this.)  Until then, we should check whether we have a
    // pending NavigationEntry with a frame ID and if so, treat the
    // cross-process "main frame" navigation as a subframe navigation.  This
    // limits us to a single cross-process subframe per RVH, and it affects
    // NavigateToEntry, NavigatorImpl::DidStartProvisionalLoad, and
    // OnDidFinishLoad.
    int root_ftn_id = frame_tree->root()->frame_tree_node_id();
    if (pending_entry &&
        pending_entry->frame_tree_node_id() != -1 &&
        pending_entry->frame_tree_node_id() != root_ftn_id) {
      frame_tree_node_id = pending_entry->frame_tree_node_id();
    FrameTreeNode* frame = frame_tree->FindByID(frame_tree_node_id);
                                       bool main_frame,
      bool is_main_frame,
    bool is_main_frame,
      this, parent_routing_id, is_main_frame, url);
    bool is_main_frame,
      this, validated_url, is_main_frame, error_code,
      error_description);
                                         bool main_frame,
      bool is_main_frame,
  return frame_tree_.root()->navigator()->NavigateToPendingEntry(
      frame_tree_.GetMainFrame(), reload_type);
    bool is_main_frame,
  // --site-per-process mode has a short-term hack allowing cross-process
  // subframe pages to commit thinking they are top-level.  Correct it here to
  // avoid confusing the observers.
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSitePerProcess) &&
      render_frame_host != GetMainFrame()) {
    is_main_frame = false;
  }

                             params.is_main_frame,
    bool is_main_frame,
                                error_description, render_view_host));;
    const GURL& url,
    bool is_main_frame) {
  RenderFrameHostImpl* rfh =
      static_cast<RenderFrameHostImpl*>(render_frame_message_source_);

  // --site-per-process mode has a short-term hack allowing cross-process
  // subframe pages to commit thinking they are top-level.  Correct it here to
  // avoid confusing the observers.
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSitePerProcess) &&
      rfh != GetMainFrame()) {
    is_main_frame = false;
  }

      bool is_main_frame,
      bool is_main_frame,
  void OnDidFinishLoad(const GURL& url,
                       bool is_main_frame);
  contents()->TestDidFinishLoad(url_from_ipc, true);
      url_from_ipc, true, 1, base::string16());
  // True if this is the top-most frame.
  IPC_STRUCT_MEMBER(bool, is_main_frame)
IPC_MESSAGE_ROUTED3(FrameHostMsg_DidStartProvisionalLoadForFrame,
                    bool /* true if it is the main frame */,
IPC_MESSAGE_ROUTED4(FrameHostMsg_DidFailLoadWithError,
                    bool /* is_main_frame */,
IPC_MESSAGE_ROUTED2(FrameHostMsg_DidFinishLoad,
                    GURL /* validated_url */,
                    bool /* is_main_frame */)
       routing_id_, parent_routing_id,
       is_top_most, ds->request().url()));
  params.is_main_frame = !frame->parent();
                                             !frame->parent(),
                                      ds->request().url(),
                                      !frame->parent()));
  OnDidStartProvisionalLoadForFrame(-1, true, url_copy);
  OnDidStartProvisionalLoadForFrame(-1, true, url);
void TestWebContents::TestDidFinishLoad(const GURL& url,
                                        bool is_main_frame) {
  FrameHostMsg_DidFinishLoad msg(0, url, is_main_frame);
    bool is_main_frame,
      0, url, is_main_frame, error_code, error_description);
  void TestDidFinishLoad(const GURL& url, bool is_main_frame);
                                bool is_main_frame,
      needs_filter_context_(false) {}
  delegated_impl->CollectUnusedResources(
      &unused_resources_for_child_compositor_);

  // TODO(danakj): TakeUnusedResourcesForChildCompositor requires a push
  // properties to happen in order to collect unused resources returned

  ReturnedResourceArray unused_resources_for_child_compositor_;
    ResourceProvider::ResourceIdSet *remapped_resources,
  remapped_resources->insert(remapped_id);
  // This is just a copy for testing since we keep the data on the pending layer
  // for returning resources to the child for now.
  CreateChildIdIfNeeded();
  DCHECK(child_id_);

  ResourceProvider::ResourceIdSet used_resources;
                 &used_resources);
  if (invalid_frame)
  resources_.swap(used_resources);
void DelegatedRendererLayerImpl::CollectUnusedResources(
    ReturnedResourceArray* resources_for_ack) {
  CreateChildIdIfNeeded();
  DCHECK(child_id_);

  ResourceProvider* resource_provider = layer_tree_impl()->resource_provider();
    const ResourceProvider::ResourceIdMap& resource_map =
        resource_provider->GetChildToParentMap(child_id_);

  ResourceProvider::ResourceIdArray unused_resources;
  for (ResourceProvider::ResourceIdMap::const_iterator it =
           resource_map.begin();
       it != resource_map.end();
       ++it) {
    bool resource_is_in_current_frame = resources_.count(it->second) > 0;
    bool resource_is_in_use = resource_provider->InUseByConsumer(it->second);
    if (!resource_is_in_current_frame && !resource_is_in_use)
      unused_resources.push_back(it->second);
  }
  resource_provider->PrepareSendReturnsToChild(
      child_id_, unused_resources, resources_for_ack);
}

void DelegatedRendererLayerImpl::CreateChildIdIfNeeded() {
  if (child_id_)
    return;

  ResourceProvider* resource_provider = layer_tree_impl()->resource_provider();
  child_id_ = resource_provider->CreateChild();
  own_child_id_ = true;
}

  void CollectUnusedResources(ReturnedResourceArray* resources_for_ack);

  const ResourceProvider::ResourceIdSet& ResourcesForTesting() const {
  // Creates an ID with the resource provider for the child renderer
  // that will be sending quads to the layer.
  void CreateChildIdIfNeeded();
  ResourceProvider::ResourceIdSet resources_;
    : gl_id(0),
ResourceProvider::Resource::Resource(
    unsigned texture_id,
    gfx::Size size,
    GLenum filter,
    GLenum texture_pool,
    GLint wrap_mode,
    TextureUsageHint hint,
    ResourceFormat format)
    : gl_id(texture_id),
ResourceProvider::Resource::Resource(
    uint8_t* pixels,
    gfx::Size size,
    GLenum filter,
    GLint wrap_mode)
    : gl_id(0),
int ResourceProvider::CreateChild() {
    // We're abandoning this resource, it will not get recycled.
    // crbug.com/224062
    ResourceMap::iterator resource_it = resources_.find(id);
    CHECK(resource_it != resources_.end());
    resource_it->second.imported_count = 0;
    DeleteResource(id);
void ResourceProvider::PrepareSendReturnsToChild(
    int child,
    const ResourceIdArray& resources,
    ReturnedResourceArray* list) {
  DCHECK(thread_checker_.CalledOnValidThread());
  WebGraphicsContext3D* context3d = Context3d();
  if (!context3d || !context3d->makeContextCurrent()) {
    // TODO(skaslev): Implement this path for software compositing.
    return;
  }
  Child& child_info = children_.find(child)->second;
  bool need_sync_point = false;
  for (ResourceIdArray::const_iterator it = resources.begin();
       it != resources.end(); ++it) {
    Resource* resource = GetResource(*it);
    DCHECK(!resource->locked_for_write);
    DCHECK(!resource->lock_for_read_count);
    DCHECK(child_info.parent_to_child_map.find(*it) !=
           child_info.parent_to_child_map.end());

    if (resource->filter != resource->original_filter) {
      DCHECK(resource->target);
      DCHECK(resource->gl_id);

      GLC(context3d, context3d->bindTexture(resource->target, resource->gl_id));
      GLC(context3d, context3d->texParameteri(resource->target,
                                              GL_TEXTURE_MIN_FILTER,
                                              resource->original_filter));
      GLC(context3d, context3d->texParameteri(resource->target,
                                              GL_TEXTURE_MAG_FILTER,
                                              resource->original_filter));
    }

    ReturnedResource returned;
    returned.id = child_info.parent_to_child_map[*it];
    returned.sync_point = resource->mailbox.sync_point();
    if (!returned.sync_point)
      need_sync_point = true;
    returned.count = resource->imported_count;
    list->push_back(returned);

    child_info.parent_to_child_map.erase(*it);
    child_info.child_to_parent_map.erase(returned.id);
    resources_[*it].imported_count = 0;
    DeleteResource(*it);
  }
  if (need_sync_point) {
    unsigned int sync_point = context3d->insertSyncPoint();
    for (ReturnedResourceArray::iterator it = list->begin();
         it != list->end(); ++it) {
      if (!it->sync_point)
        it->sync_point = sync_point;
    }
  }
}


    ResourceId id = next_id_++;
    Resource resource(
        texture_id,
        it->size,
        it->filter,
        0,
        GL_CLAMP_TO_EDGE,
        TextureUsageAny,
        it->format);
    resources_[id] = resource;
    child_info.parent_to_child_map[id] = it->id;
    child_info.child_to_parent_map[it->id] = id;
    ResourceMap::iterator map_iterator = resources_.find(it->id);
    DCHECK(map_iterator != resources_.end());
    CHECK_GE(resource->exported_count, it->count);
    resource->exported_count -= it->count;
      if (it->sync_point)
        GLC(context3d, context3d->waitSyncPoint(it->sync_point));
          TextureMailbox(resource->mailbox.name(), it->sync_point);
    if (resource->marked_for_deletion)
  int CreateChild();
  // Prepares resources to be transfered back to the child, moving them to
  // mailboxes and serializing meta-data into TransferableResources.
  // Resources are removed from the ResourceProvider. Note: the resource IDs
  // passed are in the parent namespace and will be translated to the child
  // namespace when returned.
  void PrepareSendReturnsToChild(int child,
                                 const ResourceIdArray& resources,
                                 ReturnedResourceArray* returned_resources);

                         ResourceProvider::ResourceId id,
                         WGC3Denum filter) {
  int child_id = resource_provider_->CreateChild();
    // Transfer resources back from the parent to the child.
    ResourceProvider::ResourceIdArray resource_ids_to_transfer;
    resource_ids_to_transfer.push_back(mapped_id1);
    resource_ids_to_transfer.push_back(mapped_id2);
    ReturnedResourceArray list;
    resource_provider_->PrepareSendReturnsToChild(
        child_id, resource_ids_to_transfer, &list);
    ASSERT_EQ(2u, list.size());
    EXPECT_NE(0u, list[0].sync_point);
    EXPECT_NE(0u, list[1].sync_point);
    child_resource_provider->ReceiveReturnsFromParent(list);
  int child_id = resource_provider_->CreateChild();
    // Transfer resources back from the parent to the child.
    ResourceProvider::ResourceIdMap resource_map =
        resource_provider_->GetChildToParentMap(child_id);
    ResourceProvider::ResourceId mapped_id = resource_map[id];
    EXPECT_NE(0u, mapped_id);
    ResourceProvider::ResourceIdArray resource_ids_to_transfer;
    resource_ids_to_transfer.push_back(mapped_id);
    ReturnedResourceArray list;
    resource_provider_->PrepareSendReturnsToChild(
        child_id, resource_ids_to_transfer, &list);
    ASSERT_EQ(1u, list.size());
    EXPECT_NE(0u, list[0].sync_point);
    child_resource_provider->ReceiveReturnsFromParent(list);
    int child_id = parent_resource_provider->CreateChild();
      // Transfer resources back from the parent to the child.
      ResourceProvider::ResourceIdArray resource_ids_to_transfer;
      resource_ids_to_transfer.push_back(mapped_id);
      ReturnedResourceArray list;
      parent_resource_provider->PrepareSendReturnsToChild(
          child_id, resource_ids_to_transfer, &list);
      ASSERT_EQ(1u, list.size());
      child_resource_provider->ReceiveReturnsFromParent(list);
    Mock::VerifyAndClearExpectations(parent_context);
  ReturnedResourceArray resources_for_ack;
  CollectUnusedResources(&resources_for_ack);
  const ResourceProvider::ResourceIdSet& Resources() const {
    return ResourcesForTesting();
  }
    EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(999)->second));
    EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(555)->second));
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 3:
      case 4:
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 5:
      case 6:
      case 7:
        // 444 and 999 are no longer in use.
          unsigned expected[] = {444, 999};
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 3:
      case 4:
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 5:
        // The 999 resource is the only unused one.
          unsigned expected[] = {999};
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 3:
      case 4:
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 5:
        // The child compositor sends a frame before receiving an for the
        // second frame. It uses 999, 444, and 555 again.
    if (host_impl->active_tree()->source_frame_number() != 5)
    EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(999)->second));
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 3:
      case 4:
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 5:
      case 6:
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 7:
    if (host_impl->active_tree()->source_frame_number() != 5)
    EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(999)->second));
    EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(555)->second));
    EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(444)->second));
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 3:
      case 4:
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 5:
      case 6:
        // Retrieve unused resources to the main thread.
        // TODO(danakj): Shouldn't need to commit to get resources.
        layer_tree_host()->SetNeedsCommit();
        return;
      case 7:
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(999)->second));
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(555)->second));
      case 3: {
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(999)->second));
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(555)->second));
      case 5:
        // Resources given to our parent compositor will be returned now, but
        // the DelegatedRendererLayerImpl doesn't know about it until the next
        // commit.
        // TODO(danakj): Shouldn't need a commit to return resources to the
        // DelegatedRendererLayerImpl or to the main thread.
        break;
      case 6: {
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(999)->second));
    EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(555)->second));
  virtual void DidCommit() OVERRIDE {
        // The impl side will get back the resource at some point.
        // TODO(piman): The test should work without this.
        layer_tree_host()->SetNeedsCommit();
        break;
      case 4:
    EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(555)->second));
        // TODO(danakj): The test should work without this.
        layer_tree_host()->SetNeedsCommit();
      case 4:
        // 999 was returned from the grandparent and could be released.
        delegated_->TakeUnusedResourcesForChildCompositor(&resources);
        {
          unsigned expected[] = {999};
          EXPECT_RESOURCES(expected, resources);
        }
        EndTest();
        break;
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(999)->second));
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(555)->second));
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(555)->second));
        // Receive 999 back from the grandparent.
        CompositorFrameAck ack;
        output_surface()->ReturnResource(map.find(999)->second, &ack);
        host_impl->ReclaimResources(&ack);
        host_impl->OnSwapBuffersComplete();
  TransferableResource resource_in_grandparent;
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(999)->second));
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(555)->second));
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(444)->second));
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(555)->second));
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(999)->second));
        EXPECT_EQ(1u, delegated_impl->Resources().count(map.find(555)->second));
    DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
    DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
    DebugScopedSetMainThreadBlocked mainThreadBlocked(this);
    layer_tree_host_impl_->SwapBuffers(frame);
    file_permissions_.erase(file.StripTrailingSeparators());
  // Determine whether permission has been granted to request url.
  // Schemes that have not been granted default to being denied.
    if (judgment == scheme_policy_.end())
      return false;  // Unmentioned schemes are disallowed.

    return judgment->second;
    // If the child process has been commanded to request a scheme, then we
    // grant it the capability to request URLs of that scheme.
  // request the URL.
    policy->GrantRequestURL(renderer_id, net::FilePathToFileURL(path));
  GURL file_url = GURL("file:///etc/passwd");
  dropped_data.url = file_url;
                             WebKit::WebDragOperationNone, 0);
  EXPECT_FALSE(ChildProcessSecurityPolicyImpl::GetInstance()->CanRequestURL(
      process()->GetID(), file_url));
    int cumulative_bindings =
        RenderProcess::current()->GetEnabledBindings();
        bool is_initial_navigation = page_id_ == -1;
  // Use the frame's original request's URL rather than the document's URL for
  // this check.  For a popup, the document's URL may become the opener window's
  // URL if the opener has called document.write.  See http://crbug.com/93517.
  GURL old_url(frame->dataSource()->request().url());

  if (web_contents) {
    Profile* profile =
        Profile::FromBrowserContext(web_contents->GetBrowserContext());
    Browser* browser = chrome::FindAnyBrowser(profile, include_incognito_);
    if (browser)
      return browser;
  }
void
ChromeContentRendererClient::DidInitializeServiceWorkerContextOnWorkerThread(
    v8::Local<v8::Context> context,
    const GURL& url) {
  extensions::Dispatcher::DidInitializeServiceWorkerContextOnWorkerThread(
      context, url);
  extensions::Dispatcher::WillDestroyServiceWorkerContextOnWorkerThread(context,
                                                                        url);
      ->DidInitializeServiceWorkerContextOnWorkerThread(context, script_url_);
      context, script_url_);
    // The renderer has done validation before sending extension api requests.
    // Therefore, we should never receive a request that is invalid in a way
    // that JSON validation in the renderer should have caught. It could be an
    // attacker trying to exploit the browser, so we crash the renderer instead.
    LOG(ERROR) <<
        "Terminating renderer because of malformed extension message.";
    if (content::RenderProcessHost::run_renderer_in_process()) {
      // In single process mode it is better if we don't suicide but just crash.
      CHECK(false);
    } else {
      KillBadMessageSender(peer_process, histogram_value);
    }
    content::RenderFrameHost* render_frame_host) {
  UIThreadResponseCallbackWrapperMap::const_iterator
      iter = ui_thread_response_callback_wrappers_.find(render_frame_host);
  UIThreadResponseCallbackWrapper* callback_wrapper = nullptr;
  if (iter == ui_thread_response_callback_wrappers_.end()) {
    callback_wrapper = new UIThreadResponseCallbackWrapper(AsWeakPtr(),
                                                           render_frame_host);
    ui_thread_response_callback_wrappers_[render_frame_host] = callback_wrapper;
    callback_wrapper = iter->second;

  DispatchWithCallbackInternal(
      params, render_frame_host,
      callback_wrapper->CreateCallback(params.request_id));
  DCHECK(render_frame_host);
  int process_id = render_frame_host->GetProcess()->GetID();
  scoped_refptr<ExtensionFunction> function(
      CreateExtensionFunction(params,
                              extension,
                              process_id,
                              *process_map,
                              ExtensionAPI::GetSharedInstance(),
                              browser_context_,
                              callback));
                content::RenderFrameHost* render_frame_host);
  dispatcher_.Dispatch(params, render_frame_host);
  EXPECT_EQ(6u, feature->contexts()->size());
  RegisterNativeHandlers(module_system, context);
// static
        if (context->IsAnyFeatureAvailableToContext(*map_entry.second.get()))
    case Feature::SERVICE_WORKER_CONTEXT:
      // Handled in DidInitializeServiceWorkerContextOnWorkerThread().
      NOTREACHED();
      break;
                                        ScriptContext* context) {
  RegisterNativeHandlers(module_system,
                         context,
                         this,
                         request_sender_.get(),
                         v8_schema_registry_.get());
  // Runs on a different thread and should not use any member variables.
  static void DidInitializeServiceWorkerContextOnWorkerThread(
                              ScriptContext* context);
  v8::Local<v8::Object> GetOrCreateObject(const v8::Local<v8::Object>& object,
                                          const std::string& field,
                                          v8::Isolate* isolate);
  v8::Local<v8::Object> GetOrCreateBindObjectIfAvailable(
      ScriptContextSet::GetContextByObject(object);
  if (!render_frame)
  ~RequestSender();
      api, extension(), context_type(), GetDataSourceURLForFrame(web_frame()));
        context = v8::Context::New(m_isolate, nullptr, globalTemplate);
                ownerNode->notifyLoadedSheetAndAllCriticalSubresources(m_didLoadErrorOccur);
    virtual void notifyLoadedSheetAndAllCriticalSubresources(bool /* error loading subresource */) { }
        if (!executeScript(ScriptSourceCode(scriptContent(), scriptURL, position)))
    if (!m_isExternalScript && (!shouldBypassMainWorldCSP && !csp->allowInlineScript(elementDocument->url(), m_startLineNumber, sourceCode.source())))
        return true;
            return true;
            return true;
void StyleElement::processStyleSheet(Document& document, Element* element)
        return;
    process(element);
void StyleElement::childrenChanged(Element* element)
        return;
    process(element);
void StyleElement::finishParsingChildren(Element* element)
    process(element);
void StyleElement::process(Element* element)
        return;
    createSheet(element, element->textFromChildren());
void StyleElement::createSheet(Element* e, const String& text)
    void processStyleSheet(Document&, Element*);
    void childrenChanged(Element*);
    void finishParsingChildren(Element*);
    void createSheet(Element*, const String& text = String());
    void process(Element*);
void HTMLLinkElement::notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred)
    linkStyle()->notifyLoadedSheetAndAllCriticalSubresources(errorOccurred);
        notifyLoadedSheetAndAllCriticalSubresources(true);
void LinkStyle::notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred)
    m_loadedSheet = !errorOccurred;
            // The request may have been denied if (for example) the stylesheet is local and the document is remote.
    void notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred);
    virtual void notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred) override;
    StyleElement::finishParsingChildren(this);
    StyleElement::processStyleSheet(document(), this);
    StyleElement::childrenChanged(this);
void HTMLStyleElement::notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred)
    m_loadedSheet = !errorOccurred;
    virtual void notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred) override;
            RefPtr<DocumentLoader> documentLoader =  m_frame->loader().provisionalDocumentLoader();
        node =  pluginDocument->pluginNode();
        RefPtr<DocumentLoader> documentLoader = frame()->loader().documentLoader();
    mutable RefPtrWillBeMember<ApplicationCache> m_applicationCache;
        return 0;
    return m_mainResource ? m_mainResource->loader() : 0;
    clearMainResourceHandle();
    m_applicationCacheHost->dispose();
    return 0;
    m_applicationCacheHost->failedLoadingMainResource();
    RefPtrWillBeRawPtr<LocalFrame> protectFrame(m_frame);
    RefPtr<DocumentLoader> protectLoader(this);
    RefPtr<DocumentLoader> protect(this);
    RefPtr<DocumentLoader> protect(this);
    RefPtr<DocumentLoader> protect(this);
    RefPtrWillBeRawPtr<LocalFrame> protectFrame(m_frame);
    RefPtr<DocumentLoader> protectLoader(this);
    RefPtrWillBeRawPtr<LocalFrame> protectFrame(m_frame);
    RefPtr<DocumentLoader> protectLoader(this);
    m_applicationCacheHost->setApplicationCache(0);
    m_frame = 0;
    m_mainResource = 0;
    RefPtr<DocumentLoader> protect(this);
    RefPtr<DocumentLoader> protect(this);
    class CORE_EXPORT DocumentLoader : public RefCounted<DocumentLoader>, private RawResourceClient {
        WTF_MAKE_FAST_ALLOCATED(DocumentLoader);
        static PassRefPtr<DocumentLoader> create(LocalFrame* frame, const ResourceRequest& request, const SubstituteData& data)
            return adoptRef(new DocumentLoader(frame, request, data));
        void detachFromFrame();
        LocalFrame* m_frame;
        RefPtrWillBePersistent<ResourceFetcher> m_fetcher;
        RefPtrWillBePersistent<DocumentWriter> m_writer;
        RefPtrWillBePersistent<MHTMLArchive> m_archive;
        friend class ApplicationCacheHost;  // for substitute resource delivery
        OwnPtrWillBePersistent<ApplicationCacheHost> m_applicationCacheHost;
}
PassRefPtr<DocumentLoader> EmptyFrameLoaderClient::createDocumentLoader(LocalFrame* frame, const ResourceRequest& request, const SubstituteData& substituteData)
    virtual PassRefPtr<DocumentLoader> createDocumentLoader(LocalFrame*, const ResourceRequest&, const SubstituteData&) override;
    RefPtr<DocumentLoader> documentLoader;
    RefPtr<DocumentLoader> documentLoader;

    RefPtr<DocumentLoader> documentLoader(m_frame->document()->loader());
        if (m_provisionalDocumentLoader)
            m_provisionalDocumentLoader->detachFromFrame();
        m_provisionalDocumentLoader = nullptr;
    if (m_provisionalDocumentLoader)
        m_provisionalDocumentLoader->detachFromFrame();
    m_provisionalDocumentLoader = nullptr;
    RefPtr<DocumentLoader> pdl = m_provisionalDocumentLoader;
        m_documentLoader->detachFromFrame();
    if (m_documentLoader)
        m_documentLoader->detachFromFrame();
    m_documentLoader = nullptr;
        m_provisionalDocumentLoader->detachFromFrame();
        m_provisionalDocumentLoader = nullptr;
        m_policyDocumentLoader->detachFromFrame();
        m_policyDocumentLoader = nullptr;
        if (m_provisionalDocumentLoader)
            m_provisionalDocumentLoader->detachFromFrame();
        m_provisionalDocumentLoader = nullptr;
    RefPtr<DocumentLoader> m_documentLoader;
    RefPtr<DocumentLoader> m_provisionalDocumentLoader;
    RefPtr<DocumentLoader> m_policyDocumentLoader;
        virtual PassRefPtr<DocumentLoader> createDocumentLoader(LocalFrame*, const ResourceRequest&, const SubstituteData&) = 0;
class ApplicationCache final : public EventTargetWithInlineData, public RefCountedWillBeNoBase<ApplicationCache>, public DOMWindowProperty {
    REFCOUNTED_EVENT_TARGET(ApplicationCache);
    static PassRefPtrWillBeRawPtr<ApplicationCache> create(LocalFrame* frame)
        return adoptRefWillBeNoop(new ApplicationCache(frame));
    if (m_host) {
        WrappedResourceRequest wrapped(request);
        const WebApplicationCacheHost* spawningHost = 0;
        Frame* spawningFrame = frame.tree().parent();
        if (!spawningFrame || !spawningFrame->isLocalFrame())
            spawningFrame = frame.loader().opener();
        if (!spawningFrame || !spawningFrame->isLocalFrame())
            spawningFrame = &frame;
        if (DocumentLoader* spawningDocLoader = toLocalFrame(spawningFrame)->loader().documentLoader())
            spawningHost = spawningDocLoader->applicationCacheHost() ? spawningDocLoader->applicationCacheHost()->m_host.get() : 0;
        m_host->willStartMainResourceRequest(wrapped, spawningHost);
    }
void ApplicationCacheHost::dispose()
    // FIXME: Oilpan: remove the dispose step when the owning DocumentLoader
    // becomes a garbage collected object. Until that time, have the
    // DocumentLoader dispose and disable this ApplicationCacheHost when
    // it is finalized. Releasing the WebApplicationCacheHost is needed
    // to prevent further embedder notifications, which risk accessing an
    // invalid DocumentLoader.
    setApplicationCache(0);
    RefPtr<DocumentLoader> protect(documentLoader());
    if (m_domApplicationCache) {
        const AtomicString& eventType = ApplicationCache::toEventType(id);
        RefPtrWillBeRawPtr<Event> event = nullptr;
        if (id == PROGRESS_EVENT)
            event = ProgressEvent::create(eventType, true, progressDone, progressTotal);
        else if (id == ERROR_EVENT)
            event = ApplicationCacheErrorEvent::create(errorReason, errorURL, errorStatus, errorMessage);
        else
            event = Event::create(eventType);
        m_domApplicationCache->dispatchEvent(event, ASSERT_NO_EXCEPTION);
    }
    class ApplicationCacheHost final : public NoBaseWillBeGarbageCollectedFinalized<ApplicationCacheHost>, public WebApplicationCacheHostClient {
        static PassOwnPtrWillBeRawPtr<ApplicationCacheHost> create(DocumentLoader* loader)
            return adoptPtrWillBeNoop(new ApplicationCacheHost(loader));
        virtual ~ApplicationCacheHost();
        void dispose();
        RawPtrWillBeWeakMember<ApplicationCache> m_domApplicationCache;
        DocumentLoader* m_documentLoader;
PassRefPtr<DocumentLoader> FrameLoaderClientImpl::createDocumentLoader(LocalFrame* frame, const ResourceRequest& request, const SubstituteData& data)
    RefPtr<WebDataSourceImpl> ds = WebDataSourceImpl::create(frame, request, data);
    virtual PassRefPtr<DocumentLoader> createDocumentLoader(LocalFrame*, const ResourceRequest&, const SubstituteData&) override;
PassRefPtr<WebDataSourceImpl> WebDataSourceImpl::create(LocalFrame* frame, const ResourceRequest& request, const SubstituteData& data)
    return adoptRef(new WebDataSourceImpl(frame, request, data));
    static PassRefPtr<WebDataSourceImpl> create(LocalFrame*, const ResourceRequest&, const SubstituteData&);
#include "content/public/browser/color_chooser.h"
#include "ui/views/color_chooser/color_chooser_listener.h"
namespace {

class ColorChooserAura : public content::ColorChooser,
                         public views::ColorChooserListener {
 public:
  static ColorChooserAura* Open(content::WebContents* web_contents,
                                SkColor initial_color);

  ColorChooserAura(content::WebContents* web_contents, SkColor initial_color);

 private:
  static ColorChooserAura* current_color_chooser_;

  // content::ColorChooser overrides:
  virtual void End() OVERRIDE;
  virtual void SetSelectedColor(SkColor color) OVERRIDE;

  // views::ColorChooserListener overrides:
  virtual void OnColorChosen(SkColor color) OVERRIDE;
  virtual void OnColorChooserDialogClosed() OVERRIDE;

  void DidEndColorChooser();

  // The actual view of the color chooser.  No ownership because its parent
  // view will take care of its lifetime.
  views::ColorChooserView* view_;

  // The widget for the color chooser.  No ownership because it's released
  // automatically when closed.
  views::Widget* widget_;

  // The web contents invoking the color chooser.  No ownership because it will
  // outlive this class.
  content::WebContents* web_contents_;

  DISALLOW_COPY_AND_ASSIGN(ColorChooserAura);
};

}  // namespace

  ExecuteOpenParams execute_params(initial_color, BeginRun(owning_window),
                                   owning_window);
bool ColorChooserDialog::IsRunning(HWND owning_hwnd) const {
  return listener_ && IsRunningDialogForOwner(owning_hwnd);
  virtual bool IsRunning(HWND owning_hwnd) const OVERRIDE;
  DCHECK(resource->pixels);
    scoped_ptr<SharedBitmap> bitmap;
    uint8_t* pixels = NULL;
    if (it->is_software) {
      if (shared_bitmap_manager_) {
        bitmap = shared_bitmap_manager_->GetSharedBitmapFromId(
            it->size, it->mailbox_holder.mailbox);
      }
      if (bitmap)
        pixels = bitmap->pixels();
    }

    if ((!it->is_software && !gl) || (it->is_software && !pixels)) {
      resource = Resource(pixels,
                          bitmap.release(),
      DCHECK(!resource->shared_bitmap);
    resource->mailbox_holder.mailbox = source->shared_bitmap->id();
    const SkBitmap* sk_bitmap() const { return &sk_bitmap_; }
  EXPECT_EQ(0u, resource_provider_->num_resources());
  ASSERT_EQ(1u, returned_to_child.size());
  EXPECT_EQ(returned_to_child[0].id, id1);
  EXPECT_EQ(0u, mapped_id1);
// static
uint64 SpdyIOBuffer::order_ = 0;
SpdyIOBuffer::SpdyIOBuffer(
    IOBuffer* buffer, int size, RequestPriority priority, SpdyStream* stream)
  : buffer_(new DrainableIOBuffer(buffer, size)),
    priority_(priority),
    position_(++order_),
    stream_(stream) {}

SpdyIOBuffer::SpdyIOBuffer() : priority_(HIGHEST), position_(0), stream_(NULL) {
}
  priority_ = rhs.priority_;
  position_ = rhs.position_;
  priority_ = rhs.priority_;
  position_ = rhs.position_;
void SpdyIOBuffer::release() {
#include "net/base/request_priority.h"
// A class for managing SPDY IO buffers.  These buffers need to be prioritized
// so that the SpdySession sends them in the right order.  Further, they need
// to track the SpdyStream which they are associated with so that incremental
// completion of the IO can notify the appropriate stream of completion.
  // |priority| is the priority of this buffer.
  // |stream| is a pointer to the stream which is managing this buffer.
  SpdyIOBuffer(IOBuffer* buffer, int size, RequestPriority priority,
               SpdyStream* stream);
  SpdyIOBuffer();
  size_t size() const { return buffer_->size(); }
  void release();
  RequestPriority priority() const { return priority_; }
  // Comparison operator to support sorting.
  bool operator<(const SpdyIOBuffer& other) const {
    if (priority_ != other.priority_)
      return priority_ < other.priority_;
    return position_ > other.position_;
  }

  RequestPriority priority_;
  uint64 position_;
  static uint64 order_;  // Maintains a FIFO order for equal priorities.
// static
void SpdySession::SpdyIOBufferProducer::ActivateStream(
    SpdySession* spdy_session,
    SpdyStream* spdy_stream) {
  spdy_session->ActivateStream(spdy_stream);
}

// static
SpdyIOBuffer* SpdySession::SpdyIOBufferProducer::CreateIOBuffer(
    SpdyFrame* frame,
    RequestPriority priority,
    SpdyStream* stream) {
  size_t size = frame->size();
  DCHECK_GT(size, 0u);

  // TODO(mbelshe): We have too much copying of data here.
  IOBufferWithSize* buffer = new IOBufferWithSize(size);
  memcpy(buffer->data(), frame->data(), size);

  return new SpdyIOBuffer(buffer, size, priority, stream);
}

  for (int i = NUM_PRIORITIES - 1; i >= MINIMUM_PRIORITY; --i) {
void SpdySession::SetStreamHasWriteAvailable(SpdyStream* stream,
                                             SpdyIOBufferProducer* producer) {
  write_queue_.push(producer);
  stream_producers_[producer] = stream;
  WriteSocketLater();
}

SpdyFrame* SpdySession::CreateSynStream(
  return syn_frame.release();
SpdyFrame* SpdySession::CreateCredentialFrame(
    RequestPriority priority) {
  DCHECK_EQ(OK, rv);
    return NULL;
  scoped_ptr<SpdyFrame> credential_frame(
  return credential_frame.release();
SpdyFrame* SpdySession::CreateHeadersFrame(
  return frame.release();
SpdyFrame* SpdySession::CreateDataFrame(SpdyStreamId stream_id,
                                        net::IOBuffer* data, int len,
                                        SpdyDataFlags flags) {
    return NULL;
      return NULL;
        return NULL;
  return frame.release();
  QueueFrame(rst_frame.release(), priority);
  DCHECK(in_flight_write_.size());
  scoped_refptr<SpdyStream> stream = in_flight_write_.stream();

  if (result >= 0) {
    // It should not be possible to have written more bytes than our
    // in_flight_write_.
    DCHECK_LE(result, in_flight_write_.buffer()->BytesRemaining());

    in_flight_write_.buffer()->DidConsume(result);

    // We only notify the stream when we've fully written the pending frame.
    if (!in_flight_write_.buffer()->BytesRemaining()) {
      if (stream) {
        // Report the number of bytes written to the caller, but exclude the
        // frame size overhead.  NOTE: if this frame was compressed the
        // reported bytes written is the compressed size, not the original
        // size.
        if (result > 0) {
          result = in_flight_write_.buffer()->size();
          DCHECK_GE(result,
                    static_cast<int>(
                        buffered_spdy_framer_->GetControlFrameHeaderSize()));
          result -= buffered_spdy_framer_->GetControlFrameHeaderSize();
        }

        // It is possible that the stream was cancelled while we were writing
        // to the socket.
        if (!stream->cancelled())
          stream->OnWriteComplete(result);
      }
      // Cleanup the write which just completed.
      in_flight_write_.release();
    }
    // Write more data.  We're already in a continuation, so we can
    // go ahead and write it immediately (without going back to the
    // message loop).
    WriteSocketLater();
  } else {
    in_flight_write_.release();
    // The stream is now errored.  Close it down.
    CloseSessionOnError(
        static_cast<net::Error>(result), true, "The stream has errored.");
  while (in_flight_write_.buffer() || !write_queue_.empty()) {
    if (!in_flight_write_.buffer()) {
      // Grab the next SpdyBuffer to send.
      scoped_ptr<SpdyIOBufferProducer> producer(write_queue_.top());
      write_queue_.pop();
      scoped_ptr<SpdyIOBuffer> buffer(producer->ProduceNextBuffer(this));
      stream_producers_.erase(producer.get());
      if (buffer == NULL)
      in_flight_write_ = *buffer;
    } else {
      DCHECK(in_flight_write_.buffer()->BytesRemaining());
  // We also need to drain the queue.
  while (!write_queue_.empty()) {
    scoped_ptr<SpdyIOBufferProducer> producer(write_queue_.top());
    write_queue_.pop();
    stream_producers_.erase(producer.get());
  }
class SimpleSpdyIOBufferProducer : public SpdySession::SpdyIOBufferProducer {
 public:
  SimpleSpdyIOBufferProducer(SpdyFrame* frame,
                             RequestPriority priority)
      : frame_(frame),
        priority_(priority) {
  }

  virtual RequestPriority GetPriority() const OVERRIDE {
    return priority_;
  }

  virtual SpdyIOBuffer* ProduceNextBuffer(SpdySession* session) OVERRIDE {
    return SpdySession::SpdyIOBufferProducer::CreateIOBuffer(
        frame_.get(), priority_, NULL);
  }

 private:
  scoped_ptr<SpdyFrame> frame_;
  RequestPriority priority_;
};
void SpdySession::QueueFrame(SpdyFrame* frame,
                             RequestPriority priority) {
  SimpleSpdyIOBufferProducer* producer =
      new SimpleSpdyIOBufferProducer(frame, priority);
  write_queue_.push(producer);
    PushedStreamMap::iterator it;
    for (it = unclaimed_pushed_streams_.begin();
  ActiveStreamMap::iterator it2 = active_streams_.find(id);
  if (it2 == active_streams_.end())
  // Possibly remove from the write queue.
  WriteQueue old = write_queue_;
  write_queue_ = WriteQueue();
  while (!old.empty()) {
    scoped_ptr<SpdyIOBufferProducer> producer(old.top());
    old.pop();
    StreamProducerMap::iterator it = stream_producers_.find(producer.get());
    if (it == stream_producers_.end() || it->second->stream_id() != id) {
      write_queue_.push(producer.release());
    } else {
      stream_producers_.erase(producer.get());
      producer.reset(NULL);
    }
  }
  const scoped_refptr<SpdyStream> stream(it2->second);
  active_streams_.erase(it2);
  DCHECK(stream);
  QueueFrame(settings_frame.release(), HIGHEST);
  QueueFrame(window_update_frame.release(), priority);
  QueueFrame(ping_frame.release(), HIGHEST);
#include <list>
#include <queue>
  // Defines an interface for producing SpdyIOBuffers.
  class NET_EXPORT_PRIVATE SpdyIOBufferProducer {
   public:
    SpdyIOBufferProducer() {}

    // Returns a newly created SpdyIOBuffer, owned by the caller, or NULL
    // if not buffer is ready to be produced.
    virtual SpdyIOBuffer* ProduceNextBuffer(SpdySession* session) = 0;

    virtual RequestPriority GetPriority() const = 0;

    virtual ~SpdyIOBufferProducer() {}

   protected:
    // Activates |spdy_stream| in |spdy_session|.
    static void ActivateStream(SpdySession* spdy_session,
                               SpdyStream* spdy_stream);

    static SpdyIOBuffer* CreateIOBuffer(SpdyFrame* frame,
                                        RequestPriority priority,
                                        SpdyStream* spdy_stream);
  };

  // Records that |stream| has a write available from |producer|.
  // |producer| will be owned by this SpdySession.
  void SetStreamHasWriteAvailable(SpdyStream* stream,
                                  SpdyIOBufferProducer* producer);
  // Send the SYN frame for |stream_id|. This also sends PING message to check
  // the status of the connection.
  SpdyFrame* CreateSynStream(
  // Write a CREDENTIAL frame to the session.
  SpdyFrame* CreateCredentialFrame(const std::string& origin,
                                   SSLClientCertType type,
                                   const std::string& key,
                                   const std::string& cert,
                                   RequestPriority priority);

  // Write a HEADERS frame to the stream.
  SpdyFrame* CreateHeadersFrame(SpdyStreamId stream_id,
                                const SpdyHeaderBlock& headers,
                                SpdyControlFlags flags);

  // Write a data frame to the stream.
  // Used to create and queue a data frame for the given stream.
  SpdyFrame* CreateDataFrame(SpdyStreamId stream_id,
                             net::IOBuffer* data, int len,
                             SpdyDataFlags flags);
  typedef std::map<SpdyIOBufferProducer*, SpdyStream*> StreamProducerMap;

  class SpdyIOBufferProducerCompare {
   public:
    bool operator() (const SpdyIOBufferProducer* lhs,
                     const SpdyIOBufferProducer* rhs) const {
      return lhs->GetPriority() < rhs->GetPriority();
    }
  };

  typedef std::priority_queue<SpdyIOBufferProducer*,
                              std::vector<SpdyIOBufferProducer*>,
                              SpdyIOBufferProducerCompare> WriteQueue;
  // Queue a frame for sending.
  // |frame| is the frame to send.
  // |priority| is the priority for insertion into the queue.
  void QueueFrame(SpdyFrame* frame, RequestPriority priority);
  // As streams have data to be sent, we put them into the write queue.
  WriteQueue write_queue_;

  // Mapping from SpdyIOBufferProducers to their corresponding SpdyStream
  // so that when a stream is destroyed, we can remove the corresponding
  // producer from |write_queue_|.
  StreamProducerMap stream_producers_;
// Test the SpdyIOBuffer class.
TEST_F(SpdySessionSpdy2Test, SpdyIOBuffer) {
  std::priority_queue<SpdyIOBuffer> queue_;
  const size_t kQueueSize = 100;

  // Insert items with random priority and increasing buffer size.
  for (size_t index = 0; index < kQueueSize; ++index) {
    queue_.push(SpdyIOBuffer(
        new IOBufferWithSize(index + 1),
        index + 1,
        static_cast<RequestPriority>(rand() % NUM_PRIORITIES),
        NULL));
  }

  EXPECT_EQ(kQueueSize, queue_.size());

  // Verify items come out with decreasing priority or FIFO order.
  RequestPriority last_priority = NUM_PRIORITIES;
  size_t last_size = 0;
  for (size_t index = 0; index < kQueueSize; ++index) {
    SpdyIOBuffer buffer = queue_.top();
    EXPECT_LE(buffer.priority(), last_priority);
    if (buffer.priority() < last_priority)
      last_size = 0;
    EXPECT_LT(last_size, buffer.size());
    last_priority = buffer.priority();
    last_size = buffer.size();
    queue_.pop();
  }

  EXPECT_EQ(0u, queue_.size());
}

// Test the SpdyIOBuffer class.
TEST_F(SpdySessionSpdy3Test, SpdyIOBuffer) {
  std::priority_queue<SpdyIOBuffer> queue_;
  const size_t kQueueSize = 100;

  // Insert items with random priority and increasing buffer size.
  for (size_t index = 0; index < kQueueSize; ++index) {
    queue_.push(SpdyIOBuffer(
        new IOBufferWithSize(index + 1),
        index + 1,
        static_cast<RequestPriority>(rand() % NUM_PRIORITIES),
        NULL));
  }

  EXPECT_EQ(kQueueSize, queue_.size());

  // Verify items come out with decreasing priority or FIFO order.
  RequestPriority last_priority = NUM_PRIORITIES;
  size_t last_size = 0;
  for (size_t index = 0; index < kQueueSize; ++index) {
    SpdyIOBuffer buffer = queue_.top();
    EXPECT_LE(buffer.priority(), last_priority);
    if (buffer.priority() < last_priority)
      last_size = 0;
    EXPECT_LT(last_size, buffer.size());
    last_priority = buffer.priority();
    last_size = buffer.size();
    queue_.pop();
  }

  EXPECT_EQ(0u, queue_.size());
}

class SpdyStream::SpdyStreamIOBufferProducer
    : public SpdySession::SpdyIOBufferProducer {
 public:
  SpdyStreamIOBufferProducer(SpdyStream* stream) : stream_(stream) {}

  // SpdyFrameProducer
  virtual RequestPriority GetPriority() const OVERRIDE {
    return stream_->priority();
  }

  virtual SpdyIOBuffer* ProduceNextBuffer(SpdySession* session) OVERRIDE {
    if (stream_->cancelled())
      return NULL;
    if (stream_->stream_id() == 0)
      SpdySession::SpdyIOBufferProducer::ActivateStream(session, stream_);
    frame_ = stream_->ProduceNextFrame();
    return frame_ == NULL ? NULL :
        SpdySession::SpdyIOBufferProducer::CreateIOBuffer(
            frame_.get(), GetPriority(), stream_);
  }

 private:
  scoped_refptr<SpdyStream> stream_;
  scoped_ptr<SpdyFrame> frame_;
};

void SpdyStream::SetHasWriteAvailable() {
  session_->SetStreamHasWriteAvailable(this,
                                       new SpdyStreamIOBufferProducer(this));
}

scoped_ptr<SpdyFrame> SpdyStream::ProduceNextFrame() {
  if (io_state_ == STATE_SEND_DOMAIN_BOUND_CERT_COMPLETE) {
    CHECK(request_.get());
    CHECK_GT(stream_id_, 0u);

    std::string origin = GetUrl().GetOrigin().spec();
    DCHECK(origin[origin.length() - 1] == '/');
    origin.erase(origin.length() - 1);  // Trim trailing slash.
    scoped_ptr<SpdyFrame> frame(session_->CreateCredentialFrame(
        origin, domain_bound_cert_type_, domain_bound_private_key_,
        domain_bound_cert_, priority_));
    return frame.Pass();
  } else if (io_state_ == STATE_SEND_HEADERS_COMPLETE) {
    CHECK(request_.get());
    CHECK_GT(stream_id_, 0u);

    SpdyControlFlags flags =
        has_upload_data_ ? CONTROL_FLAG_NONE : CONTROL_FLAG_FIN;
    scoped_ptr<SpdyFrame> frame(session_->CreateSynStream(
        stream_id_, priority_, slot_, flags, *request_));
    send_time_ = base::TimeTicks::Now();
    return frame.Pass();
  } else {
    CHECK(!cancelled());
    // We must need to write stream data.
    // Until the headers have been completely sent, we can not be sure
    // that our stream_id is correct.
    DCHECK_GT(io_state_, STATE_SEND_HEADERS_COMPLETE);
    DCHECK_GT(stream_id_, 0u);
    DCHECK(!pending_frames_.empty());

    PendingFrame frame = pending_frames_.front();
    pending_frames_.pop_front();

    waiting_completions_.push_back(frame.type);

    if (frame.type == TYPE_DATA) {
      // Send queued data frame.
      return scoped_ptr<SpdyFrame>(frame.data_frame);
    } else {
      DCHECK(frame.type == TYPE_HEADERS);
      // Create actual HEADERS frame just in time because it depends on
      // compression context and should not be reordered after the creation.
      scoped_ptr<SpdyFrame> header_frame(session_->CreateHeadersFrame(
          stream_id_, *frame.header_block, SpdyControlFlags()));
      delete frame.header_block;
      return header_frame.Pass();
    }
  }
  NOTREACHED();
}

  while (!pending_frames_.empty()) {
    PendingFrame frame = pending_frames_.back();
    pending_frames_.pop_back();
    if (frame.type == TYPE_DATA)
      delete frame.data_frame;
    else
      delete frame.header_block;
  }
  PendingFrame frame;
  frame.type = TYPE_HEADERS;
  // |frame.header_block| is deleted by either ProduceNextFrame() or
  // the destructor.
  frame.header_block = headers.release();
  pending_frames_.push_back(frame);
  SetHasWriteAvailable();
  PendingFrame frame;
  frame.type = TYPE_DATA;
  // |frame.data_frame| is either returned by ProduceNextFrame() or
  // deleted in the destructor.
  frame.data_frame = data_frame.release();
  pending_frames_.push_back(frame);
  SetHasWriteAvailable();
      // OnDataReceived, OnClose and OnWriteCompelte can be called.
  SetHasWriteAvailable();

  SetHasWriteAvailable();
#include <list>
  // Structure to contains pending frame information.
  typedef struct {
    FrameType type;
    union {
      SpdyHeaderBlock* header_block;
      SpdyFrame* data_frame;
    };
  } PendingFrame;

  class SpdyStreamIOBufferProducer;
  // Informs the SpdySession that this stream has a write available.
  void SetHasWriteAvailable();
  // Returns a newly created SPDY frame owned by the called that contains
  // the next frame to be sent by this frame.  May return NULL if this
  // stream has become stalled on flow control.
  scoped_ptr<SpdyFrame> ProduceNextFrame();
  // An in order list of pending frame data that are going to be sent. HEADERS
  // frames are queued as SpdyHeaderBlock structures because these must be
  // compressed just before sending. Data frames are queued as SpdyDataFrame.
  std::list<PendingFrame> pending_frames_;

  // An in order list of sending frame types. It will be used to know which type
  // of frame is sent and which callback should be invoked in OnOpen().
  std::list<FrameType> waiting_completions_;
    if (m_isExternalScript && m_resource && !m_resource->mimeTypeAllowedByNosniff()) {
        contextDocument->addConsoleMessage(SecurityMessageSource, ErrorMessageLevel, "Refused to execute script from '" + m_resource->url().elidedString() + "' because its MIME type ('" + m_resource->mimeType() + "') is not executable, and strict MIME type checking is enabled.");
        return;
//
// TODO(hclam): Several changes need to be made to this code:
// 1. We should host AudioRendererHost on a dedicated audio thread. Doing
//    so we don't have to worry about blocking method calls such as
//    play / stop an audio stream.
// 2. Move locked data structures into a separate structure that sanity
//    checks access by different threads that use it.
//
// SEMANTICS OF |state_|
// Note that |state_| of IPCAudioSource is accessed on two thread. Namely
// the IO thread and the audio thread. IO thread is the thread on which
// IPAudioSource::Play(), IPCAudioSource::Pause() are called. Audio thread
// is a thread operated by the audio hardware for requesting data.
// It is important that |state_| is only written on the IO thread because
// reading of such state in Play() and Pause() is not protected. However,
// since OnMoreData() is called on the audio thread and reads |state_|
// variable. Writing to this variable needs to be protected in Play()
// and Pause().
// The following parameters limit the request buffer and packet size from the
// renderer to avoid renderer from requesting too much memory.
static const uint32 kMegabytes = 1024 * 1024;
static const uint32 kMaxDecodedPacketSize = 2 * kMegabytes;
static const uint32 kMaxBufferCapacity = 5 * kMegabytes;
static const int kMaxChannels = 32;
static const int kMaxBitsPerSample = 64;
static const int kMaxSampleRate = 192000;

//-----------------------------------------------------------------------------
// AudioRendererHost::IPCAudioSource implementations.

AudioRendererHost::IPCAudioSource::IPCAudioSource(
    AudioRendererHost* host,
    int process_id,
    int route_id,
    int stream_id,
    AudioOutputStream* stream,
    uint32 hardware_packet_size,
    uint32 buffer_capacity)
    : host_(host),
      process_id_(process_id),
      route_id_(route_id),
      stream_id_(stream_id),
      stream_(stream),
      hardware_packet_size_(hardware_packet_size),
      buffer_capacity_(buffer_capacity),
      state_(kCreated),
      outstanding_request_(false),
      pending_bytes_(0) {
}

AudioRendererHost::IPCAudioSource::~IPCAudioSource() {
  DCHECK(kClosed == state_ || kCreated == state_);
}

// static
AudioRendererHost::IPCAudioSource*
AudioRendererHost::IPCAudioSource::CreateIPCAudioSource(
    AudioRendererHost* host,
    int process_id,
    int route_id,
    int stream_id,
    base::ProcessHandle process_handle,
    AudioManager::Format format,
    int channels,
    int sample_rate,
    char bits_per_sample,
    uint32 packet_size,
    bool low_latency) {
  // Perform come preliminary checks on the parameters.
  if (channels <= 0 || channels > kMaxChannels)
    return NULL;

  if (sample_rate <= 0 || sample_rate > kMaxSampleRate)
    return NULL;

  if (bits_per_sample <= 0 || bits_per_sample > kMaxBitsPerSample)
    return NULL;

  // Create the stream in the first place.
  AudioOutputStream* stream =
      AudioManager::GetAudioManager()->MakeAudioStream(
          format, channels, sample_rate, bits_per_sample);

  uint32 hardware_packet_size = packet_size;

  // If the packet size is not specified in the message we generate the best
  // value here.
  if (!hardware_packet_size) {
    hardware_packet_size =
        SelectHardwarePacketSize(channels, sample_rate, bits_per_sample);
  }
  uint32 transport_packet_size = hardware_packet_size;

  // We set the buffer capacity to be more than the total buffer amount in the
  // audio hardware. This gives about 500ms of buffer which is a safe amount
  // to avoid "audio clicks".
  uint32 buffer_capacity = 3 * hardware_packet_size;

  if (stream && !stream->Open(hardware_packet_size)) {
    stream->Close();
    stream = NULL;
  }

  if (stream) {
    IPCAudioSource* source = new IPCAudioSource(
        host,
        process_id,
        route_id,
        stream_id,
        stream,
        hardware_packet_size,
        buffer_capacity);
    // If we can open the stream, proceed with sharing the shared memory.
    base::SharedMemoryHandle foreign_memory_handle;

    // Time to create the PCM transport. Either low latency or regular latency
    // If things go well we send a message back to the renderer with the
    // transport information.
    // Note that the low latency mode is not yet ready and the if part of this
    // method is never executed. TODO(cpu): Enable this mode.

    if (source->shared_memory_.Create(L"", false, false,
                                      transport_packet_size) &&
        source->shared_memory_.Map(transport_packet_size) &&
        source->shared_memory_.ShareToProcess(process_handle,
                                              &foreign_memory_handle)) {
      if (low_latency) {
        // Low latency mode. We use SyncSocket to signal.
        base::SyncSocket* sockets[2] = {0};
        if (base::SyncSocket::CreatePair(sockets)) {
          source->shared_socket_.reset(sockets[0]);
#if defined(OS_WIN)
          HANDLE foreign_socket_handle = 0;
          ::DuplicateHandle(GetCurrentProcess(), sockets[1]->handle(),
                            process_handle, &foreign_socket_handle,
                            0, FALSE, DUPLICATE_SAME_ACCESS);
          bool valid = foreign_socket_handle != 0;
#else
          base::FileDescriptor foreign_socket_handle(sockets[1]->handle(),
                                                     false);
          bool valid = foreign_socket_handle.fd != -1;
#endif

          if (valid) {
            host->Send(new ViewMsg_NotifyLowLatencyAudioStreamCreated(
                route_id, stream_id, foreign_memory_handle,
                foreign_socket_handle, transport_packet_size));
            return source;
          }
        }
      } else {
        // Regular latency mode.
        host->Send(new ViewMsg_NotifyAudioStreamCreated(
            route_id, stream_id, foreign_memory_handle,
            transport_packet_size));

        // Also request the first packet to kick start the pre-rolling.
        source->StartBuffering();
        return source;
      }
    }
    // Failure. Close and free acquired resources.
    source->Close();
    delete source;
  }

  host->SendErrorMessage(route_id, stream_id);
  return NULL;
void AudioRendererHost::IPCAudioSource::Play() {
  // We can start from created or paused state.
  if (!stream_ || (state_ != kCreated && state_ != kPaused))
    return;

  ViewMsg_AudioStreamState_Params state;
  state.state = ViewMsg_AudioStreamState_Params::kPlaying;
  host_->Send(new ViewMsg_NotifyAudioStreamStateChanged(
      route_id_, stream_id_, state));

  State old_state;
  // Update the state and notify renderer.
  {
    AutoLock auto_lock(lock_);
    old_state = state_;
    state_ = kPlaying;
  }
  if (old_state == kCreated)
    stream_->Start(this);
void AudioRendererHost::IPCAudioSource::Pause() {
  // We can pause from started state.
  if (state_ != kPlaying)
    return;

  // Update the state and notify renderer.
  {
    AutoLock auto_lock(lock_);
    state_ = kPaused;
  }

  ViewMsg_AudioStreamState_Params state;
  state.state = ViewMsg_AudioStreamState_Params::kPaused;
  host_->Send(new ViewMsg_NotifyAudioStreamStateChanged(
      route_id_, stream_id_, state));
void AudioRendererHost::IPCAudioSource::Flush() {
  if (state_ != kPaused)
    return;
  AutoLock auto_lock(lock_);
  push_source_.ClearAll();
void AudioRendererHost::IPCAudioSource::Close() {
  if (!stream_)
    return;
  stream_->Stop();
  stream_->Close();
  // After stream is closed it is destroyed, so don't keep a reference to it.
  stream_ = NULL;
  // Update the current state.
  state_ = kClosed;
void AudioRendererHost::IPCAudioSource::SetVolume(double volume) {
  // TODO(hclam): maybe send an error message back to renderer if this object
  // is in a wrong state.
  if (!stream_)
    return;
  stream_->SetVolume(volume);
void AudioRendererHost::IPCAudioSource::GetVolume() {
  // TODO(hclam): maybe send an error message back to renderer if this object
  // is in a wrong state.
  if (!stream_)
    return;
  double volume;
  stream_->GetVolume(&volume);
  host_->Send(new ViewMsg_NotifyAudioStreamVolume(route_id_, stream_id_,
                                                  volume));
uint32 AudioRendererHost::IPCAudioSource::OnMoreData(AudioOutputStream* stream,
                                                     void* dest,
                                                     uint32 max_size,
                                                     uint32 pending_bytes) {
  AutoLock auto_lock(lock_);

  // Record the callback time.
  last_callback_time_ = base::Time::Now();

  if (state_ != kPlaying) {
    // Don't read anything. Save the number of bytes in the hardware buffer.
    pending_bytes_  = pending_bytes;
    return 0;
  }

  uint32 size;
  if (!shared_socket_.get()) {
    // Push source doesn't need to know the stream and number of pending bytes.
    // So just pass in NULL and 0 for them.
    size = push_source_.OnMoreData(NULL, dest, max_size, 0);
    pending_bytes_ = pending_bytes + size;
    SubmitPacketRequest(&auto_lock);
  } else {
    // Low latency mode.
    size = std::min(shared_memory_.max_size(), max_size);
    memcpy(dest, shared_memory_.memory(), size);
    memset(shared_memory_.memory(), 0, shared_memory_.max_size());
    shared_socket_->Send(&pending_bytes, sizeof(pending_bytes));
  }

  return size;
void AudioRendererHost::IPCAudioSource::OnClose(AudioOutputStream* stream) {
  // Push source doesn't need to know the stream so just pass in NULL.
  if (!shared_socket_.get()) {
    AutoLock auto_lock(lock_);
    push_source_.OnClose(NULL);
  } else {
    shared_socket_->Close();
  }
void AudioRendererHost::IPCAudioSource::OnError(AudioOutputStream* stream,
                                                int code) {
  host_->SendErrorMessage(route_id_, stream_id_);
  // The following method call would cause this object to be destroyed on IO
  // thread.
  host_->DestroySource(this);
void AudioRendererHost::IPCAudioSource::NotifyPacketReady(
    uint32 decoded_packet_size) {
  // Packet ready notifications do not happen in low latency mode. If they
  // do something is horribly wrong.
  DCHECK(!shared_socket_.get());
  AutoLock auto_lock(lock_);
  // If we don't have an outstanding request, we should take the data.
  if (!outstanding_request_) {
    NOTREACHED() << "Received an audio packet while there was no such request";
  outstanding_request_ = false;
  // Don't write to push source and submit a new request if the last one
  // replied with no data. This is likely due to data is depleted in the
  // renderer process.
  // If reported size is greater than capacity of the shared memory, we have
  // an error.
  if (decoded_packet_size && decoded_packet_size <= shared_memory_.max_size()) {
    bool ok = push_source_.Write(
        static_cast<char*>(shared_memory_.memory()), decoded_packet_size);
    // Submit packet request if we have written something.
    if (ok)
      SubmitPacketRequest(&auto_lock);
  }
}
void AudioRendererHost::IPCAudioSource::SubmitPacketRequest_Locked() {
  lock_.AssertAcquired();
  // Submit a new request when these two conditions are fulfilled:
  // 1. No outstanding request
  // 2. There's space for data of the new request.
  if (!outstanding_request_ &&
      (push_source_.UnProcessedBytes() <= buffer_capacity_)) {
    outstanding_request_ = true;

    // This variable keeps track of the total amount of bytes buffered for
    // the associated AudioOutputStream. This value should consist of bytes
    // buffered in AudioOutputStream and those kept inside |push_source_|.
    uint32 buffered_bytes = pending_bytes_ + push_source_.UnProcessedBytes();
    host_->Send(
        new ViewMsg_RequestAudioPacket(
            route_id_,
            stream_id_,
            buffered_bytes,
            last_callback_time_.ToInternalValue()));
  }
}
void AudioRendererHost::IPCAudioSource::SubmitPacketRequest(AutoLock* alock) {
  if (alock) {
    SubmitPacketRequest_Locked();
  } else {
    AutoLock auto_lock(lock_);
    SubmitPacketRequest_Locked();
}
void AudioRendererHost::IPCAudioSource::StartBuffering() {
  SubmitPacketRequest(NULL);
//-----------------------------------------------------------------------------
// AudioRendererHost implementations.
AudioRendererHost::AudioRendererHost()
    : process_id_(0),
      process_handle_(0),
      ipc_sender_(NULL) {
  // Increase the ref count of this object so it is active until we do
  // Release().
  AddRef();
AudioRendererHost::~AudioRendererHost() {
  DCHECK(sources_.empty());
}
void AudioRendererHost::Destroy() {
  // Post a message to the thread where this object should live and do the
  // actual operations there.
  ChromeThread::PostTask(
      ChromeThread::IO, FROM_HERE,
      NewRunnableMethod(this, &AudioRendererHost::OnDestroyed));
// Event received when IPC channel is connected to the renderer process.
void AudioRendererHost::IPCChannelConnected(int process_id,
                                            base::ProcessHandle process_handle,
                                            IPC::Message::Sender* ipc_sender) {
  process_id_ = process_id;
  process_handle_ = process_handle;
  ipc_sender_ = ipc_sender;
// Event received when IPC channel is closing.
void AudioRendererHost::IPCChannelClosing() {
  ipc_sender_ = NULL;
  process_handle_ = 0;
  process_id_ = 0;
  DestroyAllSources();
  DCHECK(Lookup(msg.routing_id(), stream_id) == NULL);
  if (sources_.size() >= GetMaxAudioStreamsAllowed()) {
  IPCAudioSource* source = IPCAudioSource::CreateIPCAudioSource(
      this,
      process_id_,
      msg.routing_id(),
      stream_id,
      process_handle_,
      params.format,
      params.channels,
      params.sample_rate,
      params.bits_per_sample,
      params.packet_size,
      low_latency);

  // If we have created the source successfully, adds it to the map.
  if (source) {
    sources_.insert(
        std::make_pair(
            SourceID(source->route_id(), source->stream_id()), source));
  IPCAudioSource* source = Lookup(msg.routing_id(), stream_id);
  if (source) {
    source->Play();
  } else {
  IPCAudioSource* source = Lookup(msg.routing_id(), stream_id);
  if (source) {
    source->Pause();
  } else {
  IPCAudioSource* source = Lookup(msg.routing_id(), stream_id);
  if (source) {
    source->Flush();
  } else {
  IPCAudioSource* source = Lookup(msg.routing_id(), stream_id);
  if (source) {
    DestroySource(source);
  }
  IPCAudioSource* source = Lookup(msg.routing_id(), stream_id);
  if (source) {
    source->SetVolume(volume);
  } else {
  IPCAudioSource* source = Lookup(msg.routing_id(), stream_id);
  if (source) {
    source->GetVolume();
  } else {
    SendErrorMessage(msg.routing_id(), stream_id);
  }
void AudioRendererHost::OnNotifyPacketReady(const IPC::Message& msg,
                                            int stream_id, uint32 packet_size) {
  IPCAudioSource* source = Lookup(msg.routing_id(), stream_id);
  if (source) {
    source->NotifyPacketReady(packet_size);
  } else {
void AudioRendererHost::OnDestroyed() {
  process_id_ = 0;
  DestroyAllSources();
void AudioRendererHost::OnSend(IPC::Message* message) {
  if (ipc_sender_) {
  }
void AudioRendererHost::OnDestroySource(IPCAudioSource* source) {
  DCHECK(ChromeThread::CurrentlyOn(ChromeThread::IO));
  if (source) {
    sources_.erase(SourceID(source->route_id(), source->stream_id()));
    source->Close();
    delete source;
  }
void AudioRendererHost::DestroyAllSources() {
  std::vector<IPCAudioSource*> sources;
  for (SourceMap::iterator i = sources_.begin(); i != sources_.end(); ++i) {
    sources.push_back(i->second);
  }
  for (size_t i = 0; i < sources.size(); ++i) {
    DestroySource(sources[i]);
  DCHECK(sources_.empty());
AudioRendererHost::IPCAudioSource* AudioRendererHost::Lookup(int route_id,
                                                             int stream_id) {
  SourceMap::iterator i = sources_.find(SourceID(route_id, stream_id));
  if (i != sources_.end())
    return i->second;
  return NULL;
void AudioRendererHost::Send(IPC::Message* message) {
  if (ChromeThread::CurrentlyOn(ChromeThread::IO)) {
    OnSend(message);
  } else {
    ChromeThread::PostTask(
        ChromeThread::IO, FROM_HERE,
        NewRunnableMethod(this, &AudioRendererHost::OnSend, message));
  }
void AudioRendererHost::SendErrorMessage(int32 render_view_id,
                                         int32 stream_id) {
  ViewMsg_AudioStreamState_Params state;
  state.state = ViewMsg_AudioStreamState_Params::kError;
  Send(new ViewMsg_NotifyAudioStreamStateChanged(
      render_view_id, stream_id, state));
void AudioRendererHost::DestroySource(IPCAudioSource* source) {
  if (ChromeThread::CurrentlyOn(ChromeThread::IO)) {
    OnDestroySource(source);
  } else {
    ChromeThread::PostTask(
        ChromeThread::IO, FROM_HERE,
        NewRunnableMethod(this, &AudioRendererHost::OnDestroySource, source));
// lives inside the render process and provide access to audio hardware. It maps
// an internal ID to AudioRendererHost::IPCAudioSource in a map, which is the
// actual object providing audio packets through IPC. It creates the actual
// AudioOutputStream object when requested by the renderer provided with
// render view id and stream id.
// AudioRendererHost::IPCAudioSource is a container of AudioOutputStream and
// provide audio packets to the associated AudioOutputStream through IPC. It
// performs the logic for buffering and controlling the AudioOutputStream.
//
// Here is a state diagram for the IPCAudioSource:
//
//          .--------->  [ Stopped ]  <--------.
//          |                ^                 |
//          |                |                 |
//    *[ Created ]  -->  [ Playing ]  -->  [ Paused ]
//                           ^                 |
//                           |                 |
//                           `-----------------'
//
#include "base/sync_socket.h"
class AudioRendererHost
    : public base::RefCountedThreadSafe<
          AudioRendererHost, ChromeThread::DeleteOnIOThread> {
 private:
  class IPCAudioSource;
  //---------------------------------------------------------------------------
 protected:
  friend class ChromeThread;
  friend class DeleteTask<AudioRendererHost>;

  // Destruction always happens on the IO thread (see DeleteOnIOThread above).
  virtual ~AudioRendererHost();

  //---------------------------------------------------------------------------
  // Helper methods called from IPCAudioSource or from this class, since
  // methods in IPCAudioSource maybe called from hardware audio threads, these
  // methods make sure the actual tasks happen on IO thread.
  // These methods are virtual protected so we can mock these methods to test
  // IPCAudioSource.

  // A helper method to send an IPC message to renderer process on IO thread.
  virtual void Send(IPC::Message* message);

  // A helper method for sending error IPC messages.
  virtual void SendErrorMessage(int32 render_view_id, int32 stream_id);

  // A helper method for calling OnDestroySource on IO thread.
  virtual void DestroySource(IPCAudioSource* source);
  friend class AudioRendererHost::IPCAudioSource;
  // The container for AudioOutputStream and serves the audio packet received
  // via IPC.
  class IPCAudioSource : public AudioOutputStream::AudioSourceCallback {
   public:
    // Internal state of the source.
    enum State {
      kCreated,
      kPlaying,
      kPaused,
      kClosed,
      kError,
    };

    // Factory method for creating an IPCAudioSource, returns NULL if failed.
    // The IPCAudioSource object will have an internal state of
    // AudioOutputStream::STATE_CREATED after creation.
    // If an IPCAudioSource is created successfully, a
    // ViewMsg_NotifyAudioStreamCreated message is sent to the renderer.
    // This factory method also starts requesting audio packet from the renderer
    // after creation. The renderer will thus receive
    // ViewMsg_RequestAudioPacket message.
    static IPCAudioSource* CreateIPCAudioSource(
        AudioRendererHost* host,             // Host of this source.
        int process_id,                      // Process ID of renderer.
        int route_id,                        // Routing ID to RenderView.
        int stream_id,                       // ID of this source.
        base::ProcessHandle process_handle,  // Process handle of renderer.
        AudioManager::Format format,         // Format of the stream.
        int channels,                        // Number of channels.
        int sample_rate,                     // Sampling frequency/rate.
        char bits_per_sample,                // Number of bits per sample.
        uint32 packet_size,                  // Size of hardware packet.
        bool low_latency                     // Use low-latency (socket) code
    );
    ~IPCAudioSource();

    // Methods to control playback of the stream.
    // Starts the playback of this audio output stream. The internal state will
    // be updated to AudioOutputStream::STATE_STARTED and the state update is
    // sent to the renderer.
    void Play();

    // Pause this audio output stream. The audio output stream will stop
    // reading from the |push_source_|. The internal state will be updated
    // to AudioOutputStream::STATE_PAUSED and the state update is sent to
    // the renderer.
    void Pause();

    // Discard all audio data buffered in this output stream. This method only
    // has effect when the stream is paused.
    void Flush();

    // Closes the audio output stream. After calling this method all activities
    // of the audio output stream are stopped.
    void Close();

    // Sets the volume of the audio output stream. There's no IPC messages
    // sent back to the renderer upon success and failure.
    void SetVolume(double volume);

    // Gets the volume of the audio output stream.
    // ViewMsg_NotifyAudioStreamVolume is sent back to renderer with volume
    // information if succeeded.
    void GetVolume();

    // Notify this source that buffer has been filled and is ready to be
    // consumed.
    void NotifyPacketReady(uint32 packet_size);

    // AudioSourceCallback methods.
    virtual uint32 OnMoreData(AudioOutputStream* stream, void* dest,
                              uint32 max_size, uint32 pending_bytes);
    virtual void OnClose(AudioOutputStream* stream);
    virtual void OnError(AudioOutputStream* stream, int code);

    int process_id() { return process_id_; }
    int route_id() { return route_id_; }
    int stream_id() { return stream_id_; }

   private:
    IPCAudioSource(AudioRendererHost* host,     // Host of this source.
                   int process_id,              // Process ID of renderer.
                   int route_id,                // Routing ID to RenderView.
                   int stream_id,               // ID of this source.
                   AudioOutputStream* stream,   // Stream associated.
                   uint32 hardware_packet_size,
                   uint32 buffer_capacity);     // Capacity of transportation
                                                // buffer.

    // Check the condition of |outstanding_request_| and |push_source_| to
    // determine if we should submit a new packet request.
    void SubmitPacketRequest_Locked();

    void SubmitPacketRequest(AutoLock* alock);

    // A helper method to start buffering. This method is used by
    // CreateIPCAudioSource to submit a packet request.
    void StartBuffering();

    AudioRendererHost* host_;
    int process_id_;
    int route_id_;
    int stream_id_;
    AudioOutputStream* stream_;
    uint32 hardware_packet_size_;
    uint32 buffer_capacity_;

    State state_;

    base::SharedMemory shared_memory_;
    scoped_ptr<base::SyncSocket> shared_socket_;

    // PushSource role is to buffer and it's only used in regular latency mode.
    PushSource push_source_;

    // Flag that indicates there is an outstanding request.
    bool outstanding_request_;

    // Number of bytes copied in the last OnMoreData call.
    uint32 pending_bytes_;
    base::Time last_callback_time_;

    // Protects:
    // - |outstanding_requests_|
    // - |last_copied_bytes_|
    // - |push_source_|
    Lock lock_;
  };
  //---------------------------------------------------------------------------
  // required properties. See IPCAudioSource::CreateIPCAudioSource() for more
  // details.
  // Starts buffering for the audio output stream. Delegates the start method
  // call to the corresponding IPCAudioSource::Play().
  // ViewMsg_NotifyAudioStreamStateChanged with
  // AudioOutputStream::AUDIO_STREAM_ERROR is sent back to renderer if the
  // required IPCAudioSource is not found.
  // Pauses the audio output stream. Delegates the pause method call to the
  // corresponding IPCAudioSource::Pause(),
  // ViewMsg_NotifyAudioStreamStateChanged with
  // AudioOutputStream::AUDIO_STREAM_ERROR is sent back to renderer if the
  // required IPCAudioSource is not found.
  // Discard all audio data buffered.
  // Closes the audio output stream, delegates the close method call to the
  // corresponding IPCAudioSource::Close(), no returning IPC message to renderer
  // upon success and failure.
  // Set the volume for the stream specified. Delegates the SetVolume() method
  // call to IPCAudioSource. No returning IPC message to renderer upon success.
  // ViewMsg_NotifyAudioStreamStateChanged with
  // AudioOutputStream::AUDIO_STREAM_ERROR is sent back to renderer if the
  // required IPCAudioSource is not found.
  // Gets the volume of the stream specified, delegates to corresponding
  // IPCAudioSource::GetVolume(), see the method for more details.
  // ViewMsg_NotifyAudioStreamStateChanged with
  // AudioOutputStream::AUDIO_STREAM_ERROR is sent back to renderer if the
  // required IPCAudioSource is not found.
  // Notify packet has been prepared for stream, delegates to corresponding
  // IPCAudioSource::NotifyPacketReady(), see the method for more details.
  // ViewMsg_NotifyAudioStreamStateChanged with
  // AudioOutputStream::AUDIO_STREAM_ERROR is sent back to renderer if the
  // required IPCAudioSource is not found.
  // Called on IO thread when this object needs to be destroyed and after
  // Destroy() is called from owner of this class in UI thread.
  void OnDestroyed();
  // Sends IPC messages using ipc_sender_.
  void OnSend(IPC::Message* message);
  // Closes the source, deletes it and removes it from the internal map.
  // Destruction of source and associated stream should always be done by this
  // method. *DO NOT* call this method from other than IPCAudioSource and from
  // this class.
  void OnDestroySource(IPCAudioSource* source);
  // A helper method that destroy all IPCAudioSource and associated audio
  // output streams.
  void DestroyAllSources();
  // A helper method to look up a IPCAudioSource with a tuple of render view id
  // and stream id. Returns NULL if not found.
  IPCAudioSource* Lookup(int render_view_id, int stream_id);
  typedef std::pair<int32, int32> SourceID;
  typedef std::map<SourceID, IPCAudioSource*> SourceMap;
  SourceMap sources_;
namespace {
const int kInvalidId = -1;
const int kProcessId = 100;
const int kRouteId = 200;
const uint32 kBufferCapacity = 65536;
const uint32 kPacketSize = 16384;

}  // namespace
  MockAudioRendererHost()
      : AudioRendererHost() {


  MOCK_METHOD3(OnStreamStateChanged,
               void(int routing_id, int stream_id,
                    const ViewMsg_AudioStreamState_Params& state));

 protected:
  virtual void Send(IPC::Message* message) {
 private:
  virtual ~MockAudioRendererHost() {}

    shared_memory_.reset(new base::SharedMemory(handle, true));
    OnStreamCreated(msg.routing_id(), stream_id, length);
                            const ViewMsg_AudioStreamState_Params& state) {
    OnStreamStateChanged(msg.routing_id(), stream_id, state);
      : current_stream_id_(0) {
  AudioRendererHost::IPCAudioSource* CreateAudioStream(
      AudioManager::Format format) {

                OnStreamCreated(kRouteId, current_stream_id_, kPacketSize));
    // 2. First packet request will arrive. This request is sent by
    //    IPCAudioSource::CreateIPCAudioSource to start buffering.
    EXPECT_CALL(*host_, OnRequestPacket(kRouteId, current_stream_id_, 0, _));
    AudioRendererHost::IPCAudioSource* source =
        AudioRendererHost::IPCAudioSource::CreateIPCAudioSource(
            host_,
            kProcessId,
            kRouteId,
            current_stream_id_,
            base::GetCurrentProcessHandle(),
            format,
            2,
            AudioManager::kAudioCDSampleRate,
            16,
            kPacketSize,
            false);
    EXPECT_TRUE(source);
    EXPECT_EQ(kProcessId, source->process_id());
    EXPECT_EQ(kRouteId, source->route_id());
    EXPECT_EQ(current_stream_id_, source->stream_id());
    return source;
  AudioRendererHost::IPCAudioSource* CreateRealStream() {
    return CreateAudioStream(AudioManager::AUDIO_PCM_LINEAR);
  AudioRendererHost::IPCAudioSource* CreateMockStream() {
    return CreateAudioStream(AudioManager::AUDIO_MOCK);
  int current_stream_id_;
  scoped_refptr<MockAudioRendererHost> host_;
  scoped_ptr<MessageLoop> message_loop_;
TEST_F(AudioRendererHostTest, MockStreamDataConversation) {
  scoped_ptr<AudioRendererHost::IPCAudioSource> source(CreateMockStream());

  // We will receive packet requests until the buffer is full. We first send
  // three packets of 16KB, then we send packets of 1KB until the buffer is
  // full. Then there will no more packet requests.
  InSequence s;
  EXPECT_CALL(*host_,
      OnRequestPacket(kRouteId, current_stream_id_, kPacketSize, _));
  EXPECT_CALL(*host_,
    OnRequestPacket(kRouteId, current_stream_id_, 2 * kPacketSize, _));

  const int kStep = kPacketSize / 4;
  EXPECT_CALL(*host_,
      OnRequestPacket(kRouteId, current_stream_id_,
                      2 * kPacketSize + kStep, _));
  EXPECT_CALL(*host_,
      OnRequestPacket(kRouteId, current_stream_id_,
                      2 * kPacketSize + 2 * kStep, _));
  EXPECT_CALL(*host_,
      OnRequestPacket(kRouteId, current_stream_id_,
                      2 * kPacketSize + 3 * kStep, _));
  EXPECT_CALL(*host_,
      OnRequestPacket(kRouteId, current_stream_id_, 3 * kPacketSize, _));
  ViewMsg_AudioStreamState_Params state;
  EXPECT_CALL(*host_, OnStreamStateChanged(kRouteId, current_stream_id_, _))
      .WillOnce(SaveArg<2>(&state));

  source->NotifyPacketReady(kPacketSize);
  source->NotifyPacketReady(kPacketSize);
  source->NotifyPacketReady(kStep);
  source->NotifyPacketReady(kStep);
  source->NotifyPacketReady(kStep);
  source->NotifyPacketReady(kStep);
  source->Play();
  EXPECT_EQ(ViewMsg_AudioStreamState_Params::kPlaying, state.state);
  source->Close();
      state_(kCreated),
  DCHECK(kClosed == state_ || kCreated == state_);
  // If we are in low latency mode then also close the SyncReader.
  // TODO(hclam): The shutdown procedure for low latency mode if not complete,
  // especially when OnModeData() is blocked on SyncReader for read and the
  // above Stop() would deadlock.
  if (sync_reader_)
    sync_reader_->Close();

  if (state_ == kError || state_ == kEmpty)
  stream_->SetVolume(volume);
  if (!sync_reader_) {
  callback_->OnClose(this);
  callback_ = NULL;
  {"foo-\xff.html", "ascii", false, ""},
#define IDC_ENCODING_ISO88591           35503
#if 0
  // Disable temporarily until Blink CL
  // (https://codereview.chromium.org/655083002/) is relanded.
#endif
#if 0
  // See the above.
#endif
    EXPECT_TRUE(base::ContentsEqual(full_file_name, expected_file_name));
#if 0
  // Temporarily disable until the Blink CL to use windows-1252 is relanded.
#endif
#if 0
      // Disable until the Blink CL to use 'windows-1252' is relanded.
#endif
  { IDC_ENCODING_ISO88591, "ISO-8859-1", IDS_ENCODING_WESTERN },
  IDC_ENCODING_ISO88591,
      category_string_id != IDS_ENCODING_TURKISH) {
  UErrorCode error_code = U_ZERO_ERROR;

  const char* canonical_name = ucnv_getCanonicalName(
      alias_name.c_str(), "MIME", &error_code);
  // If failed,  then try IANA next.
  if (U_FAILURE(error_code) || !canonical_name) {
    error_code = U_ZERO_ERROR;
    canonical_name = ucnv_getCanonicalName(
      alias_name.c_str(), "IANA", &error_code);
  }

  if (canonical_name) {
    // TODO(jnd) use a map to handle all customized {alias, canonical}
    // encoding mappings if we have more than one pair.
    // We don't want to add an unnecessary charset to the encoding menu, so we
    // alias 'US-ASCII' to 'ISO-8859-1' in our UI without touching WebKit.
    // http://crbug.com/15801.
    if (alias_name == "US-ASCII")
      return GetCanonicalEncodingNameByCommandId(IDC_ENCODING_ISO88591);
    return canonical_name;
  } else {
    return std::string();
#if 0
  // Disabled until the following Blink CL is relanded and rolled:
  // https://codereview.chromium.org/649413002
#endif
#if 0
  // Disabled until the following Blink CL is relanded and rolled:
  // https://codereview.chromium.org/649413002
#endif
    case IDC_ENCODING_ISO88591:
  command_updater_.UpdateCommandEnabled(IDC_ENCODING_ISO88591, true);
    IDC_ENCODING_ISO88591,
  EXPECT_FALSE(model.IsCommandIdChecked(IDC_ENCODING_ISO88591));

        if (!SubresourceIntegrity::CheckSubresourceIntegrity(*m_element, sourceCode.source(), sourceCode.resource()->url(), sourceCode.resource()->mimeType()))
            return;
bool Resource::passesAccessControlCheck(ExecutionContext* context, SecurityOrigin* securityOrigin)
bool Resource::passesAccessControlCheck(ExecutionContext* context, SecurityOrigin* securityOrigin, String& errorDescription)
    bool passesAccessControlCheck(ExecutionContext*, SecurityOrigin*);
    bool passesAccessControlCheck(ExecutionContext*, SecurityOrigin*, String& errorDescription);
bool ResourceFetcher::canAccessResource(Resource* resource, SecurityOrigin* sourceOrigin, const KURL& url) const
        if (!forPreload && frame() && frame()->document()) {
    virtual bool canAccessResource(Resource*, SecurityOrigin*, const KURL&) const override;
            if (!m_host->canAccessResource(resource, m_options.securityOrigin.get(), response.url())) {
    virtual bool canAccessResource(Resource*, SecurityOrigin* sourceOrigin, const KURL&) const = 0;
bool SubresourceIntegrity::CheckSubresourceIntegrity(const Element& element, const String& source, const KURL& resourceUrl, const String& resourceType)
    static bool CheckSubresourceIntegrity(const Element&, const WTF::String& content, const KURL& resourceUrl, const WTF::String& mimeType);
    void expectIntegrity(const char* integrity, const char* script, const KURL& url, const String& mimeType = String())
        EXPECT_TRUE(SubresourceIntegrity::CheckSubresourceIntegrity(*scriptElement, script, url, mimeType));
    void expectIntegrityFailure(const char* integrity, const char* script, const KURL& url, const String& mimeType = String())
        EXPECT_FALSE(SubresourceIntegrity::CheckSubresourceIntegrity(*scriptElement, script, url, mimeType));
    expectIntegrity(kSha256Integrity, kBasicScript, secureURL);
    expectIntegrity(kSha384Integrity, kBasicScript, secureURL);
    expectIntegrity(kSha512Integrity, kBasicScript, secureURL);
    expectIntegrityFailure(kSha384IntegrityLabeledAs256, kBasicScript, secureURL);
    expectIntegrityFailure(kUnsupportedHashFunctionIntegrity, kBasicScript, secureURL);
    // The same checks as CheckSubresourceIntegrityInSecureOrigin should pass here.
    expectIntegrity(kSha256Integrity, kBasicScript, secureURL);
    expectIntegrity(kSha384Integrity, kBasicScript, secureURL);
    expectIntegrity(kSha512Integrity, kBasicScript, secureURL);
    expectIntegrityFailure(kSha384IntegrityLabeledAs256, kBasicScript, secureURL);
    expectIntegrityFailure(kUnsupportedHashFunctionIntegrity, kBasicScript, secureURL);
    if (!SubresourceIntegrity::CheckSubresourceIntegrity(*m_owner, cachedStyleSheet->sheetText(), KURL(KURL(), href), cachedStyleSheet->mimeType())) {
#include "grit/extensions_renderer_resources.h"
#include "grit/extensions_renderer_resources.h"
#include "grit/extensions_renderer_resources.h"
#include "grit/extensions_renderer_resources.h"
#include "grit/extensions_renderer_resources.h"
// static
uint64 SpdyIOBuffer::order_ = 0;
SpdyIOBuffer::SpdyIOBuffer(
    IOBuffer* buffer, int size, RequestPriority priority, SpdyStream* stream)
  : buffer_(new DrainableIOBuffer(buffer, size)),
    priority_(priority),
    position_(++order_),
    stream_(stream) {}

SpdyIOBuffer::SpdyIOBuffer() : priority_(HIGHEST), position_(0), stream_(NULL) {
}
  priority_ = rhs.priority_;
  position_ = rhs.position_;
  priority_ = rhs.priority_;
  position_ = rhs.position_;
void SpdyIOBuffer::release() {
#include "net/base/request_priority.h"
// A class for managing SPDY IO buffers.  These buffers need to be prioritized
// so that the SpdySession sends them in the right order.  Further, they need
// to track the SpdyStream which they are associated with so that incremental
// completion of the IO can notify the appropriate stream of completion.
  // |priority| is the priority of this buffer.
  // |stream| is a pointer to the stream which is managing this buffer.
  SpdyIOBuffer(IOBuffer* buffer, int size, RequestPriority priority,
               SpdyStream* stream);
  SpdyIOBuffer();
  size_t size() const { return buffer_->size(); }
  void release();
  RequestPriority priority() const { return priority_; }
  // Comparison operator to support sorting.
  bool operator<(const SpdyIOBuffer& other) const {
    if (priority_ != other.priority_)
      return priority_ < other.priority_;
    return position_ > other.position_;
  }

  RequestPriority priority_;
  uint64 position_;
  static uint64 order_;  // Maintains a FIFO order for equal priorities.
// static
void SpdySession::SpdyIOBufferProducer::ActivateStream(
    SpdySession* spdy_session,
    SpdyStream* spdy_stream) {
  spdy_session->ActivateStream(spdy_stream);
}

// static
SpdyIOBuffer* SpdySession::SpdyIOBufferProducer::CreateIOBuffer(
    SpdyFrame* frame,
    RequestPriority priority,
    SpdyStream* stream) {
  size_t size = frame->size();
  DCHECK_GT(size, 0u);

  // TODO(mbelshe): We have too much copying of data here.
  IOBufferWithSize* buffer = new IOBufferWithSize(size);
  memcpy(buffer->data(), frame->data(), size);

  return new SpdyIOBuffer(buffer, size, priority, stream);
}

  for (int i = NUM_PRIORITIES - 1; i >= MINIMUM_PRIORITY; --i) {
void SpdySession::SetStreamHasWriteAvailable(SpdyStream* stream,
                                             SpdyIOBufferProducer* producer) {
  write_queue_.push(producer);
  stream_producers_[producer] = stream;
  WriteSocketLater();
}

SpdyFrame* SpdySession::CreateSynStream(
  return syn_frame.release();
SpdyFrame* SpdySession::CreateCredentialFrame(
    RequestPriority priority) {
  DCHECK_EQ(OK, rv);
    return NULL;
  scoped_ptr<SpdyFrame> credential_frame(
  return credential_frame.release();
SpdyFrame* SpdySession::CreateHeadersFrame(
  return frame.release();
SpdyFrame* SpdySession::CreateDataFrame(SpdyStreamId stream_id,
                                        net::IOBuffer* data, int len,
                                        SpdyDataFlags flags) {
    return NULL;
      return NULL;
        return NULL;
  return frame.release();
  QueueFrame(rst_frame.release(), priority);
  DCHECK(in_flight_write_.size());
  scoped_refptr<SpdyStream> stream = in_flight_write_.stream();

  if (result >= 0) {
    // It should not be possible to have written more bytes than our
    // in_flight_write_.
    DCHECK_LE(result, in_flight_write_.buffer()->BytesRemaining());

    in_flight_write_.buffer()->DidConsume(result);

    // We only notify the stream when we've fully written the pending frame.
    if (!in_flight_write_.buffer()->BytesRemaining()) {
      if (stream) {
        // Report the number of bytes written to the caller, but exclude the
        // frame size overhead.  NOTE: if this frame was compressed the
        // reported bytes written is the compressed size, not the original
        // size.
        if (result > 0) {
          result = in_flight_write_.buffer()->size();
          DCHECK_GE(result,
                    static_cast<int>(
                        buffered_spdy_framer_->GetControlFrameHeaderSize()));
          result -= buffered_spdy_framer_->GetControlFrameHeaderSize();
        }

        // It is possible that the stream was cancelled while we were writing
        // to the socket.
        if (!stream->cancelled())
          stream->OnWriteComplete(result);
      }
      // Cleanup the write which just completed.
      in_flight_write_.release();
    }
    // Write more data.  We're already in a continuation, so we can
    // go ahead and write it immediately (without going back to the
    // message loop).
    WriteSocketLater();
  } else {
    in_flight_write_.release();
    // The stream is now errored.  Close it down.
    CloseSessionOnError(
        static_cast<net::Error>(result), true, "The stream has errored.");
  while (in_flight_write_.buffer() || !write_queue_.empty()) {
    if (!in_flight_write_.buffer()) {
      // Grab the next SpdyBuffer to send.
      scoped_ptr<SpdyIOBufferProducer> producer(write_queue_.top());
      write_queue_.pop();
      scoped_ptr<SpdyIOBuffer> buffer(producer->ProduceNextBuffer(this));
      stream_producers_.erase(producer.get());
      if (buffer == NULL)
      in_flight_write_ = *buffer;
    } else {
      DCHECK(in_flight_write_.buffer()->BytesRemaining());
  // We also need to drain the queue.
  while (!write_queue_.empty()) {
    scoped_ptr<SpdyIOBufferProducer> producer(write_queue_.top());
    write_queue_.pop();
    stream_producers_.erase(producer.get());
  }
class SimpleSpdyIOBufferProducer : public SpdySession::SpdyIOBufferProducer {
 public:
  SimpleSpdyIOBufferProducer(SpdyFrame* frame,
                             RequestPriority priority)
      : frame_(frame),
        priority_(priority) {
  }

  virtual RequestPriority GetPriority() const OVERRIDE {
    return priority_;
  }

  virtual SpdyIOBuffer* ProduceNextBuffer(SpdySession* session) OVERRIDE {
    return SpdySession::SpdyIOBufferProducer::CreateIOBuffer(
        frame_.get(), priority_, NULL);
  }

 private:
  scoped_ptr<SpdyFrame> frame_;
  RequestPriority priority_;
};
void SpdySession::QueueFrame(SpdyFrame* frame,
                             RequestPriority priority) {
  SimpleSpdyIOBufferProducer* producer =
      new SimpleSpdyIOBufferProducer(frame, priority);
  write_queue_.push(producer);
    PushedStreamMap::iterator it;
    for (it = unclaimed_pushed_streams_.begin();
  ActiveStreamMap::iterator it2 = active_streams_.find(id);
  if (it2 == active_streams_.end())
  // Possibly remove from the write queue.
  WriteQueue old = write_queue_;
  write_queue_ = WriteQueue();
  while (!old.empty()) {
    scoped_ptr<SpdyIOBufferProducer> producer(old.top());
    old.pop();
    StreamProducerMap::iterator it = stream_producers_.find(producer.get());
    if (it == stream_producers_.end() || it->second->stream_id() != id) {
      write_queue_.push(producer.release());
    } else {
      stream_producers_.erase(producer.get());
      producer.reset(NULL);
    }
  }
  const scoped_refptr<SpdyStream> stream(it2->second);
  active_streams_.erase(it2);
  DCHECK(stream);
  QueueFrame(settings_frame.release(), HIGHEST);
  QueueFrame(window_update_frame.release(), priority);
  QueueFrame(ping_frame.release(), HIGHEST);
#include <list>
#include <queue>
  // Defines an interface for producing SpdyIOBuffers.
  class NET_EXPORT_PRIVATE SpdyIOBufferProducer {
   public:
    SpdyIOBufferProducer() {}

    // Returns a newly created SpdyIOBuffer, owned by the caller, or NULL
    // if not buffer is ready to be produced.
    virtual SpdyIOBuffer* ProduceNextBuffer(SpdySession* session) = 0;

    virtual RequestPriority GetPriority() const = 0;

    virtual ~SpdyIOBufferProducer() {}

   protected:
    // Activates |spdy_stream| in |spdy_session|.
    static void ActivateStream(SpdySession* spdy_session,
                               SpdyStream* spdy_stream);

    static SpdyIOBuffer* CreateIOBuffer(SpdyFrame* frame,
                                        RequestPriority priority,
                                        SpdyStream* spdy_stream);
  };

  // Records that |stream| has a write available from |producer|.
  // |producer| will be owned by this SpdySession.
  void SetStreamHasWriteAvailable(SpdyStream* stream,
                                  SpdyIOBufferProducer* producer);
  // Send the SYN frame for |stream_id|. This also sends PING message to check
  // the status of the connection.
  SpdyFrame* CreateSynStream(
  // Write a CREDENTIAL frame to the session.
  SpdyFrame* CreateCredentialFrame(const std::string& origin,
                                   SSLClientCertType type,
                                   const std::string& key,
                                   const std::string& cert,
                                   RequestPriority priority);

  // Write a HEADERS frame to the stream.
  SpdyFrame* CreateHeadersFrame(SpdyStreamId stream_id,
                                const SpdyHeaderBlock& headers,
                                SpdyControlFlags flags);

  // Write a data frame to the stream.
  // Used to create and queue a data frame for the given stream.
  SpdyFrame* CreateDataFrame(SpdyStreamId stream_id,
                             net::IOBuffer* data, int len,
                             SpdyDataFlags flags);
  typedef std::map<SpdyIOBufferProducer*, SpdyStream*> StreamProducerMap;

  class SpdyIOBufferProducerCompare {
   public:
    bool operator() (const SpdyIOBufferProducer* lhs,
                     const SpdyIOBufferProducer* rhs) const {
      return lhs->GetPriority() < rhs->GetPriority();
    }
  };

  typedef std::priority_queue<SpdyIOBufferProducer*,
                              std::vector<SpdyIOBufferProducer*>,
                              SpdyIOBufferProducerCompare> WriteQueue;
  // Queue a frame for sending.
  // |frame| is the frame to send.
  // |priority| is the priority for insertion into the queue.
  void QueueFrame(SpdyFrame* frame, RequestPriority priority);
  // As streams have data to be sent, we put them into the write queue.
  WriteQueue write_queue_;

  // Mapping from SpdyIOBufferProducers to their corresponding SpdyStream
  // so that when a stream is destroyed, we can remove the corresponding
  // producer from |write_queue_|.
  StreamProducerMap stream_producers_;
// Test the SpdyIOBuffer class.
TEST_F(SpdySessionSpdy2Test, SpdyIOBuffer) {
  std::priority_queue<SpdyIOBuffer> queue_;
  const size_t kQueueSize = 100;

  // Insert items with random priority and increasing buffer size.
  for (size_t index = 0; index < kQueueSize; ++index) {
    queue_.push(SpdyIOBuffer(
        new IOBufferWithSize(index + 1),
        index + 1,
        static_cast<RequestPriority>(rand() % NUM_PRIORITIES),
        NULL));
  }

  EXPECT_EQ(kQueueSize, queue_.size());

  // Verify items come out with decreasing priority or FIFO order.
  RequestPriority last_priority = NUM_PRIORITIES;
  size_t last_size = 0;
  for (size_t index = 0; index < kQueueSize; ++index) {
    SpdyIOBuffer buffer = queue_.top();
    EXPECT_LE(buffer.priority(), last_priority);
    if (buffer.priority() < last_priority)
      last_size = 0;
    EXPECT_LT(last_size, buffer.size());
    last_priority = buffer.priority();
    last_size = buffer.size();
    queue_.pop();
  }

  EXPECT_EQ(0u, queue_.size());
}

// Test the SpdyIOBuffer class.
TEST_F(SpdySessionSpdy3Test, SpdyIOBuffer) {
  std::priority_queue<SpdyIOBuffer> queue_;
  const size_t kQueueSize = 100;

  // Insert items with random priority and increasing buffer size.
  for (size_t index = 0; index < kQueueSize; ++index) {
    queue_.push(SpdyIOBuffer(
        new IOBufferWithSize(index + 1),
        index + 1,
        static_cast<RequestPriority>(rand() % NUM_PRIORITIES),
        NULL));
  }

  EXPECT_EQ(kQueueSize, queue_.size());

  // Verify items come out with decreasing priority or FIFO order.
  RequestPriority last_priority = NUM_PRIORITIES;
  size_t last_size = 0;
  for (size_t index = 0; index < kQueueSize; ++index) {
    SpdyIOBuffer buffer = queue_.top();
    EXPECT_LE(buffer.priority(), last_priority);
    if (buffer.priority() < last_priority)
      last_size = 0;
    EXPECT_LT(last_size, buffer.size());
    last_priority = buffer.priority();
    last_size = buffer.size();
    queue_.pop();
  }

  EXPECT_EQ(0u, queue_.size());
}

class SpdyStream::SpdyStreamIOBufferProducer
    : public SpdySession::SpdyIOBufferProducer {
 public:
  SpdyStreamIOBufferProducer(SpdyStream* stream) : stream_(stream) {}

  // SpdyFrameProducer
  virtual RequestPriority GetPriority() const OVERRIDE {
    return stream_->priority();
  }

  virtual SpdyIOBuffer* ProduceNextBuffer(SpdySession* session) OVERRIDE {
    if (stream_->cancelled())
      return NULL;
    if (stream_->stream_id() == 0)
      SpdySession::SpdyIOBufferProducer::ActivateStream(session, stream_);
    frame_ = stream_->ProduceNextFrame();
    return frame_ == NULL ? NULL :
        SpdySession::SpdyIOBufferProducer::CreateIOBuffer(
            frame_.get(), GetPriority(), stream_);
  }

 private:
  scoped_refptr<SpdyStream> stream_;
  scoped_ptr<SpdyFrame> frame_;
};

void SpdyStream::SetHasWriteAvailable() {
  session_->SetStreamHasWriteAvailable(this,
                                       new SpdyStreamIOBufferProducer(this));
}

scoped_ptr<SpdyFrame> SpdyStream::ProduceNextFrame() {
  if (io_state_ == STATE_SEND_DOMAIN_BOUND_CERT_COMPLETE) {
    CHECK(request_.get());
    CHECK_GT(stream_id_, 0u);

    std::string origin = GetUrl().GetOrigin().spec();
    DCHECK(origin[origin.length() - 1] == '/');
    origin.erase(origin.length() - 1);  // Trim trailing slash.
    scoped_ptr<SpdyFrame> frame(session_->CreateCredentialFrame(
        origin, domain_bound_cert_type_, domain_bound_private_key_,
        domain_bound_cert_, priority_));
    return frame.Pass();
  } else if (io_state_ == STATE_SEND_HEADERS_COMPLETE) {
    CHECK(request_.get());
    CHECK_GT(stream_id_, 0u);

    SpdyControlFlags flags =
        has_upload_data_ ? CONTROL_FLAG_NONE : CONTROL_FLAG_FIN;
    scoped_ptr<SpdyFrame> frame(session_->CreateSynStream(
        stream_id_, priority_, slot_, flags, *request_));
    send_time_ = base::TimeTicks::Now();
    return frame.Pass();
  } else {
    CHECK(!cancelled());
    // We must need to write stream data.
    // Until the headers have been completely sent, we can not be sure
    // that our stream_id is correct.
    DCHECK_GT(io_state_, STATE_SEND_HEADERS_COMPLETE);
    DCHECK_GT(stream_id_, 0u);
    DCHECK(!pending_frames_.empty());

    PendingFrame frame = pending_frames_.front();
    pending_frames_.pop_front();

    waiting_completions_.push_back(frame.type);

    if (frame.type == TYPE_DATA) {
      // Send queued data frame.
      return scoped_ptr<SpdyFrame>(frame.data_frame);
    } else {
      DCHECK(frame.type == TYPE_HEADERS);
      // Create actual HEADERS frame just in time because it depends on
      // compression context and should not be reordered after the creation.
      scoped_ptr<SpdyFrame> header_frame(session_->CreateHeadersFrame(
          stream_id_, *frame.header_block, SpdyControlFlags()));
      delete frame.header_block;
      return header_frame.Pass();
    }
  }
  NOTREACHED();
}

  while (!pending_frames_.empty()) {
    PendingFrame frame = pending_frames_.back();
    pending_frames_.pop_back();
    if (frame.type == TYPE_DATA)
      delete frame.data_frame;
    else
      delete frame.header_block;
  }
  PendingFrame frame;
  frame.type = TYPE_HEADERS;
  // |frame.header_block| is deleted by either ProduceNextFrame() or
  // the destructor.
  frame.header_block = headers.release();
  pending_frames_.push_back(frame);
  SetHasWriteAvailable();
  PendingFrame frame;
  frame.type = TYPE_DATA;
  // |frame.data_frame| is either returned by ProduceNextFrame() or
  // deleted in the destructor.
  frame.data_frame = data_frame.release();
  pending_frames_.push_back(frame);
  SetHasWriteAvailable();
      // OnDataReceived, OnClose and OnWriteCompelte can be called.
  SetHasWriteAvailable();

  SetHasWriteAvailable();
#include <list>
  // Structure to contains pending frame information.
  typedef struct {
    FrameType type;
    union {
      SpdyHeaderBlock* header_block;
      SpdyFrame* data_frame;
    };
  } PendingFrame;

  class SpdyStreamIOBufferProducer;
  // Informs the SpdySession that this stream has a write available.
  void SetHasWriteAvailable();
  // Returns a newly created SPDY frame owned by the called that contains
  // the next frame to be sent by this frame.  May return NULL if this
  // stream has become stalled on flow control.
  scoped_ptr<SpdyFrame> ProduceNextFrame();
  // An in order list of pending frame data that are going to be sent. HEADERS
  // frames are queued as SpdyHeaderBlock structures because these must be
  // compressed just before sending. Data frames are queued as SpdyDataFrame.
  std::list<PendingFrame> pending_frames_;

  // An in order list of sending frame types. It will be used to know which type
  // of frame is sent and which callback should be invoked in OnOpen().
  std::list<FrameType> waiting_completions_;
      shelf_visible_(false),
      capturing_contents_(false),
      is_being_destroyed_(false) {
  // Data ----------------------------------------------------------------------
  bool is_crashed_;  // true if the tab is considered crashed.
  // The download shelf view (view at the bottom of the page).
  scoped_ptr<DownloadShelf> download_shelf_;

  // Whether the shelf view is visible.
  bool shelf_visible_;

  // See capturing_contents() above.
  bool capturing_contents_;
  // popups. This pointer alsog goes in |child_windows_| for ownership,
class WebContents::GearsCreateShortcutCallbackFunctor {
 public:
  explicit GearsCreateShortcutCallbackFunctor(WebContents* contents)
     : contents_(contents) {}

  void Run(const GearsShortcutData2& shortcut_data, bool success) {
    if (contents_)
      contents_->OnGearsCreateShortcutDone(shortcut_data, success);
    delete this;
  }
  void Cancel() {
    contents_ = NULL;
  }

 private:
  WebContents* contents_;
};

// static
int WebContents::find_request_id_counter_ = -1;

    : TabContents(profile),
      view_(TabContentsView::Create(this)),
      ALLOW_THIS_IN_INITIALIZER_LIST(render_manager_(this, this)),
      printing_(*this),
      notify_disconnection_(false),
      received_page_title_(false),
      is_starred_(false),
#if defined(OS_WIN)
      message_box_active_(CreateEvent(NULL, TRUE, FALSE, NULL)),
#endif
      ALLOW_THIS_IN_INITIALIZER_LIST(fav_icon_helper_(this)),
      suppress_javascript_messages_(false),
      load_state_(net::LOAD_STATE_IDLE),
      find_ui_active_(false),
      find_op_aborted_(false),
      current_find_request_id_(find_request_id_counter_++),
      find_prepopulate_text_(NULL) {
void WebContents::OnGearsCreateShortcutDone(
    const GearsShortcutData2& shortcut_data, bool success) {
  NavigationEntry* current_entry = controller_.GetLastCommittedEntry();
  bool same_page =
      current_entry && pending_install_.page_id == current_entry->page_id();

  if (success && same_page) {
    // Only switch to app mode if the user chose to create a shortcut and
    // we're still on the same page that it corresponded to.
    if (delegate())
      delegate()->ConvertContentsToApplication(this);
  }

  // Reset the page id to indicate no requests are pending.
  pending_install_.page_id = 0;
  pending_install_.callback_functor = NULL;
}

#include "base/basictypes.h"
#include "chrome/browser/cancelable_request.h"
#include "chrome/browser/download/save_package.h"
#include "chrome/browser/fav_icon_helper.h"
#include "chrome/browser/find_notification_details.h"
#include "chrome/browser/renderer_host/render_view_host_delegate.h"
#include "chrome/browser/shell_dialogs.h"
#include "chrome/browser/tab_contents/navigation_controller.h"
#include "chrome/browser/tab_contents/render_view_host_manager.h"
#include "chrome/common/gears_api.h"
#include "net/base/load_states.h"
#include "webkit/glue/password_form.h"
#include "webkit/glue/webpreferences.h"

#if defined(OS_MACOSX) || defined(OS_LINUX)
// Remove when we've finished porting the supporting classes.
#include "chrome/common/temp_scaffolding_stubs.h"
#elif defined(OS_WIN)
#include "chrome/browser/printing/print_view_manager.h"
#endif
class AutofillManager;
class PasswordManager;
class PluginInstaller;
class TabContentsView;
  // When CreateShortcut is invoked RenderViewHost::GetApplicationInfo is
  // invoked. CreateShortcut caches the state of the page needed to create the
  // shortcut in PendingInstall. When OnDidGetApplicationInfo is invoked, it
  // uses the information from PendingInstall and the WebApplicationInfo
  // to create the shortcut.
  class GearsCreateShortcutCallbackFunctor;
  struct PendingInstall {
    int32 page_id;
    SkBitmap icon;
    std::wstring title;
    GURL url;
    // This object receives the GearsCreateShortcutCallback and routes the
    // message back to the WebContents, if we haven't been deleted.
    GearsCreateShortcutCallbackFunctor* callback_functor;
  };

  // Called when the user dismisses the shortcut creation dialog.  'success' is
  // true if the shortcut was created.
  void OnGearsCreateShortcutDone(const GearsShortcutData2& shortcut_data,
                                 bool success);

  // Data ----------------------------------------------------------------------

  // The corresponding view.
  scoped_ptr<TabContentsView> view_;

  // Manages creation and swapping of render views.
  RenderViewHostManager render_manager_;

  // Handles print preview and print job for this contents.
  printing::PrintViewManager printing_;

  // Indicates whether we should notify about disconnection of this
  // WebContents. This is used to ensure disconnection notifications only
  // happen if a connection notification has happened and that they happen only
  // once.
  bool notify_disconnection_;

  // Maps from handle to page_id.
  typedef std::map<HistoryService::Handle, int32> HistoryRequestMap;
  HistoryRequestMap history_requests_;

  // System time at which the current load was started.
  base::TimeTicks current_load_start_;

  // Whether we have a (non-empty) title for the current page.
  // Used to prevent subsequent title updates from affecting history. This
  // prevents some weirdness because some AJAXy apps use titles for status
  // messages.
  bool received_page_title_;

  // SavePackage, lazily created.
  scoped_refptr<SavePackage> save_package_;

  // Tracks our pending CancelableRequests. This maps pending requests to
  // page IDs so that we know whether a given callback still applies. The
  // page ID -1 means no page ID was set.
  CancelableRequestConsumerT<int32, -1> cancelable_consumer_;

  // Whether the current URL is starred
  bool is_starred_;

#if defined(OS_WIN)
  // Handle to an event that's set when the page is showing a message box (or
  // equivalent constrained window).  Plugin processes check this to know if
  // they should pump messages then.
  ScopedHandle message_box_active_;
#endif

  // AutofillManager, lazily created.
  scoped_ptr<AutofillManager> autofill_manager_;

  // PasswordManager, lazily created.
  scoped_ptr<PasswordManager> password_manager_;

  // PluginInstaller, lazily created.
  scoped_ptr<PluginInstaller> plugin_installer_;

  // Handles downloading favicons.
  FavIconHelper fav_icon_helper_;

  // Dialog box used for choosing files to upload from file form fields.
  scoped_refptr<SelectFileDialog> select_file_dialog_;

  // The time that the last javascript message was dismissed.
  base::TimeTicks last_javascript_message_dismissal_;

  // True if the user has decided to block future javascript messages. This is
  // reset on navigations to false on navigations.
  bool suppress_javascript_messages_;

  // When a navigation occurs, we record its contents MIME type. It can be
  // used to check whether we can do something for some special contents.
  std::string contents_mime_type_;

  // Character encoding. TODO(jungshik) : convert to std::string
  std::wstring encoding_;

  PendingInstall pending_install_;

  // The last time that the download shelf was made visible.
  base::TimeTicks last_download_shelf_show_;

  // The current load state and the URL associated with it.
  net::LoadState load_state_;
  std::wstring load_state_host_;

  // True if the Find UI is active for this Tab.
  bool find_ui_active_;

  // True if a Find operation was aborted. This can happen if the Find box is
  // closed or if the search term inside the Find box is erased while a search
  // is in progress. This can also be set if a page has been reloaded, and will
  // on FindNext result in a full Find operation so that the highlighting for
  // inactive matches can be repainted.
  bool find_op_aborted_;

  // Each time a search request comes in we assign it an id before passing it
  // over the IPC so that when the results come in we can evaluate whether we
  // still care about the results of the search (in some cases we don't because
  // the user has issued a new search).
  static int find_request_id_counter_;

  // This variable keeps track of what the most recent request id is.
  int current_find_request_id_;

  // The last string we searched for. This is used to figure out if this is a
  // Find or a FindNext operation (FindNext should not increase the request id).
  string16 find_text_;

  // Keeps track of the last search string that was used to search in any tab.
  string16* find_prepopulate_text_;

  // The last find result. This object contains details about the number of
  // matches, the find selection rectangle, etc. The UI can access this
  // information to build its presentation.
  FindNotificationDetails find_result_;

DevToolsManager::DevToolsManager() : web_contents_listeners_(NULL) {
  DCHECK(!web_contents_listeners_.get()) <<
    Source<WebContents> src(source);
    const WebContents& web_contents) {
  const NavigationController& navigation_controller = web_contents.controller();
    WebContents& web_contents,
  DCHECK(!GetDevToolsClientHostFor(web_contents));
  NavigationController* navigation_controller = &web_contents.controller();
  SendAttachToAgent(web_contents, web_contents.render_view_host());
  WebContents* wc = tc->AsWebContents();
  if (!wc) {
    return;
  }
  RenderViewHost* target_host = wc->render_view_host();
  WebContents* wc = from.delegate()->GetAsWebContents();
void DevToolsManager::OpenDevToolsWindow(WebContents* wc) {
void DevToolsManager::InspectElement(WebContents* wc, int x, int y) {
  WebContents* web_contents = tab_contents->AsWebContents();
  if (!web_contents) {
    return;
  }
  SendDetachToAgent(*web_contents);
  if (!web_contents_listeners_.get()) {
    web_contents_listeners_.reset(new NotificationRegistrar);
    web_contents_listeners_->Add(
  DCHECK(web_contents_listeners_.get());
    web_contents_listeners_.reset();
void DevToolsManager::SendAttachToAgent(const WebContents& wc,
void DevToolsManager::SendDetachToAgent(const WebContents& wc) {
class WebContents;
  // Returns DevToolsClientHost registered for |web_contents| or NULL if
  // there is no alive DevToolsClientHost registered for |web_contents|.
  DevToolsClientHost* GetDevToolsClientHostFor(const WebContents& web_contents);
  // Registers new DevToolsClientHost for |web_contents|. There must be no
  // other DevToolsClientHosts registered for the WebContents at the moment.
  void RegisterDevToolsClientHostFor(WebContents& web_contents,
  void OpenDevToolsWindow(WebContents* wc);
  void InspectElement(WebContents* web_contents, int x, int y);
  // there is a DevToolsClientHost registered for the |web_contents|.
      const WebContents& web_contents,
  void SendDetachToAgent(const WebContents& web_contents);
  scoped_ptr<NotificationRegistrar> web_contents_listeners_;
  // Our benavior is just to report that the entry was committed.
  string16 default_title = WideToUTF16Hack(GetDefaultTitle());
  controller_.pending_entry()->set_title(default_title);
  controller_.CommitPendingEntry();
  virtual const string16& GetTitle() const = 0;
  virtual SiteInstance* GetSiteInstance() const = 0;
  virtual bool ShouldDisplayURL() = 0;
  virtual bool ShouldDisplayFavIcon() = 0;
  virtual std::wstring GetStatusText() const = 0;
  virtual void DidBecomeSelected() = 0;
  virtual void WasHidden() = 0;
  virtual bool NavigateToPendingEntry(bool reload) = 0;
  virtual void Stop() = 0;
  virtual void Cut() = 0;
  virtual void Copy() = 0;
  virtual void Paste() = 0;
  virtual void DisassociateFromPopupCount() = 0;
  virtual TabContents* Clone() = 0;
  virtual void PopupNotificationVisibilityChanged(bool visible) = 0;
  virtual gfx::NativeView GetContentNativeView() = 0;
  virtual gfx::NativeView GetNativeView() const = 0;
  virtual void GetContainerBounds(gfx::Rect *out) const = 0;
  virtual void Focus() = 0;
  virtual void SetInitialFocus(bool reverse) = 0;
  virtual bool IsBookmarkBarAlwaysVisible() = 0;
  virtual void SetDownloadShelfVisible(bool visible) = 0;
  virtual void SetIsLoading(bool is_loading,
                            LoadNotificationDetails* details) = 0;
const string16& WebContents::GetTitle() const {
  DOMUI* our_dom_ui = render_manager_.pending_dom_ui() ?
      render_manager_.pending_dom_ui() : render_manager_.dom_ui();
  if (our_dom_ui) {
    // Don't override the title in view source mode.
    NavigationEntry* entry = controller_.GetActiveEntry();
    if (!(entry && entry->IsViewSourceMode())) {
      // Give the DOM UI the chance to override our title.
      const string16& title = our_dom_ui->overridden_title();
      if (!title.empty())
        return title;
    }
  }

  // We use the title for the last committed entry rather than a pending
  // navigation entry. For example, when the user types in a URL, we want to
  // keep the old page's title until the new load has committed and we get a new
  // title.
  // The exception is with transient pages, for which we really want to use
  // their title, as they are not committed.
  NavigationEntry* entry = controller_.GetTransientEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);

  entry = controller_.GetLastCommittedEntry();
  if (entry)
    return entry->GetTitleForDisplay(&controller_);
  else if (controller_.LoadingURLLazily())
    return controller_.GetLazyTitle();
  return EmptyString16();
}

SiteInstance* WebContents::GetSiteInstance() const {
  return render_manager_.current_host()->site_instance();
}

bool WebContents::ShouldDisplayURL() {
  // Don't hide the url in view source mode.
  NavigationEntry* entry = controller_.GetActiveEntry();
  if (entry && entry->IsViewSourceMode())
    return true;
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->should_hide_url();
  return true;
}

bool WebContents::ShouldDisplayFavIcon() {
  // Always display a throbber during pending loads.
  if (controller_.GetLastCommittedEntry() && controller_.pending_entry())
    return true;

  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return !dom_ui->hide_favicon();
  return true;
}

std::wstring WebContents::GetStatusText() const {
  if (!is_loading() || load_state_ == net::LOAD_STATE_IDLE)
    return std::wstring();

  switch (load_state_) {
    case net::LOAD_STATE_WAITING_FOR_CACHE:
      return l10n_util::GetString(IDS_LOAD_STATE_WAITING_FOR_CACHE);
    case net::LOAD_STATE_RESOLVING_PROXY_FOR_URL:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_PROXY_FOR_URL);
    case net::LOAD_STATE_RESOLVING_HOST:
      return l10n_util::GetString(IDS_LOAD_STATE_RESOLVING_HOST);
    case net::LOAD_STATE_CONNECTING:
      return l10n_util::GetString(IDS_LOAD_STATE_CONNECTING);
    case net::LOAD_STATE_SENDING_REQUEST:
      return l10n_util::GetString(IDS_LOAD_STATE_SENDING_REQUEST);
    case net::LOAD_STATE_WAITING_FOR_RESPONSE:
      return l10n_util::GetStringF(IDS_LOAD_STATE_WAITING_FOR_RESPONSE,
                                   load_state_host_);
    // Ignore net::LOAD_STATE_READING_RESPONSE and net::LOAD_STATE_IDLE
    case net::LOAD_STATE_IDLE:
    case net::LOAD_STATE_READING_RESPONSE:
      break;
  }

  return std::wstring();
}

bool WebContents::NavigateToPendingEntry(bool reload) {
  const NavigationEntry& entry = *controller_.pending_entry();

  RenderViewHost* dest_render_view_host = render_manager_.Navigate(entry);
  if (!dest_render_view_host)
    return false;  // Unable to create the desired render view host.

  // Tell DevTools agent that it is attached prior to the navigation.
  DevToolsManager* dev_tools_manager = g_browser_process->devtools_manager();
  if (dev_tools_manager)  // NULL in unit tests.
    dev_tools_manager->SendAttachToAgent(*this, dest_render_view_host);

  // Used for page load time metrics.
  current_load_start_ = TimeTicks::Now();

  // Navigate in the desired RenderViewHost.
  dest_render_view_host->NavigateToEntry(entry, reload);

  if (entry.page_id() == -1) {
    // HACK!!  This code suppresses javascript: URLs from being added to
    // session history, which is what we want to do for javascript: URLs that
    // do not generate content.  What we really need is a message from the
    // renderer telling us that a new page was not created.  The same message
    // could be used for mailto: URLs and the like.
    if (entry.url().SchemeIs(chrome::kJavaScriptScheme))
      return false;
  }

  // Clear any provisional password saves - this stops password infobars
  // showing up on pages the user navigates to while the right page is
  // loading.
  GetPasswordManager()->ClearProvisionalSave();

  if (reload && !profile()->IsOffTheRecord()) {
    HistoryService* history =
        profile()->GetHistoryService(Profile::IMPLICIT_ACCESS);
    if (history)
      history->SetFavIconOutOfDateForPage(entry.url());
  }

  return true;
}

void WebContents::Stop() {
  render_manager_.Stop();
  printing_.Stop();
}

void WebContents::Cut() {
  render_view_host()->Cut();
}

void WebContents::Copy() {
  render_view_host()->Copy();
}

void WebContents::Paste() {
  render_view_host()->Paste();
}

void WebContents::DisassociateFromPopupCount() {
  render_view_host()->DisassociateFromPopupCount();
}

TabContents* WebContents::Clone() {
  // We create a new SiteInstance so that the new tab won't share processes
  // with the old one. This can be changed in the future if we need it to share
  // processes for some reason.
  TabContents* tc = new WebContents(profile(),
                                    SiteInstance::CreateSiteInstance(profile()),
                                    MSG_ROUTING_NONE, NULL);
  tc->controller().CopyStateFrom(controller_);
  return tc;
}

void WebContents::DidBecomeSelected() {
  controller_.SetActive(true);

  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // If pid() is -1, that means the RenderProcessHost still hasn't been
  // initialized.  It'll register with CacheManagerHost when it is.
  if (process()->pid() != -1)
    WebCacheManager::GetInstance()->ObserveActivity(process()->pid());
}

void WebContents::WasHidden() {
  if (!capturing_contents()) {
    // |render_view_host()| can be NULL if the user middle clicks a link to open
    // a tab in then background, then closes the tab before selecting it.  This
    // is because closing the tab calls WebContents::Destroy(), which removes
    // the |render_view_host()|; then when we actually destroy the window,
    // OnWindowPosChanged() notices and calls HideContents() (which calls us).
    if (render_widget_host_view())
      render_widget_host_view()->WasHidden();

    // Loop through children and send WasHidden to them, too.
    int count = static_cast<int>(child_windows_.size());
    for (int i = count - 1; i >= 0; --i) {
      ConstrainedWindow* window = child_windows_.at(i);
      window->WasHidden();
    }
  }

  NotificationService::current()->Notify(
      NotificationType::TAB_CONTENTS_HIDDEN,
      Source<TabContents>(this),
      NotificationService::NoDetails());
}

void WebContents::ShowContents() {
  if (render_widget_host_view())
    render_widget_host_view()->DidBecomeSelected();

  // Loop through children and send DidBecomeSelected to them, too.
  int count = static_cast<int>(child_windows_.size());
  for (int i = count - 1; i >= 0; --i) {
    ConstrainedWindow* window = child_windows_.at(i);
    window->DidBecomeSelected();
  }
}

void WebContents::HideContents() {
  // TODO(pkasting): http://b/1239839  Right now we purposefully don't call
  // our superclass HideContents(), because some callers want to be very picky
  // about the order in which these get called.  In addition to making the code
  // here practically impossible to understand, this also means we end up
  // calling TabContents::WasHidden() twice if callers call both versions of
  // HideContents() on a WebContents.
  WasHidden();
}

bool WebContents::IsBookmarkBarAlwaysVisible() {
  // See GetDOMUIForCurrentState() comment for more info. This case is very
  // similar, but for non-first loads, we want to use the committed entry. This
  // is so the bookmarks bar disappears at the same time the page does.
  if (controller_.GetLastCommittedEntry()) {
    // Not the first load, always use the committed DOM UI.
    if (render_manager_.dom_ui())
      return render_manager_.dom_ui()->force_bookmark_bar_visible();
    return false;  // Default.
  }

  // When it's the first load, we know either the pending one or the committed
  // one will have the DOM UI in it (see GetDOMUIForCurrentState), and only one
  // of them will be valid, so we can just check both.
  if (render_manager_.pending_dom_ui())
    return render_manager_.pending_dom_ui()->force_bookmark_bar_visible();
  if (render_manager_.dom_ui())
    return render_manager_.dom_ui()->force_bookmark_bar_visible();
  return false;  // Default.
}

void WebContents::SetDownloadShelfVisible(bool visible) {
  if (shelf_visible_ != visible) {
    if (visible) {
      // Invoke GetDownloadShelf to force the shelf to be created.
      GetDownloadShelf();
    }
    shelf_visible_ = visible;

    if (delegate_)
      delegate_->ContentsStateChanged(this);
  }

  // SetShelfVisible can force-close the shelf, so make sure we lay out
  // everything correctly, as if the animation had finished. This doesn't
  // matter for showing the shelf, as the show animation will do it.
  ToolbarSizeChanged(false);

  if (visible) {
    // Always set this value as it reflects the last time the download shelf
    // was made visible (even if it was already visible).
    last_download_shelf_show_ = TimeTicks::Now();
  }
}

void WebContents::PopupNotificationVisibilityChanged(bool visible) {
  render_view_host()->PopupNotificationVisibilityChanged(visible);
}

bool WebContents::FocusLocationBarByDefault() {
  DOMUI* dom_ui = GetDOMUIForCurrentState();
  if (dom_ui)
    return dom_ui->focus_location_bar_by_default();
  return false;
}

gfx::NativeView WebContents::GetNativeView() const {
  return view_->GetNativeView();
}

gfx::NativeView WebContents::GetContentNativeView() {
  return view_->GetContentNativeView();
}

void WebContents::GetContainerBounds(gfx::Rect *out) const {
  view_->GetContainerBounds(out);
}

void WebContents::Focus() {
  view_->Focus();
}

void WebContents::SetInitialFocus(bool reverse) {
  render_view_host()->SetInitialFocus(reverse);
}

// Notifies the RenderWidgetHost instance about the fact that the page is
// loading, or done loading and calls the base implementation.
void WebContents::SetIsLoading(bool is_loading,
                               LoadNotificationDetails* details) {
  if (is_loading == is_loading_)
    return;

  if (!is_loading) {
    load_state_ = net::LOAD_STATE_IDLE;
    load_state_host_.clear();
  }

  render_manager_.SetIsLoading(is_loading);

  is_loading_ = is_loading;
  waiting_for_response_ = is_loading;

  if (delegate_)
    delegate_->LoadingStateChanged(this);

  NotificationType type = is_loading ? NotificationType::LOAD_START :
      NotificationType::LOAD_STOP;
  NotificationDetails det = NotificationService::NoDetails();;
  if (details)
      det = Details<LoadNotificationDetails>(details);
  NotificationService::current()->Notify(type,
      Source<NavigationController>(&controller_),
      det);
}


DOMUI* WebContents::GetDOMUIForCurrentState() {
  // When there is a pending navigation entry, we want to use the pending DOMUI
  // that goes along with it to control the basic flags. For example, we want to
  // show the pending URL in the URL bar, so we want the display_url flag to
  // be from the pending entry.
  //
  // The confusion comes because there are multiple possibilities for the
  // initial load in a tab as a side effect of the way the RenderViewHostManager
  // works.
  //
  //  - For the very first tab the load looks "normal". The new tab DOM UI is
  //    the pending one, and we want it to apply here.
  //
  //  - For subsequent new tabs, they'll get a new SiteInstance which will then
  //    get switched to the one previously associated with the new tab pages.
  //    This switching will cause the manager to commit the RVH/DOMUI. So we'll
  //    have a committed DOM UI in this case.
  //
  // This condition handles all of these cases:
  //
  //  - First load in first tab: no committed nav entry + pending nav entry +
  //    pending dom ui:
  //    -> Use pending DOM UI if any.
  //
  //  - First load in second tab: no committed nav entry + pending nav entry +
  //    no pending DOM UI:
  //    -> Use the committed DOM UI if any.
  //
  //  - Second navigation in any tab: committed nav entry + pending nav entry:
  //    -> Use pending DOM UI if any.
  //
  //  - Normal state with no load: committed nav entry + no pending nav entry:
  //    -> Use committed DOM UI.
  if (controller_.pending_entry() &&
      (controller_.GetLastCommittedEntry() ||
       render_manager_.pending_dom_ui()))
    return render_manager_.pending_dom_ui();
  return render_manager_.dom_ui();
}
  // Returns true if the location bar should be focused by default rather than
  // the page contents. The view will call this function when the tab is
  // to see what it should do.
  bool FocusLocationBarByDefault();

  const string16& GetTitle() const;
  virtual SiteInstance* GetSiteInstance() const;
  virtual bool ShouldDisplayURL();
  virtual bool ShouldDisplayFavIcon();
  virtual std::wstring GetStatusText() const;
  virtual bool NavigateToPendingEntry(bool reload);
  virtual void Stop();
  virtual void Cut();
  virtual void Copy();
  virtual void Paste();
  virtual void DisassociateFromPopupCount();
  virtual TabContents* Clone();
  virtual void DidBecomeSelected();
  virtual void WasHidden();
  virtual void ShowContents();
  virtual void HideContents();
  virtual bool IsBookmarkBarAlwaysVisible();
  virtual void SetDownloadShelfVisible(bool visible);
  virtual void PopupNotificationVisibilityChanged(bool visible);
  virtual void Focus();

  // Retarded pass-throughs to the view.
  // TODO(brettw) fix this, tab contents shouldn't have these methods, probably
  // it should be killed altogether.
  virtual gfx::NativeView GetNativeView() const;
  virtual gfx::NativeView GetContentNativeView();
  virtual void GetContainerBounds(gfx::Rect *out) const;
  RenderWidgetHostView* render_widget_host_view() const {
    return render_manager_.current_view();
  }

  // TabContents (private overrides) -------------------------------------------

  virtual void SetInitialFocus(bool reverse);
  virtual void SetIsLoading(bool is_loading, LoadNotificationDetails* details);
  // Returns the DOMUI for the current state of the tab. This will either be
  // the pending DOMUI, the committed DOMUI, or NULL.
  DOMUI* GetDOMUIForCurrentState();

        if (!m_databaseThread->start())
            m_databaseThread = 0;
#include "platform/Logging.h"
    : m_threadID(0)
    , m_transactionClient(adoptPtr(new SQLTransactionClient()))
    m_selfRef = this;
    // The DatabaseThread will only be destructed when both its owner
    // DatabaseContext has deref'ed it, and the databaseThread() thread function
    // has deref'ed the DatabaseThread object. The DatabaseContext destructor
    // will take care of ensuring that a termination request has been issued.
    // The termination request will trigger an orderly shutdown of the thread
    // function databaseThread(). In shutdown, databaseThread() will deref the
    // DatabaseThread before returning.
    ASSERT(terminationRequested());
bool DatabaseThread::start()
    MutexLocker lock(m_threadCreationMutex);

    if (m_threadID)
        return true;

    m_threadID = createThread(DatabaseThread::databaseThreadStart, this, "WebCore: Database");

    return m_threadID;
    m_queue.kill();
    return m_queue.killed();
void DatabaseThread::databaseThreadStart(void* vDatabaseThread)
    DatabaseThread* dbThread = static_cast<DatabaseThread*>(vDatabaseThread);
    dbThread->databaseThread();
}

void DatabaseThread::databaseThread()
{
    {
        // Wait for DatabaseThread::start() to complete.
        MutexLocker lock(m_threadCreationMutex);
        LOG(StorageAPI, "Started DatabaseThread %p", this);
    }

    AutodrainedPool pool;
    while (OwnPtr<DatabaseTask> task = m_queue.waitForMessage()) {
        task->run();
        pool.cycle();
    }
    LOG(StorageAPI, "About to detach thread %i and clear the ref to DatabaseThread %p, which currently has %i ref(s)", m_threadID, this, refCount());

    // Detach the thread so its resources are no longer of any concern to anyone else
    detachThread(m_threadID);

    DatabaseTaskSynchronizer* cleanupSync = m_cleanupSync;

    // Clear the self refptr, possibly resulting in deletion
    m_selfRef = 0;

    if (cleanupSync) // Someone wanted to know when we were done cleaning up.
        cleanupSync->taskCompleted();
    ASSERT(m_queue.killed() || m_openDatabaseSet.contains(database));
    return !m_queue.killed() && m_openDatabaseSet.contains(database);
    m_queue.append(task);
#include "wtf/MessageQueue.h"
#include "wtf/Threading.h"
    bool start();
    bool isDatabaseThread() { return currentThread() == m_threadID; }
    static void databaseThreadStart(void*);
    void databaseThread();
    Mutex m_threadCreationMutex;
    ThreadIdentifier m_threadID;
    RefPtr<DatabaseThread> m_selfRef;

    MessageQueue<DatabaseTask> m_queue;
    std::wstring* url, std::wstring* title) {
  if (SUCCEEDED(data_object->GetData(GetFilenameWFormat(), &store))) {
    bool success = false;
    {
      // filename using unicode
      ScopedHGlobal<wchar_t> data(store.hGlobal);
      if (data.get() && data.get()[0] &&
          (PathFileExists(data.get()) || PathIsUNC(data.get()))) {
        wchar_t file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathW(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(file_url);
          title->assign(file_url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;
  }

  if (SUCCEEDED(data_object->GetData(GetFilenameFormat(), &store))) {
    bool success = false;
    {
      // filename using ascii
      ScopedHGlobal<char> data(store.hGlobal);
      if (data.get() && data.get()[0] && (PathFileExistsA(data.get()) ||
                                          PathIsUNCA(data.get()))) {
        char file_url[INTERNET_MAX_URL_LENGTH];
        DWORD file_url_len = arraysize(file_url);
        if (SUCCEEDED(::UrlCreateFromPathA(data.get(), file_url, &file_url_len,
                                           0))) {
          url->assign(UTF8ToWide(file_url));
          title->assign(*url);
          success = true;
        }
      }
    }
    ReleaseStgMedium(&store);
    if (success)
      return true;

  return false;
  return GetUrl(data_object, plain_text, &title);
      std::wstring* url, std::wstring* title);
  bool success = ClipboardUtil::GetUrl(source_object_, &url_str, title);
      ClipboardUtil::GetUrl(data_object, &url, &title);
  if (ClipboardUtil::GetUrl(data_object, &url_str, &drop_data->url_title)) {
#include "base/logging.h"
  NOTIMPLEMENTED();
  return NULL;
ColorChooserDialog::ColorChooserDialog(Listener* listener,
    listener_->DidChooseColor(color);
  listener_->DidEnd();
  // An interface implemented by a Listener object wishing to know about the
  // the results from the color chooser dialog.
  class Listener {
   public:
    virtual ~Listener() {}
    virtual void DidChooseColor(SkColor color) = 0;
    virtual void DidEnd() = 0;
  };

  ColorChooserDialog(Listener* listener,
  Listener* listener_;
                        public ColorChooserDialog::Listener,
                        public content::WebContentsObserver {
  // content::ColorChooser:
  // ColorChooserDialog::Listener:
  virtual void DidChooseColor(SkColor color);
  virtual void DidEnd();
      content::WebContentsObserver(tab) {
      web_contents()->GetRenderViewHost()->GetView()->GetNativeView());
void ColorChooserWin::DidChooseColor(SkColor color) {
  if (web_contents())
    web_contents()->DidChooseColorInColorChooser(identifier(), color);
void ColorChooserWin::DidEnd() {
  if (web_contents())
    web_contents()->DidEndColorChooser(identifier());
  if (profile_->GetExtensionsService())
    profile_->GetExtensionsService()->InstallExtension(full_path, download_url,
                                                       referrer_url);
#if defined(OS_WIN)
#include "app/win_util.h"
#elif defined(OS_MACOSX)
#include "base/scoped_cftyperef.h"
#include "base/sys_string_conversions.h"
#include <CoreFoundation/CFUserNotification.h>
#endif
                           bool extensions_enabled,
                           bool is_from_gallery,
                           bool show_prompts,
                           ExtensionsService* frontend)
      extensions_enabled_(extensions_enabled),
      is_from_gallery_(is_from_gallery),
      show_prompts_(show_prompts),
  // Note: this is a refptr so that we keep the frontend alive long enough to
  // get our response.
  frontend_ = frontend;
  // temp_dir_deleter is stack allocated instead of a member of CrxInstaller, so
  // that delete always happens on the file thread.
  ScopedTempDir temp_dir_deleter;
  temp_dir_deleter.Set(temp_dir);

  // If we were supposed to delete the source file, we can do that now.
  if (delete_crx_)
    file_util::Delete(crx_path_, false);  // non-recursive

    ReportFailureFromFileThread(
        StringPrintf("ID in new extension manifest (%s) does not match "
                     "expected id (%s)",
                     extension->id().c_str(),
                     expected_id_.c_str()));
  // Show the confirm UI if necessary.
  // NOTE: We also special case themes to not have a dialog, because we show
  // a special infobar UI for them instead.
  if (show_prompts_ && !extension->IsTheme()) {
    if (!ConfirmInstall())
      return;  // error reported by ConfirmInstall()

  CompleteInstall();
bool CrxInstaller::ConfirmInstall() {
#if defined(OS_WIN)
  if (win_util::MessageBox(GetForegroundWindow(),
          L"Are you sure you want to install this extension?\n\n"
          L"You should only install extensions from sources you trust.",
          l10n_util::GetString(IDS_PRODUCT_NAME).c_str(),
          MB_OKCANCEL) != IDOK) {
    ReportFailureFromFileThread("User did not allow extension to be "
                                "installed.");
    return false;
  }
#elif defined(OS_MACOSX)
  // Using CoreFoundation to do this dialog is unimaginably lame but will do
  // until the UI is redone.
  scoped_cftyperef<CFStringRef> product_name(
      base::SysWideToCFStringRef(l10n_util::GetString(IDS_PRODUCT_NAME)));
  CFOptionFlags response;
  if (kCFUserNotificationAlternateResponse == CFUserNotificationDisplayAlert(
      0, kCFUserNotificationCautionAlertLevel, NULL, NULL, NULL,
      product_name,
      CFSTR("Are you sure you want to install this extension?\n\n"
           "This is a temporary message and it will be removed when "
           "extensions UI is finalized."),
      NULL, CFSTR("Cancel"), NULL, &response)) {
    ReportFailureFromFileThread("User did not allow extension to be "
                                "installed.");
    return false;
#endif  // OS_*
  return true;
  ExtensionErrorReporter::GetInstance()->ReportError(error, show_prompts_);
  ui_loop_->PostTask(FROM_HERE, NewRunnableMethod(frontend_.get(),
      &ExtensionsService::OnExtensionOverinstallAttempted, extension_->id()));
  ui_loop_->PostTask(FROM_HERE, NewRunnableMethod(frontend_.get(),
      &ExtensionsService::OnExtensionInstalled, extension_.release()));
//
// 
//
// NOTE: This class is rather huge at the moment because it is handling all
// types of installation (external, autoupdate, and manual). In the future,
// manual installation will probably pulled out of it.
// TODO(aa): Pull out the manual installation bits.
               bool extensions_enabled,
               bool is_from_gallery,
               bool show_prompts,
               ExtensionsService* frontend);
  ~CrxInstaller() {
    // This is only here for debugging purposes, as a convenient place to set
    // breakpoints.
  }
 private:
  // Confirm with the user that it is OK to install this extension.
  //
  // Note that this runs on the file thread. It happens to be OK to do this on
  // Windows and Mac, and although ugly, we leave it because this is all getting
  // pulled out soon, anyway.
  //
  // TODO(aa): Pull this up, closer to the UI layer.
  bool ConfirmInstall();
  // Whether extension installation is set. We can't just check this before
  // trying to install because themes are special-cased to always be allowed.
  // Whether this installation was initiated from the gallery. We trust it more
  // and have special UI if it was.
  bool is_from_gallery_;

  // Whether we shoud should show prompts. This is sometimes false for testing
  // and autoupdate.
  bool show_prompts_;

#include "chrome/browser/extensions/theme_preview_infobar_delegate.h"
#include "chrome/browser/tab_contents/tab_contents.h"
  InstallExtension(extension_path, GURL(), GURL());
}

void ExtensionsService::InstallExtension(const FilePath& extension_path,
                                         const GURL& download_url,
                                         const GURL& referrer_url) {
  new CrxInstaller(extension_path, install_directory_, Extension::INTERNAL,
                   "",   // no expected id
                   extensions_enabled_,
                   IsDownloadFromGallery(download_url, referrer_url),
                   show_extensions_prompts(),
                   false,  // don't delete crx when complete
                   backend_loop_,
                   this);
  new CrxInstaller(extension_path, install_directory_, Extension::INTERNAL,
                   id, extensions_enabled_,
                   false,  // not from gallery
                   show_extensions_prompts(),
                   true,  // delete crx when complete
                   backend_loop_,
                   this);
    ShowThemePreviewInfobar(extension);
    ShowThemePreviewInfobar(extension);
bool ExtensionsService::ShowThemePreviewInfobar(Extension* extension) {
  if (!profile_)
    return false;

  Browser* browser = BrowserList::GetLastActiveWithProfile(profile_);
  if (!browser)
    return false;

  TabContents* tab_contents = browser->GetSelectedTabContents();
  if (!tab_contents)
    return false;

  tab_contents->AddInfoBar(new ThemePreviewInfobarDelegate(tab_contents,
                                                           extension->name()));
  return true;
}

  new CrxInstaller(path, install_directory_, location, id, extensions_enabled_,
                   false,  // not from gallery
                   show_extensions_prompts(),
                   false,  // don't delete crx when complete
                   backend_loop_,
                   this);
  // XXX Hack: This is a temporary nasty hack to get theme installation working
  // without a dialog. Will be fixed by making ExtensionsService more modular.
  void InstallExtension(const FilePath& extension_path,
                        const GURL& download_url,
                        const GURL& referrer_url);

  // Show a confirm installation infobar on the currently active tab.
  // TODO(aa): This should be moved up into the UI and attached to the tab it
  // actually occured in. This requires some modularization of
  // ExtensionsService.
  bool ShowThemePreviewInfobar(Extension* extension);

      : crx_path_(crx_path), client_loop_(MessageLoop::current()), rdh_(rdh),
        client_(client), got_response_(false) {
  UtilityProcessHost* host = new UtilityProcessHost(rdh_, this,
                                                    MessageLoop::current());
  MessageLoop* client_loop_;
bool ThemePreviewInfobarDelegate::EqualsDelegate(InfoBarDelegate* delegate)
    const {
  // If another infobar of this type is showing, this will prevent us adding
  // a new one, we only care if they're the same type, as pressing undo always
  // has the same result each time. This does mean that the text continues
  // to refer to the old theme, but this is good enough for beta.
  // http://crbug.com/17932
  if (delegate->AsThemePreviewInfobarDelegate())
    return true;

  return false;
}

  virtual bool EqualsDelegate(InfoBarDelegate* delegate) const;
  if (context_)
  context_.reset();
      url_(web_frame_ ? GetDataSourceURLForFrame(web_frame_) : GURL()) {
  gin::PerContextData::From(v8_context)->set_runner(this);
void ScriptContext::Run(const std::string& source,
                        const std::string& resource_name) {
  module_system_->RunString(source, resource_name);
}

v8::Handle<v8::Value> ScriptContext::Call(v8::Handle<v8::Function> function,
                                          v8::Handle<v8::Value> receiver,
                                          int argc,
                                          v8::Handle<v8::Value> argv[]) {
  return CallFunction(function, argc, argv);
}

gin::ContextHolder* ScriptContext::GetContextHolder() {
  v8::HandleScope handle_scope(isolate());
  return gin::PerContextData::From(v8_context())->context_holder();
}

class ScriptContext : public RequestSender::Source, public gin::Runner {
  // gin::Runner overrides.
  void Run(const std::string& source,
           const std::string& resource_name) override;
  v8::Handle<v8::Value> Call(v8::Handle<v8::Function> function,
                             v8::Handle<v8::Value> receiver,
                             int argc,
                             v8::Handle<v8::Value> argv[]) override;
  gin::ContextHolder* GetContextHolder() override;

static bool schemeRequiresAuthority(const String& scheme)
    DEFINE_STATIC_LOCAL(URLSchemesMap, schemes, ());
    if (schemes.isEmpty()) {
        schemes.add("http");
        schemes.add("https");
        schemes.add("ftp");
    return schemes.contains(scheme);
SecurityOrigin::SecurityOrigin(const KURL& url, bool forceUnique)
    , m_isUnique(forceUnique || SchemeRegistry::shouldTreatURLSchemeAsNoAccess(m_protocol))
    , m_needsStorageIdentifierQuirkForFiles(false)
#if ENABLE(BLOB) || ENABLE(FILE_SYSTEM)
    bool isBlobOrFileSystemProtocol = false;
#if ENABLE(BLOB)
    if (m_protocol == BlobURL::blobProtocol())
        isBlobOrFileSystemProtocol = true;
#endif
#if ENABLE(FILE_SYSTEM)
    if (m_protocol == "filesystem")
        isBlobOrFileSystemProtocol = true;
#endif
    if (isBlobOrFileSystemProtocol) {
        KURL originURL(ParsedURLString, decodeURLEscapeSequences(url.path()));
        if (originURL.isValid()) {
            m_protocol = originURL.protocol().lower();
            m_host = originURL.host().lower();
            m_port = originURL.port();
        } else
            m_isUnique = true;
    }
#endif

    // For edge case URLs that were probably misparsed, make sure that the origin is unique.
    if (schemeRequiresAuthority(m_protocol) && m_host.isEmpty())
        m_isUnique = true;

    if (m_protocol.isEmpty())
        m_isUnique = true;
    // By default, only local SecurityOrigins can load local resources.
    m_canLoadLocalResources = isLocal();
    if (m_canLoadLocalResources) {
        // Directories should never be readable.
        // Note that we do not do this check for blob or filesystem url because its origin is file:/// when it is created from local file urls.
#if ENABLE(BLOB) || ENABLE(FILE_SYSTEM)
        bool doDirectoryCheck = !isBlobOrFileSystemProtocol;
#else
        bool doDirectoryCheck = true;
#endif
        if (doDirectoryCheck && (!url.hasPath() || url.path().endsWith("/")))
            m_isUnique = true;
        // Store the path in case we are doing per-file origin checking.
        m_filePath = url.path();
    }

    if (m_protocol == "file")
        m_needsStorageIdentifierQuirkForFiles = true;
    // Don't leak details from URLs into unique origins.
    if (m_isUnique) {
        m_protocol = "";
        m_host = "";
        m_port = InvalidPort;
    }
    , m_needsStorageIdentifierQuirkForFiles(other->m_needsStorageIdentifierQuirkForFiles)
    if (!url.isValid())
        return adoptRef(new SecurityOrigin(blankURL(), forceUnique));
    return adoptRef(new SecurityOrigin(url, forceUnique));
    RefPtr<SecurityOrigin> origin = create(KURL());
    if (m_needsStorageIdentifierQuirkForFiles)
    explicit SecurityOrigin(const KURL&, bool forceUnique);
    bool m_needsStorageIdentifierQuirkForFiles;
  ASSERT_TRUE(shared_buf.Create(L"", false, true, bytes));
  if (!dib->shared_memory_.Create(L"", false /* read write */,
  if (!dib->shared_memory_.Create(L"", false /* read write */,
  bool Create(const std::wstring& name, bool read_only, bool open_existing,
  bool Delete(const std::wstring& name);
  bool Open(const std::wstring& name, bool read_only);
  bool CreateOrOpen(const std::wstring &name, int posix_flags, uint32 size);
  bool FilePathForMemoryName(const std::wstring& memname, FilePath* path);

bool SharedMemory::Create(const std::wstring &name, bool read_only,
bool SharedMemory::Delete(const std::wstring& name) {
bool SharedMemory::Open(const std::wstring &name, bool read_only) {
// For the given shmem named |memname|, return a filename to mmap()
bool SharedMemory::FilePathForMemoryName(const std::wstring& memname,
  DCHECK(memname.find_first_of(L"/") == std::string::npos);
  DCHECK(memname.find_first_of(L"\0") == std::string::npos);
  if (file_util::GetShmemTempDir(&temp_dir) == false)
  *path = temp_dir.AppendASCII("com.google.chrome.shmem." +
                               WideToUTF8(memname));
bool SharedMemory::CreateOrOpen(const std::wstring &name,
  if (name == L"") {
  static const wchar_t* const s_test_name_;
const wchar_t* const MultipleThreadMain::s_test_name_ =
    L"SharedMemoryOpenThreadTest";
      EXPECT_TRUE(memory1.Create(L"SharedMemoryMultipleLockThreadTest",
  std::wstring test_name = L"SharedMemoryOpenCloseTest";
    rv = memories[i].Create(L"", false, true, kDataSize);
  static const wchar_t* const s_test_name_;
const wchar_t* const SharedMemoryProcessTest::s_test_name_ = L"MPMem";
bool SharedMemory::Create(const std::wstring &name, bool read_only,
  name_ = name;
      name.empty() ? NULL : name.c_str());
bool SharedMemory::Delete(const std::wstring& name) {
bool SharedMemory::Open(const std::wstring &name, bool read_only) {
  name_ = name;
      name.empty() ? NULL : name.c_str());
  if (!priv->shared_memory_.Create(UTF8ToWide(name), false, true, size))
  void DeleteShmem(std::string name) {
    mem.Delete(UTF8ToWide(name));
  if (!shared_memory->Create(std::wstring(),  // anonymous
    if (shared_memory_.Create(std::wstring(), false, false, buffer_size_) &&
  if (!entry->shared_memory.Create(L"", false, false, hardware_packet_size) ||
    if (shm.Create(L"", false, false, shm_size))
  if (!shared_memory->Create(L"", false /* read write */,
  shared_buf.Create(L"", false, false, buffer_size);
  if (!shared_memory_->Create(std::wstring() /* anonymous */,
      EXPECT_TRUE(shared_mem.Create(std::wstring(),
          false, false, test_page_contents_len));
    EXPECT_EQ(true, shared_handle_.Create(L"DeferredResourceLoaderTest", false,
  if (!input_transfer_buffer_->Create(std::wstring(), false, false, size))
  if (!shared_buf->Create(std::wstring(), false, false, size)) {
    CHECK(shared_mem_.Create(L"", false, false, kSize));
  shared_buf.Create(L"", false, false, buffer_size);
    if (shared_buf.Create(L"", false, false, buf_size) &&
      L"", false /* read write */, true /* open existing */, buf_size);
  ASSERT_TRUE(shared_memory.Create(std::wstring(), false,
                                   false, body.size()));
  memory.Delete(UTF8ToWide(filename));
  if (ring_buffer_->Create(std::wstring(), false, false, size)) {
  if (!buffer->Create(std::wstring(), false, false, size))
    shared_memory_->Create(std::wstring(), false, false, kRingBufferSize);
  memory.Delete(UTF8ToWide(filename));
// The following test of NormalizeFilePath() require that we create a symlink.
// This can not be done on windows before vista.  On vista, creating a symlink
// requires privilege "SeCreateSymbolicLinkPrivilege".
// TODO(skerner): Investigate the possibility of giving base_unittests the
// privileges required to create a symlink.
bool MakeSymlink(const FilePath& link_to, const FilePath& link_from) {
  return (symlink(link_to.value().c_str(), link_from.value().c_str()) == 0);
  ASSERT_TRUE(MakeSymlink(link_to, link_from))
  ASSERT_TRUE(MakeSymlink(link_to, link_from))
  ASSERT_TRUE(MakeSymlink(link_to, link_from))
  ASSERT_TRUE(MakeSymlink(link_from, link_to))
using v8_helpers::IsEmptyOrUndefined;
  if (!IsEmptyOrUndefined(retval)) {
  if (IsEmptyOrUndefined(has_port))
  context_holder_->SetContext(v8::Context::New(isolate));
#include "extensions/renderer/v8_helpers.h"
using namespace v8_helpers;

  if (IsEmptyOrUndefined(handler_function_value)) {
  v8::Local<v8::Context> v8_context = context_->v8_context();
  v8::Context::Scope context_scope(v8_context);
  SetProperty(
      v8_context, data, kHandlerFunction,

  // TODO(kalman): Cache these. See https://crbug.com/478744.
  v8::Local<v8::Context> v8_context = context_->v8_context();
  v8::Context::Scope context_scope(v8_context);
        GetPropertyUnsafe(v8_context, data, kHandlerFunction);
    DeletePropertyUnsafe(v8_context, data, kHandlerFunction);
#include "base/bind.h"
#include "base/bind_helpers.h"
#include "base/lazy_instance.h"
#include "base/synchronization/lock.h"
#include "extensions/renderer/object_backed_native_handler.h"
#include "third_party/WebKit/public/web/WebScopedMicrotaskSuppression.h"
// Preface:
//
// This is the documentation for makeCallback() function in the JavaScript, out
// here to reduce the amount of effort that the v8 parser needs to do:
//
// Returns a new object with every function on |obj| configured to call()
// itself with the given arguments.
//
// E.g. given
//    var result = makeCallable(Function.prototype)
//
// |result| will be an object including 'bind' such that
//    result.bind(foo, 1, 2, 3);
//
// is equivalent to Function.prototype.bind.call(foo, 1, 2, 3), and so on.
// This is a convenient way to save functions that user scripts may clobber.
// This is the source of a script which evaluates to a function, which should
// then be executed to save the bindings. This function is passed references
// to ScriptRunner::Apply and ScriptRunner::Save via the |natives| argument.
    "(function(natives) {\n"
    "      return natives.Apply(\n"
    "  natives.Save(builtin.name, safe);\n"
    "natives.Save('JSON', {\n"
    "});\n";
// Holds a compiled instance of |kScript| so that every instance of
// SafeBuiltins doesn't need to recompile it. Thread-safe.
// TODO(kalman): It would benefit to cache ModuleSystem's native handlers in
// this way as well.
class CompiledScript {
 public:
  CompiledScript() {}

  // Returns a handle to the instance of the compiled script, bound to the
  // current context (assumed to be |context|).
  v8::Local<v8::Script> GetForCurrentContext(v8::Local<v8::Context> context) {
    v8::Isolate* isolate = context->GetIsolate();
    DCHECK(v8::Isolate::GetCurrent() == isolate &&
           isolate->GetCurrentContext() == context);
    v8::EscapableHandleScope handle_scope(isolate);

    v8::Local<v8::Script> compiled_script;
    base::AutoLock lock_scope(lock_);
    if (unbound_compiled_script_.IsEmpty()) {
      compiled_script =
          v8::Script::Compile(context, ToV8StringUnsafe(isolate, kScript))
              .ToLocalChecked();
      unbound_compiled_script_.Reset(isolate,
                                     compiled_script->GetUnboundScript());
    } else {
      compiled_script =
          v8::Local<v8::UnboundScript>::New(isolate, unbound_compiled_script_)
              ->BindToCurrentContext();
    }
    return handle_scope.Escape(compiled_script);
  }

 private:
  // CompiledScript needs to be accessed on multiple threads - the main
  // RenderThread, plus worker threads. Singletons are thread-safe, but
  // access to |unbound_compiled_script_| must be locked.
  base::Lock lock_;

  // Use a v8::Persistent not a v8::Global because Globals attempt to reset the
  // handle on destruction, and by the time CompiledScript is destroyed the
  // renderer will be shutting down, and accessing into v8 will crash.
  v8::Persistent<v8::UnboundScript> unbound_compiled_script_;

  DISALLOW_COPY_AND_ASSIGN(CompiledScript);
};

base::LazyInstance<CompiledScript> g_compiled_script =
    LAZY_INSTANCE_INITIALIZER;

// Returns a unique key to use as a hidden value in an object without a
// namespace collision.
                          base::StringPrintf("safe_builtins::%s", name));
class ScriptNativeHandler : public ObjectBackedNativeHandler {
 public:
  explicit ScriptNativeHandler(ScriptContext* context)
      : ObjectBackedNativeHandler(context) {
    RouteFunction("Apply", base::Bind(&ScriptNativeHandler::Apply,
                                      base::Unretained(this)));
    RouteFunction(
        "Save", base::Bind(&ScriptNativeHandler::Save, base::Unretained(this)));
  }
  ~ScriptNativeHandler() override { Invalidate(); }
  // Takes 5 arguments:
  //  |function| The function that the arguments are being applied to.
  //  |recv| The receiver of the function call (i.e. the "this" value).
  //  |args| The arguments to the function call. This is actually an Arguments
  //    object but that isn't exposed in a convenient way in the v8 API, so we
  //    just use an Object and pass in |args_length| explicitly.
  //  |first_arg_index| The index of the first argument within |args|.
  //    This is 1 for prototype methods where the first argument to the
  //    function is the receiver. It's 0 for static methods which don't have a
  //    receiver.
  //  |args_length| The length of the argument list. This is needed because
  //    |args| is an Object which doesn't have a reliable concept of a length.
  void Apply(const v8::FunctionCallbackInfo<v8::Value>& info) {
    CHECK(info.Length() == 5 && info[0]->IsFunction() && info[2]->IsObject() &&
          info[3]->IsInt32() && info[4]->IsInt32());
    v8::Local<v8::Value> recv = info[1];
    v8::Local<v8::Object> args = info[2].As<v8::Object>();
    v8::Local<v8::Context> v8_context = context()->v8_context();

      CHECK(IsTrue(args->Has(v8_context, i + first_arg_index)));
      if (!GetProperty(v8_context, args, i + first_arg_index, &argv[i]))
    if (function->Call(v8_context, recv, argc, argv.get())
            .ToLocal(&return_value))
  void Save(const v8::FunctionCallbackInfo<v8::Value>& info) {
    v8::Local<v8::Object> object = info[1].As<v8::Object>();
    context()->v8_context()->Global()->SetHiddenValue(
        MakeKey(*v8::String::Utf8Value(info[0]), GetIsolate()), object);

  DISALLOW_COPY_AND_ASSIGN(ScriptNativeHandler);
void DeleteScriptHandler(scoped_ptr<ScriptNativeHandler> script_handler) {
  // |script_handler| is a scoped_ptr so will delete itself.
}

SafeBuiltins::~SafeBuiltins() {}

scoped_ptr<SafeBuiltins> SafeBuiltins::Install(ScriptContext* context) {
  v8::Isolate* isolate = context->isolate();
  v8::HandleScope handle_scope(isolate);
  v8::Handle<v8::Context> v8_context = context->v8_context();
  v8::Context::Scope context_scope(v8_context);
  blink::WebScopedMicrotaskSuppression microtask_suppression;

  // Run the script to return a new function bound to this context.
  v8::Local<v8::Script> script =
      g_compiled_script.Get().GetForCurrentContext(v8_context);
  v8::Local<v8::Value> return_value = script->Run();
  CHECK(return_value->IsFunction());
  v8::Local<v8::Function> script_function = return_value.As<v8::Function>();

  // Call the script function to save builtins.
  scoped_ptr<ScriptNativeHandler> script_handler(
      new ScriptNativeHandler(context));
  v8::Local<v8::Value> args[] = {script_handler->NewInstance()};
  CHECK(!script_function->Call(v8_context, v8_context->Global(),
                               arraysize(args), args)
             .IsEmpty());
  // Bind the lifetime of |script_handler| to |context|.
  context->AddInvalidationObserver(
      base::Bind(&DeleteScriptHandler, base::Passed(&script_handler)));
  // The SafeBuiltins instance itself is just a thin wrapper around accessing
  // the hidden properties that were just installed on |context|.
  return make_scoped_ptr(new SafeBuiltins(context));
}
  return Load("Array");
  return Load("Function");
  return Load("JSON");
  return Load("Object");
  return Load("RegExp");
  return Load("String");
  return Load("Error");
}

SafeBuiltins::SafeBuiltins(ScriptContext* context) : context_(context) {}

v8::Local<v8::Object> SafeBuiltins::Load(const char* name) const {
  v8::Local<v8::Value> value = context_->v8_context()->Global()->GetHiddenValue(
      MakeKey(name, context_->isolate()));
  CHECK(!IsEmptyOrUndefined(value));
  CHECK(value->IsObject()) << name;
  return v8::Local<v8::Object>::Cast(value);
#include "base/macros.h"
#include "base/memory/scoped_ptr.h"
// Saves a subset of the JavaScript builtin types, so that they can be used
// later without extensions tampering with them.
  ~SafeBuiltins();
  // Creates and immediately installs a SafeBuiltins instance in |context|.
  static scoped_ptr<SafeBuiltins> Install(ScriptContext* context);
  explicit SafeBuiltins(ScriptContext* context);

  v8::Local<v8::Object> Load(const char* name) const;


  DISALLOW_COPY_AND_ASSIGN(SafeBuiltins);
#include "extensions/renderer/safe_builtins.h"
  safe_builtins_ = SafeBuiltins::Install(this);
class SafeBuiltins;
  SafeBuiltins* safe_builtins() { return safe_builtins_.get(); }
  const SafeBuiltins* safe_builtins() const { return safe_builtins_.get(); }
  scoped_ptr<SafeBuiltins> safe_builtins_;
#include "extensions/renderer/safe_builtins.h"
inline bool IsEmptyOrUndefined(v8::Local<v8::Value> value) {
// DeletePropertyUnsafe() family wraps v8::Object::Delete(). They crash when an
// exception is thrown.
inline bool DeletePropertyUnsafe(v8::Local<v8::Context> context,
                                 v8::Local<v8::Object> object,
                                 v8::Local<v8::Value> key) {
  return object->Delete(context, key).FromJust();
}

inline bool DeletePropertyUnsafe(
    v8::Local<v8::Context> context,
    v8::Local<v8::Object> object,
    const char* key,
    v8::NewStringType string_type = v8::NewStringType::kNormal) {
  return object->Delete(context, ToV8StringUnsafe(context->GetIsolate(), key,
                                                  string_type))
      .FromJust();
}

#include "third_party/WebKit/public/web/WebLocalFrame.h"
  blink::WebLocalFrame* frame = context()->web_frame();
    blink::WebLocalFrame* frame,

namespace blink {
class WebLocalFrame;
}
      blink::WebLocalFrame* frame,
  script_context_set_.reset(
      new ScriptContextSet(&extensions_, &active_extension_ids_));
  ScriptContext* context = script_context_set_->Register(
      frame, v8_context, extension_group, world_id);
  if (context->context_type() == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(context->extension());
  switch (context->context_type()) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  ScriptContext* context = script_context_set_->GetByV8Context(v8_context);
  script_context_set_->Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  if (ScriptContext::IsSandboxedPage(
          extensions_, ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_->ForEach(
  script_context_set_->ForEach(
  MessagingBindings::DeliverMessage(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(*script_context_set_, port_id,
  std::set<ScriptContext*> removed_contexts =
      script_context_set_->OnExtensionUnloaded(id);
  for (ScriptContext* context : removed_contexts) {
    request_sender_->InvalidateSource(context);
#include "base/memory/scoped_ptr.h"
#include "extensions/common/extension.h"
    return *script_context_set_;
  scoped_ptr<ScriptContextSet> script_context_set_;
  ExtensionIdSet active_extension_ids_;
#include "third_party/WebKit/public/web/WebLocalFrame.h"
class CloseChannelSender {
 public:
  CloseChannelSender(int target_port_id)
      : port_created_(false), target_port_id_(target_port_id) {}

  void notify_port_created() { port_created_ = true; }

  ~CloseChannelSender() {
    if (!port_created_) {
      // If we didn't create a port, notify the other end of the channel (treat
      // it as a disconnect).
      content::RenderThread::Get()->Send(new ExtensionHostMsg_CloseChannel(
          target_port_id_, kReceivingEndDoesntExistError));
    }
  }

 private:
  bool port_created_;
  int target_port_id_;

  DISALLOW_COPY_AND_ASSIGN(CloseChannelSender);
};

    CloseChannelSender* close_channel_sender,
    if (retval->BooleanValue())
      close_channel_sender->notify_port_created();
                                   bool user_gesture,
  scoped_ptr<blink::WebScopedUserGesture> web_user_gesture;
  scoped_ptr<blink::WebScopedWindowFocusAllowedIndicator> allow_window_focus;
  if (user_gesture) {
    web_user_gesture.reset(new blink::WebScopedUserGesture);
    allow_window_focus.reset(new blink::WebScopedWindowFocusAllowedIndicator);
  }

  scoped_ptr<ExtensionMsg_TabConnectionInfo> source_copy(
      new ExtensionMsg_TabConnectionInfo());
  source_copy->tab.Swap(source.tab.DeepCopy());
  source_copy->frame_id = source.frame_id;
  context_set.RequestRunForEach(
      info.target_id, restrict_to_render_frame,
                 channel_name, base::Owned(source_copy.release()), info,
                 tls_channel_id,
                 base::Owned(new CloseChannelSender(target_port_id))));
  context_set.RequestRunForEach(
      restrict_to_render_frame,
      base::Bind(&DeliverMessageToScriptContext, message.data,
                 message.user_gesture, target_port_id));
  context_set.RequestRunForEach(
      restrict_to_render_frame,
#include "third_party/WebKit/public/web/WebLocalFrame.h"
  if (blink::WebLocalFrame* webframe = context->web_frame())
#include "extensions/common/constants.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
                             blink::WebLocalFrame* web_frame,
  gin::PerContextData* gin_data = gin::PerContextData::From(v8_context);
  CHECK(gin_data);  // may fail if the v8::Context hasn't been registered yet
  gin_data->set_runner(runner_.get());
// static
bool ScriptContext::IsSandboxedPage(const ExtensionSet& extensions,
                                    const GURL& url) {
  // TODO(kalman): This is checking for the wrong thing, it should be checking
  // if the frame's security origin is unique. The extension sandbox directive
  // is checked for in extensions/common/manifest_handlers/csp_info.cc.
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

class WebLocalFrame;
class ExtensionSet;
                blink::WebLocalFrame* frame,
  // Returns whether |url| is sandboxed (as declared in any Extension in
  // |extension_set| as sandboxed).
  //
  // Declared in ScriptContext for lack of a better place, but this should
  // become unnecessary at some point as crbug.com/466373 is worked on.
  static bool IsSandboxedPage(const ExtensionSet& extension_set,
                              const GURL& url);

  blink::WebLocalFrame* web_frame() const { return web_frame_; }
  //
  // TODO(kalman): Remove this and replace with a GetOrigin() call which reads
  // of WebDocument::securityOrigin():
  //  - The URL can change (e.g. pushState) but the origin cannot. Luckily it
  //    appears as though callers don't make security decisions based on the
  //    result of GetURL() so it's not a problem... yet.
  //  - Origin is the correct check to be making.
  //  - It might let us remove the about:blank resolving?
  // The WebLocalFrame associated with this context. This can be NULL because
  // this object can outlive is destroyed asynchronously.
  blink::WebLocalFrame* web_frame_;
#include "content/public/common/url_constants.h"
#include "content/public/renderer/render_frame.h"
#include "content/public/renderer/render_frame_observer.h"
#include "extensions/renderer/extension_groups.h"
#include "extensions/renderer/script_injection.h"
#include "third_party/WebKit/public/platform/WebSuspendableTask.h"
#include "third_party/WebKit/public/web/WebDocument.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
namespace {

// This class inherits content::RenderFrameObserver for tracking when render
// frame goes away.
class BlinkTaskRunner : public blink::WebSuspendableTask,
                        public content::RenderFrameObserver {
 public:
  BlinkTaskRunner(content::RenderFrame* render_frame,
                  ScriptContext* context,
                  const base::Callback<void(ScriptContext*)>& callback)
      : RenderFrameObserver(render_frame),
        context_(context),
        callback_(callback) {}

  void run() override {
    if (render_frame() && context_->is_valid())
      callback_.Run(context_);
  }

 private:
  ScriptContext* context_;
  base::Callback<void(ScriptContext*)> callback_;

  // Overriden to avoid being destroyed when RenderFrame goes away.
  // BlinkTaskRunner objects are owned by WebLocalFrame.
  void OnDestruct() override {}

  DISALLOW_COPY_AND_ASSIGN(BlinkTaskRunner);
};

// This class deletes ScriptContext on run or on contextDestoyed.
// It allows us to pass ScriptContext as raw pointer to BlinkTaskRunner.
// In ScriptContextSet::Remove method we mark the context as invalid, but
// don't delete the object until all scheduled tasks are finished.
class ScriptContextDeleter : public blink::WebSuspendableTask {
 public:
  explicit ScriptContextDeleter(ScriptContext* context) : context_(context) {}

  void run() override { delete context_; }
  void contextDestroyed() override { delete context_; }

 private:
  ScriptContext* context_;

  DISALLOW_COPY_AND_ASSIGN(ScriptContextDeleter);
};

}  // namespace

ScriptContextSet::ScriptContextSet(ExtensionSet* extensions,
                                   ExtensionIdSet* active_extension_ids)
    : extensions_(extensions), active_extension_ids_(active_extension_ids) {

ScriptContext* ScriptContextSet::Register(
    blink::WebLocalFrame* frame,
    const v8::Handle<v8::Context>& v8_context,
    int extension_group,
    int world_id) {
  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());
  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  contexts_.insert(context);  // takes ownership
  return context;
    content::RenderFrame* context_render_frame = context->GetRenderFrame();
    blink::WebLocalFrame* web_local_frame =
        context_render_frame ? context_render_frame->GetWebFrame() : nullptr;


    if (!web_local_frame)
      base::MessageLoop::current()->DeleteSoon(FROM_HERE, context);
    else
      web_local_frame->requestRunTask(new ScriptContextDeleter(context));
                              : nullptr;
  return calling.IsEmpty() ? nullptr : GetByV8Context(calling);
    const v8::Handle<v8::Context>& v8_context) const {
  for (ScriptContext* script_context : contexts_) {
    if (script_context->v8_context() == v8_context)
      return script_context;
  return nullptr;
}
void ScriptContextSet::ForEach(
    const std::string& extension_id,
    content::RenderView* restrict_to_render_view,
    const base::Callback<void(ScriptContext*)>& callback) const {
  ForEachImpl(extension_id, restrict_to_render_view, callback, false);
void ScriptContextSet::RequestRunForEach(
    content::RenderFrame* restrict_to_render_frame,
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  ForEachImpl(extension_id, restrict_to_render_view, callback, true);
}

std::set<ScriptContext*> ScriptContextSet::OnExtensionUnloaded(
    const std::string& extension_id) {
  std::set<ScriptContext*> removed;
  ForEach(extension_id,
          base::Bind(&ScriptContextSet::DispatchOnUnloadEventAndRemove,
                     base::Unretained(this), &removed));
  return removed;
}

const Extension* ScriptContextSet::GetExtensionFromFrameAndWorld(
    const blink::WebLocalFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.
    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_->GetExtensionOrAppIDByURL(frame_url);
  }

  // There are conditions where despite a context being associated with an
  // extension, no extension actually gets found. Ignore "invalid" because CSP
  // blocks extension page loading by switching the extension ID to "invalid".
  const Extension* extension = extensions_->GetByID(extension_id);
  if (!extension && !extension_id.empty() && extension_id != "invalid") {
    // TODO(kalman): Do something here?
  }
  return extension;
}

Feature::Context ScriptContextSet::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (ScriptContext::IsSandboxedPage(*extensions_, url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && active_extension_ids_->count(extension->id()) > 0) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of ScriptContext::IsSandboxedPage().
  if (!origin.isUnique() && extensions_->ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

void ScriptContextSet::DispatchOnUnloadEventAndRemove(
    std::set<ScriptContext*>* out,
    ScriptContext* context) {
  context->DispatchOnUnloadEvent();
  Remove(context);  // deleted asynchronously
  out->insert(context);
}

void ScriptContextSet::ForEachImpl(
    const std::string& extension_id,
    content::RenderView* restrict_to_render_view,
    const base::Callback<void(ScriptContext*)>& callback,
    bool run_asynchronously) const {
  std::set<ScriptContext*> contexts_copy = contexts_;
  for (ScriptContext* context : contexts_copy) {
    if (restrict_to_render_view &&
        restrict_to_render_view != context_render_view)
    content::RenderFrame* context_render_frame = context->GetRenderFrame();
    if (!context_render_frame)
      continue;
    if (run_asynchronously) {
      blink::WebLocalFrame* web_local_frame =
          context_render_frame->GetWebFrame();
      if (!web_local_frame)
        continue;
      // WebLocalFrame takes BlinkTaskRunner ownership.
      web_local_frame->requestRunTask(
          new BlinkTaskRunner(context_render_frame, context, callback));
    } else {
      callback.Run(context);
#include "base/macros.h"
#include "base/memory/weak_ptr.h"
#include "extensions/common/extension.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/features/feature.h"
#include "url/gurl.h"
namespace blink {
class WebLocalFrame;
class WebSecurityOrigin;
}

class RenderFrame;
// A container of ScriptContexts, responsible for both creating and managing
// them.
//
// Since calling JavaScript within a context can cause any number of contexts
// to be created or destroyed, this has additional smarts to help with the set
// changing underneath callers.
  ScriptContextSet(
      ExtensionSet* extensions,
      // Set of the IDs of extensions that are active in this process.
      // Must outlive this. TODO(kalman): Combine this and |extensions|.
      ExtensionIdSet* active_extension_ids);

  // Returns the number of contexts being tracked by this set.
  // This may also include invalid contexts. TODO(kalman): Useful?
  size_t size() const { return contexts_.size(); }
  // Creates and starts managing a new ScriptContext. Ownership is held.
  // Returns a weak reference to the new ScriptContext.
  ScriptContext* Register(blink::WebLocalFrame* frame,
                          const v8::Handle<v8::Context>& v8_context,
                          int extension_group,
                          int world_id);
  ScriptContext* GetByV8Context(const v8::Handle<v8::Context>& context) const;
  // |extension_id| in |restrict_to_render_view|.
  // An empty |extension_id| will match all extensions, and a NULL
  // |restrict_to_render_view| will match all render views, but try to use the
  // inline variants of these methods instead.
               content::RenderView* restrict_to_render_view,
  void ForEach(content::RenderView* restrict_to_render_view,
    ForEach("", restrict_to_render_view, callback);
  // Asynchronously runs |callback| with each ScriptContext that belongs to
  // |extension_id| in |restrict_to_render_frame|.
  // Running may be postponed if context is suspended.
  // If context or render frame is destroyed before context resumed then
  // |callback| won't be run.
  void RequestRunForEach(
      const std::string& extension_id,
      content::RenderFrame* restrict_to_render_frame,
      const base::Callback<void(ScriptContext*)>& callback) const;
  // RequestRunForEach matches all extensions.
  void RequestRunForEach(
      content::RenderFrame* restrict_to_render_frame,
      const base::Callback<void(ScriptContext*)>& callback) const {
    RequestRunForEach("", restrict_to_render_frame, callback);
  }
  // RequestRunForEach matches all render frames.
  void RequestRunForEach(
      const std::string& extension_id,
      const base::Callback<void(ScriptContext*)>& callback) const {
    RequestRunForEach(extension_id, nullptr, callback);
  }

  std::set<ScriptContext*> OnExtensionUnloaded(const std::string& extension_id);
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(
      const blink::WebLocalFrame* frame,
      int world_id,
      bool use_effective_url);

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  // Calls Remove on |context| then appends |context| to |out|.
  // This is a helper designed to be used by OnExtensionUnloaded with ForEach.
  void DispatchOnUnloadEventAndRemove(std::set<ScriptContext*>* out,
                                      ScriptContext* context);

  // Common implementation of ForEach methods.
  void ForEachImpl(const std::string& extension_id,
                   content::RenderView* restrict_to_render_view,
                   const base::Callback<void(ScriptContext*)>& callback,
                   bool run_asynchronously) const;

  // Weak reference to all installed Extensions.
  ExtensionSet* extensions_;

  // Weak reference to all installed Extensions that are also active in this
  // process.
  ExtensionIdSet* active_extension_ids_;

  // The set of all ScriptContexts we own.
  std::set<ScriptContext*> contexts_;
#include <vector>

#include "extensions/common/extension_set.h"
TEST(ScriptContextSetTest, Lifecycle) {
  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebLocalFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  // Do this after construction of the webview, since it may construct the
  // Isolate.

  v8::Local<v8::Context> v8_context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(v8_context);
  // ScriptContext relies on gin, it just doesn't look like it from here.
  context_holder.SetContext(v8_context);
  ExtensionSet extensions;
  ExtensionIdSet active_extensions;
  ScriptContextSet context_set(&extensions, &active_extensions);
  ScriptContext* context = context_set.Register(
      frame, v8_context, 0, 0);  // no extension group or world ID
  // Context is valid and resembles correctness.
  EXPECT_TRUE(context->is_valid());
  EXPECT_EQ(frame, context->web_frame());
  EXPECT_EQ(v8_context, context->v8_context());
  // Context has been correctly added.
  EXPECT_EQ(1u, context_set.size());
  EXPECT_EQ(context, context_set.GetByV8Context(v8_context));
  // Test context is correctly removed.
  EXPECT_EQ(0u, context_set.size());
  EXPECT_EQ(nullptr, context_set.GetByV8Context(v8_context));
  // After removal, the context should be invalid.
  EXPECT_FALSE(context->is_valid());
  EXPECT_EQ(nullptr, context->web_frame());
    , m_currentSpeechUtterance(nullptr)
    return m_currentSpeechUtterance;
void SpeechSynthesis::startSpeakingImmediately(SpeechSynthesisUtterance* utterance)
    ASSERT(!m_currentSpeechUtterance);
    m_currentSpeechUtterance = utterance;
    // If the queue was empty, speak this immediately and add it to the queue.
        startSpeakingImmediately(utterance);
    // Remove all the items from the utterance queue.
    // Hold on to the current utterance so the platform synthesizer can have a chance to clean up.
    RefPtrWillBeMember<SpeechSynthesisUtterance> current = m_currentSpeechUtterance;
    current = nullptr;

    // The platform should have called back immediately and cleared the current utterance.
    ASSERT(!m_currentSpeechUtterance);
    if (!m_currentSpeechUtterance)
    ASSERT(m_currentSpeechUtterance);
    m_currentSpeechUtterance = nullptr;
    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());
    if (m_utteranceQueue.size()) {
        RefPtrWillBeMember<SpeechSynthesisUtterance> firstUtterance = m_utteranceQueue.first();
        ASSERT(firstUtterance == utterance);
        if (firstUtterance == utterance)
            m_utteranceQueue.removeFirst();
        // Start the next job if there is one pending.
        if (!m_utteranceQueue.isEmpty())
            startSpeakingImmediately(m_utteranceQueue.first().get());
    }
    visitor->trace(m_currentSpeechUtterance);
    void startSpeakingImmediately(SpeechSynthesisUtterance*);
    RawPtrWillBeMember<SpeechSynthesisUtterance> m_currentSpeechUtterance;
    client()->speakingErrorOccurred(m_utterance);
    m_utterance = nullptr;
#include "content/common/image_messages.h"
static int StartDownload(RenderFrameHost* rfh,
                         const GURL& url,
                         bool is_favicon,
                         uint32_t max_bitmap_size,
                         bool bypass_cache) {
  static int g_next_image_download_id = 0;
  rfh->Send(new ImageMsg_DownloadImage(rfh->GetRoutingID(),
                                       ++g_next_image_download_id,
                                       url,
                                       is_favicon,
                                       max_bitmap_size,
                                       bypass_cache));
  return g_next_image_download_id;
    IPC_MESSAGE_HANDLER(ImageHostMsg_DidDownloadImage, OnDidDownloadImage)
int WebContentsImpl::DownloadImage(const GURL& url,
                                   bool is_favicon,
                                   uint32_t max_bitmap_size,
                                   bool bypass_cache,
                                   const ImageDownloadCallback& callback) {
  int id = StartDownload(GetMainFrame(), url, is_favicon, max_bitmap_size,
                         bypass_cache);
  image_download_map_[id] = callback;
  return id;
void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    const std::vector<SkBitmap>& bitmaps,
    const std::vector<gfx::Size>& original_bitmap_sizes) {
  if (bitmaps.size() != original_bitmap_sizes.size())
    return;

  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    // Currently WebContents notifies us of ANY downloads so that it is
    // possible to get here.
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(
        id, http_status_code, image_url, bitmaps, original_bitmap_sizes);
  }
  image_download_map_.erase(id);
}

  void OnDidDownloadImage(int id,
                          int http_status_code,
                          const GURL& image_url,
                          const std::vector<SkBitmap>& bitmaps,
                          const std::vector<gfx::Size>& original_bitmap_sizes);
  // Maps the ids of pending image downloads to their callbacks
  typedef std::map<int, ImageDownloadCallback> ImageDownloadMap;
  ImageDownloadMap image_download_map_;

#include "content/common/image_messages.h"
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Multiply-included message file, no traditional include guard.
#include <vector>

#include "ipc/ipc_message.h"
#include "ipc/ipc_message_macros.h"
#include "ipc/ipc_param_traits.h"
#include "third_party/skia/include/core/SkBitmap.h"
#include "ui/gfx/geometry/size.h"

#define IPC_MESSAGE_START ImageMsgStart

// Messages sent from the browser to the renderer.

// Requests the renderer to download the specified image, decode it,
// and send the image data back via ImageHostMsg_DidDownloadImage.
IPC_MESSAGE_ROUTED5(ImageMsg_DownloadImage,
                    int /* Identifier for the request */,
                    GURL /* URL of the image */,
                    bool /* is favicon (turn off cookies) */,
                    uint32_t /* Maximal bitmap size in pixel. The results are
                                filtered according the max size. If there are no
                                bitmaps at the passed in GURL <= max size, the
                                smallest bitmap is resized to the max size and
                                is the only result. A max size of zero means
                                that the max size is unlimited. */,
                    bool /* bypass cache */)

// Messages sent from the renderer to the browser.

IPC_MESSAGE_ROUTED5(ImageHostMsg_DidDownloadImage,
                    int /* Identifier of the request */,
                    int /* HTTP response status */,
                    GURL /* URL of the image */,
                    std::vector<SkBitmap> /* bitmap data */,
                    /* The sizes in pixel of the bitmaps before they were
                       resized due to the maximal bitmap size passed to
                       ImageMsg_DownloadImage. Each entry in the bitmaps vector
                       corresponds to an entry in the sizes vector. If a bitmap
                       was resized, there should be a single returned bitmap. */
                    std::vector<gfx::Size>)
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
#include "content/renderer/image_loading_helper.h"
#include "content/common/image_messages.h"
      image,
      skia::ImageOperations::RESIZE_BEST,
       it != unfiltered.end();
       ++it) {
ImageLoadingHelper::ImageLoadingHelper(RenderFrame* render_frame)
    : RenderFrameObserver(render_frame) {
ImageLoadingHelper::~ImageLoadingHelper() {
void ImageLoadingHelper::OnDownloadImage(
    int id,
    const GURL& image_url,
    bool is_favicon,
    uint32_t max_image_size,
    bool bypass_cache) {
    if (DownloadImage(id, image_url, is_favicon, max_image_size,
                      bypass_cache)) {
      // Will complete asynchronously via ImageLoadingHelper::DidDownloadImage
  Send(new ImageHostMsg_DidDownloadImage(routing_id(),
                                         id,
                                         0,
                                         image_url,
                                         result_images,
                                         result_original_image_sizes));
bool ImageLoadingHelper::DownloadImage(
    int id,
    const GURL& image_url,
    bool is_favicon,
    uint32_t max_image_size,
    bool bypass_cache) {
      image_url, render_frame()->GetWebFrame(), id,
      is_favicon ? WebURLRequest::RequestContextFavicon
                 : WebURLRequest::RequestContextImage,
      base::Bind(&ImageLoadingHelper::DidDownloadImage, base::Unretained(this),
                 max_image_size)));
void ImageLoadingHelper::DidDownloadImage(
      &result_original_image_sizes);
  // Notify requester of image download status.
  Send(new ImageHostMsg_DidDownloadImage(
      routing_id(),
      fetcher->id(),
      fetcher->http_status_code(),
      fetcher->image_url(),
      result_images,
      result_original_image_sizes));
SkBitmap ImageLoadingHelper::ImageFromDataUrl(const GURL& url) const {
  std::string mime_type, char_set, data;
  if (net::DataURL::Parse(url, &mime_type, &char_set, &data) && !data.empty()) {
    // Decode the image using WebKit's image decoder.
    ImageDecoder decoder(gfx::Size(gfx::kFaviconSize, gfx::kFaviconSize));
    const unsigned char* src_data =
        reinterpret_cast<const unsigned char*>(&data[0]);

    return decoder.Decode(src_data, data.size());
  }
  return SkBitmap();
}
bool ImageLoadingHelper::OnMessageReceived(const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(ImageLoadingHelper, message)
    IPC_MESSAGE_HANDLER(ImageMsg_DownloadImage, OnDownloadImage)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_RENDERER_IMAGE_LOADING_HELPER_H_
#define CONTENT_RENDERER_IMAGE_LOADING_HELPER_H_

#include <string>
#include <vector>

#include "base/memory/scoped_vector.h"
#include "content/public/renderer/render_frame_observer.h"
#include "url/gurl.h"

class SkBitmap;

namespace content {

class MultiResolutionImageResourceFetcher;

// This class deals with image downloading.
// One instance of ImageLoadingHelper is owned by RenderFrame.
class ImageLoadingHelper : public RenderFrameObserver {
 public:
  explicit ImageLoadingHelper(RenderFrame* render_frame);

 private:
  ~ImageLoadingHelper() override;

  // Message handler.
  void OnDownloadImage(int id,
                       const GURL& image_url,
                       bool is_favicon,
                       uint32_t max_image_size,
                       bool bypass_cache);

  // Requests to download an image. When done, the ImageLoadingHelper
  // is notified by way of DidDownloadImage. Returns true if the
  // request was successfully started, false otherwise. id is used to
  // uniquely identify the request and passed back to the
  // DidDownloadImage method. If the image is a favicon, cookies will not be
  // sent nor accepted during download. If the image has multiple frames, all
  // the frames whose size <= |max_image_size| are returned. If all of the
  // frames are larger than |max_image_size|, the smallest frame is resized to
  // |max_image_size| and is the only result. |max_image_size| == 0 is
  // interpreted as no max image size.
  bool DownloadImage(int id,
                     const GURL& image_url,
                     bool is_favicon,
                     uint32_t max_image_size,
                     bool bypass_cache);

  // This callback is triggered when DownloadImage completes, either
  // succesfully or with a failure. See DownloadImage for more
  // details.
  void DidDownloadImage(
      uint32_t max_image_size,
      MultiResolutionImageResourceFetcher* fetcher,
      const std::vector<SkBitmap>& images);

  // Decodes a data: URL image or returns an empty image in case of failure.
  SkBitmap ImageFromDataUrl(const GURL&) const;

  // RenderFrameObserver implementation.
  bool OnMessageReceived(const IPC::Message& message) override;

  typedef ScopedVector<MultiResolutionImageResourceFetcher>
      ImageResourceFetcherList;

  // ImageResourceFetchers schedule via DownloadImage.
  ImageResourceFetcherList image_fetchers_;

  DISALLOW_COPY_AND_ASSIGN(ImageLoadingHelper);
};

}  // namespace content

#endif  // CONTENT_RENDERER_IMAGE_LOADING_HELPER_H_

#include "content/renderer/image_loading_helper.h"
  if (!frame_->parent())
    new ImageLoadingHelper(this);

  ImageMsgStart,
// false otherwise.  |error_code| can be NULL.
                                            PlatformFileError* error_code);
PlatformFile CreatePlatformFile(const FilePath& name, int flags,
                                bool* created, PlatformFileError* error_code) {
    if (error_code)
      *error_code = PLATFORM_FILE_ERROR_FAILED;
  if (error_code) {
      *error_code = PLATFORM_FILE_OK;
          *error_code = PLATFORM_FILE_ERROR_ACCESS_DENIED;
          *error_code = PLATFORM_FILE_ERROR_IN_USE;
          *error_code = PLATFORM_FILE_ERROR_EXISTS;
          *error_code = PLATFORM_FILE_ERROR_NOT_FOUND;
          *error_code = PLATFORM_FILE_ERROR_TOO_MANY_OPENED;
          *error_code = PLATFORM_FILE_ERROR_NO_MEMORY;
          *error_code = PLATFORM_FILE_ERROR_NO_SPACE;
          *error_code = PLATFORM_FILE_ERROR_NOT_A_DIRECTORY;
          *error_code = PLATFORM_FILE_ERROR_FAILED;

PlatformFile CreatePlatformFile(const FilePath& name,
                                int flags,
                                bool* created,
                                PlatformFileError* error_code) {
  if (error_code) {
      *error_code = PLATFORM_FILE_OK;
          *error_code = PLATFORM_FILE_ERROR_IN_USE;
          *error_code = PLATFORM_FILE_ERROR_EXISTS;
          *error_code = PLATFORM_FILE_ERROR_NOT_FOUND;
          *error_code = PLATFORM_FILE_ERROR_ACCESS_DENIED;
          *error_code = PLATFORM_FILE_ERROR_FAILED;
  file_util::ReadFileToString(filename, &compressed);
#include "third_party/WebKit/public/web/WebLocalFrame.h"
  blink::WebLocalFrame* frame = context()->web_frame();
    blink::WebLocalFrame* frame,

namespace blink {
class WebLocalFrame;
}
      blink::WebLocalFrame* frame,
  script_context_set_.reset(
      new ScriptContextSet(&extensions_, &active_extension_ids_));
  ScriptContext* context = script_context_set_->Register(
      frame, v8_context, extension_group, world_id);
  if (context->context_type() == Feature::CONTENT_SCRIPT_CONTEXT)
    InitOriginPermissions(context->extension());
  switch (context->context_type()) {
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  ScriptContext* context = script_context_set_->GetByV8Context(v8_context);
  script_context_set_->Remove(context);
  VLOG(1) << "Num tracked contexts: " << script_context_set_->size();
  if (ScriptContext::IsSandboxedPage(
          extensions_, ScriptContext::GetDataSourceURLForFrame(frame))) {
  script_context_set_->ForEach(
  script_context_set_->ForEach(
  MessagingBindings::DeliverMessage(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnConnect(*script_context_set_, target_port_id,
  MessagingBindings::DispatchOnDisconnect(*script_context_set_, port_id,
  std::set<ScriptContext*> removed_contexts =
      script_context_set_->OnExtensionUnloaded(id);
  for (ScriptContext* context : removed_contexts) {
    request_sender_->InvalidateSource(context);
#include "base/memory/scoped_ptr.h"
#include "extensions/common/extension.h"
    return *script_context_set_;
  scoped_ptr<ScriptContextSet> script_context_set_;
  ExtensionIdSet active_extension_ids_;
#include "third_party/WebKit/public/web/WebLocalFrame.h"
class CloseChannelSender {
 public:
  CloseChannelSender(int target_port_id)
      : port_created_(false), target_port_id_(target_port_id) {}

  void notify_port_created() { port_created_ = true; }

  ~CloseChannelSender() {
    if (!port_created_) {
      // If we didn't create a port, notify the other end of the channel (treat
      // it as a disconnect).
      content::RenderThread::Get()->Send(new ExtensionHostMsg_CloseChannel(
          target_port_id_, kReceivingEndDoesntExistError));
    }
  }

 private:
  bool port_created_;
  int target_port_id_;

  DISALLOW_COPY_AND_ASSIGN(CloseChannelSender);
};

    CloseChannelSender* close_channel_sender,
    if (retval->BooleanValue())
      close_channel_sender->notify_port_created();
                                   bool user_gesture,
  scoped_ptr<blink::WebScopedUserGesture> web_user_gesture;
  scoped_ptr<blink::WebScopedWindowFocusAllowedIndicator> allow_window_focus;
  if (user_gesture) {
    web_user_gesture.reset(new blink::WebScopedUserGesture);
    allow_window_focus.reset(new blink::WebScopedWindowFocusAllowedIndicator);
  }

  scoped_ptr<ExtensionMsg_TabConnectionInfo> source_copy(
      new ExtensionMsg_TabConnectionInfo());
  source_copy->tab.Swap(source.tab.DeepCopy());
  source_copy->frame_id = source.frame_id;
  context_set.RequestRunForEach(
      info.target_id, restrict_to_render_frame,
                 channel_name, base::Owned(source_copy.release()), info,
                 tls_channel_id,
                 base::Owned(new CloseChannelSender(target_port_id))));
  context_set.RequestRunForEach(
      restrict_to_render_frame,
      base::Bind(&DeliverMessageToScriptContext, message.data,
                 message.user_gesture, target_port_id));
  context_set.RequestRunForEach(
      restrict_to_render_frame,
#include "third_party/WebKit/public/web/WebLocalFrame.h"
  if (blink::WebLocalFrame* webframe = context->web_frame())
#include "extensions/common/constants.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
                             blink::WebLocalFrame* web_frame,
  gin::PerContextData* gin_data = gin::PerContextData::From(v8_context);
  CHECK(gin_data);  // may fail if the v8::Context hasn't been registered yet
  gin_data->set_runner(runner_.get());
// static
bool ScriptContext::IsSandboxedPage(const ExtensionSet& extensions,
                                    const GURL& url) {
  // TODO(kalman): This is checking for the wrong thing, it should be checking
  // if the frame's security origin is unique. The extension sandbox directive
  // is checked for in extensions/common/manifest_handlers/csp_info.cc.
  if (url.SchemeIs(kExtensionScheme)) {
    const Extension* extension = extensions.GetByID(url.host());
    if (extension) {
      return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
    }
  }
  return false;
}

class WebLocalFrame;
class ExtensionSet;
                blink::WebLocalFrame* frame,
  // Returns whether |url| is sandboxed (as declared in any Extension in
  // |extension_set| as sandboxed).
  //
  // Declared in ScriptContext for lack of a better place, but this should
  // become unnecessary at some point as crbug.com/466373 is worked on.
  static bool IsSandboxedPage(const ExtensionSet& extension_set,
                              const GURL& url);

  blink::WebLocalFrame* web_frame() const { return web_frame_; }
  //
  // TODO(kalman): Remove this and replace with a GetOrigin() call which reads
  // of WebDocument::securityOrigin():
  //  - The URL can change (e.g. pushState) but the origin cannot. Luckily it
  //    appears as though callers don't make security decisions based on the
  //    result of GetURL() so it's not a problem... yet.
  //  - Origin is the correct check to be making.
  //  - It might let us remove the about:blank resolving?
  // The WebLocalFrame associated with this context. This can be NULL because
  // this object can outlive is destroyed asynchronously.
  blink::WebLocalFrame* web_frame_;
#include "content/public/common/url_constants.h"
#include "content/public/renderer/render_frame.h"
#include "content/public/renderer/render_frame_observer.h"
#include "extensions/renderer/extension_groups.h"
#include "extensions/renderer/script_injection.h"
#include "third_party/WebKit/public/platform/WebSuspendableTask.h"
#include "third_party/WebKit/public/web/WebDocument.h"
#include "third_party/WebKit/public/web/WebLocalFrame.h"
namespace {

// This class inherits content::RenderFrameObserver for tracking when render
// frame goes away.
class BlinkTaskRunner : public blink::WebSuspendableTask,
                        public content::RenderFrameObserver {
 public:
  BlinkTaskRunner(content::RenderFrame* render_frame,
                  ScriptContext* context,
                  const base::Callback<void(ScriptContext*)>& callback)
      : RenderFrameObserver(render_frame),
        context_(context),
        callback_(callback) {}

  void run() override {
    if (render_frame() && context_->is_valid())
      callback_.Run(context_);
  }

 private:
  ScriptContext* context_;
  base::Callback<void(ScriptContext*)> callback_;

  // Overriden to avoid being destroyed when RenderFrame goes away.
  // BlinkTaskRunner objects are owned by WebLocalFrame.
  void OnDestruct() override {}

  DISALLOW_COPY_AND_ASSIGN(BlinkTaskRunner);
};

// This class deletes ScriptContext on run or on contextDestoyed.
// It allows us to pass ScriptContext as raw pointer to BlinkTaskRunner.
// In ScriptContextSet::Remove method we mark the context as invalid, but
// don't delete the object until all scheduled tasks are finished.
class ScriptContextDeleter : public blink::WebSuspendableTask {
 public:
  explicit ScriptContextDeleter(ScriptContext* context) : context_(context) {}

  void run() override { delete context_; }
  void contextDestroyed() override { delete context_; }

 private:
  ScriptContext* context_;

  DISALLOW_COPY_AND_ASSIGN(ScriptContextDeleter);
};

}  // namespace

ScriptContextSet::ScriptContextSet(ExtensionSet* extensions,
                                   ExtensionIdSet* active_extension_ids)
    : extensions_(extensions), active_extension_ids_(active_extension_ids) {

ScriptContext* ScriptContextSet::Register(
    blink::WebLocalFrame* frame,
    const v8::Handle<v8::Context>& v8_context,
    int extension_group,
    int world_id) {
  const Extension* extension =
      GetExtensionFromFrameAndWorld(frame, world_id, false);
  const Extension* effective_extension =
      GetExtensionFromFrameAndWorld(frame, world_id, true);

  GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
  Feature::Context context_type =
      ClassifyJavaScriptContext(extension, extension_group, frame_url,
                                frame->document().securityOrigin());
  Feature::Context effective_context_type = ClassifyJavaScriptContext(
      effective_extension, extension_group,
      ScriptContext::GetEffectiveDocumentURL(frame, frame_url, true),
      frame->document().securityOrigin());
  ScriptContext* context =
      new ScriptContext(v8_context, frame, extension, context_type,
                        effective_extension, effective_context_type);
  contexts_.insert(context);  // takes ownership
  return context;
    content::RenderFrame* context_render_frame = context->GetRenderFrame();
    blink::WebLocalFrame* web_local_frame =
        context_render_frame ? context_render_frame->GetWebFrame() : nullptr;


    if (!web_local_frame)
      base::MessageLoop::current()->DeleteSoon(FROM_HERE, context);
    else
      web_local_frame->requestRunTask(new ScriptContextDeleter(context));
                              : nullptr;
  return calling.IsEmpty() ? nullptr : GetByV8Context(calling);
    const v8::Handle<v8::Context>& v8_context) const {
  for (ScriptContext* script_context : contexts_) {
    if (script_context->v8_context() == v8_context)
      return script_context;
  return nullptr;
}
void ScriptContextSet::ForEach(
    const std::string& extension_id,
    content::RenderView* restrict_to_render_view,
    const base::Callback<void(ScriptContext*)>& callback) const {
  ForEachImpl(extension_id, restrict_to_render_view, callback, false);
void ScriptContextSet::RequestRunForEach(
    content::RenderFrame* restrict_to_render_frame,
  content::RenderView* restrict_to_render_view =
      restrict_to_render_frame ? restrict_to_render_frame->GetRenderView()
                               : NULL;
  ForEachImpl(extension_id, restrict_to_render_view, callback, true);
}

std::set<ScriptContext*> ScriptContextSet::OnExtensionUnloaded(
    const std::string& extension_id) {
  std::set<ScriptContext*> removed;
  ForEach(extension_id,
          base::Bind(&ScriptContextSet::DispatchOnUnloadEventAndRemove,
                     base::Unretained(this), &removed));
  return removed;
}

const Extension* ScriptContextSet::GetExtensionFromFrameAndWorld(
    const blink::WebLocalFrame* frame,
    int world_id,
    bool use_effective_url) {
  std::string extension_id;
  if (world_id != 0) {
    // Isolated worlds (content script).
    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);
  } else if (!frame->document().securityOrigin().isUnique()) {
    // TODO(kalman): Delete the above check.
    // Extension pages (chrome-extension:// URLs).
    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);
    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,
                                                       use_effective_url);
    extension_id = extensions_->GetExtensionOrAppIDByURL(frame_url);
  }

  // There are conditions where despite a context being associated with an
  // extension, no extension actually gets found. Ignore "invalid" because CSP
  // blocks extension page loading by switching the extension ID to "invalid".
  const Extension* extension = extensions_->GetByID(extension_id);
  if (!extension && !extension_id.empty() && extension_id != "invalid") {
    // TODO(kalman): Do something here?
  }
  return extension;
}

Feature::Context ScriptContextSet::ClassifyJavaScriptContext(
    const Extension* extension,
    int extension_group,
    const GURL& url,
    const blink::WebSecurityOrigin& origin) {
  // WARNING: This logic must match ProcessMap::GetContextType, as much as
  // possible.

  DCHECK_GE(extension_group, 0);
  if (extension_group == EXTENSION_GROUP_CONTENT_SCRIPTS) {
    return extension ?  // TODO(kalman): when does this happen?
               Feature::CONTENT_SCRIPT_CONTEXT
                     : Feature::UNSPECIFIED_CONTEXT;
  }

  // We have an explicit check for sandboxed pages before checking whether the
  // extension is active in this process because:
  // 1. Sandboxed pages run in the same process as regular extension pages, so
  //    the extension is considered active.
  // 2. ScriptContext creation (which triggers bindings injection) happens
  //    before the SecurityContext is updated with the sandbox flags (after
  //    reading the CSP header), so the caller can't check if the context's
  //    security origin is unique yet.
  if (ScriptContext::IsSandboxedPage(*extensions_, url))
    return Feature::WEB_PAGE_CONTEXT;

  if (extension && active_extension_ids_->count(extension->id()) > 0) {
    // |extension| is active in this process, but it could be either a true
    // extension process or within the extent of a hosted app. In the latter
    // case this would usually be considered a (blessed) web page context,
    // unless the extension in question is a component extension, in which case
    // we cheat and call it blessed.
    return (extension->is_hosted_app() &&
            extension->location() != Manifest::COMPONENT)
               ? Feature::BLESSED_WEB_PAGE_CONTEXT
               : Feature::BLESSED_EXTENSION_CONTEXT;
  }

  // TODO(kalman): This isUnique() check is wrong, it should be performed as
  // part of ScriptContext::IsSandboxedPage().
  if (!origin.isUnique() && extensions_->ExtensionBindingsAllowed(url)) {
    if (!extension)  // TODO(kalman): when does this happen?
      return Feature::UNSPECIFIED_CONTEXT;
    return extension->is_hosted_app() ? Feature::BLESSED_WEB_PAGE_CONTEXT
                                      : Feature::UNBLESSED_EXTENSION_CONTEXT;
  }

  if (!url.is_valid())
    return Feature::UNSPECIFIED_CONTEXT;

  if (url.SchemeIs(content::kChromeUIScheme))
    return Feature::WEBUI_CONTEXT;

  return Feature::WEB_PAGE_CONTEXT;
}

void ScriptContextSet::DispatchOnUnloadEventAndRemove(
    std::set<ScriptContext*>* out,
    ScriptContext* context) {
  context->DispatchOnUnloadEvent();
  Remove(context);  // deleted asynchronously
  out->insert(context);
}

void ScriptContextSet::ForEachImpl(
    const std::string& extension_id,
    content::RenderView* restrict_to_render_view,
    const base::Callback<void(ScriptContext*)>& callback,
    bool run_asynchronously) const {
  std::set<ScriptContext*> contexts_copy = contexts_;
  for (ScriptContext* context : contexts_copy) {
    if (restrict_to_render_view &&
        restrict_to_render_view != context_render_view)
    content::RenderFrame* context_render_frame = context->GetRenderFrame();
    if (!context_render_frame)
      continue;
    if (run_asynchronously) {
      blink::WebLocalFrame* web_local_frame =
          context_render_frame->GetWebFrame();
      if (!web_local_frame)
        continue;
      // WebLocalFrame takes BlinkTaskRunner ownership.
      web_local_frame->requestRunTask(
          new BlinkTaskRunner(context_render_frame, context, callback));
    } else {
      callback.Run(context);
#include "base/macros.h"
#include "base/memory/weak_ptr.h"
#include "extensions/common/extension.h"
#include "extensions/common/extension_set.h"
#include "extensions/common/features/feature.h"
#include "url/gurl.h"
namespace blink {
class WebLocalFrame;
class WebSecurityOrigin;
}

class RenderFrame;
// A container of ScriptContexts, responsible for both creating and managing
// them.
//
// Since calling JavaScript within a context can cause any number of contexts
// to be created or destroyed, this has additional smarts to help with the set
// changing underneath callers.
  ScriptContextSet(
      ExtensionSet* extensions,
      // Set of the IDs of extensions that are active in this process.
      // Must outlive this. TODO(kalman): Combine this and |extensions|.
      ExtensionIdSet* active_extension_ids);

  // Returns the number of contexts being tracked by this set.
  // This may also include invalid contexts. TODO(kalman): Useful?
  size_t size() const { return contexts_.size(); }
  // Creates and starts managing a new ScriptContext. Ownership is held.
  // Returns a weak reference to the new ScriptContext.
  ScriptContext* Register(blink::WebLocalFrame* frame,
                          const v8::Handle<v8::Context>& v8_context,
                          int extension_group,
                          int world_id);
  ScriptContext* GetByV8Context(const v8::Handle<v8::Context>& context) const;
  // |extension_id| in |restrict_to_render_view|.
  // An empty |extension_id| will match all extensions, and a NULL
  // |restrict_to_render_view| will match all render views, but try to use the
  // inline variants of these methods instead.
               content::RenderView* restrict_to_render_view,
  void ForEach(content::RenderView* restrict_to_render_view,
    ForEach("", restrict_to_render_view, callback);
  // Asynchronously runs |callback| with each ScriptContext that belongs to
  // |extension_id| in |restrict_to_render_frame|.
  // Running may be postponed if context is suspended.
  // If context or render frame is destroyed before context resumed then
  // |callback| won't be run.
  void RequestRunForEach(
      const std::string& extension_id,
      content::RenderFrame* restrict_to_render_frame,
      const base::Callback<void(ScriptContext*)>& callback) const;
  // RequestRunForEach matches all extensions.
  void RequestRunForEach(
      content::RenderFrame* restrict_to_render_frame,
      const base::Callback<void(ScriptContext*)>& callback) const {
    RequestRunForEach("", restrict_to_render_frame, callback);
  }
  // RequestRunForEach matches all render frames.
  void RequestRunForEach(
      const std::string& extension_id,
      const base::Callback<void(ScriptContext*)>& callback) const {
    RequestRunForEach(extension_id, nullptr, callback);
  }

  std::set<ScriptContext*> OnExtensionUnloaded(const std::string& extension_id);
  // Finds the extension for the JavaScript context associated with the
  // specified |frame| and isolated world. If |world_id| is zero, finds the
  // extension ID associated with the main world's JavaScript context. If the
  // JavaScript context isn't from an extension, returns empty string.
  const Extension* GetExtensionFromFrameAndWorld(
      const blink::WebLocalFrame* frame,
      int world_id,
      bool use_effective_url);

  // Returns the Feature::Context type of context for a JavaScript context.
  Feature::Context ClassifyJavaScriptContext(
      const Extension* extension,
      int extension_group,
      const GURL& url,
      const blink::WebSecurityOrigin& origin);

  // Calls Remove on |context| then appends |context| to |out|.
  // This is a helper designed to be used by OnExtensionUnloaded with ForEach.
  void DispatchOnUnloadEventAndRemove(std::set<ScriptContext*>* out,
                                      ScriptContext* context);

  // Common implementation of ForEach methods.
  void ForEachImpl(const std::string& extension_id,
                   content::RenderView* restrict_to_render_view,
                   const base::Callback<void(ScriptContext*)>& callback,
                   bool run_asynchronously) const;

  // Weak reference to all installed Extensions.
  ExtensionSet* extensions_;

  // Weak reference to all installed Extensions that are also active in this
  // process.
  ExtensionIdSet* active_extension_ids_;

  // The set of all ScriptContexts we own.
  std::set<ScriptContext*> contexts_;
#include <vector>

#include "extensions/common/extension_set.h"
TEST(ScriptContextSetTest, Lifecycle) {
  blink::WebView* webview = blink::WebView::create(nullptr);
  blink::WebLocalFrame* frame = blink::WebLocalFrame::create(nullptr);
  webview->setMainFrame(frame);
  // Do this after construction of the webview, since it may construct the
  // Isolate.

  v8::Local<v8::Context> v8_context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(v8_context);
  // ScriptContext relies on gin, it just doesn't look like it from here.
  context_holder.SetContext(v8_context);
  ExtensionSet extensions;
  ExtensionIdSet active_extensions;
  ScriptContextSet context_set(&extensions, &active_extensions);
  ScriptContext* context = context_set.Register(
      frame, v8_context, 0, 0);  // no extension group or world ID
  // Context is valid and resembles correctness.
  EXPECT_TRUE(context->is_valid());
  EXPECT_EQ(frame, context->web_frame());
  EXPECT_EQ(v8_context, context->v8_context());
  // Context has been correctly added.
  EXPECT_EQ(1u, context_set.size());
  EXPECT_EQ(context, context_set.GetByV8Context(v8_context));
  // Test context is correctly removed.
  EXPECT_EQ(0u, context_set.size());
  EXPECT_EQ(nullptr, context_set.GetByV8Context(v8_context));
  // After removal, the context should be invalid.
  EXPECT_FALSE(context->is_valid());
  EXPECT_EQ(nullptr, context->web_frame());
  // to_path may not exist yet, start the loop with to_path
    std::string suffix(&current.value().c_str()[from_path.value().size()]);
TEST_F(FileUtilTest, Move) {
TEST_F(FileUtilTest, CopyDirectoryRecursively) {
TEST_F(FileUtilTest, CopyDirectory) {
    detachDocumentLoader(m_provisionalDocumentLoader);
  bool is_client_side_array = IsUsageClientSideArray(usage);
  bool shadow = buffer->target() == GL_ELEMENT_ARRAY_BUFFER ||
                allow_buffers_on_multiple_targets_ ||
                is_client_side_array;
    buffer_manager()->set_allow_buffers_on_multiple_targets(true);
